<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>body {
  max-width: 980px;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAABE0AA8AAAAAHWwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY3d1HZY21hcAAAAdgAAACqAAACOvWLi0FjdnQgAAAChAAAABMAAAAgBtX/BGZwZ20AAAKYAAAFkAAAC3CKkZBZZ2FzcAAACCgAAAAIAAAACAAAABBnbHlmAAAIMAAABdQAAAjkYT9TNWhlYWQAAA4EAAAAMwAAADYQ6WvNaGhlYQAADjgAAAAfAAAAJAc6A1pobXR4AAAOWAAAACAAAAA0Kmz/7mxvY2EAAA54AAAAHAAAABwQPBJubWF4cAAADpQAAAAgAAAAIAEHC/NuYW1lAAAOtAAAAYQAAALxhQT4h3Bvc3QAABA4AAAAfgAAAMS3SYh9cHJlcAAAELgAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZHZmnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4Pwz+yMwf9z2KIYg5imAYUZgTJAQDcoQvQAHic7ZHNDYJAFIRnBXf94cDRIiyCKkCpwFCPJ092RcKNDoYKcN4+EmMPvpdvk539zQyAPYBCXEUJhBcCrJ5SQ9YLnLJe4qF5rdb+uWPDngNHTkta101pNyWa8lMhn6xx2dqUnW4q9YOIhAOOeueMSgsR/6ry+P7O5s6xVNg4chBsHUuFnWNJ8uZYwrw7chrsHXkODo7cB0dHOYCTY8kv0VE2WJKD6gOlWjsxAAB4nGNgQAMSEMgc9D8LhAESbAPdAHicrVZpd9NGFB15SZyELCULLWphxMRpsEYmbMGACUGyYyBdnK2VoIsUO+m+8Ynf4F/zZNpz6Dd+Wu8bLySQtOdwmpOjd+fN1czbZRJaktgL65GUmy/F1NYmjew8CemGTctRfCg7eyFlisnfBVEQrZbatx2HREQiULWusEQQ+x5ZmmR86FFGy7akV03KLT3pLlvjQb1V334aOsqxO6GkZjN0aD2yJVUYVaJIpj1S0qZlqPorSSu8v8LMV81QwohOImm8GcbQSN4bZ7TKaDW24yiKbLLcKFIkmuFBFHmU1RLn5IoJDMoHzZDyyqcR5cP8iKzYo5xWsEu20/y+L3mndzk/sV9vUbbkQB/Ijuzg7HQlX4RbW2HctJPtKFQRdtd3QmzZ7FT/Zo/ymkYDtysyvdCMYKl8hRArP6HM/iFZLZxP+ZJHo1qykRNB62VO7Es+gdbjiClxzRhZ0N3RCRHU/ZIzDPaYPh788d4plgsTAngcy3pHJZwIEylhczRJ2jByYCVliyqp9a6YOOV1WsRbwn7t2tGXzmjjUHdiPFsPHVs5UcnxaFKnmUyd2knNoykNopR0JnjMrwMoP6JJXm1jNYmVR9M4ZsaERCICLdxLU0EsO7GkKQTNoxm9uRumuXYtWqTJA/Xco/f05la4udNT2g70s0Z/VqdiOtgL0+lp5C/xadrlIkXp+ukZfkziQdYCMpEtNsOUgwdv/Q7Sy9eWHIXXBtju7fMrqH3WRPCkAfsb0B5P1SkJTIWYVYhWQGKta1mWydWsFqnI1HdDmla+rNMEinIcF8e+jHH9XzMzlpgSvt+J07MjLj1z7UsI0xx8m3U9mtepxXIBcWZ5TqdZlu/rNMfyA53mWZ7X6QhLW6ejLD/UaYHlRzodY3lBC5p038GQizDkAg6QMISlA0NYXoIhLBUMYbkIQ1gWYQjLJRjC8mMYwnIZhrC8rGXV1FNJ49qZWAZsQmBijh65zEXlaiq5VEK7aFRqQ54SbpVUFM+qf2WgXjzyhjmwFkiXyJpfMc6Vj0bl+NYVLW8aO1fAsepvH472OfFS1ouFPwX/1dZUJb1izcOTq/Abhp5sJ6o2qXh0TZfPVT26/l9UVFgL9BtIhVgoyrJscGcihI86nYZqoJVDzGzMPLTrdcuan8P9NzFCFlD9+DcUGgvcg05ZSVnt4KzV19uy3DuDcjgTLEkxN/P6VvgiI7PSfpFZyp6PfB5wBYxKZdhqA60VvNknMQ+Z3iTPBHFbUTZI2tjOBIkNHPOAefOdBCZh6qoN5E7hhg34BWFuwXknXKJ6oyyH7kXs8yik/Fun4kT2qGiMwLPZG2Gv70LKb3EMJDT5pX4MVBWhqRg1FdA0Um6oBl/G2bptQsYO9CMqdsOyrOLDxxb3lZJtGYR8pIjVo6Of1l6iTqrcfmYUl++dvgXBIDUxf3vfdHGQyrtayTJHbQNTtxqVU9eaQ+NVh+rmUfW94+wTOWuabronHnpf06rbwcVcLLD2bQ7SUiYX1PVhhQ2iy8WlUOplNEnvuAcYFhjQ71CKjf+r+th8nitVhdFxJN9O1LfR52AM/A/Yf0f1A9D3Y+hyDS7P95oTn2704WyZrqIX66foNzBrrblZugbc0HQD4iFHrY64yg18pwZxeqS5HOkh4GPdFeIBwCaAxeAT3bWM5lMAo/mMOT7A58xh0GQOgy3mMNhmzhrADnMY7DKHwR5zGHzBnHWAL5nDIGQOg4g5DJ4wJwB4yhwGXzGHwdfMYfANc+4DfMscBjFzGCTMYbCv6dYwzC1e0F2gtkFVoANTT1jcw+JQU2XI/o4Xhv29Qcz+wSCm/qjp9pD6Ey8M9WeDmPqLQUz9VdOdIfU3Xhjq7wYx9Q+DmPpMvxjLZQa/jHyXCgeUXWw+5++J9w/bxUC5AAEAAf//AA94nIVVX2hbZRQ/5/t7893s5ja9f7ouzdZ0TTqz3bRJmogbWya6bG6Cq0VbSV2ddIJjFtfIQHEig80Hda8yUN/0YQz8AyriiyD+xQd92R4HCnaCb3samnpumrpsCsLlfPf7zvedc37nL3CAtc/5W/wQZGA3tOBSY/g+TMjHmwzEoM1Q8+ZjRZY4oJhmBw5/YB6Za0yC5AkhlwA1A1yCBIBOwCII0Cj0U8BAMdUCzq05sKwkP7SlUY6fcJk4Fb/RyE79/6P5hjM/F4aZiXBoeMgzcqQ4Xi1hPqfDLG5FT+lchCVU3lYMyvuwhl1mqndQL0RsuloLywHtthLXI06OblTrhfWVnpSJ5+mwu/JdbtuN3IAnkW0LLMcRwaC7ktrlzridM6kVdyf9uO1UNBByI7JhwtG2sEwab07ORBeilWhqavJCqV0qzZTOl/7ZXQ5TbTcdcFelyGhhRDAQpdqp1FEX3w3cFTc1k9pJQkmm4ySCbSikxRP2QOfN+0tHS5MrpQuTU1Mk5nw0E5Xa0WvrOwDyGax9yB9ma6DAg82wHc43SAGTI4GjBWebOePAERFE8/AHaQpZASSTy8A4WwZiLQMQ82mFKATO0ILicRAoDm9p5P99E5b/fXG+kQYY3TYUuqmERWYoT0u/GNYL2q/4WB3LaVS+VynXsVYIcWw6DkCh3nX1D+VzlYN4LClF5yexSQos8exqZ3KVP+wtrC54u4Nznq6cq+xpMpUUnZ8FUYzE86ud0g28NOIv3Gj5/rmA3ABs7S/ywzFuQ4qyd6QxfNtiQIaEgp3w/entQg4Vcbqa16M5FfpeUB8t1+qeg7mI7cUyOe79wOk86gSxkVec4KPTX69++5x68Yubn5/F+w52z7u08sJX7fZXv8ekT/d2mILJxq6sn+SC6qEJknzLJCxyZEKwWVqYmAPBxBE/9DLeZiWHu7lcr/VytrCRuHojncNuTt9h46tmacmYisnSamdN2bZptcsmSysdVsy1PrOvOzF3xN64Rb937t/og9KHxYdcjIUqFAmIAHGHNzlns+RTPgeUYAQm9DwpNxfxbhhBHPaw3/gfTcXO2L+eJVIx5nsyGkvm9X4/f+bGkH45G0PaSjcMXTjcZyTvi3UdHoCDjQd3IDUVsgwYmUoJK/gp4JJxeRI0MKHZIkgynyIBqBTOUs6rOVCojvjZ4mCQz49ZMlMcp8QoYk6NoBfsxnJtsBohpa8iGJS+ZH7gU7NxME6cmF+t7cO9vB8d3jTWSct0ycW9ranXmolNDwmVkNnxe+8JtoztwS5rKJ0xWS95tQ/1zMYzg69MzUZnNtl1ofNbsml/OJm6f9wjRjpnu2o4MzHzn77IQkRd+1DjwMQ2pqSjGMMhyjrgTbBAKksuUm0iU7hI0aN2wOKOq7WYBSH0HGihj/jkiPxAfmwsEbfYrjMG+j3ij932Db/LV7I/xruNrhnroxjR9HRMb2nTvO0ZXOoHPk8H2ZhDPx93qcE/53sH5np/dkIP7zzhTVKdR/BAY/9ElkkR+A6lJGsqpJ4oQcTxpvBT3Kn58VkaJjgHyPEIws57xkaHh9KuVpDEpJZeMbZ5w/zBHi5NMQ4r5VphsFqID7TyB9eR4pX216c3AHxpdAwoqU9qg0ZJ6yVLKmMSz1iG2z27ifx18NkY0LPx1W/wCc2l5LrznrIsiKsqbmB78A9wIGx4tI8rjihVHJyY9pgMirenVq0yWg7Iw7eogG7ZgYM3qR9959A/fZkg6MnD/exlkmc+jWV4SB15XUR+eqC6l6ZmgPtN9z5JMfik05OV8ljylunJ4J+wA/FUaQSSKotsYsCWqaPBidBLcxkWx7XKFRIb45TGaEhjlF9uUVPqXOtcIwsXbBvfoZXIyRYFdkfnqjExH98xpnPczqzjX/uNdO1Y17Wpi5+6Ts8BXtjVFasp9KZ1mOiNbH65c5w6HgmyF2jFCZywM8mWjRc7T5Pmt0lRy7Y71+jYbpGyvwG4sH0XeJxjYGRgYADiwBB/53h+m68M3MwvgCIM1z5N/g6j///9v5H5BbMnkMvBwAQSBQCIcA9gAHicY2BkYGAO+p8FJF/8//v/F/MLBqAICuAFALYQB5kAeJxjfsHAwLwAiCNB+P9fbJjJmoGBMRUo/wKCAfO2EnQAAAAAANoBXgGcAgICVALaA1IDvAPkBAYEPARyAAEAAAANAF0ABAAAAAAAAgAUACQAcwAAAG4LcAAAAAB4nHWRzWrCQBSFT+pPqUIXLXTTzayKUohGKIibCoLuhbrrYtTRxCYZmYyKyz5Fd32HvlDfoO/QkziIFJtw9bvnnpl7ZwLgBt/wcHieGAf2UGd24Atcou+4RH3kuEweO66QXx1XyaHjGh6ROa7jFp/cwStfMVvhy7GHO+/e8QWuvcBxifqz4zL5xXGF/Oa4Sn53XMPE+3Bcx4P3M9DrvYmWoRWNQVN02kFXTPdCU4pSGQu5saE2meiLhU6timPtz3SSs9ypTCdqrJabWJoT5QQnymSRTkXgt0/UkUqVkVbN807ZdtmxdiEWRidi6HqItdErNbN+aO2612qd9sYAGmvsYRBhyUu0EGhQbfK/gzYCdElTOgSdB1eEFBIxFYkNV4RFJWPeZyyYpVQVHTHZx4y/yVGX2LGWFZri51TccUOn5B7nPefVCSPvGhVVwUl9znveO2KkhV8Wk82PZ8qwZf8OVcu1+fSmWCMw/HMOwXvKaysqM+p+cVuWag8tvv+c+xdd+4+teJxtjUEOwiAURJla24KliQfhUA2g/Sl+CKXx+loNrpzVezOLEY34Ron/0WhwQoszOvQYIKFwwQiNSbSBeO2SZ0tBP4j3zVjKNng32ZmtD1VVXCuOiw/pJ8S3WOU6l+K5UOTaDC4+2TjKMtN9KQf1ezLx/Sg/00FCvABHhjDjAAB4nGPw3sFwIihiIyNjX+QGxp0cDBwMyQUbGVidNjEwMmiBGJu5mBg5ICw+BjCLzWkX0wGgNCeQze60i8EBwmZmcNmowtgRGLHBoSNiI3OKy0Y1EG8XRwMDI4tDR3JIBEhJJBBs5mFi5NHawfi/dQNL70YmBhcADHYj9AAA) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable,
.markdown-body .highlighttable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr,
.markdown-body .highlighttable {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite,
.markdown-body .highlighttable pre,
.markdown-body .highlighttable div.highlight {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td,
.markdown-body .highlighttable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite,
.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* MultiMarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><style>/*GitHub*/
.highlight {background-color:#fff;color:#333333;}
.highlight .hll {background-color:#ffffcc;}
.highlight .c{color:#999988;font-style:italic}
.highlight .err{color:#a61717;background-color:#e3d2d2}
.highlight .k{font-weight:bold}
.highlight .o{font-weight:bold}
.highlight .cm{color:#999988;font-style:italic}
.highlight .cp{color:#999999;font-weight:bold}
.highlight .c1{color:#999988;font-style:italic}
.highlight .cs{color:#999999;font-weight:bold;font-style:italic}
.highlight .gd{color:#000000;background-color:#ffdddd}
.highlight .ge{font-style:italic}
.highlight .gr{color:#aa0000}
.highlight .gh{color:#999999}
.highlight .gi{color:#000000;background-color:#ddffdd}
.highlight .go{color:#888888}
.highlight .gp{color:#555555}
.highlight .gs{font-weight:bold}
.highlight .gu{color:#800080;font-weight:bold}
.highlight .gt{color:#aa0000}
.highlight .kc{font-weight:bold}
.highlight .kd{font-weight:bold}
.highlight .kn{font-weight:bold}
.highlight .kp{font-weight:bold}
.highlight .kr{font-weight:bold}
.highlight .kt{color:#445588;font-weight:bold}
.highlight .m{color:#009999}
.highlight .s{color:#dd1144}
.highlight .n{color:#333333}
.highlight .na{color:teal}
.highlight .nb{color:#0086b3}
.highlight .nc{color:#445588;font-weight:bold}
.highlight .no{color:teal}
.highlight .ni{color:purple}
.highlight .ne{color:#990000;font-weight:bold}
.highlight .nf{color:#990000;font-weight:bold}
.highlight .nn{color:#555555}
.highlight .nt{color:navy}
.highlight .nv{color:teal}
.highlight .ow{font-weight:bold}
.highlight .w{color:#bbbbbb}
.highlight .mf{color:#009999}
.highlight .mh{color:#009999}
.highlight .mi{color:#009999}
.highlight .mo{color:#009999}
.highlight .sb{color:#dd1144}
.highlight .sc{color:#dd1144}
.highlight .sd{color:#dd1144}
.highlight .s2{color:#dd1144}
.highlight .se{color:#dd1144}
.highlight .sh{color:#dd1144}
.highlight .si{color:#dd1144}
.highlight .sx{color:#dd1144}
.highlight .sr{color:#009926}
.highlight .s1{color:#dd1144}
.highlight .ss{color:#990073}
.highlight .bp{color:#999999}
.highlight .vc{color:teal}
.highlight .vg{color:teal}
.highlight .vi{color:teal}
.highlight .il{color:#009999}
.highlight .gc{color:#999;background-color:#EAF2F5}
</style><title>algorithm</title></head><body><article class="markdown-body"><div class="finished-info-wrapper">
  完成度 <span class="finished-info">500 / 500 -> 100%<span>
</div>

<h1 id="_1">✔ 算法知名仓库<a class="headerlink" href="#_1" title="Permanent link"></a></h1>
<ul>
<li><a href="https://github.com/SharingSource/LogicStack-LeetCode">【微软】宫水三叶</a></li>
<li><a href="https://github.com/azl397985856/leetcode">路西法</a></li>
</ul>
<h1 id="_2">刷题指南<a class="headerlink" href="#_2" title="Permanent link"></a></h1>
<p>刷题的时候要按照大概的题目分类来刷，每个方面都要有所了解。</p>
<ul>
<li><a href="#😻✔-基础算法">基础算法</a></li>
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>集合</li>
<li>字典</li>
<li>树</li>
<li>堆</li>
<li>图</li>
<li>搜索、排序</li>
<li>分治法</li>
<li>动态规划</li>
<li>贪心算法</li>
<li>回溯算法</li>
</ul>
<h2 id="_3">栈、队列<a class="headerlink" href="#_3" title="Permanent link"></a></h2>
<ul>
<li>【easy】 <a href="https://leetcode.cn/problems/valid-parentheses/">20 有效的括号</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/number-of-recent-calls/">933 最近的请求次数</a></li>
</ul>
<h2 id="_4">链表<a class="headerlink" href="#_4" title="Permanent link"></a></h2>
<ul>
<li>【medium】 <a href="https://leetcode.cn/problems/add-two-numbers/">2 两数相加</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21 合并两个有序链表</a></li>
<li>【hard】 <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23 合并K个升序链表</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83 删除排序链表中的重复元素</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/linked-list-cycle/">141 环形链表</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/reverse-linked-list/">206 反转链表</a></li>
<li>🌟【hard】<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></li>
</ul>
<h2 id="_5">集合<a class="headerlink" href="#_5" title="Permanent link"></a></h2>
<ul>
<li>【easy】 <a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349 两个数组的交集</a></li>
</ul>
<h2 id="_6">字典、滑动窗口、双指针<a class="headerlink" href="#_6" title="Permanent link"></a></h2>
<ul>
<li>【easy】 <a href="https://leetcode.cn/problems/two-sum/">1 两数之和</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3 无重复字符的最长子串</a></li>
<li>【hard】 <a href="https://leetcode.cn/problems/minimum-window-substring/">76 最小覆盖子串</a></li>
</ul>
<h2 id="_7">树、深度优先、广度优先<a class="headerlink" href="#_7" title="Permanent link"></a></h2>
<ul>
<li>【easy】 <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94 二叉树的中序遍历</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/same-tree/">100 相同的树</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/symmetric-tree/">101 对称二叉树</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102 二叉树的层序遍历</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104 二叉树的最大深度</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111 二叉树的最小深度</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/path-sum/">112 路径总和</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/invert-binary-tree/">226 翻转二叉树</a></li>
<li>🌟【easy】 <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543 二叉树的直径</a></li>
</ul>
<h2 id="_8">堆<a class="headerlink" href="#_8" title="Permanent link"></a></h2>
<ul>
<li>【hard】 <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23 合并K个升序链表</a></li>
<li>🌟【medium】 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215 数组中的第K个最大元素</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/invert-binary-tree/">226 翻转二叉树</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/top-k-frequent-elements/">347 前 K 个高频元素</a></li>
</ul>
<h2 id="_9">图、深度优先、广度优先<a class="headerlink" href="#_9" title="Permanent link"></a></h2>
<ul>
<li>【medium】 <a href="https://leetcode.cn/problems/clone-graph/">113 克隆图</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417 太平洋大西洋水流问题</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/number-of-islands/">200 岛屿数量</a></li>
</ul>
<h2 id="_10">搜索、排序<a class="headerlink" href="#_10" title="Permanent link"></a></h2>
<ul>
<li>【easy】 <a href="https://leetcode.cn/problems/guess-number-higher-or-lower/">374 猜数字大小</a></li>
</ul>
<h2 id="_11">分治法<a class="headerlink" href="#_11" title="Permanent link"></a></h2>
<p>特征是：先拆分、再解决、后合并</p>
<p>将一个问题拆分成很多个和原问题相似的小问题，递归解决小问题，再将结果合并以解决原来的问题</p>
<ul>
<li>【easy】<a href="https://leetcode.cn/problems/same-tree/">100 相同的树</a></li>
<li>【easy】<a href="https://leetcode.cn/problems/invert-binary-tree/">226 翻转二叉树</a></li>
</ul>
<h2 id="_12">动态规划<a class="headerlink" href="#_12" title="Permanent link"></a></h2>
<p>特征是：某个结果会依赖前面的结果，或者前面的几个结果之间有关联</p>
<ul>
<li>【easy】 <a href="https://leetcode.cn/problems/climbing-stairs/">70 爬楼梯</a></li>
<li>【easy】<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121 买卖股票的最佳时机</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122 买卖股票的最佳时机 II</a></li>
<li>【hard】 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123 买卖股票的最佳时机 III</a></li>
<li>【hard】 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188 买卖股票的最佳时机 IV</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714 买卖股票的最佳时机含手续费</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/house-robber/">198 打家劫舍</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309 最佳买卖股票时机含冷冻期</a></li>
<li>【hard】 <a href="https://leetcode.cn/problems/trapping-rain-water/">42 接雨水</a></li>
<li>🌟【easy】 <a href="https://leetcode.cn/problems/maximum-subarray/">53 最大子数组和</a></li>
<li>🌟【medium】 <a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300 最长递增子序列</a></li>
<li>🌟【hard】 <a href="https://leetcode.cn/problems/edit-distance/">72 编辑距离</a></li>
</ul>
<h2 id="_13">贪心算法<a class="headerlink" href="#_13" title="Permanent link"></a></h2>
<p>特征是：期盼通过每个阶段的局部最优选择，从而达到全局的最优，结果并不一定是最优。</p>
<ul>
<li>【medium】 <a href="https://leetcode.cn/problems/longest-palindromic-substring/">5 最长回文子串</a></li>
<li>【easy】 <a href="https://leetcode.cn/problems/assign-cookies/">455 分发饼干</a></li>
</ul>
<h2 id="_14">回溯算法<a class="headerlink" href="#_14" title="Permanent link"></a></h2>
<p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<ul>
<li>【medium】 <a href="https://leetcode.cn/problems/permutations/">46 全排列</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/permutations-ii/">47 全排列 II</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/subsets/">78 子集</a></li>
<li>【medium】 <a href="https://leetcode.cn/problems/generate-parentheses/">22 括号生成</a></li>
</ul>
<h2 id="_15">二分查找、二分搜索<a class="headerlink" href="#_15" title="Permanent link"></a></h2>
<ul>
<li>【easy】 <a href="https://leetcode.cn/problems/binary-search/">704 二分查找</a></li>
<li>🌟【hard】 <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4 寻找两个正序数组的中位数</a></li>
<li>🌟【easy】 <a href="https://leetcode.cn/problems/first-bad-version/">278 第一个错误的版本</a></li>
<li>🌟【medium】<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33 搜索旋转排序数组</a></li>
</ul>
<h1 id="_16">时间复杂度和空间复杂度<a class="headerlink" href="#_16" title="Permanent link"></a></h1>
<p>递归时间复杂度就是看它 每次递归进行了什么操作和递归了多少次</p>
<p>递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度</p>
<p>或者说递归算法的空间复杂度是任一时刻，占用的空间是多少</p>
<h2 id="_17">递归算法的时间与空间复杂度分析<a class="headerlink" href="#_17" title="Permanent link"></a></h2>
<ul>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md">递归算法的时间与空间复杂度分析！</a></li>
<li><a href="https://blog.csdn.net/youngyangyang04/article/details/106313759">程序员算法面试中，递归算法的空间复杂度你知道怎么求么？</a></li>
</ul>
<h1 id="_18">😻✔ 基础算法<a class="headerlink" href="#_18" title="Permanent link"></a></h1>
<p>常见复杂度曲线：</p>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/1652356442444_09edc6aa-6dfe-41aa-bd02-b9f3097b3717.png" /></p>
<p>排序算法排序流程图解：</p>
<p><a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a></p>
<h2 id="_19">😻✔ 排序算法<a class="headerlink" href="#_19" title="Permanent link"></a></h2>
<p>ref</p>
<ul>
<li><a href="https://juejin.im/post/5d9033fa5188257f6f1ba46b">丰富图例讲解十大经典排序算法</a></li>
<li><a href="https://github.com/lxfriday/give-me-job/tree/7c193c8279/algorithm/%E6%8E%92%E5%BA%8F">排序算法</a></li>
</ul>
<p><img alt="排序算法一览" src="https://qiniu1.lxfriday.xyz/feoffer/sort.png" /></p>
<h3 id="_20">😻✔ 冒泡排序<a class="headerlink" href="#_20" title="Permanent link"></a></h3>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/bubbleSort.png" /></p>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">swap</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">([</span><span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">b</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">b</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">]])</span>
<span class="kd">function</span> <span class="nx">bubbleSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">changed</span> <span class="o">=</span> <span class="kc">false</span> <span class="c1">// 没有数据交换则表示已经有序了</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nx">changed</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">changed</span><span class="p">)</span> <span class="k">break</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</pre></div>

<h3 id="_21">😻✔ 选择排序<a class="headerlink" href="#_21" title="Permanent link"></a></h3>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/ec43f415-5224-bd9b-ad33-0ee480cd19e7.png" /></p>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/selectionSort.gif" /></p>
<p>核心思想：进行 n 轮，每轮找出最小的放在这一轮的初始位置</p>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">swap</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">([</span><span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">b</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">b</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">]])</span>
<span class="kd">function</span> <span class="nx">selectionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">len</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">i</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">min</span><span class="p">])</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">j</span>
    <span class="p">}</span>
    <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">min</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</pre></div>

<h3 id="_22">😻✔ 插入排序<a class="headerlink" href="#_22" title="Permanent link"></a></h3>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/6e79c1d5-2896-68bc-ebc0-280ee2881035.png" /></p>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/insertionSort.gif" /></p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">insertionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">len</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">cur</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cur</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</pre></div>

<h3 id="_23">😻✔ 快速排序<a class="headerlink" href="#_23" title="Permanent link"></a></h3>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/008ba6a2-d847-8894-a3b4-70b09a1b44b8.png" /></p>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/quicksort.gif" /></p>
<p>复杂度分析：</p>
<ul>
<li><a href="https://www.cnblogs.com/tuyang1129/p/12857821.html#22-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">快速排序的时间复杂度</a></li>
</ul>
<p>快排的最好时间复杂度是O(logn)、最差会退化到 O(n^2)。</p>
<p>单路快排</p>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">swap</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">([</span><span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">b</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">b</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">]])</span>
<span class="kd">function</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">pivot</span> <span class="o">=</span> <span class="nx">left</span>
  <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">pivot</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">pivot</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span>
      <span class="nx">index</span><span class="o">++</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">pivot</span><span class="p">,</span> <span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">l</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span> <span class="o">?</span> <span class="nx">l</span> <span class="o">:</span> <span class="mi">0</span>
  <span class="kr">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">r</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span> <span class="o">?</span> <span class="nx">r</span> <span class="o">:</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="kd">let</span> <span class="nx">partitionIndex</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">partitionIndex</span> <span class="o">=</span> <span class="nx">partition</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
    <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">partitionIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">partitionIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</pre></div>

<p>更好理解的快排</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">partition2</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span>
  <span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="kr">const</span> <span class="nx">leftArr</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kr">const</span> <span class="nx">rightArr</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">leftArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">rightArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">[...</span><span class="nx">partition2</span><span class="p">(</span><span class="nx">leftArr</span><span class="p">),</span> <span class="nx">target</span><span class="p">,</span> <span class="p">...</span><span class="nx">partition2</span><span class="p">(</span><span class="nx">rightArr</span><span class="p">)]</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">quickSort2</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">partition2</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<h3 id="_24">😻✔ 归并排序<a class="headerlink" href="#_24" title="Permanent link"></a></h3>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/3ccf988e-b992-84f0-a622-dd03c51123c9.png" /></p>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/d3de0b1f-7827-e3b9-eeb7-1993e03e0372.png" /></p>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/16d7b507ece11c9d.gif" /></p>
<p>归并排序（英语：Merge sort，或 mergesort），是创建在归并操作上的一种有效的排序算法，效率为 O(nlogn)。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用 分治法（Divide and Conquer） 的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<p>采用分治法:</p>
<ol>
<li>分割：递归地把当前序列平均分割成两半。</li>
<li>集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。</li>
</ol>
<p>归并排序时间复杂度分析</p>
<ul>
<li><a href="https://www.cnblogs.com/tuyang1129/p/12857821.html">快速排序和归并排序的时间复杂度分析——通俗易懂</a></li>
</ul>
<p>时间复杂度计算方式：递归层数 * 每层的时间复杂度(logn * n)，每层的时间复杂度都是n，都会把 n 个元素全部遍历一遍，而递归的层数取决于拆分的次数，n个元素需要拆分 logn 次。</p>
<p>空间复杂度计算方式：任一时刻占用的空间，</p>
<p>比较容易理解的版本</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">arr2</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr1</span><span class="p">.</span><span class="nx">shift</span><span class="p">())</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr2</span><span class="p">.</span><span class="nx">shift</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr1</span><span class="p">.</span><span class="nx">shift</span><span class="p">())</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">arr2</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr2</span><span class="p">.</span><span class="nx">shift</span><span class="p">())</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">len</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span>
  <span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="kr">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
  <span class="kr">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr1</span><span class="p">),</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr2</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>

<p>执行效率更高的版本</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">mergeSort1</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">l</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">l</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span> <span class="o">?</span> <span class="nx">l</span> <span class="o">:</span> <span class="mi">0</span>
  <span class="nx">r</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">r</span> <span class="o">===</span> <span class="s1">&#39;number&#39;</span> <span class="o">?</span> <span class="nx">r</span> <span class="o">:</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="o">===</span> <span class="nx">l</span><span class="p">)</span> <span class="k">return</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">l</span><span class="p">]]</span>
  <span class="kr">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">merge1</span><span class="p">(</span><span class="nx">mergeSort1</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">mid</span><span class="p">),</span> <span class="nx">mergeSort1</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">r</span><span class="p">))</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">merge1</span><span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kr">const</span> <span class="nx">len1</span> <span class="o">=</span> <span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">len2</span> <span class="o">=</span> <span class="nx">arr2</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">let</span> <span class="nx">l1</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">l2</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">l1</span> <span class="o">&lt;</span> <span class="nx">len1</span> <span class="o">&amp;&amp;</span> <span class="nx">l2</span> <span class="o">&lt;</span> <span class="nx">len2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">l1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">arr2</span><span class="p">[</span><span class="nx">l2</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">l1</span><span class="o">++</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr2</span><span class="p">[</span><span class="nx">l2</span><span class="o">++</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">l1</span> <span class="o">&lt;</span> <span class="nx">len1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">l1</span><span class="o">++</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">l2</span> <span class="o">&lt;</span> <span class="nx">len2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr2</span><span class="p">[</span><span class="nx">l2</span><span class="o">++</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>

<p>上面两个的归并排序在排序大数据量时将会有非常大的差距，原因在于前一个易于理解的版本大量使用了数组操作的函数(slice、shift)，而后者并没有这种操作。</p>
<div class="highlight"><pre><span class="c1">// 比较时间</span>
<span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">500000</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">data1</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">time</span><span class="p">(</span><span class="s1">&#39;mergeSort1&#39;</span><span class="p">)</span>
<span class="nx">mergeSort1</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">timeLog</span><span class="p">(</span><span class="s1">&#39;mergeSort1&#39;</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">time</span><span class="p">(</span><span class="s1">&#39;mergeSort2&#39;</span><span class="p">)</span>
<span class="nx">mergeSort2</span><span class="p">(</span><span class="nx">data1</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">timeLog</span><span class="p">(</span><span class="s1">&#39;mergeSort2&#39;</span><span class="p">)</span>

<span class="c1">// mergeSort1: 44.905s</span>
<span class="c1">// mergeSort2: 81.709ms</span>
</pre></div>

<p>迭代法实现</p>
<div class="highlight"><pre><span class="c1">// 迭代法实现归并排序</span>
<span class="c1">// 对 [i, j] 范围内的数字进行排序</span>
<span class="c1">// [i, j] 范围内的数字分为两半之后，两个部分都是已经排好序数组</span>
<span class="kd">function</span> <span class="nx">sort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">let</span> <span class="nx">firstL</span> <span class="o">=</span> <span class="nx">i</span>
  <span class="kr">const</span> <span class="nx">firstR</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">j</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// midIndex</span>
  <span class="kd">let</span> <span class="nx">secondL</span> <span class="o">=</span> <span class="nx">firstR</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="kr">const</span> <span class="nx">secondR</span> <span class="o">=</span> <span class="nx">j</span>
  <span class="c1">// 需要一个数字暂存排序结果</span>
  <span class="kr">const</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">firstL</span> <span class="o">&lt;=</span> <span class="nx">firstR</span> <span class="o">&amp;&amp;</span> <span class="nx">secondL</span> <span class="o">&lt;=</span> <span class="nx">secondR</span> <span class="o">&amp;&amp;</span> <span class="nx">secondL</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">firstL</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">secondL</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">tmp</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">firstL</span><span class="o">++</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">tmp</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">secondL</span><span class="o">++</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">firstL</span> <span class="o">&lt;=</span> <span class="nx">firstR</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">tmp</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">firstL</span><span class="o">++</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">secondL</span> <span class="o">&lt;=</span> <span class="nx">secondR</span> <span class="o">&amp;&amp;</span> <span class="nx">secondL</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">tmp</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">secondL</span><span class="o">++</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">k</span> <span class="o">=</span> <span class="nx">i</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">k</span> <span class="o">&lt;=</span> <span class="nx">j</span> <span class="o">&amp;&amp;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">[</span><span class="nx">k</span> <span class="o">-</span> <span class="nx">i</span><span class="p">]</span>
    <span class="nx">k</span><span class="o">++</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="c1">// 拆分 logn 次</span>
  <span class="c1">// 每次拆分之后，总和来看进行的是对 n 个数字排序，空间复杂度是 O(n)，所有的数子都会被放到 tmp 数组中一次</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 对拆分的所有子序列进行排序，复杂度是 n</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">*</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">startIndex</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">*</span> <span class="nx">j</span>
      <span class="kr">const</span> <span class="nx">endIndex</span> <span class="o">=</span> <span class="nx">startIndex</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="kr">const</span> <span class="nx">midIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">startIndex</span> <span class="o">+</span> <span class="nx">endIndex</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
      <span class="c1">// 结尾可能存在小于i个数的情况，这时候要判断要不要排序</span>
      <span class="c1">// 如果结尾有k个数，且 k &gt; i / 2，则是需要排序的</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">midIndex</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">startIndex</span><span class="p">,</span> <span class="nx">endIndex</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</pre></div>

<h3 id="_25">😻✔ 希尔排序<a class="headerlink" href="#_25" title="Permanent link"></a></h3>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/907976b2-e3b0-91fc-0b6d-3ead3ee08c1c.png" /></p>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/16d7b4ce200763d6.gif" /></p>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">shellSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">len</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span>
  <span class="c1">// gap 不断缩小，最后变成 1</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">gap</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">gap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">gap</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// gap 确定之后，从 gap 位置开始向后循环</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">gap</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="nx">gap</span>
      <span class="c1">// i 每轮循环中需要从左往右做插排</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">temp</span><span class="p">;</span> <span class="nx">j</span> <span class="o">-=</span> <span class="nx">gap</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="nx">gap</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
      <span class="p">}</span>
      <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="nx">gap</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</pre></div>

<h3 id="heap-sort">😻✔ 堆排序(heap-sort)<a class="headerlink" href="#heap-sort" title="Permanent link"></a></h3>
<p><img alt="堆排序" src="https://qiniu1.lxfriday.xyz/feoffer/heapSort2.png" />
<img alt="堆排序" src="https://qiniu1.lxfriday.xyz/feoffer/heapSort.gif" /></p>
<p>堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。其中每个节点最多存在两个子节点，对以 0 开始的堆数组，有如下规则：</p>
<ol>
<li>父节点 <code>i</code> 的<strong>左</strong>子节点在位置 <code>2 * i + 1</code></li>
<li>父节点 <code>i</code> 的<strong>右</strong>子节点在位置 <code>2 * i + 2</code></li>
<li>子节点 <code>i</code> 的父节点在位置 <code>Math.floor((i - 1) / 2)</code></li>
</ol>
<p>大顶堆：所有节点 <code>i</code> 的值比其左右子节点都大的堆</p>
<p>小顶堆：所有节点 <code>i</code> 的值比其左右子节点都小的堆</p>
<p>堆排序的重要过程（以大顶堆实现从小到大为例）：</p>
<ol>
<li>构建大顶堆</li>
<li>把 0 和最后一位交换（无序数组的最后一位）</li>
<li>从 0 位重新构建大顶堆</li>
<li>重复步骤 2、3</li>
</ol>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">swap</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">([</span><span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">b</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">b</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">a</span><span class="p">]])</span>
<span class="c1">// 构建大顶堆的核心递归算法</span>
<span class="kd">function</span> <span class="nx">heapifyMax</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="kr">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span>
  <span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">i</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">max</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">max</span> <span class="o">=</span> <span class="nx">left</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">right</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">max</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">max</span> <span class="o">=</span> <span class="nx">right</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">!=</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">heapifyMax</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">max</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 构建小顶堆的核心递归算法</span>
<span class="kd">function</span> <span class="nx">heapifyMin</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="kr">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span>
  <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">i</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">min</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">min</span> <span class="o">=</span> <span class="nx">left</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">right</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">min</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">min</span> <span class="o">=</span> <span class="nx">right</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">!=</span> <span class="nx">min</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">min</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">heapifyMin</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">min</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">buildMaxHeap</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">heapifyMax</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">buildMinHeap</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">heapifyMin</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// asc 为 true 表示从小到大，false 为从大到小</span>
<span class="kd">function</span> <span class="nx">heapSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">asc</span> <span class="o">=</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">asc</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 使用大顶堆实现从小到大排序</span>
    <span class="nx">buildMaxHeap</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
    <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
      <span class="nx">heapifyMax</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 使用小顶堆实现从大到小排序</span>
    <span class="nx">buildMinHeap</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
    <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
      <span class="nx">heapifyMin</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</pre></div>

<h3 id="counting-sort">😻✔ 计数排序(counting-sort)<a class="headerlink" href="#counting-sort" title="Permanent link"></a></h3>
<p><img alt="计数排序" src="https://qiniu1.lxfriday.xyz/feoffer/countingSort.png" /></p>
<p><strong>限定为非负数</strong></p>
<p>计数排序是一种稳定的线性时间排序算法。计数排序使用一个额外的数组 <code>C</code> ，其中第 <code>i</code> 个元素是待排序数组 <code>A</code> 中值等于 <code>i</code> 的元素的个数。然后根据数组 <code>C</code> 来将 <code>A</code> 中的元素排到正确的位置。</p>
<p>当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 <code>t(n+k)</code>。<strong>计数排序不是比较排序，排序的速度快于任何比较排序算法。</strong></p>
<p>由于用来计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">countingSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span>
  <span class="kr">const</span> <span class="nx">bucket</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">let</span> <span class="nx">sortIndex</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]])</span> <span class="p">{</span>
      <span class="nx">bucket</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">bucket</span><span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">bucket</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="nx">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">arr</span><span class="p">[</span><span class="nx">sortIndex</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</pre></div>

<h3 id="radix-sort">😻✔ 基数排序(radix-sort)<a class="headerlink" href="#radix-sort" title="Permanent link"></a></h3>
<p><img alt="基数排序" src="https://qiniu1.lxfriday.xyz/feoffer/radixSort.png" /></p>
<p><strong>限定为非负数</strong></p>
<p>基数排序原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>基数排序的方式可以采用 <strong>LSD（Least significant digital）</strong> 或 <strong>MSD（Most significant digital）</strong>，LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。</p>
<p>基数排序的时间复杂度是 <code>O(k*n)</code>，其中 <code>n</code> 是排序元素个数，<code>k</code> 是数字位数。这不是说这个时间复杂度一定优于 <code>O(nlogn)</code>，<code>k</code> 的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；<code>k</code> 决定了进行多少轮处理，而 <code>n</code> 是每轮处理的操作数目。</p>
<p>LSD 实现</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">radixSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="c1">// 得到最大值</span>
  <span class="kr">const</span> <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">arr</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">bucket</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1">// 获取最大值的位数</span>
  <span class="kd">let</span> <span class="nx">digit</span> <span class="o">=</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">max</span><span class="p">}</span><span class="err">`</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">let</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="c1">// 待操作的新数组</span>
  <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">()</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">digit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 每轮向左移动一位</span>
    <span class="nx">start</span> <span class="o">*=</span> <span class="mi">10</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">%</span> <span class="nx">start</span>
      <span class="c1">// 和计数排序类似</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="p">}</span>
      <span class="c1">// bucket 是一个二维数组</span>
      <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>

    <span class="c1">// 拼接前 res 设为空数组</span>
    <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">bucket</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// res 拼接 bucket[i] 数组</span>
        <span class="nx">res</span> <span class="o">=</span> <span class="nx">res</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 结束之后 bucket 重置</span>
    <span class="nx">bucket</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nx">digit</span><span class="o">--</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>

<h3 id="bucket-sort">😻✔ 桶排序、箱排序(bucket-sort)<a class="headerlink" href="#bucket-sort" title="Permanent link"></a></h3>
<p><img alt="桶排序" src="https://qiniu1.lxfriday.xyz/feoffer/bucketSort.png" /></p>
<p>桶排序工作原理是将数组分到有限数量的桶里，每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p>
<p>桶排序以下列步骤进行：</p>
<ol>
<li>设置桶个数 <code>size</code>，计算每个桶的存储范围；</li>
<li>遍历数组，把数字放到对应的桶中；</li>
<li>对步骤 2 放新数字的桶数组排序；</li>
<li>数组遍历完之后，把桶中的数字依次取出放到最终的数组中；</li>
</ol>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">;[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * @param {array} arr 待排序的数组</span>
<span class="cm"> * @param {number} size 桶的个数</span>
<span class="cm"> */</span>
<span class="kd">function</span> <span class="nx">bucketSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="c1">// 取到最小值</span>
  <span class="kr">const</span> <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(...</span><span class="nx">arr</span><span class="p">)</span>
  <span class="c1">// 取得最大值</span>
  <span class="kr">const</span> <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">arr</span><span class="p">)</span>
  <span class="c1">// 每个桶的范围</span>
  <span class="kr">const</span> <span class="nx">bucketSize</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">max</span> <span class="o">-</span> <span class="nx">min</span><span class="p">)</span> <span class="o">/</span> <span class="nx">size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1">// 总共的桶容器</span>
  <span class="kr">const</span> <span class="nx">bucket</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// arr[i] 分布在桶 j</span>
    <span class="kr">const</span> <span class="nx">j</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">min</span><span class="p">)</span> <span class="o">/</span> <span class="nx">bucketSize</span><span class="p">)</span>

    <span class="c1">// 桶不存在则创建</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="p">}</span>
    <span class="c1">// 将 arr[i] 推入桶中</span>
    <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">l</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 对个别桶使用冒泡</span>
      <span class="c1">// 若 arr[i] 在桶内不是最小，则向前移动</span>
      <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">][</span><span class="nx">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nx">l</span><span class="o">--</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 把 bucket 二维数组中的数据全部拿出来</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">bucket</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">bucket</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">bucket</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>

<h2 id="_26">✔ 搜索算法<a class="headerlink" href="#_26" title="Permanent link"></a></h2>
<h3 id="_27">😻✔ 二分搜索算法<a class="headerlink" href="#_27" title="Permanent link"></a></h3>
<p>二分搜索算法的前提是目标数组已经排好序了。</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(1 * logn)  =&gt; O(logn)</span>
<span class="c1">// 空间复杂度：O(1* logn) =&gt; O(logn)</span>
<span class="kd">function</span> <span class="nx">binarySearch</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">l</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">med</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">target</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">med</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">r</span> <span class="o">=</span> <span class="nx">med</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">target</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">med</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">l</span> <span class="o">=</span> <span class="nx">med</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">med</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>

<p>复杂度分析：</p>
<ul>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md#%E4%BA%8C%E5%88%86%E6%B3%95%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">二分法（递归实现）的性能分析</a></li>
</ul>
<p>二分法的拆分次数是 logn 次</p>
<p>时间复杂度 = 拆分次数 * 每次拆分的时间复杂度，则结果是 logn * 1 = O(logn)</p>
<p>空间复杂度= 递归深度 * 每次递归的空间复杂度，则结果是 logn * 1 = O(logn)</p>
<h2 id="lru">😻✔ LRU 缓存算法<a class="headerlink" href="#lru" title="Permanent link"></a></h2>
<p>ref</p>
<ul>
<li><a href="https://juejin.im/post/5d77b68951882520d46abd18">https://juejin.im/post/5d77b68951882520d46abd18</a></li>
</ul>
<blockquote>
<p>运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
</blockquote>
<p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：<strong>先进先出策略</strong> FIFO（First In，First Out）、<strong>最少使用策略</strong> LFU（Least Frequently Used）、<strong>最近最少使用策略</strong> LRU（Least Recently Used）。</p>
<p>最近最少，越是最近使用就越是不会被清除，而最远使用的将会逐渐被推到丢弃端，如果一直不被使用，数据不断存入时将会丢弃它们。</p>
<p>使用 ES6 Map 实现</p>
<div class="highlight"><pre><span class="kr">class</span> <span class="nx">LRUCache</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">capacity</span> <span class="o">=</span> <span class="nx">capacity</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="nx">put</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">k</span><span class="p">))</span> <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">capacity</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">keys</span><span class="p">().</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">get</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span> <span class="k">this</span><span class="p">.</span><span class="nx">moveToEnd</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">v</span>
  <span class="p">}</span>
  <span class="nx">moveToEnd</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>双向链表实现</p>
<div class="highlight"><pre><span class="kr">class</span> <span class="nx">LinkedListNode</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">prev</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="nx">k</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">v</span>
    <span class="c1">// 前向节点</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">prev</span>
    <span class="c1">// 后向节点</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">next</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">LRUCache</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 容量</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">capacity</span> <span class="o">=</span> <span class="nx">capacity</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cache</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1">// 实际存储的容量</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// 哨兵头结点</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LinkedListNode</span><span class="p">()</span>
    <span class="c1">// 哨兵尾结点</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LinkedListNode</span><span class="p">()</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tail</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span>
  <span class="p">}</span>

  <span class="c1">// 删除节点</span>
  <span class="nx">removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">prev</span>
    <span class="kr">const</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span>

    <span class="nx">prev</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">next</span>
    <span class="nx">next</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">prev</span>
  <span class="p">}</span>

  <span class="c1">// 新增一个节点</span>
  <span class="nx">addNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">prev</span> <span class="o">=</span> <span class="nx">node</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span>
  <span class="p">}</span>
  <span class="c1">// 删除尾结点</span>
  <span class="nx">popTail</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">prev</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">removeNode</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
  <span class="p">}</span>

  <span class="nx">put</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LinkedListNode</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">n</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">addNode</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">deleteNode</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">popTail</span><span class="p">()</span>
        <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">deleteNode</span><span class="p">.</span><span class="nx">key</span><span class="p">]</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">v</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">addNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">get</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">addNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="_28">😻✔ 斐波拉契数列<a class="headerlink" href="#_28" title="Permanent link"></a></h2>
<div class="highlight"><pre>1 1 2 3 5 8 13 21 34 55 89
</pre></div>

<p><strong>尾递归</strong></p>
<p>现在浏览器和 NodeJS 已经禁用了尾递归优化，所以仅仅是尾递归，并不会起到优化的作用。</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">function</span> <span class="nx">Fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">prev1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">prev2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">prev1</span>
  <span class="k">return</span> <span class="nx">Fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">prev1</span> <span class="o">+</span> <span class="nx">prev2</span><span class="p">,</span> <span class="nx">prev1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<p><strong>迭代</strong></p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">function</span> <span class="nx">Fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">init</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">;[</span><span class="nx">init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">init</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">init</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>

<p>递归版本，极其低效，其实际进行了大量的重复计算</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(2 ^ n)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">function</span> <span class="nx">Fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="nx">Fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">Fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<h2 id="_29">✔ 斐波拉契数列的时间复杂度和空间复杂度<a class="headerlink" href="#_29" title="Permanent link"></a></h2>
<p>依据实现存在较大的差异。</p>
<p><a href="https://blog.csdn.net/youngyangyang04/article/details/106313759">ref</a>
<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md">递归算法的时间与空间复杂度分析！</a></p>
<h2 id="_30">😻✔ 因式分解<a class="headerlink" href="#_30" title="Permanent link"></a></h2>
<p>实现一个 <code>calc</code> 方法，可以将输入的数拆解为尽可能多的乘数，所有数相乘等于输入数。</p>
<div class="highlight"><pre><span class="nx">calc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// [2]</span>
<span class="nx">calc</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="c1">// [2, 2, 2]</span>
<span class="nx">calc</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span> <span class="c1">// [2, 2, 2, 3]</span>
<span class="nx">calc</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="c1">// [2, 3, 5]</span>
</pre></div>

<div class="highlight"><pre><span class="kd">function</span> <span class="nx">calc</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">n</span>
  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">prev</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">prev</span> <span class="o">%</span> <span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
      <span class="nx">prev</span> <span class="o">/=</span> <span class="nx">i</span>
      <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prev</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">i</span><span class="o">++</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">prev</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>

  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>

<h1 id="from-">from - 其他<a class="headerlink" href="#from-" title="Permanent link"></a></h1>
<h2 id="_31">✔ 从数组中找出和为某个值的两数下标<a class="headerlink" href="#_31" title="Permanent link"></a></h2>
<blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]。</p>
</blockquote>
<p>初始代码：</p>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">twoSum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{}</span>
</pre></div>

<hr />
<p>解法 1 - <code>Map</code>：</p>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">twoSum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span> <span class="o">-</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">i</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>解法 2 - 两次循环：</p>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">twoSum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">===</span> <span class="nx">target</span><span class="p">)</span> <span class="k">return</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h1 id="leetcode">leetcode 刷题记录<a class="headerlink" href="#leetcode" title="Permanent link"></a></h1>
<h2 id="1-easy">😻✔ 1 两数之和【easy】<a class="headerlink" href="#1-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/two-sum/">ref</a></p>
<p>Map、字典</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">twoSum</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// for (var i = 0; i &lt; nums.length; i++) {</span>
  <span class="c1">//   for (var j = i + 1; j &lt; nums.length; j++) {</span>
  <span class="c1">//     if (nums[i] + nums[j] === target) return [i, j]</span>
  <span class="c1">//   }</span>
  <span class="c1">// }</span>
  <span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="kr">const</span> <span class="nx">other</span> <span class="o">=</span> <span class="nx">target</span> <span class="o">-</span> <span class="nx">num</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">other</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">m</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">other</span><span class="p">),</span> <span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="2-medium">😻✔ 2 两数相加【medium】<a class="headerlink" href="#2-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/add-two-numbers/">ref</a></p>
<p>链表</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">addTwoNumbers</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">l1</span><span class="p">,</span> <span class="nx">l2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nx">curr</span> <span class="o">=</span> <span class="nx">head</span>
  <span class="kd">let</span> <span class="nx">add</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">l1</span> <span class="o">||</span> <span class="nx">l2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">l1</span> <span class="o">?</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">val</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">l2</span> <span class="o">?</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">val</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nx">add</span>
    <span class="nx">add</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nx">curr</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">sum</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">add</span><span class="p">)</span>
    <span class="nx">l1</span> <span class="o">=</span> <span class="nx">l1</span> <span class="o">&amp;&amp;</span> <span class="nx">l1</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">l2</span> <span class="o">=</span> <span class="nx">l2</span> <span class="o">&amp;&amp;</span> <span class="nx">l2</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">curr</span> <span class="o">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">next</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">add</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curr</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">val</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="nx">val</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">next</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="nx">next</span>
<span class="p">}</span>
</pre></div>

<h2 id="3-medium">😻✔ 3 无重复字符的最长子串【medium】<a class="headerlink" href="#3-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">ref</a></p>
<p>滑动窗口、字典</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">lengthOfLongestSubstring</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maxLen</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">currStr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">indInCurrStr</span> <span class="o">=</span> <span class="nx">currStr</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="kd">let</span> <span class="nx">len</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">indInCurrStr</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">currStr</span> <span class="o">+=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="nx">len</span> <span class="o">=</span> <span class="nx">currStr</span><span class="p">.</span><span class="nx">length</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">len</span> <span class="o">=</span> <span class="nx">currStr</span><span class="p">.</span><span class="nx">length</span>
      <span class="nx">currStr</span> <span class="o">=</span> <span class="nx">currStr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">indInCurrStr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="nx">maxLen</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">&gt;</span> <span class="nx">maxLen</span> <span class="o">?</span> <span class="nx">len</span> <span class="o">:</span> <span class="nx">maxLen</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">maxLen</span>
<span class="p">}</span>
</pre></div>

<p>or</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">lengthOfLongestSubstring</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">r</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="nx">l</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">l</span> <span class="o">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">r</span><span class="p">],</span> <span class="nx">r</span><span class="p">)</span>
    <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">max</span><span class="p">,</span> <span class="nx">r</span> <span class="o">-</span> <span class="nx">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">max</span>
<span class="p">}</span>
</pre></div>

<h2 id="4-hard">🌟😻✔ 4 寻找两个正序数组的中位数【hard】<a class="headerlink" href="#4-hard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">ref</a></p>
<p>二分查找</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(log(m + n))</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">findMedianSortedArrays</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums1</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 利用中位数的特殊属性</span>
  <span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">nums1</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">nums2</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">totalLength</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">totalLength</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 中位数就在数组中</span>
    <span class="kr">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="p">(</span><span class="nx">totalLength</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="nx">getTarget</span><span class="p">(</span><span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">nums1</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 中位数是最中间两个数的均值</span>
    <span class="kr">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nx">totalLength</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">getTarget</span><span class="p">(</span><span class="nx">mid</span><span class="p">,</span> <span class="nx">nums1</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">getTarget</span><span class="p">(</span><span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">nums1</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 转化为获取 nums1 和 nums2 数组中的第 k 大的数</span>
<span class="c1">// 两个数组是排好序的数组</span>
<span class="kd">function</span> <span class="nx">getTarget</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">nums1</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 对于两个数组中下标为 k / 2 - 1(即第 k / 2 个) 的数字A(k / 2 - 1)和 B(k / 2 - 1)</span>
  <span class="c1">// ----------------------------------------------------------------------</span>
  <span class="c1">// 如果 A(k / 2 - 1) &lt; B(k / 2 - 1) ，则有这样一个规则存在</span>
  <span class="c1">// 在 A、B 两个数组的前 k / 2 个数字中（即 A+B 的前K个数字中），A(k / 2 - 1)最多只能是第 k - 1 个数字，不可能是第 K 个数字</span>
  <span class="c1">// 由于 A(k / 2 - 1)  前面的数字比它还小，则其前面的数字只能排在A + B 数组的 k - 1 之前，则可以断定，第 K 个数字肯定不在 A[0]~A[k / 2 - 1] 内</span>
  <span class="c1">// 就可以把 A 中下标在 k / 2 之前的全部排除</span>
  <span class="c1">// 排除之后，新的 newK = k - (k / 2)</span>
  <span class="c1">// ----------------------------------------------------------------------</span>
  <span class="c1">// 如果 A(k / 2 - 1) &gt; B(k / 2 - 1) 则对 B 进行上面的操作</span>
  <span class="c1">// ----------------------------------------------------------------------</span>
  <span class="c1">// 如果 A(k / 2 - 1) === B(k / 2 - 1) ，则 A 中 k / 2 - 1 前面的数字和 B 中 k / 2 - 1 前面的数字合并起来，也最多只能排在 k - 2 位</span>
  <span class="c1">// 则实际上 A(k / 2 - 1) 和 B(k / 2 - 1) 前面的数字都可以【排除掉】</span>
  <span class="c1">// 因为 A(k / 2 - 1) 和 B(k / 2 - 1) 是相等的，则 A(k / 2 - 1) 这一项也可以排除掉，极端情况下，刚好 B(k / 2 - 1) 就是想要的值</span>
  <span class="c1">// 综合之后就是，两者相等的时候，选择同 A(k / 2 - 1) &lt; B(k / 2 - 1) 一样的操作，把 A 中前 k / 2 个数字全部排除掉</span>
  <span class="c1">// ----------------------------------------------------------------------</span>
  <span class="c1">// 由于 k 表示的是在 剩下的 nums1 和 nums2 合并后的有序数组中，第 k 个数字</span>
  <span class="c1">// 则当 k = 1 的时候 ，直接比较剩下的 nums1 和 nums2 两数组中靠在最前面且未被排除的下标，即可得出结果。</span>
  <span class="c1">// ----------------------------------------------------------------------</span>
  <span class="c1">// 这里 k 可能是奇数也可能是偶数，是偶数就完全符合上面的推断，是奇数的时候， k / 2 向下取整</span>
  <span class="c1">// 这样 Math.floor(k / 2) * 2 &lt; k，所以从两个数组上取的数之和小于 k</span>
  <span class="c1">// 当 A(Math.floor(k / 2) - 1) &lt; B(Math.floor(k / 2) - 1) 成立的时候，A(Math.floor(k / 2) - 1) 最多只能排在第 Math.floor(k / 2) * 2 - 1 的位置上</span>
  <span class="c1">// Math.floor(k / 2) * 2 - 1 &lt; k - 1，故 A(Math.floor(k / 2) - 1) 对应的数字及其前面的数字都能排除掉，这和 k 是偶数的时候完全一样</span>
  <span class="c1">// 当 A(Math.floor(k / 2) - 1) === B(Math.floor(k / 2) - 1) 成立的时候</span>
  <span class="c1">// A(Math.floor(k / 2) - 1) 最多排在第 Math.floor(k / 2) * 2 的位置，而 Math.floor(k / 2) * 2 &lt; k，故结果 k 是偶数的时候也是一致的</span>
  <span class="c1">// ----------------------------------------------------------------------</span>
  <span class="c1">// 上述思路对应的是两个数组中存在数字大于中位数，则一直执行上述操作直到获取到第k个数数字的时候，两个数组中都还有数字</span>
  <span class="c1">// 还有另外一种情况，某个数组中的数字全部排在中位数前面</span>
  <span class="c1">// 则肯定会出现一个数组中的所有数字全部是不需要的数字</span>
  <span class="c1">// 当上述操作执行到某个数组的下标超过边界的时候，只需要在另一个数组中找到第 k（去掉被排除的数字） 个数字即是结果</span>

  <span class="kd">let</span> <span class="nx">nums1Target</span>
  <span class="kd">let</span> <span class="nx">nums2Target</span>
  <span class="kd">let</span> <span class="nx">halfK</span>
  <span class="kd">let</span> <span class="nx">showDropCount</span>
  <span class="kd">let</span> <span class="nx">ind1</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">ind2</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">ind1</span> <span class="o">&gt;=</span> <span class="nx">nums1</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">ind2</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">ind2</span> <span class="o">&gt;=</span> <span class="nx">nums2</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">ind1</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">k</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">nums1</span><span class="p">[</span><span class="nx">ind1</span><span class="p">],</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">ind2</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="nx">halfK</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">k</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1">// showDropCount 表示应该丢弃的数字个数，由于可能存在下标越界的问题，当下标越界出现的时候</span>
    <span class="c1">// 默认使用数组的最后一个数字来做比较，而这个时候要排除的数字个数就可能不是 halfK 个了</span>
    <span class="nx">showDropCount</span> <span class="o">=</span> <span class="nx">halfK</span>
    <span class="c1">// 超出了数组长度，则使用最后一个，也就是数组中最大的一个数</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">ind1</span> <span class="o">+</span> <span class="nx">halfK</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="nx">nums1</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">nums1Target</span> <span class="o">=</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">nums1</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
      <span class="nx">showDropCount</span> <span class="o">=</span> <span class="nx">nums1</span><span class="p">.</span><span class="nx">length</span>  <span class="o">-</span> <span class="nx">ind1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">nums1Target</span> <span class="o">=</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">ind1</span> <span class="o">+</span> <span class="nx">halfK</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">ind2</span> <span class="o">+</span> <span class="nx">halfK</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="nx">nums2</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">nums2Target</span> <span class="o">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">nums2</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
      <span class="nx">showDropCount</span> <span class="o">=</span> <span class="nx">nums2</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">ind2</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">nums2Target</span> <span class="o">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">ind2</span> <span class="o">+</span> <span class="nx">halfK</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">nums1Target</span> <span class="o">&lt;=</span> <span class="nx">nums2Target</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">ind1</span> <span class="o">=</span> <span class="nx">ind1</span> <span class="o">+</span> <span class="nx">showDropCount</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">ind2</span> <span class="o">=</span> <span class="nx">ind2</span> <span class="o">+</span> <span class="nx">showDropCount</span>
    <span class="p">}</span>

    <span class="nx">k</span> <span class="o">=</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">showDropCount</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="5-medium">😻✔ 5 最长回文子串【medium】<a class="headerlink" href="#5-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/submissions/">ref</a></p>
<p>贪心算法</p>
<p>核心就是尝试以每个字符为中心，往两侧扩散</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(0^2)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">longestPalindrome</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">end</span> <span class="o">=</span> <span class="nx">findDuplicate</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span>
    <span class="nx">l</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">end</span> <span class="o">===</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 中心不是重复值</span>
      <span class="nx">r</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 中心是重复值</span>
      <span class="nx">r</span> <span class="o">=</span> <span class="nx">end</span>
      <span class="c1">// 因为都是重复值，所以直接把所有重复的值都跳过</span>
      <span class="nx">i</span> <span class="o">=</span> <span class="nx">end</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">===</span> <span class="nx">s</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">l</span><span class="o">--</span>
      <span class="nx">r</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">r</span> <span class="o">-</span> <span class="nx">l</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">res</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>


<span class="kd">function</span> <span class="nx">findDuplicate</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">i</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">s</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">r</span><span class="o">++</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</pre></div>

<h2 id="6-z-medium">🌟😻✔ 6 Z 字形变换【medium】<a class="headerlink" href="#6-z-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/zigzag-conversion/">ref</a></p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(k) k=numRows</span>
<span class="kd">var</span> <span class="nx">convert</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">numRows</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 行数为 1 则直接返回 s</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numRows</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">s</span>
  <span class="c1">// 建一个 长度为 numRows 的数组，数组中每个元素为空字符串</span>
  <span class="c1">// 一个空字符串对应结果中的一行</span>
  <span class="kr">const</span> <span class="nx">resArr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">numRows</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
  <span class="c1">// 对每个字符，计算出其所处的行</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 2 * numRows - 2 最小的一个排列来回</span>
    <span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">numRows</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">m</span> <span class="o">&lt;=</span> <span class="nx">numRows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 从上往下</span>
      <span class="nx">resArr</span><span class="p">[</span><span class="nx">m</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 从下往上</span>
      <span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">-</span> <span class="p">(</span><span class="nx">numRows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nx">resArr</span><span class="p">[</span><span class="nx">numRows</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">n</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">resArr</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>

<h2 id="7-medium">😻✔ 7 整数反转【medium】<a class="headerlink" href="#7-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/reverse-integer/">ref</a></p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">reverse</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">isNegative</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="nx">isNegative</span> <span class="o">?</span> <span class="o">-</span><span class="nx">x</span> <span class="o">:</span> <span class="nx">x</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">10</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">result</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">x</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">result</span> <span class="o">+</span> <span class="nx">n</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">isNegative</span><span class="o">?</span> <span class="o">-</span><span class="nx">result</span> <span class="o">:</span> <span class="nx">result</span>
<span class="p">};</span>
</pre></div>

<h2 id="9-easy">🌟😻✔ 9 回文数【easy】<a class="headerlink" href="#9-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/palindrome-number/">ref</a></p>
<p>对回文数比较好的解决办法是，把从数字中取到的余数全部存进数组中，这样就算是0也可以表示，如果是直接计算成数字则可能出现 00123 这种情况，而前导0会被省略，导致出错。</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">isPalindrome</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span>
  <span class="kd">let</span> <span class="nx">nums</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">x</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">x</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">};</span>
</pre></div>

<h2 id="11-medium">🌟😻✔ 11 盛最多水的容器【medium】<a class="headerlink" href="#11-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/container-with-most-water/">ref</a></p>
<p>双指针</p>
<p><a href="https://leetcode.cn/problems/container-with-most-water/solution/by-lxfriday-udsc/">我的题解</a></p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(N)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">maxArea</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">height</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">height</span><span class="p">[</span><span class="nx">l</span><span class="p">],</span> <span class="nx">height</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="nx">r</span> <span class="o">-</span> <span class="nx">l</span><span class="p">),</span> <span class="nx">max</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">height</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">height</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">l</span><span class="o">++</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">r</span><span class="o">--</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">max</span>
<span class="p">};</span> 
</pre></div>

<h2 id="13-easy">✔ 13 罗马数字转整数【easy】<a class="headerlink" href="#13-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/roman-to-integer/">ref</a></p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">romanToInt</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;I&#39;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s1">&#39;V&#39;</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="s1">&#39;X&#39;</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;L&#39;</span><span class="o">:</span> <span class="mi">50</span><span class="p">,</span>
    <span class="s1">&#39;C&#39;</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="s1">&#39;D&#39;</span><span class="o">:</span> <span class="mi">500</span><span class="p">,</span>
    <span class="s1">&#39;M&#39;</span><span class="o">:</span> <span class="mi">1000</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span>
      <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;I&#39;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;V&#39;</span> <span class="o">||</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;X&#39;</span><span class="p">))</span> <span class="o">||</span> 
      <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;X&#39;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;L&#39;</span> <span class="o">||</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;C&#39;</span><span class="p">))</span> <span class="o">||</span> 
      <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;C&#39;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;D&#39;</span> <span class="o">||</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;M&#39;</span><span class="p">))</span>
    <span class="p">)</span> <span class="p">{</span>
      <span class="nx">sum</span> <span class="o">-=</span> <span class="nx">map</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">map</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">sum</span>
<span class="p">};</span>
</pre></div>

<h2 id="14-easy">✔ 14 最长公共前缀【easy】<a class="headerlink" href="#14-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/longest-common-prefix/">ref</a></p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n*k) k 公共前缀的长度</span>
<span class="c1">// 空间复杂度：O(1) </span>
<span class="kd">var</span> <span class="nx">longestCommonPrefix</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">strs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">strs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">strs</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">};</span>
</pre></div>

<h2 id="15-medium">🌟😻✔ 15 三数之和 【medium】<a class="headerlink" href="#15-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/3sum/">ref</a></p>
<p>双指针</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(N^2)</span>
<span class="c1">// 空间复杂度：O(logN) 排序的空间复杂度</span>
<span class="kd">var</span> <span class="nx">threeSum</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="k">return</span> <span class="p">[]</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="nx">nums</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="k">continue</span>
    <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">l</span> <span class="o">&gt;</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">===</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">l</span><span class="o">++</span>
        <span class="k">continue</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">r</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="o">===</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">r</span><span class="o">--</span>
        <span class="k">continue</span>
      <span class="p">}</span>
      <span class="kr">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">sum</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">l</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">r</span><span class="p">]])</span>
        <span class="nx">l</span><span class="o">++</span>
        <span class="nx">r</span><span class="o">--</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 在每一个轮次中 nums[i] 固定不变，且知道 nums[l] &lt;= nums[r]</span>
        <span class="c1">// sum &gt; 0 则三个数中最大的数 nums[r] 一定大了， 要往左移</span>
        <span class="c1">// sum &lt; 0 则 sum[l] 小了，要变大</span>
        <span class="nx">r</span><span class="o">--</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">l</span><span class="o">++</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>

<h2 id="16-medium">🌟😻✔ 16 最接近的三数之和【medium】<a class="headerlink" href="#16-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/3sum-closest/">ref</a></p>
<p>双指针</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n^2)</span>
<span class="c1">// 空间复杂度：O(logn) 排序</span>
<span class="kd">var</span> <span class="nx">threeSumClosest</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">nums</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">finalSum</span>
  <span class="kd">let</span> <span class="nx">minGap</span> <span class="o">=</span> <span class="kc">Infinity</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">len</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span>
      <span class="kr">const</span> <span class="nx">gap</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">sum</span> <span class="o">-</span> <span class="nx">target</span><span class="p">)</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">gap</span> <span class="o">&lt;</span> <span class="nx">minGap</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">finalSum</span> <span class="o">=</span> <span class="nx">sum</span>
        <span class="nx">minGap</span> <span class="o">=</span> <span class="nx">gap</span>
      <span class="p">}</span>
      <span class="p">(</span><span class="nx">sum</span> <span class="o">&lt;</span> <span class="nx">target</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="nx">l</span><span class="o">++</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="nx">r</span><span class="o">--</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">finalSum</span>
<span class="p">};</span>
</pre></div>

<h2 id="20-easy">🌟😻✔ 20 有效的括号【easy】<a class="headerlink" href="#20-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/valid-parentheses/">ref</a></p>
<p>关键词：栈</p>
<div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * @param {string} s</span>
<span class="cm"> * @return {boolean}</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">isValid</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">leftValues</span> <span class="o">=</span> <span class="s1">&#39;({[&#39;</span>
  <span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;(&#39;</span><span class="o">:</span> <span class="s1">&#39;)&#39;</span><span class="p">,</span>
    <span class="s1">&#39;{&#39;</span><span class="o">:</span> <span class="s1">&#39;}&#39;</span><span class="p">,</span>
    <span class="s1">&#39;[&#39;</span><span class="o">:</span> <span class="s1">&#39;]&#39;</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">leftValues</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">lastValue</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">lastValue</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">!</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span>
<span class="p">}</span>
</pre></div>

<h2 id="21-easy">😻✔ 21 合并两个有序链表【easy】<a class="headerlink" href="#21-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">ref</a></p>
<p>链表</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n) n=list1.length + list2.length</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">mergeTwoLists</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">list1</span><span class="p">,</span> <span class="nx">list2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nx">th</span> <span class="o">=</span> <span class="nx">head</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">list1</span> <span class="o">&amp;&amp;</span> <span class="nx">list2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">list1</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="nx">list2</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">th</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list1</span>
      <span class="nx">list1</span> <span class="o">=</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">th</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list2</span>
      <span class="nx">list2</span> <span class="o">=</span> <span class="nx">list2</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
    <span class="nx">th</span> <span class="o">=</span> <span class="nx">th</span><span class="p">.</span><span class="nx">next</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">list1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">th</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list1</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">list2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">th</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list2</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
<span class="p">};</span>
</pre></div>

<h2 id="22-medium">😻✔ 22 括号生成【medium】<a class="headerlink" href="#22-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/generate-parentheses/">ref</a></p>
<p>回溯、递归</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">generateParenthesis</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">let</span> <span class="nx">leftCount</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">rightCount</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">function</span> <span class="nx">calc</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">leftCount</span> <span class="o">&lt;</span> <span class="nx">rightCount</span> <span class="o">||</span> <span class="nx">leftCount</span> <span class="o">&gt;</span> <span class="nx">n</span> <span class="o">||</span> <span class="nx">rightCount</span> <span class="o">&gt;</span> <span class="nx">n</span><span class="p">)</span> <span class="k">return</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">leftCount</span> <span class="o">===</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="nx">rightCount</span> <span class="o">===</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">leftCount</span><span class="o">++</span>
    <span class="nx">calc</span><span class="p">(</span><span class="nx">str</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span><span class="p">)</span>
    <span class="nx">leftCount</span><span class="o">--</span>
    <span class="nx">rightCount</span><span class="o">++</span>
    <span class="nx">calc</span><span class="p">(</span><span class="nx">str</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
    <span class="nx">rightCount</span><span class="o">--</span>
  <span class="p">}</span>
  <span class="nx">calc</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>

<h2 id="23-khard">😻✔ 23 合并K个升序链表【hard】<a class="headerlink" href="#23-khard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">ref</a></p>
<p>链表、堆</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(nlogk)</span>
<span class="c1">// 空间复杂度：O(k)</span>
<span class="c1">// k 是 list.lenght</span>
<span class="c1">// n 是所有链表节点的个数</span>
<span class="kd">var</span> <span class="nx">mergeKLists</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">lists</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nx">th</span> <span class="o">=</span> <span class="nx">head</span>
  <span class="kr">const</span> <span class="nx">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MinHeap</span><span class="p">()</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">list</span> <span class="nx">of</span> <span class="nx">lists</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">list</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">while</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">hPop</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="nx">th</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">hPop</span>
    <span class="nx">th</span> <span class="o">=</span> <span class="nx">th</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">hPop</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="nx">h</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">hPop</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
<span class="p">};</span>
<span class="kr">class</span> <span class="nx">MinHeap</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">}</span>

  <span class="nx">insert</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">shiftUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">p</span>
  <span class="p">}</span>

  <span class="nx">peek</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="nx">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">}</span>

  <span class="nx">shiftDown</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="kr">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getRightIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">val</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">left</span><span class="p">].</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">left</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">right</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">val</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">right</span><span class="p">].</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">shiftUp</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span>
    <span class="kr">const</span> <span class="nx">parentIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">].</span><span class="nx">val</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftUp</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span>
  <span class="p">}</span>

  <span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="nx">getRightIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>或者</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(nlogn)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">mergeKLists</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">lists</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nx">th</span> <span class="o">=</span> <span class="nx">head</span>
  <span class="kr">const</span> <span class="nx">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MinHeap</span><span class="p">()</span> <span class="c1">// 小顶堆</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">list</span> <span class="nx">of</span> <span class="nx">lists</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">h</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
      <span class="nx">list</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">while</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">th</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">pop</span><span class="p">())</span>
    <span class="nx">th</span> <span class="o">=</span> <span class="nx">th</span><span class="p">.</span><span class="nx">next</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
<span class="p">};</span>
<span class="kr">class</span> <span class="nx">MinHeap</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">}</span>

  <span class="nx">insert</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">shiftUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">peek</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="nx">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">}</span>

  <span class="nx">shiftDown</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="kr">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getRightIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">left</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">left</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">right</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">right</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">shiftUp</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span>
    <span class="kr">const</span> <span class="nx">parentIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftUp</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span>
  <span class="p">}</span>

  <span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="nx">getRightIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>利用归并思路实现</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(k * n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="c1">// k 是 list.lenght</span>
<span class="c1">// n 是所有链表节点的个数</span>
<span class="kd">var</span> <span class="nx">mergeKLists</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">lists</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">lists</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">lists</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="kr">const</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">head</span>
  <span class="kd">let</span> <span class="nx">list1</span> <span class="o">=</span> <span class="nx">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">lists</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">list2</span> <span class="o">=</span> <span class="nx">lists</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">list1</span> <span class="o">&amp;&amp;</span> <span class="nx">list2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">list1</span><span class="p">.</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="nx">list2</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list1</span>
        <span class="nx">list1</span> <span class="o">=</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">next</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list2</span>
        <span class="nx">list2</span> <span class="o">=</span> <span class="nx">list2</span><span class="p">.</span><span class="nx">next</span>
      <span class="p">}</span>
      <span class="nx">t</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">list1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list1</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">list2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list2</span>
    <span class="p">}</span>
    <span class="nx">list1</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">t</span> <span class="o">=</span> <span class="nx">head</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
<span class="p">};</span>
</pre></div>

<h2 id="25-k-hard">🌟😻✔ 25 K 个一组翻转链表【hard】<a class="headerlink" href="#25-k-hard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">ref</a></p>
<div class="highlight"><pre><span class="c1">// 比较优秀的版本</span>
<span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">reverseKGroup</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kr">const</span> <span class="nx">myHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">head</span>
  <span class="kd">let</span> <span class="nx">start</span> <span class="o">=</span> <span class="nx">myHead</span>
  <span class="kd">let</span> <span class="nx">end</span> <span class="o">=</span> <span class="nx">start</span>

  <span class="k">while</span><span class="p">(</span><span class="nx">end</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">end</span> <span class="o">=</span> <span class="nx">end</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">count</span><span class="o">++</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">count</span> <span class="o">%</span> <span class="nx">k</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">start</span> <span class="o">=</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
      <span class="nx">end</span> <span class="o">=</span> <span class="nx">start</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span>
<span class="p">};</span>

<span class="c1">// start 的下一个节点才是起点</span>
<span class="c1">// 返回反转后的 end 节点</span>
<span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">myHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="kr">const</span> <span class="nx">reversePrev</span> <span class="o">=</span> <span class="nx">start</span>
  <span class="kr">const</span> <span class="nx">reverseNext</span> <span class="o">=</span> <span class="nx">end</span><span class="p">.</span><span class="nx">next</span>
  <span class="nx">start</span> <span class="o">=</span> <span class="nx">start</span><span class="p">.</span><span class="nx">next</span>
  <span class="kr">const</span> <span class="nx">prevStart</span> <span class="o">=</span> <span class="nx">start</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span> <span class="o">!==</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">start</span>
    <span class="nx">start</span> <span class="o">=</span> <span class="nx">start</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">prev</span>
  <span class="p">}</span>
  <span class="nx">reversePrev</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span>
  <span class="nx">prevStart</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">reverseNext</span>
  <span class="k">return</span> <span class="nx">prevStart</span>
<span class="p">}</span>
</pre></div>

<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">reverseKGroup</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kr">const</span> <span class="nx">myHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">myHead</span>
  <span class="kr">const</span> <span class="nx">gapHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nx">tGapHead</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">gapHead</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">head</span>
    <span class="nx">tGapHead</span> <span class="o">=</span> <span class="nx">gapHead</span> <span class="c1">// *</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">tGapHead</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">tGapHead</span> <span class="o">=</span> <span class="nx">tGapHead</span><span class="p">.</span><span class="nx">next</span>
      <span class="nx">count</span><span class="o">++</span>
      <span class="nx">head</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">count</span> <span class="o">%</span> <span class="nx">k</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">tGapHead</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">next</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">gapHead</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="c1">// *</span>
        <span class="k">break</span> <span class="c1">// *</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">count</span> <span class="o">%</span> <span class="nx">k</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">next</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">gapHead</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">myHead</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">head</span>
    <span class="nx">head</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">prev</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">myHead</span><span class="p">.</span><span class="nx">next</span>
<span class="p">}</span>
</pre></div>

<h2 id="26-easy">✔ 26 删除有序数组中的重复项【easy】<a class="headerlink" href="#26-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">ref</a></p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">removeDuplicates</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">nums</span><span class="p">[</span><span class="nx">count</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="nx">count</span><span class="o">++</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">count</span> 
<span class="p">};</span>
</pre></div>

<h2 id="31-medium">🌟😻✔ 31 下一个排列【medium】<a class="headerlink" href="#31-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/next-permutation/">ref</a></p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">nextPermutation</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">for</span><span class="p">(;</span><span class="nx">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">i</span> <span class="p">;</span><span class="nx">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">swap</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">reverse</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">nums</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
  <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="nx">mid</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">r</span> <span class="o">+</span> <span class="nx">l</span> <span class="o">-</span> <span class="nx">i</span><span class="p">]</span>
    <span class="nx">arr</span><span class="p">[</span><span class="nx">r</span> <span class="o">+</span> <span class="nx">l</span> <span class="o">-</span> <span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="33-medium">🌟😻✔ 33 搜索旋转排序数组【medium】<a class="headerlink" href="#33-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">ref</a></p>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/1653007574423_685e61d8-c663-4699-8719-3b7d78a01427.png" /></p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(logn)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">search</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">len</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">len</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">target</span> <span class="o">===</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span>
  <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">mid</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">target</span> <span class="o">&amp;&amp;</span> <span class="nx">target</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">r</span><span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">l</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">target</span> <span class="o">&amp;&amp;</span> <span class="nx">target</span> <span class="o">&lt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">l</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">r</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span>  <span class="o">-</span><span class="mi">1</span>
<span class="p">};</span>
</pre></div>

<h2 id="34-medium">?🌟😻✔ 34 在排序数组中查找元素的第一个和最后一个位置【medium】<a class="headerlink" href="#34-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">ref</a></p>
<p>二分搜索</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(logn)</span>
<span class="c1">// 空复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">searchRange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">leftIndex</span> <span class="o">=</span> <span class="nx">binarySearch</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
  <span class="kr">const</span> <span class="nx">rightIndex</span> <span class="o">=</span> <span class="nx">binarySearch</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

  <span class="k">if</span><span class="p">(</span>
    <span class="nx">leftIndex</span> <span class="o">&lt;=</span> <span class="nx">rightIndex</span> <span class="o">&amp;&amp;</span>
    <span class="nx">leftIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
    <span class="nx">rightIndex</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span>
    <span class="nx">nums</span><span class="p">[</span><span class="nx">leftIndex</span><span class="p">]</span> <span class="o">===</span> <span class="nx">target</span> <span class="o">&amp;&amp;</span>
    <span class="nx">nums</span><span class="p">[</span><span class="nx">rightIndex</span><span class="p">]</span> <span class="o">===</span> <span class="nx">target</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">leftIndex</span><span class="p">,</span> <span class="nx">rightIndex</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">binarySearch</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">lower</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="kd">let</span> <span class="nx">resIndex</span> <span class="o">=</span> <span class="nx">len</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">target</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">lower</span> <span class="o">&amp;&amp;</span> <span class="nx">target</span> <span class="o">&lt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]))</span> <span class="p">{</span>
      <span class="nx">r</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="nx">resIndex</span> <span class="o">=</span> <span class="nx">mid</span>
</pre></div>

<h2 id="42-hard">🌟😻✔ 42 接雨水【hard】<a class="headerlink" href="#42-hard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/trapping-rain-water/">ref</a></p>
<p>动态规划</p>
<p>双指针版</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">trap</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">lMax</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">rMax</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">height</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">height</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">height</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">lMax</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">lMax</span><span class="p">,</span> <span class="nx">height</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span>
      <span class="nx">total</span> <span class="o">+=</span> <span class="nx">lMax</span> <span class="o">-</span> <span class="nx">height</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
      <span class="nx">l</span> <span class="o">++</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">rMax</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">rMax</span><span class="p">,</span> <span class="nx">height</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span>
      <span class="nx">total</span> <span class="o">+=</span> <span class="nx">rMax</span> <span class="o">-</span> <span class="nx">height</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span>
      <span class="nx">r</span><span class="o">--</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">total</span>
<span class="p">};</span>
</pre></div>

<p>动态规划版</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">trap</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">height</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">leftMax</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="kr">const</span> <span class="nx">rightMax</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="nx">rightMax</span><span class="p">[</span><span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">leftMax</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">height</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">leftMax</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rightMax</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">height</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">rightMax</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">leftMax</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">rightMax</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">-</span> <span class="nx">height</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">total</span>
<span class="p">};</span>
</pre></div>

<p>常规思路版</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n^2)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">trap</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">height</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">height</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kd">let</span> <span class="nx">lMax</span> <span class="o">=</span> <span class="nx">height</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nx">rMax</span> <span class="o">=</span> <span class="nx">height</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

    <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">height</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">lMax</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">lMax</span> <span class="o">=</span> <span class="nx">height</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
      <span class="p">}</span> 
      <span class="nx">l</span><span class="o">--</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">r</span> <span class="o">&lt;=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">height</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">rMax</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">rMax</span> <span class="o">=</span> <span class="nx">height</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span>
      <span class="p">}</span> 
      <span class="nx">r</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="kr">const</span> <span class="nx">receive</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">lMax</span><span class="p">,</span> <span class="nx">rMax</span><span class="p">)</span> <span class="o">-</span> <span class="nx">height</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nx">receive</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">total</span>
<span class="p">};</span>
</pre></div>

<h2 id="43-medium">🌟😻✔ 43 字符串相乘【medium】<a class="headerlink" href="#43-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/multiply-strings/">ref</a></p>
<p>字符串相加、字符串相乘</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">multiply</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">num1</span> <span class="o">===</span> <span class="s1">&#39;0&#39;</span> <span class="o">||</span> <span class="nx">num2</span> <span class="o">===</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="s2">&quot;0&quot;</span>
  <span class="kr">const</span> <span class="nx">len1</span> <span class="o">=</span> <span class="nx">num1</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">len1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">num1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">sum</span> <span class="o">=</span> <span class="nx">stringAdd</span><span class="p">(</span><span class="nx">smallMulti</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">num2</span><span class="p">,</span> <span class="nx">len1</span> <span class="o">-</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nx">sum</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">sum</span>
<span class="p">};</span>

<span class="c1">// 字符串相乘，x只有一位</span>
<span class="c1">// zeroCount 是后置0的个数</span>
<span class="kd">function</span> <span class="nx">smallMulti</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">zeroCount</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="s1">&#39;0&#39;</span>
  <span class="kr">const</span> <span class="nx">yLen</span> <span class="o">=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">let</span> <span class="nx">add</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">yLen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">y</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">+</span> <span class="nx">add</span>
    <span class="nx">add</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">n</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nx">res</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="nx">add</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="nx">res</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">add</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">=</span> <span class="nx">add</span> <span class="o">+</span> <span class="nx">res</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">zeros</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">zeroCount</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">zeros</span> <span class="o">+=</span><span class="s1">&#39;0&#39;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span> <span class="o">+</span> <span class="nx">zeros</span>
<span class="p">}</span>

<span class="c1">// 任意数字字符串相加</span>
<span class="kd">function</span> <span class="nx">stringAdd</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">xLen</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">yLen</span> <span class="o">=</span> <span class="nx">y</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">xLen</span> <span class="o">&gt;=</span> <span class="nx">yLen</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">xLen</span> <span class="o">-</span> <span class="nx">yLen</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">y</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span> <span class="o">+</span> <span class="nx">y</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">yLen</span> <span class="o">-</span> <span class="nx">xLen</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">x</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span> <span class="o">+</span> <span class="nx">x</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="kd">let</span> <span class="nx">add</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">x</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">+</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">y</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">+</span> <span class="nx">add</span>
    <span class="nx">add</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nx">res</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">-</span> <span class="nx">add</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="nx">res</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">add</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">=</span> <span class="nx">add</span> <span class="o">+</span> <span class="nx">res</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>

<h2 id="45-iimedium">😻✔ 45 跳跃游戏 II【medium】<a class="headerlink" href="#45-iimedium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/jump-game-ii/">ref</a></p>
<p>贪心算法</p>
<div class="highlight"><pre><span class="c1">// 从后往前分析，贪心的找到能到达最后一个数字的最远数字</span>
<span class="c1">// 可能会担心到不了这个下标，实际上，如果到不了这个下标，则一定到不了最后一个下标，故这个下标是一定能到的</span>
<span class="c1">// 用相同的办法，不断地把下标以每次最远的距离往前靠近，直到到达第一个数字</span>
<span class="c1">// 时间复杂度：O(N^2)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">jump</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">r</span> <span class="o">=</span> <span class="nx">i</span>
        <span class="nx">min</span><span class="o">++</span>
        <span class="k">break</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">min</span>
<span class="p">};</span>
</pre></div>

<p>更优版本</p>
<p>不太好理解，可以参照这张图，黑色的蹦跶线代表每次跳的时候能跳的最远距离，红色线从终点反过来推，在每个黑色起跳区间内找一个值，最终推到起跳点位于0。</p>
<p><img alt="" src="https://qiniu1.lxfriday.xyz/feoffer/1652678598702_5db9138d-58b3-4bbf-81ae-44b6795bacc5.png" /></p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">jump</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 每移动一次下标都计算一次能走到的最远距离</span>
  <span class="kd">let</span> <span class="nx">maxIndex1</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="c1">// 当走到上一轮能走到的最远下标的时候，更新当前轮次能走的最远下标</span>
  <span class="kd">let</span> <span class="nx">maxIndex2</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">maxIndex1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">maxIndex1</span><span class="p">,</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">maxIndex2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">count</span><span class="o">++</span>
      <span class="nx">maxIndex2</span> <span class="o">=</span> <span class="nx">maxIndex1</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">count</span>
<span class="p">};</span>
</pre></div>

<h2 id="46-medium">😻✔ 46 全排列【medium】<a class="headerlink" href="#46-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/permutations/">ref</a></p>
<p>排列组合、回溯法、递归</p>
<p><div class="highlight"><pre><span class="kd">var</span> <span class="nx">permute</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">numsLen</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kr">const</span> <span class="nx">used</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kd">function</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">numsLen</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">([...</span><span class="nx">path</span><span class="p">])</span>
      <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numsLen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="kr">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="k">continue</span>
      <span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="nx">dfs</span><span class="p">([...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">num</span><span class="p">])</span>
      <span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">dfs</span><span class="p">([])</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>
or</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n!)</span>
<span class="c1">// 空间复杂度：O(n) 递归的层数</span>
<span class="kd">var</span> <span class="nx">permute</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="kd">function</span> <span class="nx">calc</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
      <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">nums</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">path</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">calc</span><span class="p">([...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">n</span><span class="p">])</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">}</span>
  <span class="nx">calc</span><span class="p">([])</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>

<p>or</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n!)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">permute</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="p">[</span><span class="nx">nums</span><span class="p">]</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">permute</span><span class="p">(</span><span class="nx">nums</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">nums</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="p">...</span><span class="nx">_</span><span class="p">])</span>
    <span class="p">})</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>

<h2 id="47-iimedium">😻✔ 47 全排列 II【medium】<a class="headerlink" href="#47-iimedium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/permutations-ii/">ref</a></p>
<p>排列组合、回溯法、递归</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n*n!)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">permuteUnique</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 把无序数组排成有序的，方便后面相同数字的处理</span>
  <span class="nx">nums</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span>
  <span class="kr">const</span> <span class="nx">numsLen</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1">// 对某个值是否使用过做一个记录</span>
  <span class="kr">const</span> <span class="nx">used</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kd">function</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">numsLen</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">([...</span><span class="nx">path</span><span class="p">])</span>
      <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numsLen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="kr">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="c1">// 在相同层级的情况下，如果后续还有很多相同的数字，则都会直接跳过</span>
      <span class="c1">// 而这里 num === nums[i - 1] 就是表示相同的数字</span>
      <span class="c1">// !used[i - 1] 表示的是相同层级，即数组中装填的数字个数相同就表示是同一层级</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">num</span> <span class="o">===</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span> <span class="k">continue</span>
      <span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
      <span class="c1">// 这个地方在 dfs 前后会把 used[i] 的值更改两次</span>
      <span class="c1">// 原因是：执行 dfs 前，置为 true，然后进行 dfs 内的递归调用时，该调用栈内都会得到 used[i] 为 true</span>
      <span class="nx">dfs</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
      <span class="nx">path</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
      <span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">dfs</span><span class="p">([])</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>

<h2 id="53-easy">🌟😻✔ 53 最大子数组和【easy】<a class="headerlink" href="#53-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/maximum-subarray/">ref</a></p>
<p>动态规划</p>
<p>数组版</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(N)</span>
<span class="c1">// 空间复杂度：O(N)</span>
<span class="kd">var</span> <span class="nx">maxSubArray</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
 <span class="kr">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="p">[]</span>
 <span class="c1">// dp[i] 定义的是以 i 作为结束的连续子数组的 最大值</span>
 <span class="c1">// 则整个数组的最大连续子数组必然会命中 dp 中的一项，且为值最大的那一项</span>
 <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
 <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
   <span class="p">}</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">dp</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>

<p>精简版</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="c1">// 这个解法相比数组解法更难理解</span>
<span class="kd">var</span> <span class="nx">maxSubArray</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// 前 i 个数字中连续子数组的最大和</span>
 <span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
 <span class="c1">// 以 i 为结尾的连续子数组的最大和</span>
 <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span>
 <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span><span class="p">(</span><span class="nx">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">sum</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="nx">sum</span> <span class="o">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
   <span class="p">}</span>
   <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">max</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">max</span>
<span class="p">};</span>
</pre></div>

<h2 id="54-medium">🌟😻✔ 54 螺旋矩阵【medium】<a class="headerlink" href="#54-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/spiral-matrix/">ref</a></p>
<div class="highlight"><pre><span class="c1">// 直接递归硬找，好理解</span>
<span class="c1">// 时间复杂度：O(m*n)</span>
<span class="c1">// 空间复杂度：O(m*n)</span>
<span class="kd">var</span> <span class="nx">spiralOrder</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">matrix</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">matrix</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">used</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">m</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">false</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">n</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="kd">function</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">direction</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">matrix</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">direction</span> <span class="o">===</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">((</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">m</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">direction</span> <span class="o">===</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">((</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">m</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">(</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">direction</span> <span class="o">===</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">((</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">direction</span> <span class="o">===</span> <span class="s1">&#39;top&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">((</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">walk</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>

  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>

<h2 id="55-medium">😻✔ 55 跳跃游戏【medium】<a class="headerlink" href="#55-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/jump-game/">ref</a></p>
<div class="highlight"><pre><span class="c1">// 从左往右扫描 i 位置往后最多能跳到哪</span>
<span class="c1">// maxIndex 用来记录 i 前面最多能跳到哪个下标，每到一个位置都刷新 maxIndex</span>
<span class="c1">// 如果出现 maxIndex &lt; i，则说明i前面的位置无法跳到 i</span>
<span class="c1">// 时间复杂度：O(N)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">canJump</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maxIndex</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">maxIndex</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span>
    <span class="nx">maxIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">maxIndex</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">};</span>
</pre></div>

<h2 id="56-medium">😻✔ 56 合并区间【medium】<a class="headerlink" href="#56-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/merge-intervals/">ref</a></p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(NlogN) 排序</span>
<span class="c1">// 空间复杂度：O(logN) 排序</span>
<span class="kd">var</span> <span class="nx">merge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">intervals</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">intervals</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">intervals</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">first</span> <span class="o">=</span> <span class="nx">intervals</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
    <span class="kd">let</span> <span class="nx">second</span> <span class="o">=</span> <span class="nx">intervals</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
    <span class="c1">// 区间有交集</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">first</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">second</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">second</span> <span class="o">=</span> <span class="nx">first</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">first</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">second</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">second</span> <span class="o">=</span> <span class="p">[</span><span class="nx">first</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">second</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">first</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">intervals</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">second</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">intervals</span><span class="p">.</span><span class="nx">shift</span><span class="p">())</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>

<h2 id="65-hard">😻✔ 65 有效的数字【hard】<a class="headerlink" href="#65-hard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/valid-number/">ref</a></p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">isNumber</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// if(s === &#39;Infinity&#39; || s === &#39;+Infinity&#39; || s === &#39;-Infinity&#39;) return false</span>
  <span class="c1">// const num = Number(s)</span>
  <span class="c1">// if(isNaN(num)) return false</span>
  <span class="c1">// return true</span>
  <span class="c1">// 模拟法</span>
  <span class="kd">let</span> <span class="nx">numLeft</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="kd">let</span> <span class="nx">numRight</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="nx">s</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">trim</span><span class="p">().</span><span class="nx">toLowerCase</span><span class="p">()</span>
 <span class="k">if</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">))</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">sSplit</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">sSplit</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="p">[</span><span class="nx">numLeft</span><span class="p">,</span> <span class="nx">numRight</span><span class="p">]</span> <span class="o">=</span> <span class="nx">sSplit</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">validateNumLeft</span><span class="p">(</span><span class="nx">numLeft</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">validateNumRight</span><span class="p">(</span><span class="nx">numRight</span><span class="p">))</span> <span class="k">return</span> <span class="kc">true</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">numLeft</span> <span class="o">=</span> <span class="nx">s</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">validateNumLeft</span><span class="p">(</span><span class="nx">numLeft</span><span class="p">))</span> <span class="k">return</span> <span class="kc">true</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">validateNumLeft</span><span class="p">(</span><span class="nx">numLeft</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="s1">&#39;-+&#39;</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">numLeft</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
    <span class="nx">numLeft</span> <span class="o">=</span> <span class="nx">numLeft</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">numLeft</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="nx">numLeft</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">))</span> <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">numLeft</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span>
  <span class="kd">let</span> <span class="nx">numLeftSplit</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numLeft</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">numLeftSplit</span> <span class="o">=</span> <span class="nx">numLeft</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">numLeftSplit</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">)</span> <span class="k">return</span> <span class="kc">false</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">numLeftSplit</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">isNumStr</span><span class="p">(</span><span class="nx">numLeftSplit</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">return</span> <span class="kc">true</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">numLeftSplit</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">isNumStr</span><span class="p">(</span><span class="nx">numLeftSplit</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">return</span> <span class="kc">true</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">isNumStr</span><span class="p">(</span><span class="nx">numLeftSplit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">isNumStr</span><span class="p">(</span><span class="nx">numLeftSplit</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">return</span> <span class="kc">true</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">isNumStr</span><span class="p">(</span><span class="nx">numLeft</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">validateNumRight</span><span class="p">(</span><span class="nx">numRight</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">numRight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;-&#39;</span> <span class="o">||</span> <span class="nx">numRight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">numRight</span> <span class="o">=</span> <span class="nx">numRight</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">isNumStr</span><span class="p">(</span><span class="nx">numRight</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">isNumStr</span><span class="p">(</span><span class="nx">numStr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">numStr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">c</span> <span class="nx">of</span> <span class="nx">numStr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">c</span> <span class="o">&gt;=</span> <span class="s1">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="s1">&#39;9&#39;</span><span class="p">))</span> <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>

<h2 id="70-easy">😻✔ 70 爬楼梯【easy】<a class="headerlink" href="#70-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/climbing-stairs/">ref</a></p>
<p>动态规划</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">climbStairs</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">2</span>
  <span class="nx">d1</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="nx">d2</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">tmpD2</span> <span class="o">=</span> <span class="nx">d2</span>
    <span class="nx">d2</span> <span class="o">=</span> <span class="nx">d1</span> <span class="o">+</span> <span class="nx">d2</span>
    <span class="nx">d1</span> <span class="o">=</span> <span class="nx">tmpD2</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">d2</span>
<span class="p">};</span>
</pre></div>

<p>数组解</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">climbStairs</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="nx">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="nx">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">d</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">d</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">d</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">d</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="p">};</span>
</pre></div>

<h2 id="72-hard">🌟😻✔ 72 编辑距离【hard】<a class="headerlink" href="#72-hard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/edit-distance/">ref</a></p>
<p>定义 <code>dp[i][j]</code> 是 word1 长度为 i 的字符串转换成 word2 长度为 j 字符串的最少操作次数。则 <code>dp[i][j]</code> 可由下面三种情况得到：</p>
<ul>
<li><code>dp[i - 1][j - 1]</code> 替换掉 word1 中第 i 个字符</li>
<li><code>dp[i - 1][j]</code>  删除 word1 中第 i 个字符</li>
<li><code>dp[i][j - 1]</code>  在 word1 中第 i 个字符后面新增一个字符</li>
</ul>
<p>上面三种情况的最小值 + 1，就是 <code>dp[i][j]</code>。</p>
<p>所以状态转移方程为：</p>
<div class="highlight"><pre><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>

<p>然后设置初始值， i 为 0 则最短操作次数就是 j，j 为 0 则最短操作次数就是 i。</p>
<p>动态规划</p>
<div class="highlight"><pre><span class="c1">// m=word1.length n=word2.length</span>
<span class="c1">// 时间复杂度：O(m*n)</span>
<span class="c1">// 空间复杂度：O(m*n)</span>
<span class="kd">var</span> <span class="nx">minDistance</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">word1</span><span class="p">,</span> <span class="nx">word2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len1</span> <span class="o">=</span> <span class="nx">word1</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">len2</span> <span class="o">=</span> <span class="nx">word2</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">len1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">len2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">len1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">len2</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">j</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">len1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">len2</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">word1</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="nx">word2</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">len1</span><span class="p">][</span><span class="nx">len2</span><span class="p">]</span>
<span class="p">};</span>
</pre></div>

<h2 id="76-hard">😻✔ 76 最小覆盖子串【hard】<a class="headerlink" href="#76-hard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/minimum-window-substring/">ref</a></p>
<p>双指针、滑动窗口</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">minWindow</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">need</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nx">needType</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">c</span> <span class="nx">of</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">need</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">need</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">need</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">need</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nx">needType</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">minStr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">r</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">need</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">c</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">need</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">need</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">need</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">needType</span> <span class="o">-=</span> <span class="mi">1</span> 
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">needType</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">minStr</span><span class="p">.</span><span class="nx">length</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="nx">minStr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="nx">minStr</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">need</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">l</span><span class="p">]))</span> <span class="p">{</span>
        <span class="nx">need</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">l</span><span class="p">],</span> <span class="nx">need</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">need</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">needType</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">l</span><span class="o">++</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">minStr</span>
<span class="p">};</span>
</pre></div>

<h2 id="78-medium">🌟😻✔ 78 子集【medium】<a class="headerlink" href="#78-medium" title="Permanent link"></a></h2>
<p>回溯、递归</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(N*2^N)</span>
<span class="c1">// 时间复杂度：O(N)</span>
<span class="kd">var</span> <span class="nx">subsets</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="kd">function</span> <span class="nx">calc</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">calc</span><span class="p">([...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]],</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">calc</span><span class="p">([])</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>

<h2 id="83-easy">✔ 83 删除排序链表中的重复元素【easy】<a class="headerlink" href="#83-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">ref</a></p>
<p>链表</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">deleteDuplicates</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">head</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">t</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">tNext</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">val</span> <span class="o">!==</span> <span class="nx">tNext</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">t</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">tNext</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">head</span>
<span class="p">}</span>
</pre></div>

<h2 id="88-easy">✔ 88 合并两个有序数组【easy】<a class="headerlink" href="#88-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/merge-sorted-array/">ref</a></p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(m+n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">merge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums1</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">mn</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="kd">let</span> <span class="nx">mIndex</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="kd">let</span> <span class="nx">nIndex</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">mIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nums1</span><span class="p">[</span><span class="nx">mIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">nIndex</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">nums1</span><span class="p">[</span><span class="nx">mn</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums1</span><span class="p">[</span><span class="nx">mIndex</span><span class="p">]</span>
      <span class="nx">mIndex</span><span class="o">--</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">nums1</span><span class="p">[</span><span class="nx">mn</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">nIndex</span><span class="p">]</span>
      <span class="nx">nIndex</span><span class="o">--</span>
    <span class="p">}</span>
    <span class="nx">mn</span><span class="o">--</span>
  <span class="p">}</span>
  <span class="c1">// 有可能 nums1 中的数字都复制完了，nums2 中还存在数字</span>
  <span class="c1">// 则把 nums2 中的数字都复制过来</span>
  <span class="c1">// 如果是 nums2 没有需要复制的，而 nums1 有需要复制的，则可以直接跳过</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">nIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nums1</span><span class="p">[</span><span class="nx">nIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums2</span><span class="p">[</span><span class="nx">nIndex</span><span class="p">]</span>
    <span class="nx">nIndex</span><span class="o">--</span>
    <span class="nx">mn</span><span class="o">--</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<h2 id="94-easy">😻✔ 94 二叉树的中序遍历【easy】<a class="headerlink" href="#94-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">ref</a></p>
<p>二叉树、中序遍历、DFS、深度优先遍历</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">inorderTraversal</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kr">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="nx">node</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span><span class="mi">1</span>
</pre></div>

<h2 id="100-easy">😻✔ 100 相同的树【easy】<a class="headerlink" href="#100-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/same-tree/">ref</a></p>
<p>二叉树、树</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(logn)~O(n)</span>
<span class="kd">var</span> <span class="nx">isSameTree</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">p</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">q</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">p</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">val</span> <span class="o">===</span> <span class="nx">q</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">};</span>
</pre></div>

<h2 id="101-easy">😻✔ 101 对称二叉树【easy】<a class="headerlink" href="#101-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/symmetric-tree/">ref</a></p>
<p>二叉树</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(logn)~O(n)</span>
<span class="kd">var</span> <span class="nx">isSymmetric</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span>
  <span class="kr">const</span> <span class="nx">isMirror</span> <span class="o">=</span> <span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">l</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">r</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">l</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="o">&amp;&amp;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">val</span> <span class="o">===</span> <span class="nx">r</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">isMirror</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isMirror</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">isMirror</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>

<h2 id="102-medium">😻✔ 102 二叉树的层序遍历【medium】<a class="headerlink" href="#102-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">ref</a></p>
<p>二叉树、BFS、广度优先遍历、层序遍历</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">levelOrder</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">[]</span>
  <span class="kr">const</span> <span class="nx">q</span> <span class="o">=</span> <span class="p">[[</span><span class="nx">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="p">[</span><span class="nx">node</span><span class="p">,</span> <span class="nx">depth</span><span class="p">]</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
    <span class="nx">res</span><span class="p">[</span><span class="nx">depth</span><span class="p">]</span> <span class="o">?</span> <span class="nx">res</span><span class="p">[</span><span class="nx">depth</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="nx">depth</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">])</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>

<h2 id="104-easy">😻✔ 104 二叉树的最大深度【easy】<a class="headerlink" href="#104-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">ref</a></p>
<p>二叉树、深度优先遍历、DFS</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">maxDepth</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maxLen</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kr">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">l</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span>
    <span class="nx">maxLen</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">maxLen</span><span class="p">,</span> <span class="nx">l</span><span class="p">)</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">maxLen</span>
<span class="p">}</span>
</pre></div>

<h2 id="111-easy">😻✔ 111 二叉树的最小深度【easy】<a class="headerlink" href="#111-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">ref</a></p>
<p>二叉树、广度优先遍历、BFS</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">minDepth</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span>
  <span class="kr">const</span> <span class="nx">q</span> <span class="o">=</span> <span class="p">[[</span><span class="nx">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="p">[</span><span class="nx">node</span><span class="p">,</span> <span class="nx">depth</span><span class="p">]</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="k">return</span> <span class="nx">depth</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="112-easy">😻✔ 112 路径总和【easy】<a class="headerlink" href="#112-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/path-sum/">ref</a></p>
<p>二叉树、二叉树的路径总和、DFS、深度优先遍历</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">hasPathSum</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">targetSum</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span>
  <span class="kd">let</span> <span class="nx">has</span> <span class="o">=</span> <span class="kc">false</span>
  <span class="kr">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">val</span> <span class="o">+</span> <span class="nx">sum</span> <span class="o">===</span> <span class="nx">targetSum</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">has</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">&amp;&amp;</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span> <span class="o">+</span> <span class="nx">sum</span><span class="p">)</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">&amp;&amp;</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span> <span class="o">+</span> <span class="nx">sum</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">has</span>
<span class="p">}</span>
</pre></div>

<h2 id="113-medium">😻✔ 113 克隆图【medium】<a class="headerlink" href="#113-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/clone-graph/">ref</a></p>
<p>图、深度优先遍历、广度优先遍历、DFS、BFS</p>
<div class="highlight"><pre><span class="c1">// DFS</span>
<span class="cm">/**</span>
<span class="cm"> * // Definition for a Node.</span>
<span class="cm"> * function Node(val, neighbors) {</span>
<span class="cm"> *    this.val = val === undefined ? 0 : val;</span>
<span class="cm"> *    this.neighbors = neighbors === undefined ? [] : neighbors;</span>
<span class="cm"> * };</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * @param {Node} node</span>
<span class="cm"> * @return {Node}</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">cloneGraph</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span> 
  <span class="kr">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="kd">function</span> <span class="nx">dfs</span> <span class="p">(</span><span class="nx">targetNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">targetNode</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
    <span class="nx">visited</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">targetNode</span><span class="p">,</span> <span class="nx">newNode</span><span class="p">);</span>
    <span class="p">(</span><span class="nx">targetNode</span><span class="p">.</span><span class="nx">neighbors</span> <span class="o">||</span> <span class="p">[]).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">neighborNode</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">neighborNode</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">neighborNode</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="nx">newNode</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">visited</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">neighborNode</span><span class="p">))</span>
    <span class="p">})</span>
  <span class="p">}</span>
  <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">visited</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">// BFS</span>
<span class="kd">var</span> <span class="nx">cloneGraph</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span> 
  <span class="kr">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="kr">const</span> <span class="nx">q</span> <span class="o">=</span> <span class="p">[</span><span class="nx">node</span><span class="p">]</span>
  <span class="nx">visited</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">));</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">targetNode</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
    <span class="p">(</span><span class="nx">targetNode</span><span class="p">.</span><span class="nx">neighbors</span> <span class="o">||</span> <span class="p">[]).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">neighborNode</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">neighborNode</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">neighborNode</span><span class="p">)</span>
        <span class="nx">visited</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">neighborNode</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">neighborNode</span><span class="p">.</span><span class="nx">val</span><span class="p">))</span>
      <span class="p">}</span>
      <span class="nx">visited</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">targetNode</span><span class="p">).</span><span class="nx">neighbors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">visited</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">neighborNode</span><span class="p">))</span>
    <span class="p">})</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">visited</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>

<h2 id="121-easy">😻✔ 121 买卖股票的最佳时机【easy】<a class="headerlink" href="#121-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">ref</a></p>
<p>动态规划</p>
<div class="highlight"><pre><span class="c1">// 抓住一个点：从后往前看，到某一天的时候，能获得的最大利润是：Math.max(至前一天能获得的最大利润, 至当天能获得的最大利润)</span>
<span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">everMin</span> <span class="o">=</span> <span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">everMin</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">everMin</span><span class="p">,</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="nx">maxProfit</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">maxProfit</span><span class="p">,</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">everMin</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">maxProfit</span>
<span class="p">};</span>
</pre></div>

<p>数组版</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">dp</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">let</span> <span class="nx">everMin</span> <span class="o">=</span> <span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">everMin</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">everMin</span><span class="p">,</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">everMin</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">};</span>
</pre></div>

<h2 id="122-iimedium">😻✔ 122 买卖股票的最佳时机 II【medium】<a class="headerlink" href="#122-iimedium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">ref</a></p>
<p>动态规划</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">maxProfit</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">maxProfit</span><span class="p">,</span> <span class="nx">maxProfit</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">maxProfit</span>
<span class="p">};</span>
</pre></div>

<p>数组版本</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">};</span>
</pre></div>

<p>or</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 时间复杂度：O(1)</span>
<span class="c1">// 赚钱的宗旨：只要后一天比前一天价格高，我就会赚，所以我每天都买，但是我知道第二天会跌</span>
<span class="c1">// 会涨：则默认为我昨天就买了，今天的涨幅算进利润里</span>
<span class="c1">// 会跌：那我前一天买了又卖了</span>
<span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">buyPrice</span> <span class="o">=</span> <span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">buyPrice</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">maxProfit</span> <span class="o">+=</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">buyPrice</span>
    <span class="p">}</span>
    <span class="nx">buyPrice</span> <span class="o">=</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">maxProfit</span>
<span class="p">};</span>
</pre></div>

<h2 id="123-iiihard">😻✔ 123 买卖股票的最佳时机 III【hard】<a class="headerlink" href="#123-iiihard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">ref</a></p>
<p>动态规划</p>
<p>超高效版本</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">buy1</span> <span class="o">=</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">buy2</span> <span class="o">=</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kd">let</span> <span class="nx">sell1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">sell2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">sell2</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">sell2</span><span class="p">,</span> <span class="nx">buy2</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="nx">buy2</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">buy2</span><span class="p">,</span> <span class="nx">sell1</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="nx">sell1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">sell1</span><span class="p">,</span> <span class="nx">buy1</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="nx">buy1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">buy1</span><span class="p">,</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">sell2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>普通版本</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="c1">// ref https://blog.csdn.net/qq_35027690/article/details/118557921</span>
<span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 最多操作两次时</span>
  <span class="c1">// 第i天的收益，总共包含5中情况（i 对应数组下标）</span>
  <span class="c1">// 0：没操作，收益为0，可以直接排除，对应 d[i][0] = 0 一直是 0</span>
  <span class="c1">// 1：只买了一次，流动资金相比初始状态是负值</span>
  <span class="c1">// 2：买了一次，卖了一次，流动资金相比初始状态是正值（只赚不赔）</span>
  <span class="c1">// 3：买了一次，卖了一次，又买了一次，流动资金相比初始状态是未知的</span>
  <span class="c1">// 4：买了一次，卖了一次，又买了一次，又卖了一次，流动资金相比初始状态是正值（只赚不赔）</span>
  <span class="kr">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span><span class="p">[])</span>
  <span class="c1">// 把初始值定出来</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 构建状态转移方程</span>
    <span class="c1">// --------------------------</span>
    <span class="c1">// i 天内只买了一次的最大收益</span>
    <span class="c1">// dp[i][1] = max(dp[i - 1][1] , dp[i - 1][0] - prices[i])</span>
    <span class="c1">// dp[i - 1][1]： 第i天没操作，顺延到 i - 1 天内只买了一次，没卖</span>
    <span class="c1">// dp[i - 1][0] - prices[i]： i - 1 天内没操作，在 i 天买了,  - prices[i]</span>
    <span class="c1">// 实际就是：dp[i][1] = max(dp[i - 1][1] , - prices[i])</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="c1">// --------------------------</span>
    <span class="c1">// i 天内只买了一次又卖了一次的最大收益</span>
    <span class="c1">// dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])</span>
    <span class="c1">// dp[i-1][2]：第 i 天没操作，顺延到 i - 1 天内进行了买卖各一次</span>
    <span class="c1">// dp[i-1][1] + prices[i]：第 i 天卖了，在第 i - 1 天内进行了一次买入操作</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="c1">// --------------------------</span>
    <span class="c1">// i 天内进行了买一次，卖一次，又买一次的最大收益</span>
    <span class="c1">// dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])</span>
    <span class="c1">// dp[i-1][3]：第 i 天没有操作，顺延到 i - 1 天内进行买卖买操作后的结果</span>
    <span class="c1">// dp[i-1][2] - prices[i]：第 i 天买了，在 i - 1 天内进行了一次买卖操作</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="c1">// --------------------------</span>
    <span class="c1">// i 天内进行了买一次，卖一次，又买一次，又卖一次的最大收益</span>
    <span class="c1">// dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])</span>
    <span class="c1">// dp[i-1][4]：第 i 天没操作，顺延到 i - 1 天内进行了买卖各两次</span>
    <span class="c1">// dp[i-1][3] + prices[i]：第 i 天卖了一次，并且在 i - 1 天内进行了买卖买操作</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="c1">// --------------------------</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span>
<span class="p">};</span>
</pre></div>

<h2 id="124-hard">🌟😻✔ 124 二叉树中的最大路径和【hard】<a class="headerlink" href="#124-hard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">ref</a></p>
<p>一般涉及到路径的问题，都可以从路径根节点下手，任一一条路径必然会有一个根节点，二叉树中以任意一个节点为根节点的最大路径节点总和的<strong>最大值</strong>即为答案。</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(n) 空间复杂度取决于递归调用的层数，最差情况下为 O(n)</span>
<span class="kd">var</span> <span class="nx">maxPathSum</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">val</span>
  <span class="kd">function</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">leftMax</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="kd">let</span> <span class="nx">rightMax</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">leftMax</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">rightMax</span> <span class="o">=</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">const</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">leftMax</span> <span class="o">+</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">rightMax</span> <span class="o">+</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
    <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">leftMax</span> <span class="o">+</span> <span class="nx">rightMax</span> <span class="o">+</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">ret</span>
  <span class="p">}</span>

  <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">max</span>
<span class="p">};</span>
</pre></div>

<h2 id="136-easy">✔ 136 只出现一次的数字【easy】<a class="headerlink" href="#136-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/single-number/">ref</a></p>
<div class="highlight"><pre><span class="c1">// 要求时间空间复杂度是：O(n) O(1)</span>
<span class="kd">var</span> <span class="nx">singleNumber</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">^=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>

<h2 id="141-easy">😻✔ 141 环形链表【easy】<a class="headerlink" href="#141-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/linked-list-cycle/">ref</a></p>
<p>环形链表，双指针，快慢指针</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">hasCycle</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">p1</span> <span class="o">=</span> <span class="nx">head</span>
  <span class="kd">let</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nx">head</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">p2</span> <span class="o">&amp;&amp;</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">p2</span> <span class="o">=</span> <span class="nx">p2</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">p1</span> <span class="o">===</span> <span class="nx">p2</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>

<h2 id="146-lru-medium">😻✔ 146 LRU 缓存【medium】<a class="headerlink" href="#146-lru-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/lru-cache/">ref</a></p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">LRUCache</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">capacity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">capacity</span> <span class="o">=</span> <span class="nx">capacity</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
<span class="p">};</span>

<span class="cm">/** </span>
<span class="cm"> * @param {number} key</span>
<span class="cm"> * @return {number}</span>
<span class="cm"> */</span>
<span class="nx">LRUCache</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">get</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">moveToEnd</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">value</span>
<span class="p">};</span>

<span class="cm">/** </span>
<span class="cm"> * @param {number} key </span>
<span class="cm"> * @param {number} value</span>
<span class="cm"> * @return {void}</span>
<span class="cm"> */</span>
<span class="nx">LRUCache</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">put</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">size</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">keys</span><span class="p">().</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">};</span>

<span class="nx">LRUCache</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">moveToEnd</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">cache</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>

<h2 id="188-ivhard">😻✔ 188 买卖股票的最佳时机 IV【hard】<a class="headerlink" href="#188-ivhard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">ref</a></p>
<p>动态规划</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n*k)</span>
<span class="c1">// 空间复杂度：O(n*k)</span>
<span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">prices</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span>
  <span class="kr">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">k</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="nx">j</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">k</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">isOdd</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span>
      <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nx">isOdd</span><span class="o">?</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">:</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">dp</span><span class="p">[</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
<span class="p">};</span>
</pre></div>

<h2 id="198-medium">😻✔ 198 打家劫舍【medium】<a class="headerlink" href="#198-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/house-robber/">ref</a></p>
<p>动态规划</p>
<p><div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">rob</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="kd">let</span> <span class="nx">d0</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="kd">let</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">d1</span>
    <span class="nx">d1</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">d0</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">d1</span><span class="p">)</span>
    <span class="nx">d0</span> <span class="o">=</span> <span class="nx">t</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">d1</span>
<span class="p">};</span>
</pre></div>
or
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">rob</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">};</span>
</pre></div></p>
<h2 id="200-medium">😻✔ 200 岛屿数量【medium】<a class="headerlink" href="#200-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/number-of-islands/">ref</a></p>
<p>深度优先搜索</p>
<div class="highlight"><pre><span class="c1">// 贪心标记法，DFS</span>
<span class="c1">// 时间复杂度：O(M*N)</span>
<span class="c1">// 空间复杂度：O(M*N)</span>
<span class="kd">var</span> <span class="nx">numIslands</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">grid</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kr">const</span> <span class="nx">used</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">m</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">false</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">n</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">m</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="o">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span> <span class="k">continue</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">count</span><span class="o">++</span>
        <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span> <span class="k">return</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">grid</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">used</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span>  
    <span class="p">}</span>
    <span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>
    <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span>  <span class="nx">m</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">);</span>
    <span class="p">(</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">walk</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">count</span>
<span class="p">};</span>
</pre></div>

<h2 id="206-easy">🌟😻✔ 206 反转链表【easy】<a class="headerlink" href="#206-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/reverse-linked-list/">ref</a></p>
<p>链表</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">reverseList</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">()</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">prev</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">head</span>
    <span class="nx">head</span> <span class="o">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">prev</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">next</span>
</pre></div>

<h2 id="215-kmedium">🌟😻✔ 215 数组中的第K个最大元素【medium】<a class="headerlink" href="#215-kmedium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">ref</a></p>
<p>堆、小顶堆、第K大、大顶堆</p>
<div class="highlight"><pre> <span class="c1">// 小顶堆解法</span>
 <span class="c1">// 时间复杂度：O(nlogn)</span>
 <span class="c1">// 空间复杂度：O(logn)</span>
<span class="kd">var</span> <span class="nx">findKthLargest</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MinHeap</span><span class="p">()</span>

  <span class="nx">nums</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">heap</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">heap</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">heap</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="nx">heap</span><span class="p">.</span><span class="nx">peek</span><span class="p">()</span>
<span class="p">};</span>

<span class="kr">class</span> <span class="nx">MinHeap</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">}</span>

  <span class="nx">insert</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">shiftUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">peek</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="nx">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">}</span>

  <span class="nx">shiftDown</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="kr">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getRightIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">left</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">left</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">right</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">right</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">shiftUp</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span>
    <span class="kr">const</span> <span class="nx">parentIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftUp</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span>
  <span class="p">}</span>

  <span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="nx">getRightIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<div class="highlight"><pre><span class="c1">// 大顶堆解法</span>
<span class="c1">// 时间复杂度：O(nlogn)</span>
<span class="c1">// 空间复杂度：O(logn)</span>
<span class="kd">var</span> <span class="nx">findKthLargest</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">maxHeap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MaxHeap</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="nx">of</span> <span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">maxHeap</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">maxHeap</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="nx">k</span><span class="o">--</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">maxHeap</span><span class="p">.</span><span class="nx">peek</span><span class="p">()</span>
<span class="p">};</span>
<span class="c1">// 大顶堆法，从大顶堆执行 pop() k - 1 次，则数组首个就是第 k 大</span>
<span class="kr">class</span> <span class="nx">MaxHeap</span><span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">}</span>
  <span class="nx">insert</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">up</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nx">swap</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">down</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">target</span>
  <span class="p">}</span>
  <span class="nx">peek</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="nx">get</span> <span class="nx">size</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">}</span>
  <span class="nx">up</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">parentIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">swap</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">parentIndex</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">up</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">down</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">lIndex</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kr">const</span> <span class="nx">rIndex</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">index</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">lIndex</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">swap</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">,</span> <span class="nx">lIndex</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">down</span><span class="p">(</span><span class="nx">lIndex</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">rIndex</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">swap</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">,</span> <span class="nx">rIndex</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">down</span><span class="p">(</span><span class="nx">rIndex</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
  <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span>
<span class="p">}</span>
</pre></div>

<p>更优解、也是用大顶堆，但是没有创建新数组</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(nlogn)</span>
<span class="c1">// 空间复杂度：O(logn)</span>
<span class="kd">var</span> <span class="nx">findKthLargest</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="nx">buildMaxHeap</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">swap</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">maxHeapify</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="nx">i</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">buildMaxHeap</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">maxHeapify</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">maxHeapify</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">endIndex</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">lIndex</span> <span class="o">=</span>  <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="kr">const</span> <span class="nx">rIndex</span> <span class="o">=</span>  <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">lIndex</span> <span class="o">&lt;=</span> <span class="nx">endIndex</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">lIndex</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">swap</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">lIndex</span><span class="p">)</span>
    <span class="nx">maxHeapify</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">lIndex</span><span class="p">,</span> <span class="nx">endIndex</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">rIndex</span> <span class="o">&lt;=</span> <span class="nx">endIndex</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">rIndex</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">swap</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">rIndex</span><span class="p">)</span>
    <span class="nx">maxHeapify</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">rIndex</span><span class="p">,</span> <span class="nx">endIndex</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
  <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span>
<span class="p">}</span>
</pre></div>

<h2 id="217-easy">✔ 217 存在重复元素【easy】<a class="headerlink" href="#217-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/contains-duplicate/">ref</a></p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">containsDuplicate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">nums</span><span class="p">)].</span><span class="nx">length</span> <span class="o">!==</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
<span class="p">};</span>
</pre></div>

<h2 id="226-easy">😻✔ 226 翻转二叉树【easy】<a class="headerlink" href="#226-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/invert-binary-tree/">ref</a></p>
<p>翻转二叉树实际就是把每个节点的子树全部翻转一次</p>
<p>二叉树、二叉树翻转、翻转二叉树、堆</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n) 每个节点都访问到了</span>
<span class="c1">// 空间复杂度：O(h) h 是树的高度，h 最坏的情况是 n</span>
<span class="kd">var</span> <span class="nx">invertTree</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="k">return</span> <span class="nx">root</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">val</span><span class="o">:</span> <span class="nx">root</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span>
    <span class="nx">left</span><span class="o">:</span> <span class="nx">invertTree</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">),</span>
    <span class="nx">right</span><span class="o">:</span> <span class="nx">invertTree</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<p>解法2</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">invertTree</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">root</span><span class="p">)</span> <span class="k">return</span> <span class="nx">root</span>
  <span class="kr">const</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreeNode</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>

  <span class="kr">const</span> <span class="nx">dfs</span> <span class="o">=</span> <span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">isLeft</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">isLeft</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">parent</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
      <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
      <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">parent</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
      <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
      <span class="nx">dfs</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">head</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
  <span class="nx">dfs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">head</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>

  <span class="k">return</span> <span class="nx">head</span>
<span class="p">};</span>
</pre></div>

<h2 id="278-easy">🌟😻✔ 278 第一个错误的版本【easy】<a class="headerlink" href="#278-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/first-bad-version/">ref</a></p>
<p>二分查找</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">solution</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">isBadVersion</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/**</span>
<span class="cm">   * @param {integer} n Total versions</span>
<span class="cm">   * @return {integer} The first bad version</span>
<span class="cm">   */</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">n</span>
      <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">isBadVersion</span><span class="p">(</span><span class="nx">mid</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">l</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">r</span> <span class="o">=</span> <span class="nx">mid</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">r</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>

<h2 id="239-hard">🌟😻✔ 239 滑动窗口最大值【hard】<a class="headerlink" href="#239-hard" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/">ref</a></p>
<p>优先队列、大顶堆、单调队列</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(nlogn)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">maxSlidingWindow</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kr">const</span> <span class="nx">maxHeap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MaxHeap</span><span class="p">()</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">maxHeap</span><span class="p">.</span><span class="nx">insert</span><span class="p">({</span>
      <span class="nx">index</span><span class="o">:</span> <span class="nx">i</span><span class="p">,</span>
      <span class="nx">val</span><span class="o">:</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">})</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">len</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">maxHeap</span><span class="p">.</span><span class="nx">insert</span><span class="p">({</span>
      <span class="nx">index</span><span class="o">:</span> <span class="nx">i</span><span class="p">,</span>
      <span class="nx">val</span><span class="o">:</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">})</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">maxHeap</span><span class="p">.</span><span class="nx">peek</span><span class="p">().</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">k</span><span class="p">)</span> <span class="nx">maxHeap</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">maxHeap</span><span class="p">.</span><span class="nx">peek</span><span class="p">().</span><span class="nx">val</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>

<span class="kr">class</span> <span class="nx">MaxHeap</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">}</span>
  <span class="nx">insert</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">shiftUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">get</span> <span class="nx">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">}</span>
  <span class="nx">peek</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="nx">shiftUp</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">parentIndex</span> <span class="o">=</span>  <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">parentIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">].</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">parentIndex</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftUp</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">shiftDown</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kr">const</span> <span class="nx">r</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="kd">let</span> <span class="nx">maxIndex</span> <span class="o">=</span> <span class="nx">i</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">maxIndex</span><span class="p">].</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">l</span><span class="p">].</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">maxIndex</span> <span class="o">=</span> <span class="nx">l</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">r</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">maxIndex</span><span class="p">].</span><span class="nx">val</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">r</span><span class="p">].</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">maxIndex</span> <span class="o">=</span> <span class="nx">r</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">maxIndex</span> <span class="o">!==</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">maxIndex</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="nx">maxIndex</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>单调队列解法，比较难理解</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n) 每个下标被放进队列1次，且出队列1次</span>
<span class="c1">// 空间复杂度：O(k) </span>
<span class="kd">var</span> <span class="nx">maxSlidingWindow</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">q</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">q</span><span class="p">[</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">q</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">len</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">q</span><span class="p">[</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">q</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">i</span> <span class="o">-</span> <span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">q</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
<span class="p">};</span>
</pre></div>

<h2 id="300-medium">🌟😻✔ 300 最长递增子序列【medium】<a class="headerlink" href="#300-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">ref</a></p>
<p>动态规划</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n^2)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">lengthOfLIS</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">len</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">len</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">dp</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>

<p>更高效版</p>
<p>理论依据：在查找最长递增子序列的过程中，需要尽可能让长度为 x 的子序列的最大值最小，这样才能尽可能多的在后面补上新数字</p>
<p>dp[i] 代表长度为 i 的最长递增子序列的最后一个数的最小值</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(nlogn)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">lengthOfLIS</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1">// dp[i] 代表长度为 i 的最长递增子序列的最后一个数的最小值</span>
  <span class="c1">// 最长递增子序列、最后一个数、最小值</span>
  <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nx">dp</span><span class="p">[</span><span class="o">++</span><span class="nx">count</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">count</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">dp</span><span class="p">[</span><span class="o">++</span><span class="nx">count</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 在 dp 中找到 nums[i] &gt; dp[j - 1] 且 nums[i] &lt;= dp[j]</span>
      <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">count</span>
      <span class="kd">let</span> <span class="nx">pos</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">===</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
          <span class="nx">pos</span> <span class="o">=</span> <span class="nx">mid</span>
          <span class="k">break</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
          <span class="nx">l</span><span class="o">++</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">pos</span> <span class="o">=</span> <span class="nx">r</span>
          <span class="nx">r</span><span class="o">--</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">dp</span><span class="p">[</span><span class="nx">pos</span><span class="p">]</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">count</span>
<span class="p">};</span>
</pre></div>

<h2 id="309-medium">😻✔ 309 最佳买卖股票时机含冷冻期【medium】<a class="headerlink" href="#309-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">ref</a></p>
<p>高效版</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span>
  <span class="c1">// 确定初始值</span>
  <span class="kd">let</span> <span class="nx">profitWithShare</span> <span class="o">=</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="kd">let</span> <span class="nx">profitWithCooldown</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">profitWithoutCooldown</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">profitWithShareBefore</span> <span class="o">=</span> <span class="nx">profitWithShare</span>
    <span class="kr">const</span> <span class="nx">profitWithCooldownBefore</span> <span class="o">=</span> <span class="nx">profitWithCooldown</span>
    <span class="kr">const</span> <span class="nx">profitWithoutCooldownBefore</span> <span class="o">=</span> <span class="nx">profitWithoutCooldown</span>
    <span class="nx">profitWithShare</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">profitWithShareBefore</span><span class="p">,</span> <span class="nx">profitWithoutCooldownBefore</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="nx">profitWithCooldown</span> <span class="o">=</span> <span class="nx">profitWithShareBefore</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">profitWithoutCooldown</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">profitWithoutCooldownBefore</span><span class="p">,</span> <span class="nx">profitWithCooldownBefore</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">profitWithCooldown</span><span class="p">,</span> <span class="nx">profitWithoutCooldown</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>

<p>数组版</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// -------------------------------------</span>
  <span class="c1">// i 天结束之后会存在三种状态（注意，是 i 天结束）：</span>
  <span class="c1">// 0. 持有股票</span>
  <span class="c1">// 1. 不持有股票，且处于冷冻期</span>
  <span class="c1">// 2. 不持有股票，且不处于冷冻期</span>
  <span class="c1">// -------------------------------------</span>
  <span class="c1">// 三种状态的转移方程</span>
  <span class="c1">// -------------------------------------</span>
  <span class="c1">// 0. 持有股票：</span>
  <span class="c1">// i - 1 天结束的时候就持有股票</span>
  <span class="c1">// 或者 i 天买了股票（i - 1 天的时候不处于冷冻期）</span>
  <span class="c1">// dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2] - prices[i])</span>
  <span class="c1">// -------------------------------------</span>
  <span class="c1">// 1. 不持有股票，且处于冷冻期</span>
  <span class="c1">// i 天卖出了股票, i - 1 结束的时候持有股票</span>
  <span class="c1">// dp[i][1] = dp[i-1][0] + prices[i]</span>
  <span class="c1">// -------------------------------------</span>
  <span class="c1">// 2. 不持有股票，且不处于冷冻期</span>
  <span class="c1">// i - 1 天结束的时候就是不持有股票且不处于冷冻期</span>
  <span class="c1">// i - 1 天结束的时候处于冷冻期</span>
  <span class="c1">// dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1])</span>
  <span class="c1">// -------------------------------------</span>
  <span class="c1">// 综合下来 i 天结束之后，能获得的最大收益</span>
  <span class="c1">// Math.max(dp[i][0], d[i][1], dp[i][2])</span>
  <span class="c1">// 要注意一点，i 天结束之后，如果还持有股票，这肯定比 i 天结束之后不持有股票的收益低</span>
  <span class="c1">// 则最终结果 Math.max(d[i][1], dp[i][2])</span>

  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span>
  <span class="c1">// 确定初始值</span>
  <span class="kr">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">len</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="p">[])</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
<span class="p">};</span>
</pre></div>

<h2 id="347-k-medium">😻✔ 347 前 K 个高频元素【medium】<a class="headerlink" href="#347-k-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">ref</a></p>
<p>堆、小顶堆、前K大</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(nlogk)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">topKFrequent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="kr">const</span> <span class="nx">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MinHeap</span><span class="p">()</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="nx">of</span> <span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">?</span> <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">map</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">frequence</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">h</span><span class="p">.</span><span class="nx">insert</span><span class="p">({</span><span class="nx">num</span><span class="p">,</span> <span class="nx">frequence</span><span class="p">})</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">h</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">})</span>

  <span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">_</span><span class="p">.</span><span class="nx">num</span><span class="p">)</span>
<span class="p">};</span>

<span class="kr">class</span> <span class="nx">MinHeap</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">}</span>

  <span class="nx">insert</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">shiftUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">p</span>
  <span class="p">}</span>

  <span class="nx">peek</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="nx">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">}</span>

  <span class="nx">shiftDown</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="kr">const</span> <span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getRightIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">frequence</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">left</span><span class="p">].</span><span class="nx">frequence</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">left</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">right</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">frequence</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">right</span><span class="p">].</span><span class="nx">frequence</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftDown</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">shiftUp</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span>
    <span class="kr">const</span> <span class="nx">parentIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">parentIndex</span><span class="p">].</span><span class="nx">frequence</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">frequence</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">swap</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">shiftUp</span><span class="p">(</span><span class="nx">parentIndex</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span>
  <span class="p">}</span>

  <span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="nx">getRightIndex</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">2</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>还有一个解法，时间复杂度稍微差点</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(nlogn) 快排</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">topKFrequent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="nx">of</span> <span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">?</span> <span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">mapArr</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span>
  <span class="nx">mapArr</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">return</span> <span class="nx">mapArr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">k</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="nx">_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
<span class="p">};</span>
</pre></div>

<h2 id="374-easy">😻✔ 374 猜数字大小【easy】<a class="headerlink" href="#374-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/">ref</a></p>
<p>二分搜索</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">guessNumber</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">n</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">med</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">guess</span><span class="p">(</span><span class="nx">med</span><span class="p">)</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">r</span> <span class="o">=</span> <span class="nx">med</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">guess</span><span class="p">(</span><span class="nx">med</span><span class="p">)</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">l</span> <span class="o">=</span> <span class="nx">med</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">med</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<h2 id="349-easy">😻✔ 349 两个数组的交集【easy】<a class="headerlink" href="#349-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">ref</a></p>
<p>集合</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">intersection</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">nums1</span><span class="p">,</span> <span class="nx">nums2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">nums1</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">nums2</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">v</span><span class="p">)))]</span>
<span class="p">}</span>
</pre></div>

<h2 id="417-medium">😻✔ 417 太平洋大西洋水流问题【medium】<a class="headerlink" href="#417-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">ref</a></p>
<p>深度优先遍历、DFS、图、逆流而上</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">pacificAtlantic</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">heights</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">heights</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">heights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">leftTopFlow</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">m</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">n</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span>
  <span class="kr">const</span> <span class="nx">rightBottomFlow</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">m</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">n</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span>
  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="kd">function</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">flow</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">flow</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">[[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">],</span> <span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">],</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]].</span><span class="nx">forEach</span><span class="p">(([</span><span class="nx">ni</span><span class="p">,</span> <span class="nx">nj</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span>
        <span class="nx">ni</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">ni</span> <span class="o">&lt;</span> <span class="nx">m</span> <span class="o">&amp;&amp;</span>
        <span class="nx">nj</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nj</span> <span class="o">&lt;</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="nx">flow</span><span class="p">[</span><span class="nx">ni</span><span class="p">][</span><span class="nx">nj</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
        <span class="nx">heights</span><span class="p">[</span><span class="nx">ni</span><span class="p">][</span><span class="nx">nj</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">heights</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
      <span class="p">)</span> <span class="p">{</span>
        <span class="nx">dfs</span><span class="p">(</span><span class="nx">ni</span><span class="p">,</span> <span class="nx">nj</span><span class="p">,</span> <span class="nx">flow</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">leftTopFlow</span><span class="p">)</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">rightBottomFlow</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">leftTopFlow</span><span class="p">)</span>
    <span class="nx">dfs</span><span class="p">(</span><span class="nx">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">rightBottomFlow</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">leftTopFlow</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">rightBottomFlow</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">])</span> <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">res</span>
<span class="p">};</span>
</pre></div>

<h2 id="455-easy">😻✔ 455 分发饼干【easy】<a class="headerlink" href="#455-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/assign-cookies/">ref</a></p>
<p>贪心算法</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(nlogn) 排序时间复杂度</span>
<span class="c1">// 时间复杂度：O(logn) 排序空间复杂度</span>
<span class="kd">var</span> <span class="nx">findContentChildren</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">g</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span>

  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nx">s</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="nx">g</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">i</span><span class="o">++</span>
    <span class="p">}</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="nx">i</span>
<span class="p">};</span>
</pre></div>

<h2 id="543-easy">🌟😻✔ 543 二叉树的直径【easy】<a class="headerlink" href="#543-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">ref</a></p>
<p>二叉树</p>
<p>一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p>二叉树的任何一条路径都会以某个节点作为根，而最长路径则是 Max(左子树深度 + 右子树深度) 。</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n) n 是二叉树的节点数</span>
<span class="c1">// 空间复杂度：O(H) H 是二叉树的高度</span>
<span class="kd">var</span> <span class="nx">diameterOfBinaryTree</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">maxRes</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="kd">function</span> <span class="nx">depth</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="kd">let</span> <span class="nx">lDepth</span> <span class="o">=</span> <span class="nx">depth</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">rDepth</span> <span class="o">=</span> <span class="nx">depth</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
    <span class="nx">maxRes</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">maxRes</span><span class="p">,</span> <span class="nx">lDepth</span> <span class="o">+</span> <span class="nx">rDepth</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">lDepth</span><span class="p">,</span> <span class="nx">rDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="nx">depth</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">maxRes</span>
<span class="p">};</span>
</pre></div>

<h2 id="704-easy">😻✔ 704 二分查找【easy】<a class="headerlink" href="#704-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/binary-search/">ref</a></p>
<p>二分查找</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(logn)</span>
<span class="c1">// 时间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">search</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">l</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">l</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">r</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">mid</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">};</span>
</pre></div>

<h2 id="714-medium">😻✔ 714 买卖股票的最佳时机含手续费【medium】<a class="headerlink" href="#714-medium" title="Permanent link"></a></h2>
<p>动态规划</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(1)</span>
<span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">,</span> <span class="nx">fee</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">profitWithoutShare</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="kd">let</span> <span class="nx">profitWithShare</span> <span class="o">=</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">profitWithoutShareBefore</span> <span class="o">=</span> <span class="nx">profitWithoutShare</span>
    <span class="kr">const</span> <span class="nx">profitWithShareBefore</span> <span class="o">=</span> <span class="nx">profitWithShare</span>
    <span class="nx">profitWithoutShare</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">profitWithoutShareBefore</span><span class="p">,</span> <span class="nx">profitWithShareBefore</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">fee</span><span class="p">)</span>
    <span class="nx">profitWithShare</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">profitWithShareBefore</span><span class="p">,</span> <span class="nx">profitWithoutShare</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">profitWithoutShare</span>
<span class="p">};</span>
</pre></div>

<p>数组版</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(n)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="kd">var</span> <span class="nx">maxProfit</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prices</span><span class="p">,</span> <span class="nx">fee</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 0 不持有股票</span>
  <span class="c1">// 1 持有股票</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">len</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">_</span> <span class="o">=&gt;</span> <span class="p">[])</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">prices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">fee</span><span class="p">)</span>
    <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">prices</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="p">};</span>
</pre></div>

<h2 id="933-easy">✔ 933 最近的请求次数【easy】<a class="headerlink" href="#933-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/number-of-recent-calls/">ref</a></p>
<p>这个题的描述很容易看不懂，但是实现起来非常简单</p>
<p>关键词：队列</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">RecentCounter</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">q</span> <span class="o">=</span> <span class="p">[]</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * @param {number} t</span>
<span class="cm"> * @return {number}</span>
<span class="cm"> */</span>
<span class="nx">RecentCounter</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">ping</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
  <span class="k">while</span> <span class="p">(</span><span class="nx">t</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3000</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span>
<span class="p">}</span>
</pre></div>

<h2 id="1306-iiimedium">✔ 1306 跳跃游戏 III【medium】<a class="headerlink" href="#1306-iiimedium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/jump-game-iii/">ref</a></p>
<p>广度优先遍历</p>
<div class="highlight"><pre><span class="c1">// BFS</span>
<span class="c1">// 时间复杂度：O(N)</span>
<span class="c1">// 空间复杂度：O(N)</span>
<span class="kd">var</span> <span class="nx">canReach</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span>
  <span class="kr">const</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span>
  <span class="kr">const</span> <span class="nx">usedIndexes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kr">const</span> <span class="nx">nextIndexes</span> <span class="o">=</span> <span class="p">[</span><span class="nx">start</span><span class="p">]</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">nextIndexes</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">targetIndex</span> <span class="o">=</span> <span class="nx">nextIndexes</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">targetIndex</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span>
    <span class="nx">usedIndexes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">targetIndex</span><span class="p">)</span>
    <span class="k">if</span><span class="p">((</span><span class="nx">targetIndex</span> <span class="o">-</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">targetIndex</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">usedIndexes</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">targetIndex</span> <span class="o">-</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">targetIndex</span><span class="p">]))</span> <span class="p">{</span>
      <span class="nx">nextIndexes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">targetIndex</span> <span class="o">-</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">targetIndex</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">((</span><span class="nx">targetIndex</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">targetIndex</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">usedIndexes</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">targetIndex</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">targetIndex</span><span class="p">]))</span> <span class="p">{</span>
      <span class="nx">nextIndexes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">targetIndex</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">targetIndex</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">};</span>
</pre></div>

<p>深度优先遍历</p>
<div class="highlight"><pre><span class="c1">// DFS</span>
<span class="c1">// 时间复杂度：O(N)</span>
<span class="c1">// 空间复杂度：O(N)</span>
<span class="kd">var</span> <span class="nx">canReach</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span>
  <span class="kr">const</span> <span class="nx">usedIndexes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="nx">usedIndexes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span>

  <span class="kd">function</span> <span class="nx">jump</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">usedIndexes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">||</span> <span class="nx">usedIndexes</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">index</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="nx">usedIndexes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">jump</span><span class="p">(</span><span class="nx">index</span> <span class="o">-</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span> <span class="o">||</span> <span class="nx">jump</span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">jump</span><span class="p">(</span><span class="nx">start</span> <span class="o">-</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">])</span> <span class="o">||</span> <span class="nx">jump</span><span class="p">(</span><span class="nx">start</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">start</span><span class="p">])</span>
<span class="p">};</span>
</pre></div>

<h2 id="offer-09-easy">✔ 剑指 Offer 09. 用两个栈实现队列【easy】<a class="headerlink" href="#offer-09-easy" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">ref</a></p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">CQueue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">inStack</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">outStack</span> <span class="o">=</span> <span class="p">[]</span>
<span class="p">};</span>

<span class="cm">/** </span>
<span class="cm"> * @param {number} value</span>
<span class="cm"> * @return {void}</span>
<span class="cm"> */</span>
<span class="nx">CQueue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">appendTail</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">inStack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * @return {number}</span>
<span class="cm"> */</span>
<span class="nx">CQueue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">deleteHead</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 必须要把 outStack 出干净之后才能再次从 instack 中拿数据</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">outStack</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">inStack</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">toOut</span><span class="p">()</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">outStack</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">outStack</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
<span class="p">};</span>

<span class="nx">CQueue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toOut</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">inStack</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">outStack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">inStack</span><span class="p">.</span><span class="nx">pop</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h2 id="offer-51-medium">🌟😻✔ 剑指 Offer 51 数组中的逆序对【medium】<a class="headerlink" href="#offer-51-medium" title="Permanent link"></a></h2>
<p><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">ref</a></p>
<p>归并排序</p>
<div class="highlight"><pre><span class="c1">// 时间复杂度：O(nlogn)</span>
<span class="c1">// 空间复杂度：O(n)</span>
<span class="cm">/**</span>
<span class="cm"> * @param {number[]} nums</span>
<span class="cm"> * @return {number}</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">reversePairs</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="cm">/**</span>
<span class="cm">  * @param {number[]} arr</span>
<span class="cm">  * @return {number[]}</span>
<span class="cm">  */</span>
  <span class="kd">function</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="o">===</span> <span class="nx">l</span><span class="p">)</span> <span class="k">return</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">l</span><span class="p">]]</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">)</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="kr">const</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">mid</span><span class="p">),</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">r</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">  * @param {number[]} arr1</span>
<span class="cm">  * @param {number[]} arr2</span>
<span class="cm">  * @return {number[]}</span>
<span class="cm">  */</span>
  <span class="kd">function</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">arr1</span><span class="p">,</span> <span class="nx">arr2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="kr">const</span> <span class="nx">len1</span> <span class="o">=</span> <span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span>
    <span class="kr">const</span> <span class="nx">len2</span> <span class="o">=</span> <span class="nx">arr2</span><span class="p">.</span><span class="nx">length</span>
    <span class="kd">let</span> <span class="nx">l1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="kd">let</span> <span class="nx">l2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">l1</span> <span class="o">&lt;</span> <span class="nx">len1</span> <span class="o">&amp;&amp;</span> <span class="nx">l2</span> <span class="o">&lt;</span> <span class="nx">len2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">l1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">arr2</span><span class="p">[</span><span class="nx">l2</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">l1</span><span class="o">++</span><span class="p">])</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">total</span> <span class="o">+=</span> <span class="nx">len1</span> <span class="o">-</span> <span class="nx">l1</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr2</span><span class="p">[</span><span class="nx">l2</span><span class="o">++</span><span class="p">])</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">l1</span> <span class="o">&lt;</span> <span class="nx">len1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">l1</span><span class="o">++</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">l2</span><span class="o">&lt;</span><span class="nx">len2</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr2</span><span class="p">[</span><span class="nx">l2</span><span class="o">++</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
  <span class="p">}</span>

  <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">total</span>
<span class="p">};</span>
</pre></div></article></body></html>