<div class="finished-info-wrapper">
  完成度 <span class="finished-info">500 / 500 -> 100%<span>
</div>

# ✔ 算法知名仓库

- [【微软】宫水三叶](https://github.com/SharingSource/LogicStack-LeetCode)
- [路西法](https://github.com/azl397985856/leetcode)

# 刷题指南

刷题的时候要按照大概的题目分类来刷，每个方面都要有所了解。

- [基础算法](#😻✔-基础算法)
- 栈
- 队列
- 链表
- 集合
- 字典
- 树
- 堆
- 图
- 搜索、排序
- 分治法
- 动态规划
- 贪心算法
- 回溯算法

## 栈、队列

- 【easy】 [20 有效的括号](https://leetcode.cn/problems/valid-parentheses/)
- 【easy】 [933 最近的请求次数](https://leetcode.cn/problems/number-of-recent-calls/)

## 链表

- 【medium】 [2 两数相加](https://leetcode.cn/problems/add-two-numbers/)
- 【easy】 [21 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
- 【hard】 [23 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
- 【easy】 [83 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)
- 【easy】 [141 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
- 【easy】 [206 反转链表](https://leetcode.cn/problems/reverse-linked-list/)


## 集合

- 【easy】 [349 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

## 字典、滑动窗口、双指针

- 【easy】 [1 两数之和](https://leetcode.cn/problems/two-sum/)
- 【medium】 [3 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
- 【hard】 [76 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

## 树、深度优先、广度优先

- 【easy】 [94 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
- 【easy】 [100 相同的树](https://leetcode.cn/problems/same-tree/)
- 【easy】 [101 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
- 【medium】 [102 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
- 【easy】 [104 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
- 【easy】 [111 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
- 【easy】 [112 路径总和](https://leetcode.cn/problems/path-sum/)
- 【easy】 [226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

## 堆

- 【hard】 [23 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
- 【medium】 [215 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
- 【easy】 [226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
- 【easy】 [347 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

## 图、深度优先、广度优先

- 【medium】 [113 克隆图](https://leetcode.cn/problems/clone-graph/)
- 【medium】 [417 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

## 搜索、排序

- 【easy】 [374 猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)

## 分治法

特征是：先拆分、再解决、后合并

将一个问题拆分成很多个和原问题相似的小问题，递归解决小问题，再将结果合并以解决原来的问题

- 【easy】[100 相同的树](https://leetcode.cn/problems/same-tree/)
- 【easy】[226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

## 动态规划

特征是：某个结果会依赖前面的结果，或者前面的几个结果之间有关联


- 【easy】 [70 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
- 【easy】[121 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
- 【medium】 [122 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
- 【hard】 [123 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)
- 【hard】 [188 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)
- 【medium】 [714 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
- 【medium】 [198 打家劫舍](https://leetcode.cn/problems/house-robber/)
- 【medium】 [309 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
- 【hard】 [42 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
- 🌟【easy】 [53 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

## 贪心算法

特征是：期盼通过每个阶段的局部最优选择，从而达到全局的最优，结果并不一定是最优。

- 【medium】 [5 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
- 【easy】 [455 分发饼干](https://leetcode.cn/problems/assign-cookies/)

## 回溯算法

回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

- 【medium】 [46 全排列](https://leetcode.cn/problems/permutations/)
- 【medium】 [47 全排列 II](https://leetcode.cn/problems/permutations-ii/)
- 【medium】 [78 子集](https://leetcode.cn/problems/subsets/)
- 【medium】 [22 括号生成](https://leetcode.cn/problems/generate-parentheses/)

## 二分查找

- 【easy】 [704 二分查找](https://leetcode.cn/problems/binary-search/)
- 🌟【hard】 [4 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)


# 😻✔ 基础算法 

常见复杂度曲线：

![](https://qiniu1.lxfriday.xyz/feoffer/1652356442444_09edc6aa-6dfe-41aa-bd02-b9f3097b3717.png)

排序算法排序流程图解：

[https://visualgo.net/zh/sorting](https://visualgo.net/zh/sorting)

## 😻✔ 排序算法 

ref

- [丰富图例讲解十大经典排序算法](https://juejin.im/post/5d9033fa5188257f6f1ba46b)
- [排序算法](https://github.com/lxfriday/give-me-job/tree/7c193c8279/algorithm/%E6%8E%92%E5%BA%8F)

![排序算法一览](https://qiniu1.lxfriday.xyz/feoffer/sort.png)

### 😻✔ 冒泡排序 

![](https://qiniu1.lxfriday.xyz/feoffer/bubbleSort.png)

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function bubbleSort(arr) {
  const length = arr.length
  if (length <= 1) return arr
  for (let i = 0; i < length; i++) {
    let changed = false // 没有数据交换则表示已经有序了
    for (let j = 0; j < length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
        changed = true
      }
    }
    if (!changed) break
  }
  return arr
}
```

### 😻✔ 选择排序 

![](https://qiniu1.lxfriday.xyz/feoffer/ec43f415-5224-bd9b-ad33-0ee480cd19e7.png)

![](https://qiniu1.lxfriday.xyz/feoffer/selectionSort.gif)

核心思想：进行 n 轮，每轮找出最小的放在这一轮的初始位置

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function selectionSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  for (let i = 0; i < len; i++) {
    let min = i
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[min]) min = j
    }
    swap(arr, i, min)
  }

  return arr
}
```

### 😻✔ 插入排序 

![](https://qiniu1.lxfriday.xyz/feoffer/6e79c1d5-2896-68bc-ebc0-280ee2881035.png)

![](https://qiniu1.lxfriday.xyz/feoffer/insertionSort.gif)

```javascript
function insertionSort(arr) {
  const len = arr.length
  if (len <= 1) return arr

  for (let i = 1; i < len; i++) {
    const cur = arr[i]
    let j = i - 1
    for (; j >= 0; j--) {
      if (arr[j] > cur) {
        arr[j + 1] = arr[j]
      } else {
        break
      }
    }
    arr[j + 1] = cur
  }

  return arr
}
```

### 😻✔ 快速排序 

![](https://qiniu1.lxfriday.xyz/feoffer/008ba6a2-d847-8894-a3b4-70b09a1b44b8.png)

![](https://qiniu1.lxfriday.xyz/feoffer/quicksort.gif)

单路快排

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function partition(arr, left, right) {
  let pivot = left
  let index = pivot + 1
  for (let i = index; i <= right; i++) {
    if (arr[i] < arr[pivot]) {
      swap(arr, i, index)
      index++
    }
  }
  swap(arr, pivot, index - 1)
  return index - 1
}

function quickSort(arr, l, r) {
  const len = arr.length
  const left = typeof l === 'number' ? l : 0
  const right = typeof r === 'number' ? r : len - 1
  let partitionIndex = 0
  if (left < right) {
    partitionIndex = partition(arr, left, right)
    quickSort(arr, left, partitionIndex - 1)
    quickSort(arr, partitionIndex + 1, right)
  }

  return arr
}
```

更好理解的快排

```js
function partition2(arr) {
  if (arr.length <= 1) return arr
  const target = arr[0]
  const leftArr = []
  const rightArr = []
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < target) {
      leftArr.push(arr[i])
    } else {
      rightArr.push(arr[i])
    }
  }
  return [...partition2(leftArr), target, ...partition2(rightArr)]
}

function quickSort2(arr) {
  return partition2(arr)
}
```

### 😻✔ 归并排序 

![](https://qiniu1.lxfriday.xyz/feoffer/3ccf988e-b992-84f0-a622-dd03c51123c9.png)

![](https://qiniu1.lxfriday.xyz/feoffer/d3de0b1f-7827-e3b9-eeb7-1993e03e0372.png)

![](https://qiniu1.lxfriday.xyz/feoffer/16d7b507ece11c9d.gif)

归并排序（英语：Merge sort，或 mergesort），是创建在归并操作上的一种有效的排序算法，效率为 O(nlogn)。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用 分治法（Divide and Conquer） 的一个非常典型的应用，且各层分治递归可以同时进行。

采用分治法:

1. 分割：递归地把当前序列平均分割成两半。
1. 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。

```javascript
function merge(arr1, arr2) {
  const res = []
  while (arr1.length && arr2.length) {
    if (arr1[0] < arr2[0]) {
      res.push(arr1.shift())
    } else {
      res.push(arr2.shift())
    }
  }
  while (arr1.length) {
    res.push(arr1.shift())
  }
  while (arr2.length) {
    res.push(arr2.shift())
  }

  return res
}

function mergeSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  const m = Math.floor(len / 2)
  const arr1 = arr.slice(0, m)
  const arr2 = arr.slice(m)
  return merge(mergeSort(arr1), mergeSort(arr2))
}
```

### 😻✔ 希尔排序 

![](https://qiniu1.lxfriday.xyz/feoffer/907976b2-e3b0-91fc-0b6d-3ead3ee08c1c.png)

![](https://qiniu1.lxfriday.xyz/feoffer/16d7b4ce200763d6.gif)

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

```javascript
function shellSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  // gap 不断缩小，最后变成 1
  for (let gap = len >> 1; gap > 0; gap >>= 1) {
    // gap 确定之后，从 gap 位置开始向后循环
    for (let i = gap; i < len; i++) {
      const temp = arr[i]
      let j = i - gap
      // i 每轮循环中需要从左往右做插排
      for (; j >= 0 && arr[j] > temp; j -= gap) {
        arr[j + gap] = arr[j]
      }
      arr[j + gap] = temp
    }
  }

  return arr
}
```

### 😻✔ 堆排序(heap-sort) 

![堆排序](https://qiniu1.lxfriday.xyz/feoffer/heapSort2.png)
![堆排序](https://qiniu1.lxfriday.xyz/feoffer/heapSort.gif)

堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。其中每个节点最多存在两个子节点，对以 0 开始的堆数组，有如下规则：

1. 父节点 `i` 的**左**子节点在位置 `2 * i + 1`
1. 父节点 `i` 的**右**子节点在位置 `2 * i + 2`
1. 子节点 `i` 的父节点在位置 `Math.floor((i - 1) / 2)`

大顶堆：所有节点 `i` 的值比其左右子节点都大的堆

小顶堆：所有节点 `i` 的值比其左右子节点都小的堆

堆排序的重要过程（以大顶堆实现从小到大为例）：

1. 构建大顶堆
1. 把 0 和最后一位交换（无序数组的最后一位）
1. 从 0 位重新构建大顶堆
1. 重复步骤 2、3

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
// 构建大顶堆的核心递归算法
function heapifyMax(arr, i, len) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let max = i
  if (left < len && arr[left] > arr[max]) {
    max = left
  }
  if (right < len && arr[right] > arr[max]) {
    max = right
  }
  if (i != max) {
    swap(arr, max, i)
    heapifyMax(arr, max, len)
  }
}
// 构建小顶堆的核心递归算法
function heapifyMin(arr, i, len) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let min = i
  if (left < len && arr[left] < arr[min]) {
    min = left
  }
  if (right < len && arr[right] < arr[min]) {
    min = right
  }
  if (i != min) {
    swap(arr, min, i)
    heapifyMin(arr, min, len)
  }
}

function buildMaxHeap(arr) {
  const len = arr.length
  for (let i = Math.floor(len / 2); i >= 0; i--) {
    heapifyMax(arr, i, len)
  }
}

function buildMinHeap(arr) {
  const len = arr.length
  for (let i = Math.floor(len / 2); i >= 0; i--) {
    heapifyMin(arr, i, len)
  }
}

// asc 为 true 表示从小到大，false 为从大到小
function heapSort(arr, asc = false) {
  if (asc) {
    // 使用大顶堆实现从小到大排序
    buildMaxHeap(arr)
    const len = arr.length
    for (let i = len - 1; i > 0; i--) {
      swap(arr, 0, i)
      heapifyMax(arr, 0, i)
    }
  } else {
    // 使用小顶堆实现从大到小排序
    buildMinHeap(arr)
    const len = arr.length
    for (let i = len - 1; i > 0; i--) {
      swap(arr, 0, i)
      heapifyMin(arr, 0, i)
    }
  }
  return arr
}
```

### 😻✔ 计数排序(counting-sort) 

![计数排序](https://qiniu1.lxfriday.xyz/feoffer/countingSort.png)

**限定为非负数**

计数排序是一种稳定的线性时间排序算法。计数排序使用一个额外的数组 `C` ，其中第 `i` 个元素是待排序数组 `A` 中值等于 `i` 的元素的个数。然后根据数组 `C` 来将 `A` 中的元素排到正确的位置。

当输入的元素是 `n` 个 `0` 到 `k` 之间的整数时，它的运行时间是 `t(n+k)`。**计数排序不是比较排序，排序的速度快于任何比较排序算法。**

由于用来计数的数组 `C` 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

```javascript
function countingSort(arr) {
  const len = arr.length
  if (len < 2) return arr
  const bucket = []
  let sortIndex = 0

  for (let i = 0; i < len; i++) {
    if (bucket[arr[i]]) {
      bucket[arr[i]] += 1
    } else {
      bucket[arr[i]] = 1
    }
  }

  for (let i = 0; i < bucket.length; i++) {
    for (let j = bucket[i]; j > 0; j--) {
      arr[sortIndex++] = i
    }
  }
  return arr
}
```

### 😻✔ 基数排序(radix-sort) 

![基数排序](https://qiniu1.lxfriday.xyz/feoffer/radixSort.png)

**限定为非负数**

基数排序原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。

它是这样实现的：将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

基数排序的方式可以采用 **LSD（Least significant digital）** 或 **MSD（Most significant digital）**，LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。

基数排序的时间复杂度是 `O(k*n)`，其中 `n` 是排序元素个数，`k` 是数字位数。这不是说这个时间复杂度一定优于 `O(nlogn)`，`k` 的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；`k` 决定了进行多少轮处理，而 `n` 是每轮处理的操作数目。

LSD 实现

```javascript
function radixSort(arr) {
  const len = arr.length
  // 得到最大值
  const max = Math.max(...arr)
  let bucket = []
  // 获取最大值的位数
  let digit = `${max}`.length
  let start = 1
  // 待操作的新数组
  let res = arr.slice()

  while (digit > 0) {
    // 每轮向左移动一位
    start *= 10
    for (let i = 0; i < len; i++) {
      const j = res[i] % start
      // 和计数排序类似
      if (!bucket[j]) {
        bucket[j] = []
      }
      // bucket 是一个二维数组
      bucket[j].push(res[i])
    }

    // 拼接前 res 设为空数组
    res = []
    for (let i = 0; i < bucket.length; i++) {
      if (bucket[i] !== undefined) {
        // res 拼接 bucket[i] 数组
        res = res.concat(bucket[i])
      }
    }
    // 结束之后 bucket 重置
    bucket = []
    digit--
  }

  return res
}
```

### 😻✔ 桶排序、箱排序(bucket-sort) 

![桶排序](https://qiniu1.lxfriday.xyz/feoffer/bucketSort.png)

桶排序工作原理是将数组分到有限数量的桶里，每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。

桶排序以下列步骤进行：

1. 设置桶个数 `size`，计算每个桶的存储范围；
1. 遍历数组，把数字放到对应的桶中；
1. 对步骤 2 放新数字的桶数组排序；
1. 数组遍历完之后，把桶中的数字依次取出放到最终的数组中；

```javascript
function swap(arr, i, j) {
  ;[arr[i], arr[j]] = [arr[j], arr[i]]
}

/**
 * @param {array} arr 待排序的数组
 * @param {number} size 桶的个数
 */
function bucketSort(arr, size = 5) {
  const len = arr.length
  // 取到最小值
  const min = Math.min(...arr)
  // 取得最大值
  const max = Math.max(...arr)
  // 每个桶的范围
  const bucketSize = Math.floor((max - min) / size) + 1
  const res = []
  // 总共的桶容器
  const bucket = []

  for (let i = 0; i < len; i++) {
    // arr[i] 分布在桶 j
    const j = Math.floor((arr[i] - min) / bucketSize)

    // 桶不存在则创建
    if (bucket[j] === undefined) {
      bucket[j] = []
    }
    // 将 arr[i] 推入桶中
    bucket[j].push(arr[i])
    let l = bucket[j].length - 1
    while (l > 0) {
      // 对个别桶使用冒泡
      // 若 arr[i] 在桶内不是最小，则向前移动
      bucket[j][l] < bucket[j][l - 1] && swap(bucket[j], l, l - 1)
      l--
    }
  }

  // 把 bucket 二维数组中的数据全部拿出来
  for (let i = 0; i < bucket.length; i++) {
    if (bucket[i] !== undefined) {
      for (let j = 0; j < bucket[i].length; j++) {
        res.push(bucket[i][j])
      }
    }
  }
  return res
}
```

## ✔ 搜索算法

### 😻✔ 二分搜索算法 

二分搜索算法的前提是目标数组已经排好序了。

```js
function binarySearch(arr, target) {
  let l = 0
  let r = arr.length - 1
  while (l <= r) {
    const med = Math.floor((l + r) / 2)
    if (target < arr[med]) {
      r = med - 1
    } else if (target > arr[med]) {
      l = med + 1
    } else {
      return med
    }
  }
  return -1
}
```

## 😻✔ LRU 缓存算法 

ref

- [https://juejin.im/post/5d77b68951882520d46abd18](https://juejin.im/post/5d77b68951882520d46abd18)

> 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：**先进先出策略** FIFO（First In，First Out）、**最少使用策略** LFU（Least Frequently Used）、**最近最少使用策略** LRU（Least Recently Used）。

最近最少，越是最近使用就越是不会被清除，而最远使用的将会逐渐被推到丢弃端，如果一直不被使用，数据不断存入时将会丢弃它们。

使用 ES6 Map 实现

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity
    this.cache = new Map()
  }
  put(k, v) {
    if (this.cache.has(k)) this.cache.delete(k)
    else if (this.cache.size >= this.capacity)
      this.cache.delete(this.cache.keys().next().value)
    this.cache.set(k, v)
  }
  get(k) {
    const v = this.cache.get(k)
    if (v === undefined) return -1
    else this.moveToEnd(k, v)
    return v
  }
  moveToEnd(k, v) {
    this.cache.delete(k)
    this.cache.set(k, v)
  }
}
```

双向链表实现

```javascript
class LinkedListNode {
  constructor(k, v, prev, next) {
    this.key = k
    this.value = v
    // 前向节点
    this.prev = prev
    // 后向节点
    this.next = next
  }
}

class LRUCache {
  constructor(capacity) {
    // 容量
    this.capacity = capacity
    this.cache = {}
    // 实际存储的容量
    this.size = 0
    // 哨兵头结点
    this.head = new LinkedListNode()
    // 哨兵尾结点
    this.tail = new LinkedListNode()

    this.head.next = this.tail
    this.tail.prev = this.head
  }

  // 删除节点
  removeNode(node) {
    const prev = node.prev
    const next = node.next

    prev.next = next
    next.prev = prev
  }

  // 新增一个节点
  addNode(node) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
  }
  // 删除尾结点
  popTail() {
    const res = this.tail.prev
    this.removeNode(res)
    return res
  }

  put(k, v) {
    const node = this.cache[k]
    if (!node) {
      const n = new LinkedListNode(k, v)
      this.cache[k] = n
      this.addNode(n)
      if (this.size >= this.capacity) {
        const deleteNode = this.popTail()
        delete this.cache[deleteNode.key]
      } else {
        this.size += 1
      }
    } else {
      this.removeNode(node)
      node.value = v
      this.addNode(node)
    }
  }

  get(k) {
    const node = this.cache[k]
    if (!node) return -1
    else {
      this.removeNode(node)
      this.addNode(node)
      return node.value
    }
  }
}
```

## 😻✔ 斐波拉契数列 

```
1 1 2 3 5 8 13 21 34 55 89
```

**尾递归**

现在浏览器和 NodeJS 已经禁用了尾递归优化，所以仅仅是尾递归，并不会起到优化的作用。

```javascript
function Fibonacci(n, prev1 = 1, prev2 = 0) {
  if (n === 1) return prev1
  return Fibonacci(n - 1, prev1 + prev2, prev1)
}
```

**迭代**

```javascript
function Fibonacci(n) {
  const init = [1, 0]
  for (let i = 1; i < n; i++) {
    ;[init[0], init[1]] = [init[0] + init[1], init[0]]
  }
  return init[0]
}
```

## 😻✔ 因式分解 

实现一个 `calc` 方法，可以将输入的数拆解为尽可能多的乘数，所有数相乘等于输入数。

```javascript
calc(2) // [2]
calc(8) // [2, 2, 2]
calc(24) // [2, 2, 2, 3]
calc(30) // [2, 3, 5]
```

```javascript
function calc(n) {
  const res = []
  let prev = n
  let i = 2

  while (i <= prev) {
    if (prev % i === 0) {
      res.push(i)
      prev /= i
      i = 2
    } else if (i < prev) {
      i++
    } else if (i === prev) {
      res.push(i)
    }
  }
  console.log(res)

  return res
}
```

# from - 其他

## ✔ 从数组中找出和为某个值的两数下标

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]。

初始代码：

```javascript
const twoSum = (nums, target) => {}
```

---

解法 1 - `Map`：

```javascript
const twoSum = (nums, target) => {
  const map = new Map()
  for (let i = 0, len = nums.length; i < len; i++) {
    if (map.get(nums[i])) {
      return [map.get(nums[i]), i]
    }
    map.set(target - nums[i], i)
  }
}
```

解法 2 - 两次循环：

```javascript
const twoSum = (nums, target) => {
  for (let i = 0, len = nums.length; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      if (nums[i] + nums[j] === target) return [i, j]
    }
  }
}
```

# leetcode 刷题记录

## 😻✔ 1 两数之和【easy】

[ref](https://leetcode.cn/problems/two-sum/)

Map、字典

```js
var twoSum = function (nums, target) {
  // for (var i = 0; i < nums.length; i++) {
  //   for (var j = i + 1; j < nums.length; j++) {
  //     if (nums[i] + nums[j] === target) return [i, j]
  //   }
  // }
  const m = new Map()
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i]
    const other = target - num
    if (m.has(other)) {
      return [m.get(other), i]
    } else {
      m.set(num, i)
    }
  }
}
```

## 😻✔ 2 两数相加【medium】

[ref](https://leetcode.cn/problems/add-two-numbers/)

链表

```js
var addTwoNumbers = function (l1, l2) {
  const head = new ListNode()
  let curr = head
  let add = 0
  let sum = 0
  while (l1 || l2) {
    sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + add
    add = Math.floor(sum / 10)
    curr.next = new ListNode(sum - 10 * add)
    l1 = l1 && l1.next
    l2 = l2 && l2.next
    curr = curr.next
  }
  if (add > 0) {
    curr.next = new ListNode(1)
  }

  return head.next
}

function ListNode(val, next) {
  this.val = val === undefined ? 0 : val
  this.next = next === undefined ? null : next
}
```

## 😻✔ 3 无重复字符的最长子串【medium】

[ref](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

滑动窗口、字典

```js
var lengthOfLongestSubstring = function (s) {
  let maxLen = 0
  let currStr = ''
  for (let i = 0; i < s.length; i++) {
    const indInCurrStr = currStr.indexOf(s[i])
    let len
    if (indInCurrStr === -1) {
      currStr += s[i]
      len = currStr.length
    } else {
      len = currStr.length
      currStr = currStr.slice(indInCurrStr + 1) + s[i]
    }
    maxLen = len > maxLen ? len : maxLen
  }
  return maxLen
}
```

or

```js
var lengthOfLongestSubstring = function (s) {
  let l = 0
  let max = 0
  const m = new Map()
  for (let r = 0; r < s.length; r++) {
    if (m.has(s[r]) && m.get(s[r]) >= l) {
      l = m.get(s[r]) + 1
    }
    m.set(s[r], r)
    max = Math.max(max, r - l + 1)
  }
  return max
}
```

## 🌟😻✔ 4 寻找两个正序数组的中位数【hard】

[ref](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

二分查找

```js

// 时间复杂度：O(log(m + n))
// 空间复杂度：O(1)
var findMedianSortedArrays = function(nums1, nums2) {
  // 利用中位数的特殊属性
  const m = nums1.length
  const n = nums2.length
  const totalLength = m + n
  if(totalLength % 2 === 1) {
    // 中位数就在数组中
    const mid = (totalLength - 1) / 2
    return getTarget(mid + 1, nums1, nums2)
  } else {
    // 中位数是最中间两个数的均值
    const mid = totalLength / 2
    return (getTarget(mid, nums1, nums2) + getTarget(mid + 1, nums1, nums2)) / 2
  }
};

// 转化为获取 nums1 和 nums2 数组中的第 k 大的数
// 两个数组是排好序的数组
function getTarget(k, nums1, nums2) {
  // 对于两个数组中下标为 k / 2 - 1(即第 k / 2 个) 的数字A(k / 2 - 1)和 B(k / 2 - 1)
  // ----------------------------------------------------------------------
  // 如果 A(k / 2 - 1) < B(k / 2 - 1) ，则有这样一个规则存在
  // 在 A、B 两个数组的前 k / 2 个数字中（即 A+B 的前K个数字中），A(k / 2 - 1)最多只能是第 k - 1 个数字，不可能是第 K 个数字
  // 由于 A(k / 2 - 1)  前面的数字比它还小，则其前面的数字只能排在A + B 数组的 k - 1 之前，则可以断定，第 K 个数字肯定不在 A[0]~A[k / 2 - 1] 内
  // 就可以把 A 中下标在 k / 2 之前的全部排除
  // 排除之后，新的 newK = k - (k / 2)
  // ----------------------------------------------------------------------
  // 如果 A(k / 2 - 1) > B(k / 2 - 1) 则对 B 进行上面的操作
  // ----------------------------------------------------------------------
  // 如果 A(k / 2 - 1) === B(k / 2 - 1) ，则 A 中 k / 2 - 1 前面的数字和 B 中 k / 2 - 1 前面的数字合并起来，也最多只能排在 k - 2 位
  // 则实际上 A(k / 2 - 1) 和 B(k / 2 - 1) 前面的数字都可以【排除掉】
  // 因为 A(k / 2 - 1) 和 B(k / 2 - 1) 是相等的，则 A(k / 2 - 1) 这一项也可以排除掉，极端情况下，刚好 B(k / 2 - 1) 就是想要的值
  // 综合之后就是，两者相等的时候，选择同 A(k / 2 - 1) < B(k / 2 - 1) 一样的操作，把 A 中前 k / 2 个数字全部排除掉
  // ----------------------------------------------------------------------
  // 由于 k 表示的是在 剩下的 nums1 和 nums2 合并后的有序数组中，第 k 个数字
  // 则当 k = 1 的时候 ，直接比较剩下的 nums1 和 nums2 两数组中靠在最前面且未被排除的下标，即可得出结果。
  // ----------------------------------------------------------------------
  // 这里 k 可能是奇数也可能是偶数，是偶数就完全符合上面的推断，是奇数的时候， k / 2 向下取整
  // 这样 Math.floor(k / 2) * 2 < k，所以从两个数组上取的数之和小于 k
  // 当 A(Math.floor(k / 2) - 1) < B(Math.floor(k / 2) - 1) 成立的时候，A(Math.floor(k / 2) - 1) 最多只能排在第 Math.floor(k / 2) * 2 - 1 的位置上
  // Math.floor(k / 2) * 2 - 1 < k - 1，故 A(Math.floor(k / 2) - 1) 对应的数字及其前面的数字都能排除掉，这和 k 是偶数的时候完全一样
  // 当 A(Math.floor(k / 2) - 1) === B(Math.floor(k / 2) - 1) 成立的时候
  // A(Math.floor(k / 2) - 1) 最多排在第 Math.floor(k / 2) * 2 的位置，而 Math.floor(k / 2) * 2 < k，故结果 k 是偶数的时候也是一致的
  // ----------------------------------------------------------------------
  // 上述思路对应的是两个数组中存在数字大于中位数，则一直执行上述操作直到获取到第k个数数字的时候，两个数组中都还有数字
  // 还有另外一种情况，某个数组中的数字全部排在中位数前面
  // 则肯定会出现一个数组中的所有数字全部是不需要的数字
  // 当上述操作执行到某个数组的下标超过边界的时候，只需要在另一个数组中找到第 k（去掉被排除的数字） 个数字即是结果

  let nums1Target
  let nums2Target
  let halfK
  let showDropCount
  let ind1 = 0
  let ind2 = 0

  while(true) {
    if(ind1 >= nums1.length) {
      return nums2[ind2 + k - 1]
    }
    if(ind2 >= nums2.length) {
      return nums1[ind1 + k - 1]
    }
    if(k === 1) {
      return Math.min(nums1[ind1], nums2[ind2])
    }
    halfK = Math.floor(k / 2)
    // showDropCount 表示应该丢弃的数字个数，由于可能存在下标越界的问题，当下标越界出现的时候
    // 默认使用数组的最后一个数字来做比较，而这个时候要排除的数字个数就可能不是 halfK 个了
    showDropCount = halfK
    // 超出了数组长度，则使用最后一个，也就是数组中最大的一个数
    if(ind1 + halfK - 1 >= nums1.length) {
      nums1Target = nums1[nums1.length - 1]
      showDropCount = nums1.length  - ind1
    } else {
      nums1Target = nums1[ind1 + halfK - 1]
    }
    if(ind2 + halfK - 1 >= nums2.length) {
      nums2Target = nums2[nums2.length - 1]
      showDropCount = nums2.length - ind2
    } else {
      nums2Target = nums2[ind2 + halfK - 1]
    }

    if(nums1Target <= nums2Target) {
      ind1 = ind1 + showDropCount
    } else {
      ind2 = ind2 + showDropCount
    }

    k = k - showDropCount
  }
}
```

## 😻✔ 5 最长回文子串【medium】

[ref](https://leetcode.cn/problems/longest-palindromic-substring/submissions/)

贪心算法

核心就是尝试以每个字符为中心，往两侧扩散

```js
// 时间复杂度：O(0^2)
// 空间复杂度：O(1)
var longestPalindrome = function(s) {
  let res = ''
  for(let i = 0; i < s.length; i++) {
    let end = findDuplicate(s, i)
    let l, r
    l = i - 1
    if(end === i + 1) {
      // 中心不是重复值
      r = i + 1
    } else {
      // 中心是重复值
      r = end
      // 因为都是重复值，所以直接把所有重复的值都跳过
      i = end - 1
    }
    while(l >= 0 && r < s.length && s[l] === s[r]) {
      l--
      r++
    }
    if(r - l - 1 > res.length) {
      res = s.slice(l + 1, r)
    }
  }
  return res
};


function findDuplicate(s, i) {
  let r = i
  while(s[i] === s[r]) {
    r++
  }
  return r
}
```

## 😻✔ 7 整数反转【medium】

[ref](https://leetcode.cn/problems/reverse-integer/)

```js
var reverse = function(x) {
  if(x === 0) return 0
  let isNegative = x < 0 ? true : false
  x = isNegative ? -x : x
  let result = 0
  while(x > 0) {
    const n = x % 10
    if(result > (2 ** 31 - 1 - n) / 10) return 0
    x = Math.floor(x / 10)
    result = 10 * result + n
  }
  return isNegative? -result : result
};
```

## 🌟😻✔ 9 回文数【easy】

[ref](https://leetcode.cn/problems/palindrome-number/)

对回文数比较好的解决办法是，把从数字中取到的余数全部存进数组中，这样就算是0也可以表示，如果是直接计算成数字则可能出现 00123 这种情况，而前导0会被省略，导致出错。

```js
var isPalindrome = function(x) {
  if(x < 0) return false
  if(x === 0) return true
  let nums = []
  while(x > 0) {
    nums.push(x % 10)
    x = Math.floor(x / 10)
  }
  for(let i=0;i<nums.length / 2;i++) {
    if(nums[i] !== nums[nums.length - 1 - i]) {
      return false
    }
  }
  return true
};
```

## ✔ 13 罗马数字转整数【easy】

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var romanToInt = function(s) {
  const map = {
    'I': 1,
    'V': 5,
    'X': 10,
    'L': 50,
    'C': 100,
    'D': 500,
    'M': 1000,
  }
  let sum = 0
  for(let i = 0; i < s.length; i++) {
    if(
      (s[i] === 'I' && (s[i + 1] === 'V' || s[i + 1] === 'X')) || 
      (s[i] === 'X' && (s[i + 1] === 'L' || s[i + 1] === 'C')) || 
      (s[i] === 'C' && (s[i + 1] === 'D' || s[i + 1] === 'M'))
    ) {
      sum -= map[s[i]]
    } else {
      sum += map[s[i]]
    }
  }
  return sum
};
```

## ✔ 14 最长公共前缀【easy】

[ref](https://leetcode.cn/problems/longest-common-prefix/)

```js
// 时间复杂度：O(n*k) k 公共前缀的长度
// 空间复杂度：O(1) 
var longestCommonPrefix = function(strs) {
  for(let i = 0;i <= strs[0].length; i++) {
    const target = strs[0].slice(0, i)
    for(let j = 1; j < strs.length; j++) {
      if(strs[j].indexOf(target) !== 0) {
        return strs[0].slice(0, i - 1)
      }
    }
  }
  return strs[0]
};
```

## 🌟😻✔ 15 三数之和 【medium】

[ref](https://leetcode.cn/problems/3sum/)

双指针

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(logN) 排序的空间复杂度
var threeSum = function(nums) {
  if(nums.length < 3) return []
  const res = []
  nums.sort((a, b) => a - b)
  const len = nums.length
  for(let i = 0; i < len - 2; i++) {
    if(nums[i] === nums[i - 1]) continue
    let l = i + 1
    let r = len - 1
    while(l < r) {
      if(l > i + 1 && nums[l] === nums[l - 1]) {
        l++
        continue
      }
      if(r < len - 1 && nums[r] === nums[r + 1]) {
        r--
        continue
      }
      const sum = nums[i] + nums[l] + nums[r]
      if(sum === 0) {
        res.push([nums[i], nums[l], nums[r]])
        l++
        r--
      } else if(sum > 0) {
        // 在每一个轮次中 nums[i] 固定不变，且知道 nums[l] <= nums[r]
        // sum > 0 则三个数中最大的数 nums[r] 一定大了， 要往左移
        // sum < 0 则 sum[l] 小了，要变大
        r--
      } else {
        l++
      }
    }
  }
  return res
};
```

## 🌟😻✔ 20 有效的括号【easy】

[ref](https://leetcode.cn/problems/valid-parentheses/)

关键词：栈

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
  const leftValues = '({['
  const map = {
    '(': ')',
    '{': '}',
    '[': ']',
  }
  const stack = []
  for (let i = 0; i < s.length; i++) {
    if (leftValues.includes(s[i])) {
      stack.push(s[i])
    } else {
      const lastValue = stack.pop()
      if (map[lastValue] !== s[i]) return false
    }
  }
  return !stack.length
}
```

## 😻✔ 21 合并两个有序链表【easy】

[ref](https://leetcode.cn/problems/merge-two-sorted-lists/)

链表

```js
// 时间复杂度：O(n) n=list1.length + list2.length
// 空间复杂度：O(1)
var mergeTwoLists = function(list1, list2) {
  const head = new ListNode()
  let th = head
  while(list1 && list2) {
    if(list1.val < list2.val) {
      th.next = list1
      list1 = list1.next
    } else {
      th.next = list2
      list2 = list2.next
    }
    th = th.next
  }
  if(list1) {
    th.next = list1
  }
  if(list2) {
    th.next = list2
  }
  return head.next
};
```

## 😻✔ 22 括号生成【medium】

[ref](https://leetcode.cn/problems/generate-parentheses/)

回溯、递归

```js
var generateParenthesis = function(n) {
  const res = []
  let leftCount = 0
  let rightCount = 0
  function calc(str) {
    if(leftCount < rightCount || leftCount > n || rightCount > n) return
    if(leftCount === n && rightCount === n) {
      res.push(str)
      return
    }
    leftCount++
    calc(str + '(')
    leftCount--
    rightCount++
    calc(str + ')')
    rightCount--
  }
  calc('')
  return res
};
```

## 😻✔ 23 合并K个升序链表【hard】

[ref](https://leetcode.cn/problems/merge-k-sorted-lists/)

链表、堆

```js
// 时间复杂度：O(nlogk)
// 空间复杂度：O(k)
// k 是 list.lenght
// n 是所有链表节点的个数
var mergeKLists = function(lists) {
  const head = new ListNode()
  let th = head
  const h = new MinHeap()
  for(let list of lists) {
    list && h.insert(list)
  }

  while(h.size()) {
    let hPop = h.pop()
    th.next = hPop
    th = th.next
    if(hPop.next) h.insert(hPop.next)
  }

  return head.next
};
class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    let p = this.heap.pop()
    this.shiftDown(0)
    return p
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i].val > this.heap[left].val) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i].val > this.heap[right].val) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex].val > this.heap[i].val) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

或者

```js
// 时间复杂度：O(nlogn)
// 空间复杂度：O(n)
var mergeKLists = function(lists) {
  const head = new ListNode()
  let th = head
  const h = new MinHeap() // 小顶堆
  for(let list of lists) {
    while(list) {
      h.insert(list.val)
      list = list.next
    }
  }

  while(h.size()) {
    th.next = new ListNode(h.pop())
    th = th.next
  }

  return head.next
};
class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    this.heap.pop()
    this.shiftDown(0)
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i] > this.heap[left]) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i] > this.heap[right]) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex] > this.heap[i]) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

## 🌟😻✔ 42 接雨水【hard】

[ref](https://leetcode.cn/problems/trapping-rain-water/)

动态规划

双指针版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var trap = function(height) {
  let lMax = 0
  let rMax = 0
  let l = 0
  let r = height.length - 1
  let total = 0
  while(l < r) {
    if(height[l] < height[r]) {
      lMax = Math.max(lMax, height[l])
      total += lMax - height[l]
      l ++
    } else {
      rMax = Math.max(rMax, height[r])
      total += rMax - height[r]
      r--
    }
  }
  return total
};
```

动态规划版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var trap = function(height) {
  const len = height.length
  const leftMax = [0]
  const rightMax = []
  rightMax[len - 1] = [0]
  let total = 0
  for(let i = 1; i < len; i++) {
    leftMax[i] = Math.max(height[i - 1], leftMax[i - 1])
  }
  for(let i = len - 2; i >= 0; i--) {
    rightMax[i] = Math.max(height[i + 1], rightMax[i + 1])
  }
  for(let i = 0; i < len; i++) {
    total += Math.max(Math.min(leftMax[i], rightMax[i]) - height[i], 0)
  }

  return total
};
```

常规思路版

```js
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
var trap = function(height) {
  const len = height.length
  let total = 0
  for(let i = 1; i < len - 1; i++) {
    let l = i - 1
    let r = i + 1
    let lMax = height[i]
    let rMax = height[i]

    while(l >= 0) {
      if(height[l] > lMax) {
        lMax = height[l]
      } 
      l--
    }
    while(r <= len - 1) {
      if(height[r] > rMax) {
        rMax = height[r]
      } 
      r++
    }
    const receive = Math.min(lMax, rMax) - height[i]
    total += receive
  }
  return total
};
```

## 😻✔ 45 跳跃游戏 II【medium】

[ref](https://leetcode.cn/problems/jump-game-ii/)

贪心算法

```js
// 从后往前分析，贪心的找到能到达最后一个数字的最远数字
// 可能会担心到不了这个下标，实际上，如果到不了这个下标，则一定到不了最后一个下标，故这个下标是一定能到的
// 用相同的办法，不断地把下标以每次最远的距离往前靠近，直到到达第一个数字
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var jump = function(nums) {
  let r = nums.length - 1
  let min = 0
  while(r > 0) {
    for(let i = 0; i < r; i++) {
      if(i + nums[i] >= r) {
        r = i
        min++
        break
      }
    }
  }
  return min
};
```

更优版本

不太好理解，可以参照这张图，黑色的蹦跶线代表每次跳的时候能跳的最远距离，红色线从终点反过来推，在每个黑色起跳区间内找一个值，最终推到起跳点位于0。

![](https://qiniu1.lxfriday.xyz/feoffer/1652678598702_5db9138d-58b3-4bbf-81ae-44b6795bacc5.png)

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var jump = function(nums) {
  // 每移动一次下标都计算一次能走到的最远距离
  let maxIndex1 = 0
  // 当走到上一轮能走到的最远下标的时候，更新当前轮次能走的最远下标
  let maxIndex2 = 0
  let count = 0
  for(let i = 0; i < nums.length - 1; i++) {
    maxIndex1 = Math.max(maxIndex1, i + nums[i])
    if(i === maxIndex2) {
      count++
      maxIndex2 = maxIndex1
    }
  }
  return count
};
```

## 😻✔ 46 全排列【medium】

[ref](https://leetcode.cn/problems/permutations/)

排列组合、回溯法、递归

```js
var permute = function(nums) {
  const numsLen = nums.length
  const res = []
  const used = {}
  function dfs(path) {
    if(path.length === numsLen) {
      res.push([...path])
      return
    }
    for(let i = 0; i < numsLen; i++){
      const num = nums[i]
      if(used[i]) continue
      used[i] = true
      dfs([...path, num])
      used[i] = false
    }
  }

  dfs([])
  return res
};
```
or

```js
// 时间复杂度：O(n!)
// 空间复杂度：O(n) 递归的层数
var permute = function(nums) {
  const res = []

  function calc(path) {
    if(path.length === nums.length) {
      res.push(path)
      return
    }
    nums.forEach(n => {
      if(!path.includes(n)) {
        calc([...path, n])
      }
    })
  }
  calc([])
  return res
};
```

or

```js
// 时间复杂度：O(n!)
// 空间复杂度：O(n)
var permute = function(nums) {
  if(nums.length === 1) return [nums]
  const res = []
  for(let i = 0;i < nums.length; i++) {
    permute(nums.slice(0, i).concat(nums.slice(i + 1))).forEach(_ => {
      res.push([nums[i], ..._])
    })
  }
  return res
};
```

## 😻✔ 47 全排列 II【medium】

[ref](https://leetcode.cn/problems/permutations-ii/)

排列组合、回溯法、递归

```js
// 时间复杂度：O(n*n!)
// 空间复杂度：O(n)
var permuteUnique = function(nums) {
  // 把无序数组排成有序的，方便后面相同数字的处理
  nums.sort((a, b) => a - b)
  const numsLen = nums.length
  const res = []
  // 对某个值是否使用过做一个记录
  const used = {}
  function dfs(path) {
    if(path.length === numsLen) {
      res.push([...path])
      return
    }
    for(let i = 0; i < numsLen; i++){
      const num = nums[i]
      // 在相同层级的情况下，如果后续还有很多相同的数字，则都会直接跳过
      // 而这里 num === nums[i - 1] 就是表示相同的数字
      // !used[i - 1] 表示的是相同层级，即数组中装填的数字个数相同就表示是同一层级
      if(used[i] || (i >= 1 && num === nums[i - 1] && !used[i - 1])) continue
      used[i] = true
      path.push(num)
      // 这个地方在 dfs 前后会把 used[i] 的值更改两次
      // 原因是：执行 dfs 前，置为 true，然后进行 dfs 内的递归调用时，该调用栈内都会得到 used[i] 为 true
      dfs(path)
      path.pop()
      used[i] = false
    }
  }

  dfs([])
  return res
};
```

## 🌟😻✔ 53 最大子数组和【easy】

[ref](https://leetcode.cn/problems/maximum-subarray/)

动态规划

数组版

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxSubArray = function(nums) {
 const dp = []
 // dp[i] 定义的是以 i 作为结束的连续子数组的 最大值
 // 则整个数组的最大连续子数组必然会命中 dp 中的一项，且为值最大的那一项
 dp[0] = nums[0]
 for(let i = 1;i<nums.length;i++) {
   if(dp[i - 1] < 0) {
     dp[i] = nums[i]
   } else {
     dp[i] = dp[i - 1] + nums[i]
   }
 }
 return Math.max(...dp)
};
```

精简版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
// 这个解法相比数组解法更难理解
var maxSubArray = function(nums) {
 // 前 i 个数字中连续子数组的最大和
 let max = nums[0]
 // 以 i 为结尾的连续子数组的最大和
 let sum = 0
 for(let i = 0; i < nums.length; i++) {
   if(sum < 0) {
     sum = nums[i]
   } else {
     sum = sum + nums[i]
   }
   max = Math.max(max, sum)
 }
 return max
};
```

## 😻✔ 55 跳跃游戏【medium】

[ref](https://leetcode.cn/problems/jump-game/)

```js
// 从左往右扫描 i 位置往后最多能跳到哪
// maxIndex 用来记录 i 前面最多能跳到哪个下标，每到一个位置都刷新 maxIndex
// 如果出现 maxIndex < i，则说明i前面的位置无法跳到 i
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var canJump = function(nums) {
  let maxIndex = 0
  for(let i = 0; i < nums.length; i++) {
    if(i > maxIndex) return false
    maxIndex = Math.max(i + nums[i], maxIndex)
  }
  return true
};
```

## 😻✔ 65 有效的数字【hard】

[ref](https://leetcode.cn/problems/valid-number/)

```js
var isNumber = function(s) {
  // if(s === 'Infinity' || s === '+Infinity' || s === '-Infinity') return false
  // const num = Number(s)
  // if(isNaN(num)) return false
  // return true
  // 模拟法
  let numLeft = ''
  let numRight = ''
  s = s.trim().toLowerCase()
 if(s.includes('e')) {
    const sSplit = s.split('e')
    if(sSplit.length > 2) { return false }
    [numLeft, numRight] = sSplit
    if(validateNumLeft(numLeft) && validateNumRight(numRight)) return true
  } else {
    numLeft = s
    if(validateNumLeft(numLeft)) return true
  }
  return false
};

function validateNumLeft(numLeft) {
  if('-+'.includes(numLeft[0])) {
    numLeft = numLeft.slice(1)
    if(numLeft.includes('-') || numLeft.includes('+')) return false
  }
  if(!numLeft.length) return false
  let numLeftSplit
  if(numLeft.includes('.')) {
    numLeftSplit = numLeft.split('.')
    if(numLeftSplit.length > 2 ) return false
    if(!numLeftSplit[0].length && isNumStr(numLeftSplit[1])) return true
    if(!numLeftSplit[1].length && isNumStr(numLeftSplit[0])) return true
    if(isNumStr(numLeftSplit[0]) && isNumStr(numLeftSplit[1])) return true
    return false
  } else {
    return isNumStr(numLeft)
  }
}

function validateNumRight(numRight) {
  if(numRight[0] === '-' || numRight[0] === '+') {
    numRight = numRight.slice(1)
  }
  return isNumStr(numRight)
}

function isNumStr(numStr) {
  if(!numStr.length) return false
  for(let c of numStr) {
    if(!(c >= '0' && c <= '9')) return false
  }
  return true
}
```

## 😻✔ 70 爬楼梯【easy】

[ref](https://leetcode.cn/problems/climbing-stairs/)

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var climbStairs = function(n) {
  if(n === 1) return 1
  if(n === 2) return 2
  d1 = 1
  d2 = 2
  for(let i = 3; i <= n; i++) {
    const tmpD2 = d2
    d2 = d1 + d2
    d1 = tmpD2
  }
  return d2
};
```

数组解

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var climbStairs = function(n) {
  const d = []
  d[1] = 1
  d[2] = 2
  for(let i = 3; i <= n; i++) {
    d[i] = d[i - 1] + d[i - 2]
  }
  return d[n]
};
````

## 😻✔ 76 最小覆盖子串【hard】

[ref](https://leetcode.cn/problems/minimum-window-substring/)

双指针、滑动窗口

```js
var minWindow = function(s, t) {
  const need = new Map()
  let needType = 0
  for(let c of t) {
    if(need.has(c)) {
      need.set(c, need.get(c) + 1)
    } else {
      need.set(c, 1)
      needType += 1
    }
  }

  let l = 0
  let minStr = ''
  for(let r = 0;r < s.length; r++) {
    const c = s[r]
    if(need.has(c)) {
      need.set(c, need.get(c) - 1)
      if(need.get(c) === 0) needType -= 1 
    }
    while(needType === 0) {
      if(!minStr.length || s.slice(l, r + 1).length < minStr.length) minStr = s.slice(l, r + 1)
      if(need.has(s[l])) {
        need.set(s[l], need.get(s[l]) + 1)
        if(need.get(s[l]) === 1) {
          needType += 1
        }
      }
      l++
    }
  }
  return minStr
};
```

## 😻✔ 78 子集【medium】

回溯、递归

```js
// 时间复杂度：O(2^N)
// 时间复杂度：O(N)
var subsets = function(nums) {
  const res = []

  function calc(path, start = 0) {
    res.push(path)
    for(let i = start; i < nums.length; i++) {
      calc([...path, nums[i]], i + 1)
    }
  }

  calc([])
  return res
};
```

## ✔ 83 删除排序链表中的重复元素【easy】

[ref](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

链表

```js
var deleteDuplicates = function (head) {
  let t = head
  while (t && t.next) {
    const tNext = t.next
    if (t.val !== tNext.val) {
      t = t.next
    } else {
      t.next = tNext.next
    }
  }
  return head
}
```

## 😻✔ 94 二叉树的中序遍历【easy】

[ref](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

二叉树、中序遍历、DFS、深度优先遍历

```js
var inorderTraversal = function (root) {
  const res = []
  const dfs = node => {
    if (!node) return
    dfs(node.left)
    res.push(node.val)
    dfs(node.right)
  }
  dfs(root)
  return res
}1
```

## 😻✔ 100 相同的树【easy】

[ref](https://leetcode.cn/problems/same-tree/)

二叉树、树

```js
// 时间复杂度：O(n)
// 空间复杂度：O(logn)~O(n)
var isSameTree = function(p, q) {
  if(!p && !q) return true
  if(p && q && p.val === q.val) {
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
  }
  return false
};
```

## 😻✔ 101 对称二叉树【easy】

[ref](https://leetcode.cn/problems/symmetric-tree/)

二叉树

```js
// 时间复杂度：O(n)
// 空间复杂度：O(logn)~O(n)
var isSymmetric = function(root) {
  if(!root) return true
  const isMirror = (l, r) => {
    if(!l && !r) return true
    if(l && r && l.val === r.val) {
      return isMirror(l.left, r.right) && isMirror(l.right, r.left)
    }
    return false
  }
  return isMirror(root.left, root.right)
};
```

## 😻✔ 102 二叉树的层序遍历【medium】

[ref](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

二叉树、BFS、广度优先遍历、层序遍历

```js
var levelOrder = function (root) {
  if (!root) return []
  const q = [[root, 0]]
  const res = []
  while (q.length) {
    const [node, depth] = q.shift()
    res[depth] ? res[depth].push(node.val) : (res[depth] = [node.val])
    node.left && q.push([node.left, depth + 1])
    node.right && q.push([node.right, depth + 1])
  }

  return res
}
```

## 😻✔ 104 二叉树的最大深度【easy】

[ref](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

二叉树、深度优先遍历、DFS

```js
var maxDepth = function (root) {
  let maxLen = 0
  const dfs = (node, l) => {
    if (!node) return
    maxLen = Math.max(maxLen, l)
    dfs(node.left, l + 1)
    dfs(node.right, l + 1)
  }
  dfs(root, 1)
  return maxLen
}
```

## 😻✔ 111 二叉树的最小深度【easy】

[ref](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

二叉树、广度优先遍历、BFS

```js
var minDepth = function (root) {
  if (!root) return 0
  const q = [[root, 1]]
  while (q.length) {
    const [node, depth] = q.shift()
    if (!node.left && !node.right) return depth
    node.left && q.push([node.left, depth + 1])
    node.right && q.push([node.right, depth + 1])
  }
}
```

## 😻✔ 112 路径总和【easy】

[ref](https://leetcode.cn/problems/path-sum/)

二叉树、二叉树的路径总和、DFS、深度优先遍历

```js
var hasPathSum = function (root, targetSum) {
  if (!root) return false
  let has = false
  const dfs = (node, sum) => {
    if (!node.left && !node.right) {
      if (node.val + sum === targetSum) {
        has = true
      }
    }
    node.left && dfs(node.left, node.val + sum)
    node.right && dfs(node.right, node.val + sum)
  }

  dfs(root, 0)
  return has
}
```

## 😻✔ 113 克隆图【medium】

[ref](https://leetcode.cn/problems/clone-graph/)

图、深度优先遍历、广度优先遍历、DFS、BFS

```js
// DFS
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function(node) {
  if(!node) return 
  const visited = new Map()
  function dfs (targetNode) {
    const newNode = new Node(targetNode.val)
    visited.set(targetNode, newNode);
    (targetNode.neighbors || []).forEach(neighborNode => {
      if(!visited.has(neighborNode)) {
        dfs(neighborNode)
      }
      newNode.neighbors.push(visited.get(neighborNode))
    })
  }
  dfs(node)
  return visited.get(node)
};

// BFS
var cloneGraph = function(node) {
  if(!node) return 
  const visited = new Map()
  const q = [node]
  visited.set(node, new Node(node.val));
  while(q.length) {
    const targetNode = q.shift();
    (targetNode.neighbors || []).forEach(neighborNode => {
      if(!visited.has(neighborNode)) {
        q.push(neighborNode)
        visited.set(neighborNode, new Node(neighborNode.val))
      }
      visited.get(targetNode).neighbors.push(visited.get(neighborNode))
    })
  }
  return visited.get(node)
};
```

## 😻✔ 121 买卖股票的最佳时机【easy】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

动态规划

```js
// 抓住一个点：从后往前看，到某一天的时候，能获得的最大利润是：Math.max(至前一天能获得的最大利润, 至当天能获得的最大利润)
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  let maxProfit = 0
  let everMin = prices[0]
  for(let i = 1 ;i < prices.length; i++) {
    everMin = Math.min(everMin, prices[i])
    maxProfit = Math.max(maxProfit, prices[i] - everMin)
  }
  return maxProfit
};
```

数组版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProfit = function(prices) {
  let dp = []
  let everMin = prices[0]
  dp[0] = 0
  for(let i = 1 ;i < prices.length; i++) {
    everMin = Math.min(everMin, prices[i])
    dp[i] = Math.max(dp[i - 1], prices[i] - everMin)
  }
  return dp[prices.length - 1]
};
```

## 😻✔ 122 买卖股票的最佳时机 II【medium】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

动态规划

```js
var maxProfit = function(prices) {
  let maxProfit = 0
  for(let i = 1; i < prices.length; i++) {
    maxProfit = Math.max(maxProfit, maxProfit + prices[i] - prices[i - 1])
  }
  return maxProfit
};
```

数组版本

```js
var maxProfit = function(prices) {
  const dp = []
  dp[0] = 0
  for(let i = 1; i < prices.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 1] + prices[i] - prices[i - 1])
  }
  return dp[prices.length - 1]
};
```

or

```js
// 时间复杂度：O(n)
// 时间复杂度：O(1)
// 赚钱的宗旨：只要后一天比前一天价格高，我就会赚，所以我每天都买，但是我知道第二天会跌
// 会涨：则默认为我昨天就买了，今天的涨幅算进利润里
// 会跌：那我前一天买了又卖了
var maxProfit = function(prices) {
  let maxProfit = 0
  let buyPrice = prices[0]
  for(let i = 1;i < prices.length; i++) {
    if(prices[i] >= buyPrice) {
      maxProfit += prices[i] - buyPrice
    }
    buyPrice = prices[i]
  }
  return maxProfit
};
```



## 😻✔ 123 买卖股票的最佳时机 III【hard】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

动态规划

超高效版本

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  const n = prices.length;
  let buy1 = -prices[0], buy2 = -prices[0];
  let sell1 = 0, sell2 = 0;
  for (let i = 1; i < n; i++) {
      sell2 = Math.max(sell2, buy2 + prices[i]);
      buy2 = Math.max(buy2, sell1 - prices[i]);
      sell1 = Math.max(sell1, buy1 + prices[i]);
      buy1 = Math.max(buy1, -prices[i]);
  }
  return sell2;
};
```

普通版本

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
// ref https://blog.csdn.net/qq_35027690/article/details/118557921
var maxProfit = function(prices) {
  // 最多操作两次时
  // 第i天的收益，总共包含5中情况（i 对应数组下标）
  // 0：没操作，收益为0，可以直接排除，对应 d[i][0] = 0 一直是 0
  // 1：只买了一次，流动资金相比初始状态是负值
  // 2：买了一次，卖了一次，流动资金相比初始状态是正值（只赚不赔）
  // 3：买了一次，卖了一次，又买了一次，流动资金相比初始状态是未知的
  // 4：买了一次，卖了一次，又买了一次，又卖了一次，流动资金相比初始状态是正值（只赚不赔）
  const dp = new Array(prices.length).fill('').map(_ =>[])
  // 把初始值定出来
  dp[0][0] = 0
  dp[0][1] = -prices[0]
  dp[0][2] = 0
  dp[0][3] = -prices[0]
  dp[0][4] = 0
  for(let i = 1; i < prices.length; i++) {
    // 构建状态转移方程
    // --------------------------
    // i 天内只买了一次的最大收益
    // dp[i][1] = max(dp[i - 1][1] , dp[i - 1][0] - prices[i])
    // dp[i - 1][1]： 第i天没操作，顺延到 i - 1 天内只买了一次，没卖
    // dp[i - 1][0] - prices[i]： i - 1 天内没操作，在 i 天买了,  - prices[i]
    // 实际就是：dp[i][1] = max(dp[i - 1][1] , - prices[i])
    dp[i][1] = Math.max(dp[i-1][1], -prices[i])
    // --------------------------
    // i 天内只买了一次又卖了一次的最大收益
    // dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])
    // dp[i-1][2]：第 i 天没操作，顺延到 i - 1 天内进行了买卖各一次
    // dp[i-1][1] + prices[i]：第 i 天卖了，在第 i - 1 天内进行了一次买入操作
    dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i])
    // --------------------------
    // i 天内进行了买一次，卖一次，又买一次的最大收益
    // dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])
    // dp[i-1][3]：第 i 天没有操作，顺延到 i - 1 天内进行买卖买操作后的结果
    // dp[i-1][2] - prices[i]：第 i 天买了，在 i - 1 天内进行了一次买卖操作
    dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i])
    // --------------------------
    // i 天内进行了买一次，卖一次，又买一次，又卖一次的最大收益
    // dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])
    // dp[i-1][4]：第 i 天没操作，顺延到 i - 1 天内进行了买卖各两次
    // dp[i-1][3] + prices[i]：第 i 天卖了一次，并且在 i - 1 天内进行了买卖买操作
    dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i])
    // --------------------------
  }
  return dp[prices.length - 1][4]
};
```

## ✔ 136 只出现一次的数字【easy】

[ref](https://leetcode.cn/problems/single-number/)

```js
// 要求时间空间复杂度是：O(n) O(1)
var singleNumber = function(nums) {
  let res = 0
  for(let i = 0; i < nums.length; i++) {
    res ^= nums[i]
  }
  return res
};
```

## 😻✔ 141 环形链表【easy】

[ref](https://leetcode.cn/problems/linked-list-cycle/)

环形链表，双指针，快慢指针

```js
var hasCycle = function (head) {
  let p1 = head
  let p2 = head
  while (p2 && p2.next) {
    p1 = p1.next
    p2 = p2.next.next
    if (p1 === p2) return true
  }

  return false
}
```

## 😻✔ 146 LRU 缓存【medium】

[ref](https://leetcode.cn/problems/lru-cache/)

```js
var LRUCache = function(capacity) {
  this.capacity = capacity
  this.cache = new Map()
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if(!this.cache.has(key)) {
    return -1
  }
  const value = this.cache.get(key)
  this.moveToEnd(key, value)
  return value
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if(this.cache.has(key)) {
    this.cache.delete(key)
  } else if(this.cache.size === this.capacity) {
    this.cache.delete(this.cache.keys().next().value)
  }
  this.cache.set(key, value)
};

LRUCache.prototype.moveToEnd = function(key, value) {
  this.cache.delete(key)
  this.cache.set(key, value)
};
```

## 😻✔ 188 买卖股票的最佳时机 IV【hard】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

动态规划

```js
// 时间复杂度：O(n*k)
// 空间复杂度：O(n*k)
var maxProfit = function(k, prices) {
  if(prices.length < 1) return 0
  const dp = new Array(prices.length).fill('').map(_ => new Array(2 * k + 1).fill(0))
  for(let j = 1;j <= k; j++) {
    dp[0][2 * j - 1] = -prices[0]
  }
  for(let i = 1; i < prices.length; i++) {
    for(let j = 1;j <= 2 * k; j++) {
      const isOdd = j % 2 === 1
      dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - 1] + (isOdd? - prices[i] : prices[i]))
    }
  }
  return Math.max(...dp[prices.length - 1])
};
```

## 😻✔ 198 打家劫舍【medium】

[ref](https://leetcode.cn/problems/house-robber/)

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var rob = function(nums) {
  if(nums.length === 1) return nums[0]
  if(nums.length === 2) return Math.max(nums[0], nums[1])
  let d0 = nums[0]
  let d1 = Math.max(nums[0], nums[1])
  for(let i = 2;i < nums.length; i++) {
    const t = d1
    d1 = Math.max(d0 + nums[i], d1)
    d0 = t
  }
  return d1
};
```
or
```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var rob = function(nums) {
  const dp = []
  dp[0] = nums[0]
  dp[1] = Math.max(nums[0], nums[1])
  for(let i = 2;i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1])
  }
  return dp[nums.length - 1]
};
```

## 😻✔ 206 反转链表【easy】

[ref](https://leetcode.cn/problems/reverse-linked-list/)

链表

```js
var reverseList = function (head) {
  if (head === null) return head
  let curr = head
  let next = head.next
  curr.next = null
  while (next) {
    const n = next.next
    next.next = curr
    curr = next
    next = n
  }
  return curr
}
```

## 😻✔ 215 数组中的第K个最大元素【medium】

[ref](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

堆、小顶堆、第K大

```js
 // 时间复杂度：O(nlogk)
 // 空间复杂度：O(k)
var findKthLargest = function(nums, k) {
  const heap = new MinHeap()

  nums.forEach(n => {
      heap.insert(n)
    if(heap.size() > k) {
      heap.pop()
    }
  })
  return heap.peek()
};

class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    this.heap.pop()
    this.shiftDown(0)
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i] > this.heap[left]) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i] > this.heap[right]) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex] > this.heap[i]) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

## ✔ 217 存在重复元素【easy】

[ref](https://leetcode.cn/problems/contains-duplicate/)

```js
var containsDuplicate = function(nums) {
  return [...new Set(nums)].length !== nums.length
};
```

## 😻✔ 226 翻转二叉树【easy】

[ref](https://leetcode.cn/problems/invert-binary-tree/)

翻转二叉树实际就是把每个节点的子树全部翻转一次

二叉树、二叉树翻转、翻转二叉树、堆

```js
// 时间复杂度：O(n) 每个节点都访问到了
// 空间复杂度：O(h) h 是树的高度，h 最坏的情况是 n
var invertTree = function(root) {
  if(!root) return root
  return {
    val: root.val,
    left: invertTree(root.right),
    right: invertTree(root.left),
  }
};
``` 

解法2

```js
var invertTree = function(root) {
  if(!root) return root
  const head = new TreeNode(root.val)

  const dfs = (node, parent, isLeft) => {
    if(!node) return
    if(isLeft) {
      parent.right = new TreeNode(node.val)
      dfs(node.left, parent.right, true)
      dfs(node.right, parent.right, false)
    } else {
      parent.left = new TreeNode(node.val)
      dfs(node.left, parent.left, true)
      dfs(node.right, parent.left, false)
    }
  }

  dfs(root.left, head, true)
  dfs(root.right, head, false)

  return head
};
```

## 😻✔ 309 最佳买卖股票时机含冷冻期【medium】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

高效版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  const len = prices.length
  // 确定初始值
  let profitWithShare = -prices[0]
  let profitWithCooldown = 0
  let profitWithoutCooldown = 0

  for(let i = 1; i < len; i++) {
    const profitWithShareBefore = profitWithShare
    const profitWithCooldownBefore = profitWithCooldown
    const profitWithoutCooldownBefore = profitWithoutCooldown
    profitWithShare = Math.max(profitWithShareBefore, profitWithoutCooldownBefore - prices[i])
    profitWithCooldown = profitWithShareBefore + prices[i]
    profitWithoutCooldown = Math.max(profitWithoutCooldownBefore, profitWithCooldownBefore)
  }

  return Math.max(profitWithCooldown, profitWithoutCooldown)
};
```

数组版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProfit = function(prices) {
  // -------------------------------------
  // i 天结束之后会存在三种状态（注意，是 i 天结束）：
  // 0. 持有股票
  // 1. 不持有股票，且处于冷冻期
  // 2. 不持有股票，且不处于冷冻期
  // -------------------------------------
  // 三种状态的转移方程
  // -------------------------------------
  // 0. 持有股票：
  // i - 1 天结束的时候就持有股票
  // 或者 i 天买了股票（i - 1 天的时候不处于冷冻期）
  // dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2] - prices[i])
  // -------------------------------------
  // 1. 不持有股票，且处于冷冻期
  // i 天卖出了股票, i - 1 结束的时候持有股票
  // dp[i][1] = dp[i-1][0] + prices[i]
  // -------------------------------------
  // 2. 不持有股票，且不处于冷冻期
  // i - 1 天结束的时候就是不持有股票且不处于冷冻期
  // i - 1 天结束的时候处于冷冻期
  // dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1])
  // -------------------------------------
  // 综合下来 i 天结束之后，能获得的最大收益
  // Math.max(dp[i][0], d[i][1], dp[i][2])
  // 要注意一点，i 天结束之后，如果还持有股票，这肯定比 i 天结束之后不持有股票的收益低
  // 则最终结果 Math.max(d[i][1], dp[i][2])

  const len = prices.length
  // 确定初始值
  const dp = new Array(len).fill(1).map(_ => [])
  dp[0][0] = -prices[0]
  dp[0][1] = 0
  dp[0][2] = 0

  for(let i = 1; i < len; i++) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2] - prices[i])
    dp[i][1] = dp[i-1][0] + prices[i]
    dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1])
  }

  return Math.max(dp[len - 1][1], dp[len - 1][2])
};
```

## 😻✔ 347 前 K 个高频元素【medium】

[ref](https://leetcode.cn/problems/top-k-frequent-elements/)

堆、小顶堆、前K大

```js
// 时间复杂度：O(nlogk)
// 空间复杂度：O(n)
var topKFrequent = function(nums, k) {
  const map = new Map()
  const h = new MinHeap()
  for(let n of nums) {
    map.set(n, map.has(n) ? map.get(n) + 1 : 1)
  }

  map.forEach((frequence, num) => {
    h.insert({num, frequence})
    if(h.size() > k) {
      h.pop()
    }
  })

  return h.heap.map(_ => _.num)
};

class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    let p = this.heap.pop()
    this.shiftDown(0)
    return p
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i].frequence > this.heap[left].frequence) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i].frequence > this.heap[right].frequence) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex].frequence > this.heap[i].frequence) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

还有一个解法，时间复杂度稍微差点

```js
// 时间复杂度：O(nlogn) 快排
// 空间复杂度：O(n)
var topKFrequent = function(nums, k) {
  const map = new Map()
  for(let n of nums) {
    map.set(n, map.has(n) ? map.get(n) + 1 : 1)
  }
  const mapArr = Array.from(map)
  mapArr.sort((a, b) => b[1] - a[1])
  return mapArr.slice(0, k).map(_ => _[0]) 
};
```

## 😻✔ 374 猜数字大小【easy】

[ref](https://leetcode.cn/problems/guess-number-higher-or-lower/)

二分搜索

```js
var guessNumber = function(n) {
  let l = 0
  let r = n
  while(l <= r) {
    const med = Math.floor((l + r) / 2)
    if(guess(med) === -1) {
      r = med - 1
    } else if(guess(med) === 1) {
      l = med + 1
    } else {
      return med
    }
  }
};
```

## 😻✔ 349 两个数组的交集【easy】

[ref](https://leetcode.cn/problems/intersection-of-two-arrays/)

集合

```js
var intersection = function (nums1, nums2) {
  return [...new Set(nums1.filter(v => nums2.includes(v)))]
}
```


## 😻✔ 417 太平洋大西洋水流问题【medium】

[ref](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

深度优先遍历、DFS、图、逆流而上

```js
var pacificAtlantic = function(heights) {
  const m = heights.length
  const n = heights[0].length
  const leftTopFlow = new Array(m).fill(1).map(() => new Array(n).fill(false))
  const rightBottomFlow = new Array(m).fill(1).map(() => new Array(n).fill(false))
  const res = []

  function dfs(i, j, flow) {
    flow[i][j] = true;
    [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]].forEach(([ni, nj]) => {
      if(
        ni >= 0 && ni < m &&
        nj >= 0 && nj < n &&
        !flow[ni][nj] &&
        heights[ni][nj] >= heights[i][j]
      ) {
        dfs(ni, nj, flow)
      }
    })
  }

  for(let i = 0;i < m; i++) {
    dfs(i, 0, leftTopFlow)
    dfs(i, n - 1, rightBottomFlow)
  }
  for(let j = 0;j < n; j++) {
    dfs(0, j, leftTopFlow)
    dfs(m - 1, j, rightBottomFlow)
  }

  for(let i = 0;i < m; i++) {
    for(let j = 0;j < n; j++) {
      if(leftTopFlow[i][j] && rightBottomFlow[i][j]) res.push([i, j])
    }
  }

  return res
};
```

## 😻✔ 455 分发饼干【easy】

[ref](https://leetcode.cn/problems/assign-cookies/)

贪心算法

```js
// 时间复杂度：O(nlogn) 排序时间复杂度
// 时间复杂度：O(logn) 排序空间复杂度
var findContentChildren = function(g, s) {
  g.sort((a, b) => a - b)
  s.sort((a, b) => a - b)

  let i = 0
  s.forEach((n) => {
    if(n >= g[i]) {
      i++
    }
  })
  return i
};
```

## 😻✔ 704 二分查找【easy】

[ref](https://leetcode.cn/problems/binary-search/)

二分查找

```js
// 时间复杂度：O(logn)
// 时间复杂度：O(1)
var search = function(nums, target) {
  let l = 0
  let r = nums.length - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] < target) {
      l = mid + 1
    } else if(nums[mid] > target) {
      r = mid - 1
    } else {
      return mid
    }
  }
  return -1
};
```

## 😻✔ 714 买卖股票的最佳时机含手续费【medium】

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices, fee) {
  let profitWithoutShare = 0
  let profitWithShare = -prices[0]
  for(let i = 1;i < prices.length; i++) {
    const profitWithoutShareBefore = profitWithoutShare
    const profitWithShareBefore = profitWithShare
    profitWithoutShare = Math.max(profitWithoutShareBefore, profitWithShareBefore + prices[i] - fee)
    profitWithShare = Math.max(profitWithShareBefore, profitWithoutShare - prices[i])
  }
  return profitWithoutShare
};
```

数组版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProfit = function(prices, fee) {
  // 0 不持有股票
  // 1 持有股票
  const len = prices.length
  const dp = new Array(len).fill(1).map(_ => [])
  dp[0][0] = 0
  dp[0][1] = -prices[0]
  for(let i = 1;i < prices.length; i++) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)
    dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i])
  }
  return dp[prices.length - 1][0]
};
```


## ✔ 933 最近的请求次数【easy】

[ref](https://leetcode.cn/problems/number-of-recent-calls/)

这个题的描述很容易看不懂，但是实现起来非常简单

关键词：队列

```js
var RecentCounter = function () {
  this.q = []
}
/**
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function (t) {
  this.q.push(t)
  while (t - this.q[0] > 3000) {
    this.q.shift()
  }
  return this.q.length
}
```

## ✔ 1306 跳跃游戏 III【medium】

[ref](https://leetcode.cn/problems/jump-game-iii/)

广度优先遍历

```js
// BFS
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var canReach = function(arr, start) {
  if(arr[start] === 0) return true
  const len = arr.length
  const usedIndexes = []
  const nextIndexes = [start]
  while(nextIndexes.length > 0) {
    const targetIndex = nextIndexes.pop()
    if(arr[targetIndex] === 0) return true
    usedIndexes.push(targetIndex)
    if((targetIndex - arr[targetIndex] >= 0) && !usedIndexes.includes(targetIndex - arr[targetIndex])) {
      nextIndexes.push(targetIndex - arr[targetIndex])
    }
    if((targetIndex + arr[targetIndex] <= len - 1) && !usedIndexes.includes(targetIndex + arr[targetIndex])) {
      nextIndexes.push(targetIndex + arr[targetIndex])
    }
  }
  return false
};
```

深度优先遍历

```js
// DFS
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var canReach = function(arr, start) {
  if(arr[start] === 0) return true
  const usedIndexes = []
  usedIndexes.push(start)

  function jump(index) {
    if(arr[index] === 0) {
      usedIndexes.push(index)
      return true
    }
    if(index < 0 || index >= arr.length || usedIndexes.includes(index)) {
      return false
    }
    usedIndexes.push(index)
    return jump(index - arr[index]) || jump(index + arr[index])
  }

  return jump(start - arr[start]) || jump(start + arr[start])
};

```

## ✔ 剑指 Offer 09. 用两个栈实现队列【easy】

[ref](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```js
var CQueue = function() {
  this.inStack = []
  this.outStack = []
};

/** 
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
  this.inStack.push(value)
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
  // 必须要把 outStack 出干净之后才能再次从 instack 中拿数据
  if(!this.outStack.length) {
    if(this.inStack.length) {
      this.toOut()
      return this.outStack.pop()
    }
    return -1
  }
  return this.outStack.pop()
};

CQueue.prototype.toOut = function() {
  while(this.inStack.length) {
    this.outStack.push(this.inStack.pop())
  }
}
```
