<div class="finished-info-wrapper">
  完成度 <span class="finished-info">500 / 500 -> 100%<span>
</div>

# ✔ 算法知名仓库

- [【微软】宫水三叶](https://github.com/SharingSource/LogicStack-LeetCode)
- [路西法](https://github.com/azl397985856/leetcode)
- [Krahets](https://leetcode.cn/u/jyd/)
- [全栈潇晨](https://xiaochen1024.com/)

# 大佬面试技巧

- [meta川 内推｜字节跳动｜多项岗位｜北京+上海](https://leetcode.cn/circle/discuss/fKBJcm/)

# 随便记录
- [LeetCode平台值得做的题目分类列表与参考难度](https://zhuanlan.zhihu.com/p/453897447)

# 刷题日记

- 20220809(10)
  - ?? [🌟【medium】剑指 Offer 67. 把字符串转换成整数](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/) 字符互转为整数
  - ? [🌟【medium】剑指 Offer 64. 求1+2+…+n](https://leetcode.cn/problems/qiu-12n-lcof/) 求和、非常规求和
  - [🌟【easy】剑指 Offer 27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/) 二叉树、二叉树镜像构造
  - ??? [🌟【medium】剑指 Offer 14- II. 剪绳子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/) 整数拆分、取模
  - ?? [🌟【medium】剑指 Offer 16. 数值的整数次方](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/) 快速幂、规律题
  - ?? [🌟【easy】剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/) 链表、链表公共节点
  - ?? [🌟【easy】剑指 Offer 15. 二进制中1的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/) 二进制、二进制运算
  - ?? [🌟【hard】233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/) 规律、数学规律
  - ?? [🌟【medium】剑指 Offer 44. 数字序列中某一位的数字](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/) 规律、数学规律
  - ?? [🌟【medium】剑指 Offer 20. 表示数值的字符串](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/) 规律、模拟
- 20220808(9)
  - [🌟【medium】剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/) 二叉树、二叉树的最近公共祖先
  - [🌟【easy】剑指 Offer 55 - I. 二叉树的深度](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/) 二叉树、二叉树的深度
  - [🌟【easy】剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/) 二叉搜索树
  - ?? [🌟【easy】剑指 Offer 65. 不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/) 二进制、位运算
  - [🌟【easy】剑指 Offer 55 - II. 平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/) 二叉树、平衡二叉树
  - ? [🌟【medium】剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) 二叉树、二叉树路径和
  - [🌟【medium】437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 二叉树、二叉树中的路径和
  - [【easy】剑指 Offer 57. 和为s的两个数字](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/) 双指针
  - ? [🌟【easy】剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/) 二叉树、对称二叉树
- 20220807(11)
  - [🌟【medium】剑指 Offer 47. 礼物的最大价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/) 动态规划
  - [🌟【medium】剑指 Offer 66. 构建乘积数组](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/) 数组题
  - ?? [🌟【medium】剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) 二分搜索
  - ? [🌟【medium】剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/) 二叉树、BFS
  - [【easy】剑指 Offer 18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/) 链表
  - ?? [🌟【medium】剑指 Offer 59 - II. 队列的最大值](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/) 队列、栈、单调数组、双端队列
  - [🌟【hard】剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) 双端队列、滑动窗口
  - [🌟【hard】剑指 Offer 37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/) 二叉树、二叉树序列化
  - ?? [🌟【medium】剑指 Offer 35. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) 链表
  - [🌟【easy】剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) 二叉搜索树
  - [🌟【easy】剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/) 二叉树、BFS
- 20220806(10)
  - ?? [🌟【medium】剑指 Offer 14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/) 动态规划
  - ?? [🌟【medium】剑指 Offer 60. n个骰子的点数](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/) 动态规划
  - ?? [🌟【medium】剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/) 二进制、与或非、位运算
  - ?? [🌟【medium】剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/) 二进制、位运算、规律题
  - [🌟【medium】剑指 Offer 12. 矩阵中的路径](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/) 回溯法
  - ?? [🌟【medium】剑指 Offer 31. 栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/) 栈
  - [🌟【easy】剑指 Offer 58 - I. 翻转单词顺序](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)
  - [🌟【medium】151. 颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)
  - [🌟【medium】186. 翻转字符串里的单词 II](https://leetcode.cn/problems/reverse-words-in-a-string-ii/)
  - ?? [🌟【medium】189. 轮转数组](https://leetcode.cn/problems/rotate-array/) 规律题
- 20220805(9)
  - ?? [🌟【easy】剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/) 双指针、滑动窗口
  - ?? [🌟【hard】剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/) 规律题
  - ?? [🌟【easy】剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/) 规律题、约瑟夫环、直接背结论
  - ?? [🌟【medium】剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/) 二叉搜索树、后序遍历
  - [🌟【easy】剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/) 哈希表
  - [🌟【medium】剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/) BFS
  - [【easy】剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)
  - ?? [🌟【medium】剑指 Offer 49. 丑数](https://leetcode.cn/problems/chou-shu-lcof/) 动态规划
  - ? [🌟【medium】313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/) 动态规划
- 20220804(7)
  - [🌟【medium】122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/) 动态规划
  - [🌟【hard】123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/) 动态规划
  - ?? [🌟【hard】188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/) 动态规划
  - ?? [🌟【medium】309 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/) 动态规划
  - ? [🌟【easy】剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/) 动态规划
  - ? [🌟【easy】剑指 Offer 61. 扑克牌中的顺子](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/) 规律题
  - [🌟【easy】剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/) 数组题
- 20220803(3)
  - [🌟【hard】剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) 单调队列
  - ?? [🌟【hard】剑指 Offer 19. 正则表达式匹配](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/) 动态规划
  - ?? [🌟【easy】剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/) 二分搜索
- 20220802(4)
  - ?? [🌟【medium】剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) 二叉搜索树、双向链表、链表
  - [🌟【hard】剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) 归并排序
  - ?? [🌟【hard】剑指 Offer 41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/) 优先队列、大顶堆、小顶堆
  - ?? [🌟【hard】剑指 Offer 37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/) 二叉树
- 20220801(7)
  - ?? [🌟【medium】211 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/) 字典树
  - ? [🌟【medium】230 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) 二叉搜索树
  - ? [🌟【easy】557 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/) 双指针、字符串
  - [🌟【easy】235 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/) 二叉树、二叉搜索树
  - [🌟【easy】292 Nim 游戏](https://leetcode.cn/problems/nim-game/) 规律题
  - [🌟【easy】231 2 的幂](https://leetcode.cn/problems/power-of-two/) 规律题
  - ?? [🌟【medium】89 格雷编码](https://leetcode.cn/problems/gray-code/) 规律题
- 20220731(9)
  - ? [🌟【medium】538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/) 二叉树、二叉搜索树、累加树
  - ? [🌟【easy】338 比特位计数](https://leetcode.cn/problems/counting-bits/) 规律、模拟
  - ? [🌟【easy】461 汉明距离](https://leetcode.cn/problems/hamming-distance/) 规律、模拟
  - ? [🌟【easy】112 路径总和](https://leetcode.cn/problems/path-sum/) 二叉树
  - [🌟【medium】113 路径总和 II](https://leetcode.cn/problems/path-sum-ii/) 二叉树
  - ? [🌟【medium】437 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 前缀和
  - ?? [🌟【medium】208 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/) 前缀树、字典树、trie
  - ? [🌟【medium】386 字典序排数](https://leetcode.cn/problems/lexicographical-numbers/) 前缀树、字典树
  - ? [🌟【hard】440 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/) 字典树
- 20220730(7)
  - ?? [🌟【medium】287 寻找重复数](https://leetcode.cn/problems/linked-list-cycle-ii/) 快慢指针、双指针
  - ? [🌟【easy】448 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)
  - ? [🌟【hard】41 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
  - ?? [🌟【hard】312. 戳气球](https://leetcode.cn/problems/burst-balloons/) 开区间动态规划
  - [🌟【easy】617 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)
  - [🌟【medium】438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) 双指针、滑动窗口
  - ? [🌟【medium】114 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) 二叉树、链表
- 20220729(8)
  - ? [🌟【medium】581 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)
  - ? [🌟【hard】407 接雨水 II](https://leetcode.cn/problems/trapping-rain-water-ii/) 优先队列
  - ? [🌟【medium】21 任务调度器](https://leetcode.cn/problems/task-scheduler/) 模拟推断
  - [🌟【easy】20 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 栈
  - [🌟【medium】22 括号生成](https://leetcode.cn/problems/generate-parentheses/) 回溯
  - ? [🌟【hard】32 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/) 动态规划
  - ?? [🌟【hard】301 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/) BFS
  - ?? [🌟【medium】142 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) 链表、快慢指针、双指针
- 20220728(8)
  - [🌟【easy】234 回文链表](https://leetcode.cn/problems/palindrome-linked-list/) 快慢指针、链表
  - ?? [🌟【medium】207 课程表](https://leetcode.cn/problems/palindrome-linked-list/) 图、拓扑排序、BFS
  - ?? [🌟【medium】210 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 图、拓扑排序、BFS
  - ?? [🌟【hard】630 课程表 III](https://leetcode.cn/problems/course-schedule-iii/) 贪心、优先队列、堆
  - ?? [🌟【medium】11 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) 双指针
  - [🌟【hard】42 接雨水](https://leetcode.cn/problems/trapping-rain-water/) 动态规划、双指针、单调栈
  - [🌟【hard】815 公交路线](https://leetcode.cn/problems/bus-routes/) 图、BFS
  - ? [🌟【medium】98 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) 二叉树、二叉搜索树、DFS
- 20220727(5)
  - [🌟【easy】9 回文数](https://leetcode.cn/problems/palindrome-number/)
  - [🌟【medium】5 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
  - ? [🌟【medium】516 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)
  - [🌟【medium】647 回文子串](https://leetcode.cn/problems/palindromic-substrings/)
  - ? [🌟【hard】336 回文对](https://leetcode.cn/problems/palindrome-pairs/)
- 20220726(4)
  - [🌟【medium】406 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)
  - ? [🌟【hard】315 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/) 归并排序
  - ? [🌟【hard】493 翻转对](https://leetcode.cn/problems/reverse-pairs/) 归并排序
  - ? [🌟【hard】327 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/) 归并排序
- 20220725(6)
  - [🌟【medium】256 粉刷房子](https://leetcode.cn/problems/paint-house/)
  - [🌟【hard】265 粉刷房子 II](https://leetcode.cn/problems/paint-house-ii/)
  - [🌟【medium】276 栅栏涂色](https://leetcode.cn/problems/paint-fence/)
  - [🌟【hard】239 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)
  - [🌟【hard】25 K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
  - [🌟【easy】1446 连续字符](https://leetcode.cn/problems/consecutive-characters/)
- 20220724(9)
  - [🌟【medium】560 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)
  - ? [🌟【medium】713 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)
  - ?? [🌟【medium】152 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)
  - [🌟【medium】325 和等于 k 的最长子数组长度](https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/)
  - [🌟【medium】198 打家劫舍](https://leetcode.cn/problems/house-robber/)
  - [🌟【medium】213 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
  - [🌟【medium】337 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)
  - [🌟【medium】238 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)
  - ? [🌟【medium】454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)
- 20220723(10)
  - [🌟【hard】131 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)
  - ? [🌟【hard】132 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)
  - ? [🌟【easy】232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)
  - ? [🌟【easy】225 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)
  - [🌟【easy】1 两数之和](https://leetcode.cn/problems/two-sum/)
  - ? [🌟【medium】15 三数之和](https://leetcode.cn/problems/3sum/)
  - [🌟【medium】18 四数之和](https://leetcode.cn/problems/4sum/)
  - [🌟【medium】16 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)
  - [🌟【medium】259 较小的三数之和](https://leetcode.cn/problems/3sum-smaller/)
  - [🌟【medium】259 较小的三数之和](https://leetcode.cn/problems/3sum-smaller/)
- 20220722(6)
  - [🌟【medium】33 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
  - [🌟【medium】81 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)
  - [🌟【medium】153 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
  - [🌟【hard】154 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)
  - [🌟【easy】796 旋转字符串](https://leetcode.cn/problems/rotate-string/)
  - [🌟【easy】509 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)
- 20220721(7)
  - ?? [🌟【hard】 879 盈利计划](https://leetcode.cn/problems/profitable-schemes/)
  - [🌟【medium】279 完全平方数](https://leetcode.cn/problems/profitable-schemes/)
  - [🌟【medium】204 计数质数](https://leetcode.cn/problems/count-primes/)
  - ? [🌟【easy】263 丑数](https://leetcode.cn/problems/ugly-number/)
  - ? [🌟【medium】264 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)
  - ? [🌟【medium】313 超级丑数](https://leetcode.cn/problems/super-ugly-number/)
  - [🌟【hard】23 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
- 20220720(3)
  - ?? [🌟【hard】 815 公交路线](https://leetcode.cn/problems/bus-routes/) BFS
  - ?? [🌟【medium】 416 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/) 背包问题
  - ?? [🌟【medium】 698 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)
- 20220719(1)
  - ?? [🌟【hard】 1411 给 N x 3 网格图涂色的方案数](https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/)
- 20220718(2)
  - ?? [🌟【medium】 300 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
  - ?? [🌟【hard】 354 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)
- 20220717(2)
  - ?? [🌟【medium】 424 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)
  - ? [🌟【hard】 295 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)
- 20220716(2)
  - ? [🌟【hard】 862 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)
  - [🌟【hard】 297 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)
- 20220715(4)
  - ? [🌟【medium】 253 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/)
  - [【easy】 252 会议室](https://leetcode.cn/problems/meeting-rooms/)
  - [🌟【medium】 56 合并区间](https://leetcode.cn/problems/merge-intervals/)
  - [🌟【medium】 77 组合](https://leetcode.cn/problems/combinations/)
- 20220714(3)
  - ? [🌟【medium】 386 字典序排数](https://leetcode.cn/problems/lexicographical-numbers/)
  - [🌟【medium】 面试题 02.05 链表求和](https://leetcode.cn/problems/sum-lists-lcci/)
  - [🌟【easy】 剑指 Offer 25 合并两个排序的链表](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)
- 20220713(2)
  - ? [🌟【medium】 162 寻找峰值](https://leetcode.cn/problems/find-peak-element/)
  - [🌟【hard】 面试题 17.21 直方图的水量](https://leetcode.cn/problems/volume-of-histogram-lcci/)
- 20220712(3)
  - ? [🌟【medium】 445 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)
  - ? [🌟【hard】 224 基本计算器](https://leetcode.cn/problems/basic-calculator/)
  - ? [🌟【medium】 227 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)
- 20220711(2)
  - [🌟【easy】 415 字符串相加](https://leetcode.cn/problems/add-strings/)
  - ? [🌟【easy】 160 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
- 20220708(3)
  - ? [🌟【medium】 221 最大正方形](https://leetcode.cn/problems/maximal-square/)
  - [🌟【medium】 113 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)
  - ? [🌟【hard】 329 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)
- 20220703(6)
  - ? [🌟【hard】 315 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)
  - ? [🌟【hard】 剑指 Offer 51 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)
  - ? [🌟【medium】 148 排序链表](https://leetcode.cn/problems/sort-list/)
  - [🌟【easy】 剑指 Offer 50 第一个只出现一次的字符](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)
  - [🌟【medium】 199 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
  - ? [🌟【medium】 103 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)
- 20220702(3)
  - [🌟【medium】 5 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
  - [🌟【medium】 516 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)
  - [🌟【medium】 647 回文子串](https://leetcode.cn/problems/palindromic-substrings/)
- 20220701(1)
  - [【easy】 746 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)
- 20220630(1)
  - [🌟【medium】 240 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)
- 20220629(2)
  - [🌟【medium】 494 目标和](https://leetcode.cn/problems/target-sum/)
  - [【medium】 165 比较版本号](https://leetcode.cn/problems/compare-version-numbers/)
- 20220628(1)
  - [🌟【easy】 268 丢失的数字](https://leetcode.cn/problems/missing-number/)
- 20220627(1)
  - ? [🌟【medium】 79 单词搜索](https://leetcode.cn/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/)
- 20220624(1)
  - ? [🌟【medium】 380 O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)
- 20220623(4)
  - 🌟【medium】[213 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
  - ? [🌟【medium】 337 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)
  - [🌟【medium】 剑指 Offer 40 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)
  - [【medium】 695 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)
- 20220620(1)
  - 🌟【medium】[763 划分字母区间](https://leetcode.cn/problems/partition-labels/)
- 20220616(2)
  - ? [🌟【hard】 51 N 皇后](https://leetcode.cn/problems/n-queens/)
  - ? [🌟【hard】 37 解数独](https://leetcode.cn/problems/sudoku-solver/)
- 20220611(1)
  - ? [🌟【medium】 1143 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)
- 20220610(5)
  - ? [🌟【hard】 85 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)
  - ? [🌟【medium】 剑指 Offer 45 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)
  - ? [🌟【medium】 739 每日温度](https://leetcode.cn/problems/daily-temperatures/)
  - ? [🌟【hard】 440 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)
  - [【medium】 62 不同路径](https://leetcode.cn/problems/unique-paths/)
- 20220609(5)
  - [【medium】 343 整数拆分](https://leetcode.cn/problems/integer-break/)
  - ? [🌟【hard】 84 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 
  - ? [🌟【medium】 179 最大数](https://leetcode.cn/problems/largest-number/)
  - ? [🌟【medium】 189 轮转数组](https://leetcode.cn/problems/rotate-array/)
  - [🌟【easy】 202. 快乐数](https://leetcode.cn/problems/happy-number/)
- 20220608(2)
  - [🌟【medium】 82 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)
  - [🌟【hard】 41 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
- 20220607(8)
  - [🌟【hard】 154 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)
  - ? [🌟【medium】 剑指 Offer 29 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)
  - [🌟【easy】 977 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)
  - [🌟【medium】 652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)
  - ? [🌟【01背包】【medium】 322 零钱兑换](https://leetcode.cn/problems/coin-change/)
  - [【medium】 102 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
  - [【medium】 102 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
  - ? [🌟【medium】 131 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)
- 20220606(5)
  - ? [🌟【medium】 394 字符串解码](https://leetcode.cn/problems/decode-string/)
  - [🌟【easy】 118 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)
  - [【medium】 17 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
  - [【medium】 167 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)
  - [🌟【medium】 153 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
- 20220605(5)
  - ? [🌟【medium】 540 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/) 二分
  - [【medium】 24 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) 
  - ? [🌟【medium】 209 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) 滑动窗口、双指针、前缀数组
  - ? [🌟【hard】 41 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/) 哈希
  - 【medium】 [139 单词拆分](https://leetcode.cn/problems/word-break/)
- 20220604(2)
  - ? [🌟【medium】 475 供暖器](https://leetcode.cn/problems/heaters/)
  - ? [🌟【medium】【01背包】 416 分割等和子集 ](https://leetcode.cn/problems/partition-equal-subset-sum/)
- 20220602(1)
  - ? [🌟【medium】 279 完全平方数](https://leetcode.cn/problems/perfect-squares/)

# 刷题指南

刷题的时候要按照大概的题目分类来刷，每个方面都要有所了解。

- [基础算法](#😻✔-基础算法)
- 栈
- 队列
- 链表
- 集合
- 字典
- 树
- 堆
- 图
- 搜索、排序
- 分治法
- 动态规划
- 贪心算法
- 回溯算法
- 模拟
- trie、字典树

## 二进制相关
- 🌟【medium】[剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/) 二进制、与或非、位运算
- 🌟【medium】[剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/) 二进制、位运算、规律题
- 🌟【easy】[剑指 Offer 65. 不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/) 二进制、位运算、规律题
- 🌟【easy】[剑指 Offer 15. 二进制中1的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/) 二进制、二进制运算

## 数字大小题

- 🌟【medium】[179 最大数](https://leetcode.cn/problems/largest-number/)
- 🌟【medium】[剑指 Offer 45 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

## 前缀和
- 🌟【medium】[437 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 前缀和

## trie、字典树

初识字典树

- [【图解算法】模板+变式——带你彻底搞懂字典树(Trie树)](https://blog.csdn.net/m0_46202073/article/details/107253959)

---

- 🌟【medium】[386 字典序排数](https://leetcode.cn/problems/lexicographical-numbers/)
- 🌟【hard】[440 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)
- 🌟【medium】[208 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/) 前缀树、字典树、trie
- 🌟【medium】[211 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/) 字典树

## 字符串题

- 🌟【medium】[8 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)
- 🌟【medium】[394 字符串解码](https://leetcode.cn/problems/decode-string/)
- 🌟【medium】[763 划分字母区间](https://leetcode.cn/problems/partition-labels/)
- 🌟【easy】[415 字符串相加](https://leetcode.cn/problems/add-strings/)
- 🌟【hard】[224 基本计算器](https://leetcode.cn/problems/basic-calculator/)
- 🌟【medium】[227 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)
- 🌟【hard】[301 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/) BFS
- 🌟【easy】[20 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 栈
- 🌟【medium】[22 括号生成](https://leetcode.cn/problems/generate-parentheses/) 回溯
- 🌟【hard】[32 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/) 动态规划
- 🌟【easy】[557 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/) 双指针、字符串
- 🌟【medium】[剑指 Offer 67. 把字符串转换成整数](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/) 字符互转为整数

回文串相关

- 🌟【medium】[5 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
- 🌟【easy】[9 回文数](https://leetcode.cn/problems/palindrome-number/)
- 🌟【medium】[516 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)
- 🌟【medium】[647 回文子串](https://leetcode.cn/problems/palindromic-substrings/)
- 🌟【hard】[336 回文对](https://leetcode.cn/problems/palindrome-pairs/)

## 数组题 

- 🌟【medium】[128 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)
- 🌟【medium】[33 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
- 🌟【medium】[560 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)
- 🌟【medium】[剑指 Offer 04 二维数组中的查找](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)
- 🌟【medium】[48 旋转图像](https://leetcode.cn/problems/rotate-image/)
- 🌟【medium】[209 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
- 🌟【hard】[41 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
- 🌟【medium】[剑指 Offer 29 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)
- 🌟【easy】[977 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/) 
- 🌟【hard】[84 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 
- 🌟【medium】[189 轮转数组](https://leetcode.cn/problems/rotate-array/)
- 🌟【hard】[85 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)
- 🌟【medium】[739 每日温度](https://leetcode.cn/problems/daily-temperatures/)
- 🌟【medium】[240 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)
- 🌟【medium】[221 最大正方形](https://leetcode.cn/problems/maximal-square/)
- 🌟【hard】[329 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)
- 🌟【hard】[862 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)
- 🌟【hard】[315 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)
- 🌟【hard】[493 翻转对](https://leetcode.cn/problems/reverse-pairs/)
- 🌟【hard】[327 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/) 归并排序
- 🌟【easy】[剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)
- 🌟【medium】[剑指 Offer 66. 构建乘积数组](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/) 数组题

## 模拟、规律

- 🌟【medium】[400 第 N 位数字](https://leetcode.cn/problems/nth-digit/)
- 🌟【medium】[21 任务调度器](https://leetcode.cn/problems/task-scheduler/)
- 🌟【hard】 [440 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)
- 🌟【easy】[338 比特位计数](https://leetcode.cn/problems/counting-bits/) 规律、模拟
- 🌟【medium】[21 任务调度器](https://leetcode.cn/problems/task-scheduler/) 模拟推断
- 🌟【easy】[461 汉明距离【easy】](https://leetcode.cn/problems/hamming-distance/) 规律、模拟
- 🌟【hard】[1411 给 N x 3 网格图涂色的方案数](https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/)
- 🌟【easy】[剑指 Offer 61. 扑克牌中的顺子](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/) 规律题
- 🌟【hard】[剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/) 规律题
- 🌟【easy】[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/) 规律题、约瑟夫环、直接背结论
- 🌟【medium】[剑指 Offer 60. n个骰子的点数](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/) 动态规划
- ??? 🌟【medium】[剑指 Offer 14- II. 剪绳子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/) 整数拆分、取模
- 🌟【medium】[剑指 Offer 16. 数值的整数次方](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/) 快速幂、规律题
- 🌟【medium】[剑指 Offer 64. 求1+2+…+n](https://leetcode.cn/problems/qiu-12n-lcof/) 求和、非常规求和
- 🌟【medium】[剑指 Offer 44. 数字序列中某一位的数字](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/) 规律、数学规律
- 🌟【medium】[剑指 Offer 20. 表示数值的字符串](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/) 规律、模拟

## 栈

- 【easy】 [20 有效的括号](https://leetcode.cn/problems/valid-parentheses/)
- 【easy】 [933 最近的请求次数](https://leetcode.cn/problems/number-of-recent-calls/)
- 🌟【easy】[20 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 栈
- 🌟【easy】[232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)
- 🌟【easy】[225 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)
- 🌟【medium】[剑指 Offer 31. 栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/) 栈

### 单调栈

- 🌟【hard】[84 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 
- 🌟【hard】[85 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)
- 🌟【medium】[739 每日温度](https://leetcode.cn/problems/daily-temperatures/)
- 🌟【medium】[剑指 Offer 59 - II. 队列的最大值](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/) 队列、栈、单调数组、双端队列

## 队列

- 🌟【easy】[232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)
- 🌟【easy】[225 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

## 链表

- 【medium】 [2 两数相加](https://leetcode.cn/problems/add-two-numbers/)
- 【easy】 [21 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
- 【hard】 [23 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
- 【easy】 [83 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)
- 【easy】 [141 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
- 【easy】 [206 反转链表](https://leetcode.cn/problems/reverse-linked-list/)
- 🌟【hard】[K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
- 🌟【medium】[143 重排链表](https://leetcode.cn/problems/reorder-list/)
- 【medium】[24 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)
- 🌟【medium】[82 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)
- 🌟【medium】[445 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)
- 🌟【easy】[234 回文链表](https://leetcode.cn/problems/palindrome-linked-list/) 快慢指针、链表
- 【easy】[剑指 Offer 18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/) 链表
- 🌟【medium】[剑指 Offer 35. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) 链表
- 🌟【easy】[剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/) 链表、链表公共节点

## 集合

- 【easy】 [349 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

## 字典、滑动窗口、双指针

- 【easy】 [1 两数之和](https://leetcode.cn/problems/two-sum/)
- 【medium】 [3 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
- 【hard】 [76 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)
- 【medium】 [567 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)
- 🌟【hard】 [440 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)
- 【medium】[167 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)
- 🌟【medium】[713 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)
- 🌟【medium】[11 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) 双指针
- 🌟【medium】[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) 双指针、滑动窗口
- 🌟【easy】[557 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/) 双指针、字符串
- 🌟【easy】[剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/) 双指针、滑动窗口
- 【easy】[剑指 Offer 57. 和为s的两个数字](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/) 双指针

## 树、深度优先、广度优先

- 【easy】 [94 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
- 【easy】 [100 相同的树](https://leetcode.cn/problems/same-tree/)
- 【easy】 [101 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
- 【medium】 [102 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
- 【easy】 [104 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
- 【easy】 [111 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
- 【easy】 [112 路径总和](https://leetcode.cn/problems/path-sum/)
- 【easy】 [226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
- 🌟【easy】 [543 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
- 【medium】 [298 二叉树最长连续序列](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/)
- 【medium】 [236 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
- 【medium】 [剑指 Offer 26 树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)
- 🌟【medium】 [652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)
- 🌟【medium】 [113 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)
- 🌟【medium】[98 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) 二叉树、二叉搜索树、DFS
- 🌟【easy】[617 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)
- 🌟【medium】[114 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) 二叉树、链表
- 🌟【hard】[剑指 Offer 37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/) 二叉树
- 🌟【medium】[剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/) 二叉树、BFS
- 🌟【easy】[剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/) 二叉树、BFS
- 🌟【medium】[剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/) 二叉树、二叉树的最近公共祖先
- 🌟【easy】[剑指 Offer 55 - II. 平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/) 二叉树、平衡二叉树
- 🌟【medium】[剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) 二叉树、二叉树路径和
- 🌟【medium】[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 二叉树、二叉树中的路径和
- 🌟【easy】[剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/) 二叉树、对称二叉树
- 🌟【easy】[剑指 Offer 27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/) 二叉树、二叉树镜像构造

### 二叉搜索树
- 🌟【medium】[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/) 二叉树、二叉搜索树、累加树
- 🌟【medium】[230 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) 二叉搜索树
- [🌟【easy】235 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/) 二叉树、二叉搜索树
- 🌟【medium】[剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) 二叉搜索树、双向链表、链表
- 🌟【medium】 [96 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)
- 🌟【medium】[剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/) 二叉搜索树、后序遍历
- 🌟【easy】[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) 二叉搜索树

## 堆

- 【hard】 [23 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
- 🌟【medium】 [215 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
- 【easy】 [226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
- 【easy】 [347 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)
- 🌟【hard】[630 课程表 III](https://leetcode.cn/problems/course-schedule-iii/) 贪心、优先队列、堆

## 图、深度优先、广度优先

- 【medium】 [133 克隆图](https://leetcode.cn/problems/clone-graph/)
- 【medium】 [417 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)
- 【medium】 [200 岛屿数量](https://leetcode.cn/problems/number-of-islands/)
- 🌟【hard】 [815 公交路线](https://leetcode.cn/problems/bus-routes/)
- 🌟【medium】 [207 课程表](https://leetcode.cn/problems/palindrome-linked-list/) 图、拓扑排序
- 🌟【medium】[210 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 图、拓扑排序

## 搜索、排序

- 【easy】 [374 猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)

## 分治法

特征是：先拆分、再解决、后合并

将一个问题拆分成很多个和原问题相似的小问题，递归解决小问题，再将结果合并以解决原来的问题

- 【easy】[100 相同的树](https://leetcode.cn/problems/same-tree/)
- 【easy】[226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

## 动态规划

特征是：某个结果会依赖前面的结果，或者前面的几个结果之间有关联


- 【easy】 [70 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
- 【easy】[121 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
- 【medium】 [122 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
- 【hard】 [123 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)
- 【hard】 [188 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)
- 【medium】 [714 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
- 【medium】 [198 打家劫舍](https://leetcode.cn/problems/house-robber/)
- 【medium】 [309 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
- 【hard】 [42 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
- 🌟【easy】 [53 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
- 🌟【medium】 [300 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
- 🌟【hard】 [72 编辑距离](https://leetcode.cn/problems/edit-distance/)
- 🌟【hard】 [10 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)
- 🌟【hard】 [32 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)
- 🌟【medium】 [152 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)
- 🌟【medium】 [剑指 Offer 13 机器人的运动范围](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)
- 🌟【01背包】【medium】 [416 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
- 【medium】 [139 单词拆分](https://leetcode.cn/problems/word-break/)
- 【medium】 [剑指 Offer 46 把数字翻译成字符串](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)
- 【medium】 [343 整数拆分](https://leetcode.cn/problems/integer-break/)
- 【medium】 [62 不同路径](https://leetcode.cn/problems/unique-paths/)
- 🌟【medium】 [1143 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)
- 🌟【medium】 [213 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
- 🌟【medium】 [337 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)
- 🌟【hard】[879 盈利计划](https://leetcode.cn/problems/profitable-schemes/)
- 🌟【medium】[313 超级丑数](https://leetcode.cn/problems/super-ugly-number/)
- 🌟【medium】[256 粉刷房子](https://leetcode.cn/problems/paint-house/)
- 🌟【hard】[312. 戳气球](https://leetcode.cn/problems/burst-balloons/) 开区间动态规划
- 🌟【medium】[剑指 Offer 14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/) 动态规划
- 🌟【medium】[剑指 Offer 47. 礼物的最大价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/) 动态规划

### 动态规划 - 背包问题
- 🌟【hard】[879 盈利计划](https://leetcode.cn/problems/profitable-schemes/) 多维费用背包
- 🌟【medium】[322 零钱兑换](https://leetcode.cn/problems/coin-change/) 【01背包】
- 🌟【medium】[416 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/) 背包问题
- 🌟【medium】[698 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)
- 🌟【medium】[279 完全平方数](https://leetcode.cn/problems/perfect-squares/)

## 贪心算法

特征是：期盼通过每个阶段的局部最优选择，从而达到全局的最优，结果并不一定是最优。

- 【medium】 [5 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
- 【easy】 [455 分发饼干](https://leetcode.cn/problems/assign-cookies/)
- 🌟【hard】 [135 分发糖果](https://leetcode.cn/problems/candy/)
- 🌟【hard】[630 课程表 III](https://leetcode.cn/problems/course-schedule-iii/) 贪心、优先队列、堆

## 回溯算法

回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

- 【medium】 [46 全排列](https://leetcode.cn/problems/permutations/)
- 【medium】 [47 全排列 II](https://leetcode.cn/problems/permutations-ii/)
- 【medium】 [78 子集](https://leetcode.cn/problems/subsets/)
- 【medium】 [22 括号生成](https://leetcode.cn/problems/generate-parentheses/)
- 🌟【medium】 [93 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)
- 【medium】 [17 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
- 🌟【hard】 [51 N 皇后](https://leetcode.cn/problems/n-queens/)
- 🌟【hard】 [37 解数独](https://leetcode.cn/problems/sudoku-solver/)
- 🌟【medium】 [79 单词搜索](https://leetcode.cn/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/)
- 🌟【medium】[494 目标和](https://leetcode.cn/problems/target-sum/)

## 二分查找、二分搜索

- 【easy】 [704 二分查找](https://leetcode.cn/problems/binary-search/)
- 🌟【hard】 [4 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)
- 🌟【easy】 [278 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)
- 🌟【medium】[33 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
- 🌟【medium】[34 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
- 🌟【medium】[475 供暖器](https://leetcode.cn/problems/heaters/)
- 🌟【medium】[540 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)
- 🌟【medium】[153 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
- 🌟【hard】[154 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)
- 🌟【medium】[162 寻找峰值](https://leetcode.cn/problems/find-peak-element/)
- 🌟【easy】[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/) 二分搜索
- 🌟【medium】[剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) 二分搜索

## 排序算法的应用

### 归并

逆序对、链表排序

- 🌟【medium】[48 排序链表](https://leetcode.cn/problems/sort-list/)
- 🌟【hard】[315 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)
- 🌟【hard】[剑指 Offer 51 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

### 堆排序

前 K 大、前 K 小、单调队列

- 🌟【medium】[347 前 K 个高频元素【medium】](https://leetcode.cn/problems/top-k-frequent-elements/)

# 时间复杂度和空间复杂度

递归时间复杂度就是看它 每次递归进行了什么操作和递归了多少次

递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度

或者说递归算法的空间复杂度是任一时刻，占用的空间是多少

## 递归算法的时间与空间复杂度分析

- [递归算法的时间与空间复杂度分析！](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md)
- [程序员算法面试中，递归算法的空间复杂度你知道怎么求么？](https://blog.csdn.net/youngyangyang04/article/details/106313759)

# 😻✔ 基础算法 

常见复杂度曲线：

![](https://qiniu1.lxfriday.xyz/feoffer/1652356442444_09edc6aa-6dfe-41aa-bd02-b9f3097b3717.png)

排序算法排序流程图解：

[https://visualgo.net/zh/sorting](https://visualgo.net/zh/sorting)

## 😻✔ 排序算法 

ref

- [丰富图例讲解十大经典排序算法](https://juejin.im/post/5d9033fa5188257f6f1ba46b)
- [排序算法](https://github.com/lxfriday/give-me-job/tree/7c193c8279/algorithm/%E6%8E%92%E5%BA%8F)

![排序算法一览](https://qiniu1.lxfriday.xyz/feoffer/sort.png)

### 😻✔ 冒泡排序 

![](https://qiniu1.lxfriday.xyz/feoffer/bubbleSort.png)

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function bubbleSort(arr) {
  const length = arr.length
  if (length <= 1) return arr
  for (let i = 0; i < length; i++) {
    let changed = false // 没有数据交换则表示已经有序了
    for (let j = 0; j < length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
        changed = true
      }
    }
    if (!changed) break
  }
  return arr
}
```

### 😻✔ 选择排序 

![](https://qiniu1.lxfriday.xyz/feoffer/ec43f415-5224-bd9b-ad33-0ee480cd19e7.png)

![](https://qiniu1.lxfriday.xyz/feoffer/selectionSort.gif)

核心思想：进行 n 轮，每轮找出最小的放在这一轮的初始位置

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function selectionSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  for (let i = 0; i < len; i++) {
    let min = i
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[min]) min = j
    }
    swap(arr, i, min)
  }

  return arr
}
```

### 😻✔ 插入排序 

![](https://qiniu1.lxfriday.xyz/feoffer/6e79c1d5-2896-68bc-ebc0-280ee2881035.png)

![](https://qiniu1.lxfriday.xyz/feoffer/insertionSort.gif)

```javascript
function insertionSort(arr) {
  const len = arr.length
  if (len <= 1) return arr

  for (let i = 1; i < len; i++) {
    const cur = arr[i]
    let j = i - 1
    for (; j >= 0; j--) {
      if (arr[j] > cur) {
        arr[j + 1] = arr[j]
      } else {
        break
      }
    }
    arr[j + 1] = cur
  }

  return arr
}
```

### 😻✔ 快速排序 

![](https://qiniu1.lxfriday.xyz/feoffer/008ba6a2-d847-8894-a3b4-70b09a1b44b8.png)

![](https://qiniu1.lxfriday.xyz/feoffer/quicksort.gif)

复杂度分析：

- [快速排序的时间复杂度](https://www.cnblogs.com/tuyang1129/p/12857821.html#22-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)

快排的最好时间复杂度是O(logn)、最差会退化到 O(n^2)。




单路快排

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function partition(arr, left, right) {
  let pivot = left
  let index = pivot + 1
  for (let i = index; i <= right; i++) {
    if (arr[i] < arr[pivot]) {
      swap(arr, i, index)
      index++
    }
  }
  swap(arr, pivot, index - 1)
  return index - 1
}

function quickSort(arr, l, r) {
  const len = arr.length
  const left = typeof l === 'number' ? l : 0
  const right = typeof r === 'number' ? r : len - 1
  let partitionIndex = 0
  if (left < right) {
    partitionIndex = partition(arr, left, right)
    quickSort(arr, left, partitionIndex - 1)
    quickSort(arr, partitionIndex + 1, right)
  }

  return arr
}
```

更好理解的快排

```js
function partition2(arr) {
  if (arr.length <= 1) return arr
  const target = arr[0]
  const leftArr = []
  const rightArr = []
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < target) {
      leftArr.push(arr[i])
    } else {
      rightArr.push(arr[i])
    }
  }
  return [...partition2(leftArr), target, ...partition2(rightArr)]
}

function quickSort2(arr) {
  return partition2(arr)
}
```

### 😻✔ 归并排序 

![](https://qiniu1.lxfriday.xyz/feoffer/3ccf988e-b992-84f0-a622-dd03c51123c9.png)

![](https://qiniu1.lxfriday.xyz/feoffer/d3de0b1f-7827-e3b9-eeb7-1993e03e0372.png)

![](https://qiniu1.lxfriday.xyz/feoffer/16d7b507ece11c9d.gif)

归并排序（英语：Merge sort，或 mergesort），是创建在归并操作上的一种有效的排序算法，效率为 O(nlogn)。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用 分治法（Divide and Conquer） 的一个非常典型的应用，且各层分治递归可以同时进行。

采用分治法:

1. 分割：递归地把当前序列平均分割成两半。
1. 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。

归并排序时间复杂度分析

- [快速排序和归并排序的时间复杂度分析——通俗易懂](https://www.cnblogs.com/tuyang1129/p/12857821.html)

时间复杂度计算方式：递归层数 * 每层的时间复杂度(logn * n)，每层的时间复杂度都是n，都会把 n 个元素全部遍历一遍，而递归的层数取决于拆分的次数，n个元素需要拆分 logn 次。

空间复杂度计算方式：任一时刻占用的空间，


比较容易理解的版本

```javascript
function merge(arr1, arr2) {
  const res = []
  while (arr1.length && arr2.length) {
    if (arr1[0] < arr2[0]) {
      res.push(arr1.shift())
    } else {
      res.push(arr2.shift())
    }
  }
  while (arr1.length) {
    res.push(arr1.shift())
  }
  while (arr2.length) {
    res.push(arr2.shift())
  }

  return res
}

function mergeSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  const m = Math.floor(len / 2)
  const arr1 = arr.slice(0, m)
  const arr2 = arr.slice(m)
  return merge(mergeSort(arr1), mergeSort(arr2))
}
```

执行效率更高的版本

```js
function mergeSort1(arr, l, r) {
  l = typeof l === 'number' ? l : 0
  r = typeof r === 'number' ? r : arr.length - 1
  if (r === l) return [arr[l]]
  const mid = Math.floor((l + r) / 2)
  return merge1(mergeSort1(arr, l, mid), mergeSort1(arr, mid + 1, r))
}
function merge1(arr1, arr2) {
  const res = []
  const len1 = arr1.length
  const len2 = arr2.length
  let l1 = 0
  let l2 = 0
  while (l1 < len1 && l2 < len2) {
    if (arr1[l1] <= arr2[l2]) {
      res.push(arr1[l1++])
    } else {
      res.push(arr2[l2++])
    }
  }
  while (l1 < len1) {
    res.push(arr1[l1++])
  }
  while (l2 < len2) {
    res.push(arr2[l2++])
  }
  return res
}
```

上面两个的归并排序在排序大数据量时将会有非常大的差距，原因在于前一个易于理解的版本大量使用了数组操作的函数(slice、shift)，而后者并没有这种操作。

```js
// 比较时间
const data = new Array(500000).fill(Math.random() * 1000000)
const data1 = data.slice(0)
console.time('mergeSort1')
mergeSort1(data)
console.timeLog('mergeSort1')
console.time('mergeSort2')
mergeSort2(data1)
console.timeLog('mergeSort2')

// mergeSort1: 44.905s
// mergeSort2: 81.709ms
```

迭代法实现

```js
// 迭代法实现归并排序
// 对 [i, j] 范围内的数字进行排序
// [i, j] 范围内的数字分为两半之后，两个部分都是已经排好序数组
function sort(arr, i, j) {
  const len = arr.length
  let firstL = i
  const firstR = Math.floor((i + j) / 2) // midIndex
  let secondL = firstR + 1
  const secondR = j
  // 需要一个数字暂存排序结果
  const tmp = []
  while (firstL <= firstR && secondL <= secondR && secondL < len) {
    if (arr[firstL] < arr[secondL]) {
      tmp.push(arr[firstL++])
    } else {
      tmp.push(arr[secondL++])
    }
  }
  while (firstL <= firstR) {
    tmp.push(arr[firstL++])
  }
  while (secondL <= secondR && secondL < len) {
    tmp.push(arr[secondL++])
  }
  let k = i
  while (k <= j && k < len) {
    arr[k] = tmp[k - i]
    k++
  }
}

function mergeSort(arr) {
  const len = arr.length
  // 拆分 logn 次
  // 每次拆分之后，总和来看进行的是对 n 个数字排序，空间复杂度是 O(n)，所有的数子都会被放到 tmp 数组中一次
  for (let i = 2; i < 2 * len; i *= 2) {
    // 对拆分的所有子序列进行排序，复杂度是 n
    for (let j = 0; i * j < len; j++) {
      const startIndex = i * j
      const endIndex = startIndex + i - 1
      const midIndex = Math.floor((startIndex + endIndex) / 2)
      // 结尾可能存在小于i个数的情况，这时候要判断要不要排序
      // 如果结尾有k个数，且 k > i / 2，则是需要排序的
      if (midIndex < len - 1) {
        sort(arr, startIndex, endIndex)
      }
    }
  }
  return arr
}
```

### 😻✔ 希尔排序 

![](https://qiniu1.lxfriday.xyz/feoffer/907976b2-e3b0-91fc-0b6d-3ead3ee08c1c.png)

![](https://qiniu1.lxfriday.xyz/feoffer/16d7b4ce200763d6.gif)

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

```javascript
function shellSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  // gap 不断缩小，最后变成 1
  for (let gap = len >> 1; gap > 0; gap >>= 1) {
    // gap 确定之后，从 gap 位置开始向后循环
    for (let i = gap; i < len; i++) {
      const temp = arr[i]
      let j = i - gap
      // i 每轮循环中需要从左往右做插排
      for (; j >= 0 && arr[j] > temp; j -= gap) {
        arr[j + gap] = arr[j]
      }
      arr[j + gap] = temp
    }
  }

  return arr
}
```

### 😻✔ 堆排序(heap-sort) 

![堆排序](https://qiniu1.lxfriday.xyz/feoffer/heapSort2.png)
![堆排序](https://qiniu1.lxfriday.xyz/feoffer/heapSort.gif)

堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。其中每个节点最多存在两个子节点，对以 0 开始的堆数组，有如下规则：

1. 父节点 `i` 的**左**子节点在位置 `2 * i + 1`
1. 父节点 `i` 的**右**子节点在位置 `2 * i + 2`
1. 子节点 `i` 的父节点在位置 `Math.floor((i - 1) / 2)`

大顶堆：所有节点 `i` 的值比其左右子节点都大的堆

小顶堆：所有节点 `i` 的值比其左右子节点都小的堆

堆排序的重要过程（以大顶堆实现从小到大为例）：

1. 构建大顶堆
1. 把 0 和最后一位交换（无序数组的最后一位）
1. 从 0 位重新构建大顶堆
1. 重复步骤 2、3

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
// 构建大顶堆的核心递归算法
function heapifyMax(arr, i, len) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let max = i
  if (left < len && arr[left] > arr[max]) {
    max = left
  }
  if (right < len && arr[right] > arr[max]) {
    max = right
  }
  if (i != max) {
    swap(arr, max, i)
    heapifyMax(arr, max, len)
  }
}
// 构建小顶堆的核心递归算法
function heapifyMin(arr, i, len) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let min = i
  if (left < len && arr[left] < arr[min]) {
    min = left
  }
  if (right < len && arr[right] < arr[min]) {
    min = right
  }
  if (i != min) {
    swap(arr, min, i)
    heapifyMin(arr, min, len)
  }
}

function buildMaxHeap(arr) {
  const len = arr.length
  for (let i = Math.floor(len / 2); i >= 0; i--) {
    heapifyMax(arr, i, len)
  }
}

function buildMinHeap(arr) {
  const len = arr.length
  for (let i = Math.floor(len / 2); i >= 0; i--) {
    heapifyMin(arr, i, len)
  }
}

// asc 为 true 表示从小到大，false 为从大到小
function heapSort(arr, asc = false) {
  if (asc) {
    // 使用大顶堆实现从小到大排序
    buildMaxHeap(arr)
    const len = arr.length
    for (let i = len - 1; i > 0; i--) {
      swap(arr, 0, i)
      heapifyMax(arr, 0, i)
    }
  } else {
    // 使用小顶堆实现从大到小排序
    buildMinHeap(arr)
    const len = arr.length
    for (let i = len - 1; i > 0; i--) {
      swap(arr, 0, i)
      heapifyMin(arr, 0, i)
    }
  }
  return arr
}
```

### 😻✔ 计数排序(counting-sort) 

![计数排序](https://qiniu1.lxfriday.xyz/feoffer/countingSort.png)

**限定为非负数**

计数排序是一种稳定的线性时间排序算法。计数排序使用一个额外的数组 `C` ，其中第 `i` 个元素是待排序数组 `A` 中值等于 `i` 的元素的个数。然后根据数组 `C` 来将 `A` 中的元素排到正确的位置。

当输入的元素是 `n` 个 `0` 到 `k` 之间的整数时，它的运行时间是 `t(n+k)`。**计数排序不是比较排序，排序的速度快于任何比较排序算法。**

由于用来计数的数组 `C` 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

```javascript
function countingSort(arr) {
  const len = arr.length
  if (len < 2) return arr
  const bucket = []
  let sortIndex = 0

  for (let i = 0; i < len; i++) {
    if (bucket[arr[i]]) {
      bucket[arr[i]] += 1
    } else {
      bucket[arr[i]] = 1
    }
  }

  for (let i = 0; i < bucket.length; i++) {
    for (let j = bucket[i]; j > 0; j--) {
      arr[sortIndex++] = i
    }
  }
  return arr
}
```

### 😻✔ 基数排序(radix-sort) 

![基数排序](https://qiniu1.lxfriday.xyz/feoffer/radixSort.png)

**限定为非负数**

基数排序原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。

它是这样实现的：将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

基数排序的方式可以采用 **LSD（Least significant digital）** 或 **MSD（Most significant digital）**，LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。

基数排序的时间复杂度是 `O(k*n)`，其中 `n` 是排序元素个数，`k` 是数字位数。这不是说这个时间复杂度一定优于 `O(nlogn)`，`k` 的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；`k` 决定了进行多少轮处理，而 `n` 是每轮处理的操作数目。

LSD 实现

```javascript
function radixSort(arr) {
  const len = arr.length
  // 得到最大值
  const max = Math.max(...arr)
  let bucket = []
  // 获取最大值的位数
  let digit = `${max}`.length
  let start = 1
  // 待操作的新数组
  let res = arr.slice()

  while (digit > 0) {
    // 每轮向左移动一位
    start *= 10
    for (let i = 0; i < len; i++) {
      const j = res[i] % start
      // 和计数排序类似
      if (!bucket[j]) {
        bucket[j] = []
      }
      // bucket 是一个二维数组
      bucket[j].push(res[i])
    }

    // 拼接前 res 设为空数组
    res = []
    for (let i = 0; i < bucket.length; i++) {
      if (bucket[i] !== undefined) {
        // res 拼接 bucket[i] 数组
        res = res.concat(bucket[i])
      }
    }
    // 结束之后 bucket 重置
    bucket = []
    digit--
  }

  return res
}
```

### 😻✔ 桶排序、箱排序(bucket-sort) 

![桶排序](https://qiniu1.lxfriday.xyz/feoffer/bucketSort.png)

桶排序工作原理是将数组分到有限数量的桶里，每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。

桶排序以下列步骤进行：

1. 设置桶个数 `size`，计算每个桶的存储范围；
1. 遍历数组，把数字放到对应的桶中；
1. 对步骤 2 放新数字的桶数组排序；
1. 数组遍历完之后，把桶中的数字依次取出放到最终的数组中；

```javascript
function swap(arr, i, j) {
  ;[arr[i], arr[j]] = [arr[j], arr[i]]
}

/**
 * @param {array} arr 待排序的数组
 * @param {number} size 桶的个数
 */
function bucketSort(arr, size = 5) {
  const len = arr.length
  // 取到最小值
  const min = Math.min(...arr)
  // 取得最大值
  const max = Math.max(...arr)
  // 每个桶的范围
  const bucketSize = Math.floor((max - min) / size) + 1
  const res = []
  // 总共的桶容器
  const bucket = []

  for (let i = 0; i < len; i++) {
    // arr[i] 分布在桶 j
    const j = Math.floor((arr[i] - min) / bucketSize)

    // 桶不存在则创建
    if (bucket[j] === undefined) {
      bucket[j] = []
    }
    // 将 arr[i] 推入桶中
    bucket[j].push(arr[i])
    let l = bucket[j].length - 1
    while (l > 0) {
      // 对个别桶使用冒泡
      // 若 arr[i] 在桶内不是最小，则向前移动
      bucket[j][l] < bucket[j][l - 1] && swap(bucket[j], l, l - 1)
      l--
    }
  }

  // 把 bucket 二维数组中的数据全部拿出来
  for (let i = 0; i < bucket.length; i++) {
    if (bucket[i] !== undefined) {
      for (let j = 0; j < bucket[i].length; j++) {
        res.push(bucket[i][j])
      }
    }
  }
  return res
}
```

## ✔ 搜索算法

### 😻✔ 二分搜索算法 

二分搜索算法的前提是目标数组已经排好序了。

```js
// 时间复杂度：O(1 * logn)  => O(logn)
// 空间复杂度：O(1* logn) => O(logn)
function binarySearch(arr, target) {
  let l = 0
  let r = arr.length - 1
  while (l <= r) {
    const med = Math.floor((l + r) / 2)
    if (target < arr[med]) {
      r = med - 1
    } else if (target > arr[med]) {
      l = med + 1
    } else {
      return med
    }
  }
  return -1
}
```

复杂度分析：

- [二分法（递归实现）的性能分析](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md#%E4%BA%8C%E5%88%86%E6%B3%95%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90)

二分法的拆分次数是 logn 次

时间复杂度 = 拆分次数 * 每次拆分的时间复杂度，则结果是 logn * 1 = O(logn)

空间复杂度= 递归深度 * 每次递归的空间复杂度，则结果是 logn * 1 = O(logn)

## 😻✔ LRU 缓存算法 

ref

- [https://juejin.im/post/5d77b68951882520d46abd18](https://juejin.im/post/5d77b68951882520d46abd18)

> 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：**先进先出策略** FIFO（First In，First Out）、**最少使用策略** LFU（Least Frequently Used）、**最近最少使用策略** LRU（Least Recently Used）。

最近最少，越是最近使用就越是不会被清除，而最远使用的将会逐渐被推到丢弃端，如果一直不被使用，数据不断存入时将会丢弃它们。

使用 ES6 Map 实现

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity
    this.cache = new Map()
  }
  put(k, v) {
    if (this.cache.has(k)) this.cache.delete(k)
    else if (this.cache.size >= this.capacity)
      this.cache.delete(this.cache.keys().next().value)
    this.cache.set(k, v)
  }
  get(k) {
    const v = this.cache.get(k)
    if (v === undefined) return -1
    else this.moveToEnd(k, v)
    return v
  }
  moveToEnd(k, v) {
    this.cache.delete(k)
    this.cache.set(k, v)
  }
}
```

双向链表实现

```javascript
class LinkedListNode {
  constructor(k, v, prev, next) {
    this.key = k
    this.value = v
    // 前向节点
    this.prev = prev
    // 后向节点
    this.next = next
  }
}

class LRUCache {
  constructor(capacity) {
    // 容量
    this.capacity = capacity
    this.cache = {}
    // 实际存储的容量
    this.size = 0
    // 哨兵头结点
    this.head = new LinkedListNode()
    // 哨兵尾结点
    this.tail = new LinkedListNode()

    this.head.next = this.tail
    this.tail.prev = this.head
  }

  // 删除节点
  removeNode(node) {
    const prev = node.prev
    const next = node.next

    prev.next = next
    next.prev = prev
  }

  // 新增一个节点
  addNode(node) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
  }
  // 删除尾结点
  popTail() {
    const res = this.tail.prev
    this.removeNode(res)
    return res
  }

  put(k, v) {
    const node = this.cache[k]
    if (!node) {
      const n = new LinkedListNode(k, v)
      this.cache[k] = n
      this.addNode(n)
      if (this.size >= this.capacity) {
        const deleteNode = this.popTail()
        delete this.cache[deleteNode.key]
      } else {
        this.size += 1
      }
    } else {
      this.removeNode(node)
      node.value = v
      this.addNode(node)
    }
  }

  get(k) {
    const node = this.cache[k]
    if (!node) return -1
    else {
      this.removeNode(node)
      this.addNode(node)
      return node.value
    }
  }
}
```

## 😻✔ 斐波拉契数列 

```
1 1 2 3 5 8 13 21 34 55 89
```

**尾递归**

现在浏览器和 NodeJS 已经禁用了尾递归优化，所以仅仅是尾递归，并不会起到优化的作用。

```javascript
// 时间复杂度：O(n)
// 空间复杂度：O(n)
function Fibonacci(n, prev1 = 1, prev2 = 0) {
  if (n === 1) return prev1
  return Fibonacci(n - 1, prev1 + prev2, prev1)
}
```

**迭代**

```javascript
// 时间复杂度：O(n)
// 空间复杂度：O(1)
function Fibonacci(n) {
  const init = [1, 0]
  for (let i = 1; i < n; i++) {
    ;[init[0], init[1]] = [init[0] + init[1], init[0]]
  }
  return init[0]
}
```

递归版本，极其低效，其实际进行了大量的重复计算

```js
// 时间复杂度：O(2 ^ n)
// 空间复杂度：O(n)
function Fibonacci(n) {
  if(n === 1) return 1
  if(n <= 0) return 0
  return Fibonacci(n - 1) + Fibonacci(n - 2)
}
```

## ✔ 斐波拉契数列的时间复杂度和空间复杂度

依据实现存在较大的差异。

[ref](https://blog.csdn.net/youngyangyang04/article/details/106313759)
[递归算法的时间与空间复杂度分析！](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md)


## 😻✔ 因式分解 

实现一个 `calc` 方法，可以将输入的数拆解为尽可能多的乘数，所有数相乘等于输入数。

```javascript
calc(2) // [2]
calc(8) // [2, 2, 2]
calc(24) // [2, 2, 2, 3]
calc(30) // [2, 3, 5]
```

```javascript
function calc(n) {
  const res = []
  let prev = n
  let i = 2

  while (i <= prev) {
    if (prev % i === 0) {
      res.push(i)
      prev /= i
      i = 2
    } else if (i < prev) {
      i++
    } else if (i === prev) {
      res.push(i)
    }
  }
  console.log(res)

  return res
}
```

# from - 其他

## ✔ 从数组中找出和为某个值的两数下标

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]。

初始代码：

```javascript
const twoSum = (nums, target) => {}
```

---

解法 1 - `Map`：

```javascript
const twoSum = (nums, target) => {
  const map = new Map()
  for (let i = 0, len = nums.length; i < len; i++) {
    if (map.get(nums[i])) {
      return [map.get(nums[i]), i]
    }
    map.set(target - nums[i], i)
  }
}
```

解法 2 - 两次循环：

```javascript
const twoSum = (nums, target) => {
  for (let i = 0, len = nums.length; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      if (nums[i] + nums[j] === target) return [i, j]
    }
  }
}
```

# leetcode 刷题记录

## 😻✔ 1 两数之和【easy】

[ref](https://leetcode.cn/problems/two-sum/)

Map、字典

```js
var twoSum = function (nums, target) {
  // for (var i = 0; i < nums.length; i++) {
  //   for (var j = i + 1; j < nums.length; j++) {
  //     if (nums[i] + nums[j] === target) return [i, j]
  //   }
  // }
  const m = new Map()
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i]
    const other = target - num
    if (m.has(other)) {
      return [m.get(other), i]
    } else {
      m.set(num, i)
    }
  }
}
```

## 😻✔ 2 两数相加【medium】

[ref](https://leetcode.cn/problems/add-two-numbers/)

链表

```js
var addTwoNumbers = function (l1, l2) {
  const head = new ListNode()
  let curr = head
  let add = 0
  let sum = 0
  while (l1 || l2) {
    sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + add
    add = Math.floor(sum / 10)
    curr.next = new ListNode(sum - 10 * add)
    l1 = l1 && l1.next
    l2 = l2 && l2.next
    curr = curr.next
  }
  if (add > 0) {
    curr.next = new ListNode(1)
  }

  return head.next
}

function ListNode(val, next) {
  this.val = val === undefined ? 0 : val
  this.next = next === undefined ? null : next
}
```

## 😻✔ 3 无重复字符的最长子串【medium】

[ref](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

滑动窗口、字典

```js
var lengthOfLongestSubstring = function(s) {
  let max = 0
  const set = new Set()
  let i=0
  for(let j=0;j<s.length;j++) {
    while(set.has(s[j])) {
      set.delete(s[i])
      i++
    }
    set.add(s[j])
    max = Math.max(max, set.size)
  }
  return max
};
```

```js
var lengthOfLongestSubstring = function (s) {
  let maxLen = 0
  let currStr = ''
  for (let i = 0; i < s.length; i++) {
    const indInCurrStr = currStr.indexOf(s[i])
    let len
    if (indInCurrStr === -1) {
      currStr += s[i]
      len = currStr.length
    } else {
      len = currStr.length
      currStr = currStr.slice(indInCurrStr + 1) + s[i]
    }
    maxLen = len > maxLen ? len : maxLen
  }
  return maxLen
}
```

or

```js
var lengthOfLongestSubstring = function (s) {
  let l = 0
  let max = 0
  const m = new Map()
  for (let r = 0; r < s.length; r++) {
    if (m.has(s[r]) && m.get(s[r]) >= l) {
      l = m.get(s[r]) + 1
    }
    m.set(s[r], r)
    max = Math.max(max, r - l + 1)
  }
  return max
}
```

## 🌟😻✔ 4 寻找两个正序数组的中位数【hard】

[ref](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

二分查找

```js

// 时间复杂度：O(log(m + n))
// 空间复杂度：O(1)
var findMedianSortedArrays = function(nums1, nums2) {
  // 利用中位数的特殊属性
  const m = nums1.length
  const n = nums2.length
  const totalLength = m + n
  if(totalLength % 2 === 1) {
    // 中位数就在数组中
    const mid = (totalLength - 1) / 2
    return getTarget(mid + 1, nums1, nums2)
  } else {
    // 中位数是最中间两个数的均值
    const mid = totalLength / 2
    return (getTarget(mid, nums1, nums2) + getTarget(mid + 1, nums1, nums2)) / 2
  }
};

// 转化为获取 nums1 和 nums2 数组中的第 k 大的数
// 两个数组是排好序的数组
function getTarget(k, nums1, nums2) {
  // 对于两个数组中下标为 k / 2 - 1(即第 k / 2 个) 的数字A(k / 2 - 1)和 B(k / 2 - 1)
  // ----------------------------------------------------------------------
  // 如果 A(k / 2 - 1) < B(k / 2 - 1) ，则有这样一个规则存在
  // 在 A、B 两个数组的前 k / 2 个数字中（即 A+B 的前K个数字中），A(k / 2 - 1)最多只能是第 k - 1 个数字，不可能是第 K 个数字
  // 由于 A(k / 2 - 1)  前面的数字比它还小，则其前面的数字只能排在A + B 数组的 k - 1 之前，则可以断定，第 K 个数字肯定不在 A[0]~A[k / 2 - 1] 内
  // 就可以把 A 中下标在 k / 2 之前的全部排除
  // 排除之后，新的 newK = k - (k / 2)
  // ----------------------------------------------------------------------
  // 如果 A(k / 2 - 1) > B(k / 2 - 1) 则对 B 进行上面的操作
  // ----------------------------------------------------------------------
  // 如果 A(k / 2 - 1) === B(k / 2 - 1) ，则 A 中 k / 2 - 1 前面的数字和 B 中 k / 2 - 1 前面的数字合并起来，也最多只能排在 k - 2 位
  // 则实际上 A(k / 2 - 1) 和 B(k / 2 - 1) 前面的数字都可以【排除掉】
  // 因为 A(k / 2 - 1) 和 B(k / 2 - 1) 是相等的，则 A(k / 2 - 1) 这一项也可以排除掉，极端情况下，刚好 B(k / 2 - 1) 就是想要的值
  // 综合之后就是，两者相等的时候，选择同 A(k / 2 - 1) < B(k / 2 - 1) 一样的操作，把 A 中前 k / 2 个数字全部排除掉
  // ----------------------------------------------------------------------
  // 由于 k 表示的是在 剩下的 nums1 和 nums2 合并后的有序数组中，第 k 个数字
  // 则当 k = 1 的时候 ，直接比较剩下的 nums1 和 nums2 两数组中靠在最前面且未被排除的下标，即可得出结果。
  // ----------------------------------------------------------------------
  // 这里 k 可能是奇数也可能是偶数，是偶数就完全符合上面的推断，是奇数的时候， k / 2 向下取整
  // 这样 Math.floor(k / 2) * 2 < k，所以从两个数组上取的数之和小于 k
  // 当 A(Math.floor(k / 2) - 1) < B(Math.floor(k / 2) - 1) 成立的时候，A(Math.floor(k / 2) - 1) 最多只能排在第 Math.floor(k / 2) * 2 - 1 的位置上
  // Math.floor(k / 2) * 2 - 1 < k - 1，故 A(Math.floor(k / 2) - 1) 对应的数字及其前面的数字都能排除掉，这和 k 是偶数的时候完全一样
  // 当 A(Math.floor(k / 2) - 1) === B(Math.floor(k / 2) - 1) 成立的时候
  // A(Math.floor(k / 2) - 1) 最多排在第 Math.floor(k / 2) * 2 的位置，而 Math.floor(k / 2) * 2 < k，故结果 k 是偶数的时候也是一致的
  // ----------------------------------------------------------------------
  // 上述思路对应的是两个数组中存在数字大于中位数，则一直执行上述操作直到获取到第k个数数字的时候，两个数组中都还有数字
  // 还有另外一种情况，某个数组中的数字全部排在中位数前面
  // 则肯定会出现一个数组中的所有数字全部是不需要的数字
  // 当上述操作执行到某个数组的下标超过边界的时候，只需要在另一个数组中找到第 k（去掉被排除的数字） 个数字即是结果

  let nums1Target
  let nums2Target
  let halfK
  let showDropCount
  let ind1 = 0
  let ind2 = 0

  while(true) {
    if(ind1 >= nums1.length) {
      return nums2[ind2 + k - 1]
    }
    if(ind2 >= nums2.length) {
      return nums1[ind1 + k - 1]
    }
    if(k === 1) {
      return Math.min(nums1[ind1], nums2[ind2])
    }
    halfK = Math.floor(k / 2)
    // showDropCount 表示应该丢弃的数字个数，由于可能存在下标越界的问题，当下标越界出现的时候
    // 默认使用数组的最后一个数字来做比较，而这个时候要排除的数字个数就可能不是 halfK 个了
    showDropCount = halfK
    // 超出了数组长度，则使用最后一个，也就是数组中最大的一个数
    if(ind1 + halfK - 1 >= nums1.length) {
      nums1Target = nums1[nums1.length - 1]
      showDropCount = nums1.length  - ind1
    } else {
      nums1Target = nums1[ind1 + halfK - 1]
    }
    if(ind2 + halfK - 1 >= nums2.length) {
      nums2Target = nums2[nums2.length - 1]
      showDropCount = nums2.length - ind2
    } else {
      nums2Target = nums2[ind2 + halfK - 1]
    }

    if(nums1Target <= nums2Target) {
      ind1 = ind1 + showDropCount
    } else {
      ind2 = ind2 + showDropCount
    }

    k = k - showDropCount
  }
}
```

## 😻✔ 5 最长回文子串【medium】

[ref](https://leetcode.cn/problems/longest-palindromic-substring/submissions/)

动态规划

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var longestPalindrome = function(s) {
  const len = s.length
  let maxStr = s[0]
  const dp = new Array(len).fill(false).map(_ => new Array(len).fill(false))

  for(let i=0;i<len;i++) {
    dp[i][i] = true
  }

  for(let L=2;L<=len;L++) {
    for(let i=0;i + L - 1 <len;i++) {
      if(s[i] === s[i + L - 1]) {
        dp[i][i + L - 1] = i + L - 2 >= i + 1 ? dp[i + 1][i + L - 2] : true
        if(dp[i][i + L - 1] && L > maxStr.length) {
          maxStr = s.slice(i, i + L)
        }
      }
    }
  }
  return maxStr
};
```

常规中心往两侧扩散

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var longestPalindrome = function(s) {
  let maxStr = ''
  for(let i=0;i<s.length;i++) {
    // 扫描两次
    // 单中心扫描
    let l=r=i
    while(r + 1 < s.length && l - 1 >= 0 && s[r + 1] === s[l - 1]) {
      l--
      r++
    }
    if(maxStr.length < r - l + 1) {
      maxStr = s.slice(l, r + 1)
    }
    // 双中心扫描
    if(i + 1 < s.length && s[i] === s[i + 1]) {
      l = i
      r = i + 1
      while(r + 1 < s.length && l - 1 >= 0 && s[r + 1] === s[l - 1]) {
        l--
        r++
      }
      if(maxStr.length < r - l + 1) {
        maxStr = s.slice(l, r + 1)
      }
    }

  }
  return maxStr
};
```

贪心算法

核心就是尝试以每个字符为中心，往两侧扩散

```js
// 时间复杂度：O(0^2)
// 空间复杂度：O(1)
var longestPalindrome = function(s) {
  let res = ''
  for(let i = 0; i < s.length; i++) {
    let end = findDuplicate(s, i)
    let l, r
    l = i - 1
    if(end === i + 1) {
      // 中心不是重复值
      r = i + 1
    } else {
      // 中心是重复值
      r = end
      // 因为都是重复值，所以直接把所有重复的值都跳过
      i = end - 1
    }
    while(l >= 0 && r < s.length && s[l] === s[r]) {
      l--
      r++
    }
    if(r - l - 1 > res.length) {
      res = s.slice(l + 1, r)
    }
  }
  return res
};


function findDuplicate(s, i) {
  let r = i
  while(s[i] === s[r]) {
    r++
  }
  return r
}
```

## 🌟😻✔ 6 Z 字形变换【medium】

[ref](https://leetcode.cn/problems/zigzag-conversion/)


```js
// 时间复杂度：O(n)
// 空间复杂度：O(k) k=numRows
var convert = function(s, numRows) {
  // 行数为 1 则直接返回 s
  if(numRows === 1) return s
  // 建一个 长度为 numRows 的数组，数组中每个元素为空字符串
  // 一个空字符串对应结果中的一行
  const resArr = new Array(numRows).fill('')
  // 对每个字符，计算出其所处的行
  for(let i = 0; i < s.length; i++) {
    // 2 * numRows - 2 最小的一个排列来回
    const m = i % (2 * numRows - 2)
    if(m <= numRows - 1) {
      // 从上往下
      resArr[m] += s[i]
    } else {
      // 从下往上
      const n = m - (numRows - 1)
      resArr[numRows - 1 - n] += s[i]
    }
  }
  return resArr.join('')
};
```


## 😻✔ 7 整数反转【medium】

[ref](https://leetcode.cn/problems/reverse-integer/)

```js
var reverse = function(x) {
  if(x === 0) return 0
  let isNegative = x < 0 ? true : false
  x = isNegative ? -x : x
  let result = 0
  while(x > 0) {
    const n = x % 10
    if(result > (2 ** 31 - 1 - n) / 10) return 0
    x = Math.floor(x / 10)
    result = 10 * result + n
  }
  return isNegative? -result : result
};
```

## ?? 🌟😻✔ 8 字符串转换整数 (atoi)【medium】

[ref](https://leetcode.cn/problems/string-to-integer-atoi/)

```js
// 时间复杂度：O(N)
// 时间复杂度：O(1)
var myAtoi = function(s) {
  while(s[0] === ' ') {
    s = s.slice(1)
  }
  let isNegative = false
  if(s[0] === '-') {
    isNegative = true
    s = s.slice(1)
  }else if(s[0] === '+') {
    s = s.slice(1)
  }
  let num = 0
  let i = 0
  while(i < s.length && s[i] >= '0' && s[i] <= '9') {
    if(!isNegative && (10 * num + Number(s[i]) > 2 ** 31 - 1)) {
      return 2 ** 31 - 1
    }else if(isNegative && (10 * num + Number(s[i]) > 2 ** 31 )) {
      return - (2 ** 31)
    }
    num = 10 * num + Number(s[i])
    i++
  }
  return !isNegative ? num : -num
};
```


## 🌟😻✔ 9 回文数【easy】

[ref](https://leetcode.cn/problems/palindrome-number/)

对回文数比较好的解决办法是，把从数字中取到的余数全部存进数组中，这样就算是0也可以表示，如果是直接计算成数字则可能出现 00123 这种情况，而前导0会被省略，导致出错。

```js
var isPalindrome = function(x) {
  if(x < 0) return false
  if(x === 0) return true
  let nums = []
  while(x > 0) {
    nums.push(x % 10)
    x = Math.floor(x / 10)
  }
  for(let i=0;i<nums.length / 2;i++) {
    if(nums[i] !== nums[nums.length - 1 - i]) {
      return false
    }
  }
  return true
};
```

## ?🌟😻✔ 10 正则表达式匹配【hard】

[ref](https://leetcode.cn/problems/regular-expression-matching/)

动态规划

```js
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var isMatch = function(s, p) {
  const m = s.length
  const n = p.length
  const dp = new Array(m + 1).fill(false).map(_ => new Array(n + 1).fill(false))
  dp[0][0] = true
  for(let j=2;j<=n;j+=2) {
    if(p[j - 1] === '*') {
      dp[0][j] = dp[0][j - 2]
    }
  }
  for(let i=1;i<=m;i++) {
    for(let j=1;j<=n;j++) {
      if(s[i - 1] === p[j - 1] || p[j - 1] === '.') {
        dp[i][j] = dp[i - 1][j - 1]
      } else if (p[j - 1] === '*') {
        dp[i][j] = dp[i][j-2] || false
        if(p[j - 2] === s[i - 1] || p[j - 2] === '.') {
          dp[i][j] = dp[i][j] || dp[i-1][j]
        }
      }
    }
  }
  return dp[m][n]
};

```

## ??🌟😻✔ 11 盛最多水的容器【medium】

[ref](https://leetcode.cn/problems/container-with-most-water/)

双指针

[我的题解](https://leetcode.cn/problems/container-with-most-water/solution/by-lxfriday-udsc/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxArea = function(height) {
  let l = 0
  let r = height.length - 1
  let max = 0
  while(l < r) {
    max = Math.max(Math.min(height[l], height[r]) * (r - l), max)
    if(height[l] <= height[r]) {
      l++
    } else {
      r--
    }
  }
  return max
}; 
```

## ✔ 13 罗马数字转整数【easy】

[ref](https://leetcode.cn/problems/roman-to-integer/)

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var romanToInt = function(s) {
  const map = {
    'I': 1,
    'V': 5,
    'X': 10,
    'L': 50,
    'C': 100,
    'D': 500,
    'M': 1000,
  }
  let sum = 0
  for(let i = 0; i < s.length; i++) {
    if(
      (s[i] === 'I' && (s[i + 1] === 'V' || s[i + 1] === 'X')) || 
      (s[i] === 'X' && (s[i + 1] === 'L' || s[i + 1] === 'C')) || 
      (s[i] === 'C' && (s[i + 1] === 'D' || s[i + 1] === 'M'))
    ) {
      sum -= map[s[i]]
    } else {
      sum += map[s[i]]
    }
  }
  return sum
};
```

## ✔ 14 最长公共前缀【easy】

[ref](https://leetcode.cn/problems/longest-common-prefix/)

```js
// 时间复杂度：O(n*k) k 公共前缀的长度
// 空间复杂度：O(1) 
var longestCommonPrefix = function(strs) {
  for(let i = 0;i <= strs[0].length; i++) {
    const target = strs[0].slice(0, i)
    for(let j = 1; j < strs.length; j++) {
      if(strs[j].indexOf(target) !== 0) {
        return strs[0].slice(0, i - 1)
      }
    }
  }
  return strs[0]
};
```

## 🌟😻✔ 15 三数之和 【medium】

[ref](https://leetcode.cn/problems/3sum/)

双指针

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(logN) 排序的空间复杂度
var threeSum = function(nums) {
  if(nums.length < 3) return []
  const res = []
  nums.sort((a, b) => a - b)
  const len = nums.length
  for(let i = 0; i < len - 2; i++) {
    if(nums[i] === nums[i - 1]) continue
    let l = i + 1
    let r = len - 1
    while(l < r) {
      if(l > i + 1 && nums[l] === nums[l - 1]) {
        l++
        continue
      }
      if(r < len - 1 && nums[r] === nums[r + 1]) {
        r--
        continue
      }
      const sum = nums[i] + nums[l] + nums[r]
      if(sum === 0) {
        res.push([nums[i], nums[l], nums[r]])
        l++
        r--
      } else if(sum > 0) {
        // 在每一个轮次中 nums[i] 固定不变，且知道 nums[l] <= nums[r]
        // sum > 0 则三个数中最大的数 nums[r] 一定大了， 要往左移
        // sum < 0 则 sum[l] 小了，要变大
        r--
      } else {
        l++
      }
    }
  }
  return res
};
```

## 🌟😻✔ 16 最接近的三数之和【medium】

[ref](https://leetcode.cn/problems/3sum-closest/)

双指针

```js
// 时间复杂度：O(n^2)
// 空间复杂度：O(logn) 排序
var threeSumClosest = function(nums, target) {
  nums.sort((a, b) => a - b)
  let finalSum
  let minGap = Infinity
  const len = nums.length
  for(let i=0;i<len;i++) {
    let l = i + 1
    let r = len - 1
    while(l < r) {
      const sum = nums[i] + nums[l] + nums[r]
      const gap = Math.abs(sum - target)
      if(gap < minGap) {
        finalSum = sum
        minGap = gap
      }
      (sum < target) ? (l++) : (r--)
    }
  }
  return finalSum
};
```

## ✔ 17. 电话号码的字母组合【medium】

[ref](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

回溯、递归、排列组合

```js
// 回溯
// 时间复杂度：O(3^M*4^N)
// 空间复杂度：O(M+N)
var letterCombinations = function(digits) {
  if(!digits.length) return []
  const numMap = {
    2: ['a', 'b', 'c'],
    3: ['d', 'e', 'f'],
    4: ['g', 'h', 'i'],
    5: ['j', 'k', 'l'],
    6: ['m', 'n', 'o'],
    7: ['p', 'q', 'r', 's'],
    8: ['t', 'u', 'v'],
    9: ['w', 'x', 'y', 'z'],
  }
  const words = []
  for(let i=0;i<digits.length;i++) {
    words.push(numMap[digits[i]])
  }
  const len = words.length
  const res = []
  function dfs(path, startIndex) {
    if(path.length === len) {
      res.push(path)
      return
    } else {
      for(let word of words[startIndex]) {
        dfs(path + word, startIndex + 1)
      }
    }
  }
  dfs('', 0)
  return res
};

// [['a', 'b', 'c'], ['g', 'h', 'i'], ]
// [['a', 'b', 'c'], ['g', 'h', 'i'], ['g', 'h', 'i']]
```

## 🌟😻✔ 18 四数之和【medium】

[ref](https://leetcode.cn/problems/4sum/)

```js
// 时间复杂度：O(N^3)
// 空间复杂度：O(logN)
var fourSum = function(nums, target) {
  if(nums.length < 4) return []
  nums.sort((a, b) => a - b)
  const n = nums.length
  const res = []
  for(let i = 0;i<n - 3;i++) {
    if(i - 1 >= 0 && nums[i] === nums[i - 1]) continue
    const a = nums[i]
    const atarget = target - a
    for(let ii = i + 1;ii<n - 2;ii++) {
      if(ii - 1 >= i + 1 && nums[ii] === nums[ii - 1]) continue
      let b = nums[ii]
      let l = ii + 1, r = n - 1
      while(l < r) {
        const s = b + nums[l] + nums[r]
        if(s === atarget) {
          res.push([a, b, nums[l], nums[r]])
          while(nums[l] === nums[l + 1] && l < r) {
            l++
          }
          while(nums[r] === nums[r - 1] && l < r) {
            r--
          }
          l++
          r--
        } else {
          if(s > atarget) {
            r--
          } else {
            l++
          }
        }
      }
    }
  }
  return res
};
```

## 🌟😻✔ 20 有效的括号【easy】

[ref](https://leetcode.cn/problems/valid-parentheses/)

关键词：栈

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
  const leftValues = '({['
  const map = {
    '(': ')',
    '{': '}',
    '[': ']',
  }
  const stack = []
  for (let i = 0; i < s.length; i++) {
    if (leftValues.includes(s[i])) {
      stack.push(s[i])
    } else {
      const lastValue = stack.pop()
      if (map[lastValue] !== s[i]) return false
    }
  }
  return !stack.length
}
```

## 😻✔ 21 合并两个有序链表【easy】

[ref](https://leetcode.cn/problems/merge-two-sorted-lists/)

链表

```js
// 时间复杂度：O(n) n=list1.length + list2.length
// 空间复杂度：O(1)
var mergeTwoLists = function(list1, list2) {
  const head = new ListNode()
  let th = head
  while(list1 && list2) {
    if(list1.val < list2.val) {
      th.next = list1
      list1 = list1.next
    } else {
      th.next = list2
      list2 = list2.next
    }
    th = th.next
  }
  if(list1) {
    th.next = list1
  }
  if(list2) {
    th.next = list2
  }
  return head.next
};
```

## 😻✔ 22 括号生成【medium】

[ref](https://leetcode.cn/problems/generate-parentheses/)

回溯、递归

```js
var generateParenthesis = function(n) {
  const res = []
  let leftCount = 0
  let rightCount = 0
  function calc(str) {
    if(leftCount < rightCount || leftCount > n || rightCount > n) return
    if(leftCount === n && rightCount === n) {
      res.push(str)
      return
    }
    leftCount++
    calc(str + '(')
    leftCount--
    rightCount++
    calc(str + ')')
    rightCount--
  }
  calc('')
  return res
};
```

## ?😻✔ 23 合并K个升序链表【hard】

[ref](https://leetcode.cn/problems/merge-k-sorted-lists/)

链表、堆、分治法、归并

```js
// 时间复杂度：O(kn*logk)
// 空间复杂度：O(logk)
var mergeKLists = function(lists, l, r) {
  l = typeof l === 'number' ? l : 0
  r = typeof r === 'number' ? r: lists.length - 1
  if(l === r) return lists[l]
  if(l > r) return null
  const mid = Math.floor((l + r) / 2)
  return merge(mergeKLists(lists, l, mid), mergeKLists(lists, mid + 1, r))
};

function merge(list1, list2) {
  const head = new ListNode()
  let tHead = head
  while(list1 && list2) {
    if(list1.val < list2.val) {
      tHead.next = list1
      list1 = list1.next
    } else {
      tHead.next = list2
      list2 = list2.next
    }
    tHead = tHead.next
  }
  if(list1) {
    tHead.next = list1
  }
  if(list2) {
    tHead.next = list2
  }
  return head.next
}
```

```js
// 时间复杂度：O(kn*logk)
// 空间复杂度：O(k)
// k 是 list.lenght
// n 是所有链表节点的个数
var mergeKLists = function(lists) {
  const head = new ListNode()
  let th = head
  const h = new MinHeap()
  for(let list of lists) {
    list && h.insert(list)
  }

  while(h.size()) {
    let hPop = h.pop()
    th.next = hPop
    th = th.next
    if(hPop.next) h.insert(hPop.next)
  }

  return head.next
};
class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    let p = this.heap.pop()
    this.shiftDown(0)
    return p
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i].val > this.heap[left].val) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i].val > this.heap[right].val) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex].val > this.heap[i].val) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

常规顺序合并

```js
// 时间复杂度：O(n*k^2)
// 空间复杂度：O(1)
var mergeKLists = function(lists) {
  if(!lists.length) return null
  const len = lists.length
  const head = new ListNode()
  head.next = lists[0]
  for(let i=1;i<len;i++) {
    head.next = merge(head.next, lists[i])
  }
  return head.next
};

function merge(list1, list2) {
  const head = new ListNode()
  let tHead = head
  while(list1 && list2) {
    if(list1.val < list2.val) {
      tHead.next = list1
      list1 = list1.next
    } else {
      tHead.next = list2
      list2 = list2.next
    }
    tHead = tHead.next
  }
  if(list1) {
    tHead.next = list1
  }
  if(list2) {
    tHead.next = list2
  }
  return head.next
}
```

## 😻✔ 24 两两交换链表中的节点【medium】

[ref](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```js
var swapPairs = function(head) {
  let tHead = new ListNode()
  tHead.next = head
  let slow = tHead
  let fast = tHead
  while(fast.next && fast.next.next) {
    const tPrevSlow = slow
    slow = slow.next
    fast = fast.next.next
    const tFastNext = fast.next
    tPrevSlow.next = fast
    fast.next = slow
    slow.next = tFastNext
    fast = slow
  }
  return tHead.next
};
```

## 🌟😻✔ 25 K 个一组翻转链表【hard】

[ref](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

```js
// 比较优秀的版本
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var reverseKGroup = function(head, k) {
  let count = 0
  const myHead = new ListNode()
  myHead.next = head
  let start = myHead
  let end = start

  while(end.next) {
    end = end.next
    count++
    if(count % k === 0) {
      start = reverse(start, end)
      end = start
    }
  }
  return myHead.next
};

// start 的下一个节点才是起点
// 返回反转后的 end 节点
function reverse(start, end) {
  const myHead = new ListNode()
  const reversePrev = start
  const reverseNext = end.next
  start = start.next
  const prevStart = start
  while(myHead.next !== end) {
    const prev = myHead.next
    myHead.next = start
    start = start.next
    myHead.next.next = prev
  }
  reversePrev.next = myHead.next
  prevStart.next = reverseNext
  return prevStart
}
```

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var reverseKGroup = function(head, k) {
  let count = 0
  const myHead = new ListNode()
  let t = myHead
  const gapHead = new ListNode()
  let tGapHead
  while(head) {
    gapHead.next = head
    tGapHead = gapHead // *
    while(tGapHead.next) {
      tGapHead = tGapHead.next
      count++
      head = head.next
      if(count % k === 0) {
        tGapHead.next = null
        while(t.next) t = t.next
        t.next = reverse(gapHead.next) // *
        break // *
      }
    }
    if(count % k !== 0) {
      while(t.next) t = t.next
      t.next = gapHead.next
    }
  }
  return myHead.next
};

function reverse(head) {
  const myHead = new ListNode()
  while(head) {
    const prev = myHead.next
    myHead.next = head
    head = head.next
    myHead.next.next = prev
  }
  return myHead.next
}
```

## ✔ 26 删除有序数组中的重复项【easy】

[ref](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```js
var removeDuplicates = function(nums) {
  if(!nums.length) return 0
  let count = 1
  for(let i = 1; i < nums.length; i++) {
    if(nums[i] !== nums[i - 1]) {
      nums[count] = nums[i]
      count++
    }
  }
  return count 
};
```

## ✔ 27 移除元素【easy】

[ref](https://leetcode.cn/problems/remove-element/)

```js
var removeElement = function(nums, val) {
  const len = nums.length
  let index = 0
  for(let i=0;i<len;i++) {
    if(nums[i] !== val) {
      nums[index++] = nums[i]
    }
  }
  return index
};
```

## ✔ 28 实现 strStr()【easy】

[ref](https://leetcode.cn/problems/implement-strstr/)

```js
// M=haystack.length N=needle.length
// 时间复杂度：O(M*N)
// 空间复杂度：O(1)
var strStr = function(haystack, needle) {
  if(!needle.length) return 0
  for(let i=0;i<haystack.length;i++) {
    if(haystack[i] === needle[0]) {
      let j=1
      for(;j<needle.length;j++) {
        if(i + j >= haystack.length || needle[j] !== haystack[i + j]) break
      }
      if(j === needle.length) return i
    }
  }
  return -1
};
```

## 🌟😻✔ 31 下一个排列【medium】

[ref](https://leetcode.cn/problems/next-permutation/)

```js
var nextPermutation = function(nums) {
  const len = nums.length
  let i = len - 1
  for(;i>0;i--) {
    if(nums[i] > nums[i - 1]) {
      break
    }
  }
  for(let j = len - 1;j >= i ;j--) {
    if(nums[j] > nums[i - 1]) {
      swap(nums, i - 1, j)
      break
    }
  }
  reverse(nums, i, len - 1)
  return nums
};

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}

function reverse(arr, l, r) {
  const mid = Math.floor((l + r) / 2)
  for(let i=l;i<=mid;i++) {
    const t = arr[i]
    arr[i] = arr[r + l - i]
    arr[r + l - i] = t
  }
}
```

## ?🌟😻✔ 32 最长有效括号【hard】

[ref](https://leetcode.cn/problems/longest-valid-parentheses/)

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var longestValidParentheses = function(s) {
  const len = s.length
  const dp = new Array(len).fill(0)
  dp[0] = 0
  for(let i=1;i<len;i++) {
    if(s[i] === ')') {
      if(s[i - 1] === '(') {
        dp[i] = (i - 2 >= 0?dp[i - 2] : 0) + 2
      } else if(i - 1 - dp[i - 1] >=0 && s[i - 1 - dp[i - 1]] === '(') {
        dp[i] = 2 + dp[i - 1] + (i - 2 - dp[i - 1] >=0 ? dp[i - 2 - dp[i - 1]] : 0) 
      }
    }
  }
  return Math.max(...dp)
};
```

## ?🌟😻✔ 33 搜索旋转排序数组【medium】

[ref](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

![](https://qiniu1.lxfriday.xyz/feoffer/1653007574423_685e61d8-c663-4699-8719-3b7d78a01427.png)

```js
// 时间复杂度：O(logn)
// 空间复杂度：O(n)
var search = function(nums, target) {
  const len = nums.length
  if(!len) return -1
  if(len === 1) return target === nums[0] ? 0 : -1
  let l = 0
  let r = len - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(target === nums[mid]) {
      return mid
    }
    if(nums[0] <= nums[mid]) {
      if(nums[0] <= target && target < nums[mid]) {
        r= mid - 1
      } else {
        l = mid + 1
      }
    } else {
      if(nums[mid] < target && target <= nums[r]) {
        l = mid + 1
      } else {
        r = mid - 1
      }
    }
  }
  return  -1
};

```

## ?🌟😻✔ 34 在排序数组中查找元素的第一个和最后一个位置【medium】

[ref](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

二分搜索

```js
// 时间复杂度：O(logn)
// 空复杂度：O(1)
var searchRange = function(nums, target) {
  const leftIndex = binarySearch(nums, target, true)
  const rightIndex = binarySearch(nums, target, false) - 1
  if(
    leftIndex >= 0 &&
    rightIndex < nums.length &&
    nums[leftIndex] === target &&
    nums[rightIndex] === target
  ) {
    return [leftIndex, rightIndex]
  }
  
  return [-1, -1]
};

function binarySearch(nums, target, lower) {
  const len = nums.length
  let l = 0
  let r = len - 1
  let resIndex = len
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(target < nums[mid] || (lower && target <= nums[mid])) {
      r = mid - 1
      resIndex = mid
    } else {
      l = mid + 1
    }
  }
  return resIndex
}
```

## ?🌟😻✔ 37 解数独【hard】

[ref](https://leetcode.cn/problems/sudoku-solver/)

同[#51 N皇后](https://leetcode.cn/problems/n-queens/)问题比较类似

回溯、枚举

```js
// 基本上只要是涉及到枚举的，都可以用下面的这种方式，解法同样适用于 N 皇后问题
// 先扫描矩阵，把矩阵中的数字填充到其对应的行、列、3x3 宫格中，用于后续填充数字时的冲突检测
// 后面用 dfs 枚举每个空格处能填充的数字，且 dfs 会返回一个布尔值
// 表示当前位置填充对应数字之后后续 dfs 能否成功把九宫格填满，返回 true 就表示填满了，那就直接也返回 true
// 这题需要用原地修改的处理方式，所以直接 return 用来阻断后续的枚举
// 另外我使用了 matrixIndex 来表示九宫格格中对应的位置，这样可以避免 i 或者 j 到头之后难以找到下一个 i j 的问题
// matrixIndex 能直接推断出 i j，而 matrixIndex 最大为 n ** 2 - 1 = 80
var solveSudoku = function(board) {
  const rows = new Array(9).fill(0).map(_ => new Set())
  const cols = new Array(9).fill(0).map(_ => new Set())
  const blocks = new Array(9).fill(0).map(_ => new Set())

  for(let i=0;i<9;i++) {
    for(let j=0;j<9;j++) {
      if(board[i][j] !== '.') {
        rows[i].add(board[i][j])
        cols[j].add(board[i][j])
        blocks[Math.floor(i / 3) * 3 + Math.floor(j / 3)].add(board[i][j])
      }
    }
  }

  function dfs(matrixIndex) {
    let i = Math.floor(matrixIndex / 9)
    let j = matrixIndex - i * 9
    while(matrixIndex < 81 && board[i][j] !== '.') {
      matrixIndex ++
      i = Math.floor(matrixIndex / 9)
      j = matrixIndex - i * 9
    }

    if(matrixIndex === 81) {
      return true
    } else {
      for(let num = 1;num<=9;num++) {
        const numStr = String(num)
        const blockIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3)
        if(
          !rows[i].has(numStr) &&
          !cols[j].has(numStr) &&
          !blocks[blockIndex].has(numStr)
        ) {
          board[i][j] = numStr
          rows[i].add(numStr)
          cols[j].add(numStr)
          blocks[blockIndex].add(numStr)

          if(dfs(matrixIndex + 1)) {
            return true
          } else {
            board[i][j] = '.'
            rows[i].delete(numStr)
            cols[j].delete(numStr)
            blocks[blockIndex].delete(numStr)
          }
        }
      }
      return false
    }
  }

  dfs(0)
};
```

## ?🌟😻✔ 41 缺失的第一个正数【hard】

[ref](https://leetcode.cn/problems/first-missing-positive/)

数组、哈希

```js
// 原地哈希就相当于，让每个数字n都回到下标为n-1的家里。
// 而那些没有回到家里的就成了孤魂野鬼流浪在外，他们要么是根本就没有自己的家（数字小于等于0或者大于nums.size()），要么是自己的家被别人占领了（出现了重复）。
// 这些流浪汉被临时安置在下标为i的空房子里，之所以有空房子是因为房子i的主人i+1失踪了（数字i+1缺失）。
// 因此通过原地构建哈希让各个数字回家，我们就可以找到原始数组中重复的数字还有消失的数字。
// 时间复杂度：O(N)
// 时间复杂度：O(1)
var firstMissingPositive = function(nums) {
 const len = nums.length
 for(let i=0;i<len;i++) {
   while(nums[i] - 1 >= 0 && nums[i] - 1 < len && nums[nums[i] - 1] !== nums[i]) {
     swap(nums, i, nums[i] - 1)
   }
 }
 for(let i=0;i<len;i++) {
   if(i + 1 !== nums[i]) {
     return i + 1
   }
 }
 return len + 1
};

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```


```js
// 常规思路
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var firstMissingPositive = function(nums) {
  const s = new Set(nums)
  let i=1
  while(true) {
    if(!s.has(i)) return i
    i++
  }
};
```

## 🌟😻✔ 42 接雨水【hard】

[ref](https://leetcode.cn/problems/trapping-rain-water/)

动态规划

双指针版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var trap = function(height) {
  let lMax = 0
  let rMax = 0
  let l = 0
  let r = height.length - 1
  let total = 0
  while(l < r) {
    if(height[l] < height[r]) {
      lMax = Math.max(lMax, height[l])
      total += lMax - height[l]
      l ++
    } else {
      rMax = Math.max(rMax, height[r])
      total += rMax - height[r]
      r--
    }
  }
  return total
};
```

动态规划版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var trap = function(height) {
  const len = height.length
  const leftMax = [0]
  const rightMax = []
  rightMax[len - 1] = [0]
  let total = 0
  for(let i = 1; i < len; i++) {
    leftMax[i] = Math.max(height[i - 1], leftMax[i - 1])
  }
  for(let i = len - 2; i >= 0; i--) {
    rightMax[i] = Math.max(height[i + 1], rightMax[i + 1])
  }
  for(let i = 0; i < len; i++) {
    total += Math.max(Math.min(leftMax[i], rightMax[i]) - height[i], 0)
  }

  return total
};
```

常规思路版

```js
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
var trap = function(height) {
  const len = height.length
  let total = 0
  for(let i = 1; i < len - 1; i++) {
    let l = i - 1
    let r = i + 1
    let lMax = height[i]
    let rMax = height[i]

    while(l >= 0) {
      if(height[l] > lMax) {
        lMax = height[l]
      } 
      l--
    }
    while(r <= len - 1) {
      if(height[r] > rMax) {
        rMax = height[r]
      } 
      r++
    }
    const receive = Math.min(lMax, rMax) - height[i]
    total += receive
  }
  return total
};
```

## 🌟😻✔ 43 字符串相乘【medium】

[ref](https://leetcode.cn/problems/multiply-strings/)

字符串相加、字符串相乘

```js
// 时间复杂度：O(mn)
// 空间复杂度：O(m + n)
var multiply = function(num1, num2) {
  if(num1 === '0' || num2 === '0') return '0'
  const m = num1.length
  const n = num2.length
  const numArr = new Array(m + n).fill(0)
  for(let i=m - 1;i>=0;i--) {
    for(let j=n - 1;j>=0;j--) {
      let addIndex = i + j + 1
      const sum = Number(num1[i]) * Number(num2[j]) + numArr[addIndex]
      numArr[addIndex] = sum % 10
      k = Math.floor(sum / 10)
      while(k > 0) {
        addIndex--
        const s = k + numArr[addIndex]
        numArr[addIndex] = s % 10
        k = Math.floor(s / 10)
      }
    }
  }
  while(numArr[0] === 0) numArr.shift()
  return numArr.join('')
};
```

or

```js
// 时间复杂度：O(mn + n^2)
// 空间复杂度：O(m + n) 空间复杂度取决于 sum 这个存储中间状态的字符串长度，实际上也可以认为是 O(1)
var multiply = function(num1, num2) {
  if(num1 === '0' || num2 === '0') return "0"
  const len1 = num1.length
  let sum = '0'
  for(let i=len1 -1;i>=0;i--) {
    const target = num1[i]
    sum = stringAdd(smallMulti(target, num2, len1 - i - 1), sum)
  }
  return sum
};

// 字符串相乘，x只有一位
// zeroCount 是后置0的个数
function smallMulti(x, y, zeroCount) {
  if(x === '0') return '0'
  const yLen = y.length
  let add = 0
  let res = ''
  
  for(let i=yLen - 1;i>=0;i--) {
    const n = Number(x) * Number(y[i]) + add
    add = Math.floor(n / 10)
    res = (n - add * 10) + res
  }
  if(add > 0) {
    res = add + res
  }
  let zeros = ''
  for(let i=0;i<zeroCount;i++) {
    zeros +='0'
  }
  return res + zeros
}

// 任意数字字符串相加
function stringAdd(x, y) {
  const xLen = x.length
  const yLen = y.length
  if(xLen >= yLen) {
    for(let i=0;i<xLen - yLen;i++) {
      y = '0' + y
    }
  } else {
    for(let i=0;i<yLen - xLen;i++) {
      x = '0' + x
    }
  }
  let res = ''
  let add = 0
  for(let i=x.length - 1;i>=0;i--) {
    const sum = Number(x[i]) + Number(y[i]) + add
    add = Math.floor(sum / 10)
    res = (sum - add * 10) + res
  }
  if(add > 0) {
    res = add + res
  }
  return res
}
```

## 😻✔ 45 跳跃游戏 II【medium】

[ref](https://leetcode.cn/problems/jump-game-ii/)

贪心算法

```js
// 从后往前分析，贪心的找到能到达最后一个数字的最远数字
// 可能会担心到不了这个下标，实际上，如果到不了这个下标，则一定到不了最后一个下标，故这个下标是一定能到的
// 用相同的办法，不断地把下标以每次最远的距离往前靠近，直到到达第一个数字
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var jump = function(nums) {
  let r = nums.length - 1
  let min = 0
  while(r > 0) {
    for(let i = 0; i < r; i++) {
      if(i + nums[i] >= r) {
        r = i
        min++
        break
      }
    }
  }
  return min
};
```

更优版本

不太好理解，可以参照这张图，黑色的蹦跶线代表每次跳的时候能跳的最远距离，红色线从终点反过来推，在每个黑色起跳区间内找一个值，最终推到起跳点位于0。

![](https://qiniu1.lxfriday.xyz/feoffer/1652678598702_5db9138d-58b3-4bbf-81ae-44b6795bacc5.png)

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var jump = function(nums) {
  // 每移动一次下标都计算一次能走到的最远距离
  let maxIndex1 = 0
  // 当走到上一轮能走到的最远下标的时候，更新当前轮次能走的最远下标
  let maxIndex2 = 0
  let count = 0
  for(let i = 0; i < nums.length - 1; i++) {
    maxIndex1 = Math.max(maxIndex1, i + nums[i])
    if(i === maxIndex2) {
      count++
      maxIndex2 = maxIndex1
    }
  }
  return count
};
```

## 😻✔ 46 全排列【medium】

[ref](https://leetcode.cn/problems/permutations/)

排列组合、回溯法、递归

```js
var permute = function(nums) {
  const numsLen = nums.length
  const res = []
  const used = {}
  function dfs(path) {
    if(path.length === numsLen) {
      res.push([...path])
      return
    }
    for(let i = 0; i < numsLen; i++){
      const num = nums[i]
      if(used[i]) continue
      used[i] = true
      dfs([...path, num])
      used[i] = false
    }
  }

  dfs([])
  return res
};
```
or

```js
// 时间复杂度：O(n!)
// 空间复杂度：O(n) 递归的层数
var permute = function(nums) {
  const res = []

  function calc(path) {
    if(path.length === nums.length) {
      res.push(path)
      return
    }
    nums.forEach(n => {
      if(!path.includes(n)) {
        calc([...path, n])
      }
    })
  }
  calc([])
  return res
};
```

or

```js
// 时间复杂度：O(n!)
// 空间复杂度：O(n)
var permute = function(nums) {
  if(nums.length === 1) return [nums]
  const res = []
  for(let i = 0;i < nums.length; i++) {
    permute(nums.slice(0, i).concat(nums.slice(i + 1))).forEach(_ => {
      res.push([nums[i], ..._])
    })
  }
  return res
};
```

## 😻✔ 47 全排列 II【medium】

[ref](https://leetcode.cn/problems/permutations-ii/)

排列组合、回溯法、递归

```js
// 时间复杂度：O(n*n!)
// 空间复杂度：O(n)
var permuteUnique = function(nums) {
  // 把无序数组排成有序的，方便后面相同数字的处理
  nums.sort((a, b) => a - b)
  const numsLen = nums.length
  const res = []
  // 对某个值是否使用过做一个记录
  const used = {}
  function dfs(path) {
    if(path.length === numsLen) {
      res.push([...path])
      return
    }
    for(let i = 0; i < numsLen; i++){
      const num = nums[i]
      // 在相同层级的情况下，如果后续还有很多相同的数字，则都会直接跳过
      // 而这里 num === nums[i - 1] 就是表示相同的数字
      // !used[i - 1] 表示的是相同层级，即数组中装填的数字个数相同就表示是同一层级
      if(used[i] || (i >= 1 && num === nums[i - 1] && !used[i - 1])) continue
      used[i] = true
      path.push(num)
      // 这个地方在 dfs 前后会把 used[i] 的值更改两次
      // 原因是：执行 dfs 前，置为 true，然后进行 dfs 内的递归调用时，该调用栈内都会得到 used[i] 为 true
      dfs(path)
      path.pop()
      used[i] = false
    }
  }

  dfs([])
  return res
};
```

## 🌟😻✔ 48. 旋转图像【medium】

[ref](https://leetcode.cn/problems/rotate-image/)

数组、旋转数组、矩阵

```js
// 原地置换
// 时间复杂度：O(N^2)
// 时间复杂度：O(1)
var rotate = function(matrix) {
  const n = matrix.length;
  for (let i = 0; i < Math.floor(n / 2); ++i) {
    for (let j = 0; j < Math.floor((n + 1) / 2); ++j) {
      const temp = matrix[i][j];
      matrix[i][j] = matrix[n - j - 1][i];
      matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
      matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
      matrix[j][n - i - 1] = temp;
    }
  }
};
```

```js
// 常规解法
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var rotate = function(matrix) {
  const n = matrix.length
  const tmpArr = new Array(n).fill([]).map(_ => [])
  for(let i = 0;i < n;i++) {
    for(let j = 0;j< n;j++) {
      tmpArr[j][n - 1 - i] = matrix[i][j]
    }
  }
  for(let i = 0;i < n;i++) {
    for(let j = 0;j< n;j++) {
      matrix[i][j] = tmpArr[i][j]
    }
  }
};
// 0 3 => 3 3
// 0 2 => 2 3
// 1 1 => 1 2
// 2 1 => 1 1
// 3 0 => 0 0
```

## ✔ 49 字母异位词分组【medium】

[ref](https://leetcode.cn/problems/group-anagrams/)

```js
// 时间复杂度：O(NKlogK)
// 空间复杂度：O(NK)
var groupAnagrams = function(strs) {
  const map = new Map()
  for(let i=0;i<strs.length;i++) {
    const hash = strs[i].split('').sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).join('')
    map.set(hash,map.has(hash) ? [...map.get(hash), strs[i]]: [strs[i]])
  }
  return Array.from(map.values())
};
```

## ?🌟😻✔ 51 N 皇后【hard】

[ref](https://leetcode.cn/problems/n-queens/)

回溯、枚举

```js
var solveNQueens = function(n) {
  const rows = new Set()
  const cols = new Set()
  // 对称轴左上
  const leftTop = new Set()
  // 对称轴右上
  const rightTop = new Set()
  const preRes = []

  function dfs(matrixIndex, path, k) {
    if(k === 0) {
      preRes.push([...path])
      return
    }
    if(matrixIndex >= n ** 2) {
      return
    }

    let i = Math.floor(matrixIndex / n)
    let j = matrixIndex - i * n
    if(
      !rows.has(i) &&
      !cols.has(j) &&
      !leftTop.has(i + j) &&
      !rightTop.has(j - i)
    ) {
      path.push(matrixIndex)
      rows.add(i)
      cols.add(j)
      leftTop.add(i + j)
      rightTop.add(j - i)

      dfs(matrixIndex + 1, path, k - 1)

      path.pop()
      rows.delete(i)
      cols.delete(j)
      leftTop.delete(i + j)
      rightTop.delete(j - i)
    }
    dfs(matrixIndex + 1, path, k)
  }

  dfs(0, [],  n)
  const res = []
  preRes.forEach(_ => {
    const tplArr = new Array(n).fill(0).map(_ => new Array(n).fill('.'))
    for(let ind of _) {
      let i = Math.floor(ind / n)
      let j = ind - i * n
      tplArr[i][j] = 'Q'
    }
    res.push(tplArr.map(__ => __.join('')))
  })
  return res
};
```

## 🌟😻✔ 53 最大子数组和【easy】

[ref](https://leetcode.cn/problems/maximum-subarray/)

动态规划

数组版

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxSubArray = function(nums) {
 const dp = []
 // dp[i] 定义的是以 i 作为结束的连续子数组的 最大值
 // 则整个数组的最大连续子数组必然会命中 dp 中的一项，且为值最大的那一项
 dp[0] = nums[0]
 for(let i = 1;i<nums.length;i++) {
   if(dp[i - 1] < 0) {
     dp[i] = nums[i]
   } else {
     dp[i] = dp[i - 1] + nums[i]
   }
 }
 return Math.max(...dp)
};
```

精简版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
// 这个解法相比数组解法更难理解
var maxSubArray = function(nums) {
 // 前 i 个数字中连续子数组的最大和
 let max = nums[0]
 // 以 i 为结尾的连续子数组的最大和
 let sum = 0
 for(let i = 0; i < nums.length; i++) {
   if(sum < 0) {
     sum = nums[i]
   } else {
     sum = sum + nums[i]
   }
   max = Math.max(max, sum)
 }
 return max
};
```

## 🌟😻✔ 54 螺旋矩阵【medium】

[ref](https://leetcode.cn/problems/spiral-matrix/)

```js
// 直接递归硬找，好理解
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var spiralOrder = function(matrix) {
  const m = matrix.length
  const n = matrix[0].length
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  const res = []

  function walk(i, j, direction) {
    used[i][j] = true
    res.push(matrix[i][j])

    if(direction === 'right') {
      if((j + 1 < n) && !used[i][j + 1]) {
        walk(i, j + 1, 'right')
      } else {
        (i + 1 < m) && !used[i + 1][j] && walk(i + 1, j, 'bottom')
      }
    }

    if(direction === 'bottom') {
      if((i + 1 < m) && !used[i + 1][j]) {
        walk(i + 1, j, 'bottom')
      } else {
        (j - 1 >= 0) && !used[i][j - 1] && walk(i, j - 1, 'left')
      }
    }

    if(direction === 'left') {
      if((j - 1 >= 0) && !used[i][j - 1]) {
        walk(i, j - 1, 'left')
      } else {
        (i - 1 >= 0) && !used[i-1][j] && walk(i-1, j, 'top')
      }
    }

    if(direction === 'top') {
      if((i - 1 >= 0) && !used[i - 1][j]) {
        walk(i - 1, j, 'top')
      } else {
        (j + 1 < n) && !used[i][j + 1] && walk(i, j + 1, 'right')
      }
    }
  }

  walk(0, 0, 'right')

  return res
};
```


## 😻✔ 55 跳跃游戏【medium】

[ref](https://leetcode.cn/problems/jump-game/)

```js
// 从左往右扫描 i 位置往后最多能跳到哪
// maxIndex 用来记录 i 前面最多能跳到哪个下标，每到一个位置都刷新 maxIndex
// 如果出现 maxIndex < i，则说明i前面的位置无法跳到 i
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var canJump = function(nums) {
  let maxIndex = 0
  for(let i = 0; i < nums.length; i++) {
    if(i > maxIndex) return false
    maxIndex = Math.max(i + nums[i], maxIndex)
  }
  return true
};
```

## 😻✔ 56 合并区间【medium】

[ref](https://leetcode.cn/problems/merge-intervals/)

```js
// 时间复杂度：O(NlogN) 排序
// 空间复杂度：O(logN) 排序
var merge = function(intervals) {
  intervals.sort((a, b) => a[0] - b[0])
  const res = []
  while(intervals.length > 1) {
    let first = intervals.shift()
    let second = intervals.shift()
    // 区间有交集
    if(first[1] >= second[1]) {
      second = first
    } else if(first[1] >= second[0]) {
      second = [first[0], second[1]]
    } else {
      res.push(first)
    }
    intervals.unshift(second)
  }
  res.push(intervals.shift())
  return res
};
```

## 😻✔ 62 不同路径【medium】

[ref](https://leetcode.cn/problems/unique-paths/)

动态规划

```js
// 时间复杂度：O(mn)
// 空间复杂度：O(mn)
var uniquePaths = function(m, n) {
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  dp[0][0] = 1
  for(let i=1;i<m;i++) {
    dp[i][0] = dp[i - 1][0]
  }
  for(let j=1;j<n;j++) {
    dp[0][j] = dp[0][j - 1]
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    } 
  }
  return dp[m - 1][n - 1]
};
```

## 😻✔ 65 有效的数字【hard】

[ref](https://leetcode.cn/problems/valid-number/)

```js
var isNumber = function(s) {
  // if(s === 'Infinity' || s === '+Infinity' || s === '-Infinity') return false
  // const num = Number(s)
  // if(isNaN(num)) return false
  // return true
  // 模拟法
  let numLeft = ''
  let numRight = ''
  s = s.trim().toLowerCase()
 if(s.includes('e')) {
    const sSplit = s.split('e')
    if(sSplit.length > 2) { return false }
    [numLeft, numRight] = sSplit
    if(validateNumLeft(numLeft) && validateNumRight(numRight)) return true
  } else {
    numLeft = s
    if(validateNumLeft(numLeft)) return true
  }
  return false
};

function validateNumLeft(numLeft) {
  if('-+'.includes(numLeft[0])) {
    numLeft = numLeft.slice(1)
    if(numLeft.includes('-') || numLeft.includes('+')) return false
  }
  if(!numLeft.length) return false
  let numLeftSplit
  if(numLeft.includes('.')) {
    numLeftSplit = numLeft.split('.')
    if(numLeftSplit.length > 2 ) return false
    if(!numLeftSplit[0].length && isNumStr(numLeftSplit[1])) return true
    if(!numLeftSplit[1].length && isNumStr(numLeftSplit[0])) return true
    if(isNumStr(numLeftSplit[0]) && isNumStr(numLeftSplit[1])) return true
    return false
  } else {
    return isNumStr(numLeft)
  }
}

function validateNumRight(numRight) {
  if(numRight[0] === '-' || numRight[0] === '+') {
    numRight = numRight.slice(1)
  }
  return isNumStr(numRight)
}

function isNumStr(numStr) {
  if(!numStr.length) return false
  for(let c of numStr) {
    if(!(c >= '0' && c <= '9')) return false
  }
  return true
}
```

## 😻✔ 70 爬楼梯【easy】

[ref](https://leetcode.cn/problems/climbing-stairs/)

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var climbStairs = function(n) {
  if(n === 1) return 1
  if(n === 2) return 2
  d1 = 1
  d2 = 2
  for(let i = 3; i <= n; i++) {
    const tmpD2 = d2
    d2 = d1 + d2
    d1 = tmpD2
  }
  return d2
};
```

数组解

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var climbStairs = function(n) {
  const d = []
  d[1] = 1
  d[2] = 2
  for(let i = 3; i <= n; i++) {
    d[i] = d[i - 1] + d[i - 2]
  }
  return d[n]
};
```

## 🌟😻✔ 72 编辑距离【hard】

[ref](https://leetcode.cn/problems/edit-distance/)

定义 `dp[i][j]` 是 word1 长度为 i 的字符串转换成 word2 长度为 j 字符串的最少操作次数。则 `dp[i][j]` 可由下面三种情况得到：

- `dp[i - 1][j - 1]` 替换掉 word1 中第 i 个字符
- `dp[i - 1][j]`  删除 word1 中第 i 个字符
- `dp[i][j - 1]`  在 word1 中第 i 个字符后面新增一个字符

上面三种情况的最小值 + 1，就是 `dp[i][j]`。

所以状态转移方程为：

```js
dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
```

然后设置初始值， i 为 0 则最短操作次数就是 j，j 为 0 则最短操作次数就是 i。


动态规划

```js
// m=word1.length n=word2.length
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var minDistance = function(word1, word2) {
  const len1 = word1.length
  const len2 = word2.length
  const dp = new Array(len1 + 1).fill(0).map(_ => new Array(len2 + 1).fill(0))
  for(let i = 0; i <= len1; i++) {
    dp[i][0] = i
  }
  for(let j = 0; j <= len2; j++) {
    dp[0][j] = j
  }
  for(let i = 1; i <= len1; i++) {
    for(let j = 1; j <= len2; j++) {
      if(word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1]
      } else {
        dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
      }
    }
  }
  return dp[len1][len2]
};
```

## 😻✔ 76 最小覆盖子串【hard】

[ref](https://leetcode.cn/problems/minimum-window-substring/)

双指针、滑动窗口

```js
var minWindow = function(s, t) {
  const need = new Map()
  let needType = 0
  for(let c of t) {
    if(need.has(c)) {
      need.set(c, need.get(c) + 1)
    } else {
      need.set(c, 1)
      needType += 1
    }
  }

  let l = 0
  let minStr = ''
  for(let r = 0;r < s.length; r++) {
    const c = s[r]
    if(need.has(c)) {
      need.set(c, need.get(c) - 1)
      if(need.get(c) === 0) needType -= 1 
    }
    while(needType === 0) {
      if(!minStr.length || s.slice(l, r + 1).length < minStr.length) minStr = s.slice(l, r + 1)
      if(need.has(s[l])) {
        need.set(s[l], need.get(s[l]) + 1)
        if(need.get(s[l]) === 1) {
          needType += 1
        }
      }
      l++
    }
  }
  return minStr
};
```

## 🌟😻✔ 77 组合【medium】

[ref](https://leetcode.cn/problems/combinations/)

```js
// 时间复杂度：O(C(n, k)) 组合数
// 空间复杂度：O(k)
var combine = function(n, k) {
  const res = []

  function run(path, start) {
    if(path.length === k) {
      res.push([...path])
      return
    }

    for(let i=start;i<=n;i++) {
      path.push(i)
      run(path, i + 1)
      path.pop()
    }
  }

  run([], 1)

  return res
};
```

## 🌟😻✔ 78 子集【medium】

回溯、递归

```js
// 时间复杂度：O(N*2^N)
// 时间复杂度：O(N)
var subsets = function(nums) {
  const res = []

  function calc(path, start = 0) {
    res.push(path)
    for(let i = start; i < nums.length; i++) {
      calc([...path, nums[i]], i + 1)
    }
  }

  calc([])
  return res
};
```

## ?🌟😻✔ 79 单词搜索【medium】

[ref](https://leetcode.cn/problems/word-search/)

```js
var exist = function(board, word) {
  const m = board.length
  const n = board[0].length
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  const words = word.split('')
  let has = false

  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      find(i, j, words)
    }
  }

  function find(i, j) {
    if(used[i][j]) return
    if(board[i][j] === words[0]) {
      const w = words.shift()
      used[i][j] = true

      if(!words.length) {
        has = true
        return
      }

      j + 1 < n && find(i, j + 1)
      j - 1 >= 0 && find(i, j - 1)
      i - 1 >=0 && find(i - 1, j)
      i + 1 < m && find(i + 1, j)
      words.unshift(w)
      used[i][j] = false
    }
  }

  return has
};
```

## ?🌟😻✔ 82 删除排序链表中的重复元素 II【medium】

[ref](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var deleteDuplicates = function(head) {
  let myHead = new ListNode()
  myHead.next = head
  let fast = myHead
  let slow = myHead
  while(fast.next && fast.next.next) {
    if(fast.next.val === fast.next.next.val) {
      fast = fast.next
    } else {
      if(fast === slow) {
        slow = slow.next
        fast = fast.next
      } else {
        slow.next = fast.next.next
        fast = slow
      }
    }
  }
  if(slow !== fast) {
    slow.next = null
  }
  return myHead.next
};
```

## ✔ 83 删除排序链表中的重复元素【easy】

[ref](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

链表

```js
var deleteDuplicates = function (head) {
  let t = head
  while (t && t.next) {
    const tNext = t.next
    if (t.val !== tNext.val) {
      t = t.next
    } else {
      t.next = tNext.next
    }
  }
  return head
}
```

## ?🌟😻✔ 84 柱状图中最大的矩形【hard】

[ref](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var largestRectangleArea = function(heights) {
  heights = [0, ...heights, 0]
  let max = 0
  const q = [0]
  for(let i=1;i<heights.length;i++) {
    while(heights[i] < heights[q[q.length - 1]]) {
      const h = heights[q.pop()]
      const w = i - q[q.length - 1] - 1
      max = Math.max(max, w * h)
    }
    if(heights[i] >= heights[q[q.length - 1]]) {
      q.push(i)
    }
  }
  return max
};
```

## ?🌟😻✔ 85 最大矩形【hard】

[ref](https://leetcode.cn/problems/maximal-rectangle/)

单调栈

相关请看 84 题

```js
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var maximalRectangle = function(matrix) {
  if(!matrix.length || !matrix[0].length) return 0
  const m = matrix.length
  const n = matrix[0].length
  const left = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(matrix[i][j] === '1') {
        left[i][j] = (j - 1 >= 0 ? left[i][j - 1] : 0) + 1
      }
    }
  }
  // 给每列加前导0和后置0，具体原因请看
  // #84 https://leetcode.cn/problems/largest-rectangle-in-histogram/
  // 前导0可以用于 w 宽度计算时的左边界
  // 后置0可以用于清空q栈，q是必须要清空的，如果不加后置0，则对于递增的高度需要做额外的后置处理
  left.unshift(new Array(n).fill(0))
  left.push(new Array(n).fill(0))
  let max = 0
  for(let j=0;j< n;j++) {
    const q = []
    for(let i=0;i<m + 2;i++) {
      while(q.length - 1 >= 0 && left[q[q.length - 1]][j] > left[i][j]) {
        const h = left[q.pop()][j]
        const w = i - q[q.length - 1] - 1
        max = Math.max(max, w * h)
      }
      q.push(i)
    }
  }
  return max
};
```

## ✔ 88 合并两个有序数组【easy】

[ref](https://leetcode.cn/problems/merge-sorted-array/)

```js
// 时间复杂度：O(m+n)
// 空间复杂度：O(1)
var merge = function(nums1, m, nums2, n) {
  let mn = m + n - 1
  let mIndex = m - 1
  let nIndex = n - 1
  while(mIndex >= 0 && nIndex >= 0) {
    if(nums1[mIndex] > nums2[nIndex]) {
      nums1[mn] = nums1[mIndex]
      mIndex--
    } else {
      nums1[mn] = nums2[nIndex]
      nIndex--
    }
    mn--
  }
  // 有可能 nums1 中的数字都复制完了，nums2 中还存在数字
  // 则把 nums2 中的数字都复制过来
  // 如果是 nums2 没有需要复制的，而 nums1 有需要复制的，则可以直接跳过
  while(nIndex >= 0) {
    nums1[nIndex] = nums2[nIndex]
    nIndex--
    mn--
  }
};
```

## ?? 🌟😻✔ 89 格雷编码【medium】

[ref](https://leetcode.cn/problems/gray-code/)

规律题

```js
// 规律题
// 时间复杂度：O(2^N)
// 时间复杂度：O(2^N)
// 注意条件：
// 结果数组中有 2^N 个数，且刚好是 [0, 2^N -1] 内的数
// 1. 对于 N-1 的格雷编码，N 中的数字是N-1中数字的一倍
// 2. N-1 中已形成格雷编码的情况下，对这 N-1 个数字的二进制前面加一个1，然后翻转就是另外 2^(N-1) 个数字
// 0 01 => 0 01 0 01 => 0 01 10 11 => 0 01 11 10
// 0 01 11 10 => 0 01 11 10 0 01 11 10 => 0 01 11 10 100 101 111 110 => 0 01 11 10 110 111 101 100
var grayCode = function(n) {
  const res = [0];
  for (let i = 1; i <= n; i++) {
    const len = res.length;
    for (let j = len - 1; j >= 0; j--) {
      res.push(res[j] + len)
    }
  }
  return res;
};

// 0 1 11 10
// 0 1 3 2

// 0  0
// 1  1
// 2  10
// 3  11 
// 4  100
// 5  101
// 6  110
// 7  111
// 8  1000
// 9  1001
// 10 1010
// 11 1011
// 12 1100
// 13 1101
// 14 1110
// 15 1111

```

## 🌟😻✔ 90 子集 II【medium】

[ref](https://leetcode.cn/problems/subsets-ii/)

回溯、深度优先遍历

```js
// 时间复杂度：O(n×2^n)
// 空间复杂度：O(n)
var subsetsWithDup = function(nums) {
  nums.sort((a, b) => a - b)
  const res = []
  const len = nums.length
  const used = []
  function dfs(path, index) {
    res.push(path)
    for(let i=index;i<len;i++) {
      if(i - 1 >= index && !used[i - 1] && nums[i] === nums[i - 1]) continue
      used[i] = true
      dfs([...path, nums[i]], i + 1)
      used[i] = false
    }
  }
  dfs([], 0)
  return res
};
```

## 🌟😻✔ 93 复原 IP 地址【medium】

[ref](https://leetcode.cn/problems/restore-ip-addresses/)

回溯法

```js
// SEG_COUNT=4 表示 ip 的地址段数
// 时间复杂度：O(3*SEG_COUNT)
// 空间复杂度：O(SEG_COUNT)
var restoreIpAddresses = function(s) {
  if(s.length < 4) return []
  const res = []

  function calc(path, start, dotLeft) {
    if(dotLeft === 0) {
      const end = s.slice(start)
      if(isValidSub(end)) {
        res.push(path + end)
      }
      return
    }
    ;([1, 2, 3]).forEach(l => {
      const current = s.slice(start, start + l)
      if(isValidSub(current)) {
        calc(path + current + '.', start + l, dotLeft - 1)
      }
    })
  }

  calc('', 0, 3)
  return res
};

function isValidSub(str) {
  if(str === '0' || str.indexOf('0') !== 0 && Number(str) > 0 && Number(str) <= 255) {
    return true
  }
  return false
}
```

## 😻✔ 94 二叉树的中序遍历【easy】

[ref](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

二叉树、中序遍历、DFS、深度优先遍历

```js
var inorderTraversal = function (root) {
  const res = []
  const dfs = node => {
    if (!node) return
    dfs(node.left)
    res.push(node.val)
    dfs(node.right)
  }
  dfs(root)
  return res
}1
```

## 🌟😻✔ 96 不同的二叉搜索树【medium】

[ref](https://leetcode.cn/problems/unique-binary-search-trees/)

动态规划

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var numTrees = function(n) {
  const dp = new Array(n + 1).fill(0)
  dp[0] = 1
  dp[1] = 1
  for(let i=2;i<=n;i++) {
    for(let j=0;j<i;j++) {
      dp[i] += dp[j] * dp[i - 1 - j]
    }
  }
  return dp[n]
};
```

## ?🌟😻✔ 98. 验证二叉搜索树【medium】

[ref](https://leetcode.cn/problems/validate-binary-search-tree/submissions/)

二叉树、二叉搜索树

```js
// 自顶向下，碰到异常情况直接结束，效率更优，不需要扫描所有节点
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var isValidBST = function(root) {
  function dfs(node, max, min) {
    if(!node) return true
    if(!(node.val > min && node.val < max)) return false
    return dfs(node.left, node.val, min) && dfs(node.right, max, node.val)
  }
  return dfs(root, Infinity, -Infinity)
};
```

```js
// DFS
// 自底向上，必须扫描所有节点
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var isValidBST = function(root) {
  let is = true
  function dfs(node) {
    let min = node.val, max = node.val
    if(node.left) {
      const [lmin, lmax] = dfs(node.left)
      if(lmax >= node.val) is = false
      min = Math.min(lmin, lmax, min)
      max = Math.max(lmin, lmax, max)
    }
    if(node.right) {
      const [rmin, rmax] = dfs(node.right)
      if(rmin <= node.val) is = false
      min = Math.min(rmin, rmax, min)
      max = Math.max(rmin, rmax, max)
    }
    return [min, max]
  }
  dfs(root)
  return is
};

```

## 😻✔ 100 相同的树【easy】

[ref](https://leetcode.cn/problems/same-tree/)

二叉树、树

```js
// 时间复杂度：O(n)
// 空间复杂度：O(logn)~O(n)
var isSameTree = function(p, q) {
  if(!p && !q) return true
  if(p && q && p.val === q.val) {
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
  }
  return false
};
```

## 😻✔ 101 对称二叉树【easy】

[ref](https://leetcode.cn/problems/symmetric-tree/)

二叉树

```js
// 时间复杂度：O(n)
// 空间复杂度：O(logn)~O(n)
var isSymmetric = function(root) {
  if(!root) return true
  const isMirror = (l, r) => {
    if(!l && !r) return true
    if(l && r && l.val === r.val) {
      return isMirror(l.left, r.right) && isMirror(l.right, r.left)
    }
    return false
  }
  return isMirror(root.left, root.right)
};
```

## 😻✔ 102 二叉树的层序遍历【medium】

[ref](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

二叉树、BFS、广度优先遍历、层序遍历

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var levelOrder = function(root) {
  if(!root) return []
  const res = []
  let q = [root]
  let tmpQ = []
  let depthArr = []
  while(q.length) {
    const node = q.shift()
    depthArr.push(node.val)
    node.left && tmpQ.push(node.left)
    node.right && tmpQ.push(node.right)
    if(!q.length && tmpQ.length) {
      q = tmpQ
      tmpQ = []
      res.push(depthArr)
      depthArr = []
    } else if(!q.length && !tmpQ.length) {
      res.push(depthArr)
    }
  }
  return res
};
```

```js
var levelOrder = function (root) {
  if (!root) return []
  const q = [[root, 0]]
  const res = []
  while (q.length) {
    const [node, depth] = q.shift()
    res[depth] ? res[depth].push(node.val) : (res[depth] = [node.val])
    node.left && q.push([node.left, depth + 1])
    node.right && q.push([node.right, depth + 1])
  }

  return res
}
```

## ?😻✔ 103. 二叉树的锯齿形层序遍历【medium】

[ref](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

二叉树、广度优先搜索

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var zigzagLevelOrder = function(root) {
  if(!root) return []
  const res = [[root.val]]
  let q = [root]
  let tmp = []
  let isLeft = false
  while(q.length) {
    const node = q.shift()
    node.left && tmp.push(node.left)
    node.right && tmp.push(node.right)
    if(!q.length) {
      const tRes = []
      q = [...tmp]
      while(tmp.length) {
        tRes.push(tmp.shift().val)
      }
      tRes.length && res.push(isLeft ? tRes : tRes.reverse())
      isLeft = !isLeft
    }
  }
  return res
};
```

## 😻✔ 104 二叉树的最大深度【easy】

[ref](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

二叉树、深度优先遍历、DFS

```js
var maxDepth = function (root) {
  let maxLen = 0
  const dfs = (node, l) => {
    if (!node) return
    maxLen = Math.max(maxLen, l)
    dfs(node.left, l + 1)
    dfs(node.right, l + 1)
  }
  dfs(root, 1)
  return maxLen
}
```

## ?🌟😻✔ 105 从前序与中序遍历序列构造二叉树【medium】

[ref](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

二叉树、二叉树的构造

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var buildTree = function(preorder, inorder) {
  const root = new TreeNode(preorder.shift())
  let i= inorder.indexOf(root.val)
  const leftOrders = inorder.slice(0, i)
  const rightOrders = inorder.slice(i + 1)
  if(leftOrders.length) {
    root.left = buildTree(preorder, leftOrders)
  }
  if(rightOrders.length) {
    root.right = buildTree(preorder, rightOrders)
  }
  return root
};

```

## 😻✔ 111 二叉树的最小深度【easy】

[ref](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

二叉树、广度优先遍历、BFS

```js
var minDepth = function (root) {
  if (!root) return 0
  const q = [[root, 1]]
  while (q.length) {
    const [node, depth] = q.shift()
    if (!node.left && !node.right) return depth
    node.left && q.push([node.left, depth + 1])
    node.right && q.push([node.right, depth + 1])
  }
}
```

## 😻✔ 112 路径总和【easy】

[ref](https://leetcode.cn/problems/path-sum/)

二叉树、二叉树的路径总和、DFS、深度优先遍历

```js
var hasPathSum = function (root, targetSum) {
  if (!root) return false
  let has = false
  const dfs = (node, sum) => {
    if (!node.left && !node.right) {
      if (node.val + sum === targetSum) {
        has = true
      }
    }
    node.left && dfs(node.left, node.val + sum)
    node.right && dfs(node.right, node.val + sum)
  }

  dfs(root, 0)
  return has
}
```

## 😻✔ 113 路径总和 II【medium】

[ref](https://leetcode.cn/problems/path-sum-ii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var pathSum = function(root, targetSum) {
  if(!root) return []
  const res = []

  function dfs(node, path, sum) {
    if(!node.left && !node.right) {
      if(sum + node.val === targetSum) {
        res.push([...path, node.val])
      }
      return
    }
    path.push(node.val)
    node.left && dfs(node.left, path, sum + node.val)
    node.right && dfs(node.right, path, sum + node.val)
    path.pop()
  }

  dfs(root, [], 0)

  return res
};
````

## ?🌟😻✔ 114 二叉树展开为链表【medium】

[ref](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

二叉树、链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var flatten = function(root) {
  if(!root) return root
  let left = flatten(root.left)
  let right = flatten(root.right)
  root.left = null
  if(left) {
    root.right = left
    while(left.right) {
      left = left.right
    }
    left.right = right
  } else {
    root.right = right
  }
  return root
};
```

## 🌟✔ 118 杨辉三角【easy】

[ref](https://leetcode.cn/problems/pascals-triangle/)

```js
// N=numRows
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var generate = function(numRows) {
  const res = []
  for(let i=0;i<numRows;i++) {
    const cur = []
    for(let j=0;j<=i;j++) {
      if(j === 0 || j === i) {
        cur.push(1)
      } else {
        cur.push(res[i - 1][j - 1] + res[i - 1][j])
      }
    }
    res.push(cur)
  }
  return res
};
```

## 😻✔ 121 买卖股票的最佳时机【easy】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

动态规划

```js
// 抓住一个点：从后往前看，到某一天的时候，能获得的最大利润是：Math.max(至前一天能获得的最大利润, 至当天能获得的最大利润)
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  let maxProfit = 0
  let everMin = prices[0]
  for(let i = 1 ;i < prices.length; i++) {
    everMin = Math.min(everMin, prices[i])
    maxProfit = Math.max(maxProfit, prices[i] - everMin)
  }
  return maxProfit
};
```

数组版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProfit = function(prices) {
  let dp = []
  let everMin = prices[0]
  dp[0] = 0
  for(let i = 1 ;i < prices.length; i++) {
    everMin = Math.min(everMin, prices[i])
    dp[i] = Math.max(dp[i - 1], prices[i] - everMin)
  }
  return dp[prices.length - 1]
};
```

## 😻✔ 122 买卖股票的最佳时机 II【medium】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

动态规划

```js
var maxProfit = function(prices) {
  let maxProfit = 0
  for(let i = 1; i < prices.length; i++) {
    maxProfit = Math.max(maxProfit, maxProfit + prices[i] - prices[i - 1])
  }
  return maxProfit
};
```

数组版本

```js
var maxProfit = function(prices) {
  const dp = []
  dp[0] = 0
  for(let i = 1; i < prices.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 1] + prices[i] - prices[i - 1])
  }
  return dp[prices.length - 1]
};
```

or

```js
// 时间复杂度：O(n)
// 时间复杂度：O(1)
// 赚钱的宗旨：只要后一天比前一天价格高，我就会赚，所以我每天都买，但是我知道第二天会跌
// 会涨：则默认为我昨天就买了，今天的涨幅算进利润里
// 会跌：那我前一天买了又卖了
var maxProfit = function(prices) {
  let maxProfit = 0
  let buyPrice = prices[0]
  for(let i = 1;i < prices.length; i++) {
    if(prices[i] >= buyPrice) {
      maxProfit += prices[i] - buyPrice
    }
    buyPrice = prices[i]
  }
  return maxProfit
};
```



## 😻✔ 123 买卖股票的最佳时机 III【hard】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

动态规划


容易理解的版本

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxProfit = function(prices) {
  const n = prices.length
  const lDp = new Array(n).fill(0)
  const rDp = new Array(n).fill(0)

  // 从左往右扫描，记录 0~i 范围内操作一次的最大收益
  let lMin = prices[0]
  let lProMax = 0
  for(let i=1;i<n;i++) {
    if(prices[i] > lMin) {
      lProMax = Math.max(prices[i] - lMin, lProMax)
    } else {
      lMin = prices[i]
    }
    lDp[i] = lProMax
  }

  // 从右往左扫描，记录 i~n-1 范围内操作一次的最大收益
  let rMax = prices[n-1]
  let rProMax = 0
  for(let i=n-2;i>=0;i--) {
    if(prices[i] < rMax) {
      rProMax = Math.max(rMax - prices[i], rProMax)
    } else {
      rMax = prices[i]
    }
    rDp[i] = rProMax
  }

  let maxPro = 0
  // 最多操作两次，而且两次不能重叠，所以上面 lDp 和 rDp 刚好互补
  // 从0~n做一次扫描，记录左右操作的和，取最大值即为结果
  for(let i = 0; i < n; i++) {
    maxPro = Math.max(lDp[i] + rDp[i], maxPro)
  }
  return maxPro
};
```

超高效版本

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  const n = prices.length;
  let buy1 = -prices[0], buy2 = -prices[0];
  let sell1 = 0, sell2 = 0;
  for (let i = 1; i < n; i++) {
      sell2 = Math.max(sell2, buy2 + prices[i]);
      buy2 = Math.max(buy2, sell1 - prices[i]);
      sell1 = Math.max(sell1, buy1 + prices[i]);
      buy1 = Math.max(buy1, -prices[i]);
  }
  return sell2;
};
```

普通版本

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
// ref https://blog.csdn.net/qq_35027690/article/details/118557921
var maxProfit = function(prices) {
  // 最多操作两次时
  // 第i天的收益，总共包含5中情况（i 对应数组下标）
  // 0：没操作，收益为0，可以直接排除，对应 d[i][0] = 0 一直是 0
  // 1：只买了一次，流动资金相比初始状态是负值
  // 2：买了一次，卖了一次，流动资金相比初始状态是正值（只赚不赔）
  // 3：买了一次，卖了一次，又买了一次，流动资金相比初始状态是未知的
  // 4：买了一次，卖了一次，又买了一次，又卖了一次，流动资金相比初始状态是正值（只赚不赔）
  const dp = new Array(prices.length).fill('').map(_ =>[])
  // 把初始值定出来
  dp[0][0] = 0
  dp[0][1] = -prices[0]
  dp[0][2] = 0
  dp[0][3] = -prices[0]
  dp[0][4] = 0
  for(let i = 1; i < prices.length; i++) {
    // 构建状态转移方程
    // --------------------------
    // i 天内只买了一次的最大收益
    // dp[i][1] = max(dp[i - 1][1] , dp[i - 1][0] - prices[i])
    // dp[i - 1][1]： 第i天没操作，顺延到 i - 1 天内只买了一次，没卖
    // dp[i - 1][0] - prices[i]： i - 1 天内没操作，在 i 天买了,  - prices[i]
    // 实际就是：dp[i][1] = max(dp[i - 1][1] , - prices[i])
    dp[i][1] = Math.max(dp[i-1][1], -prices[i])
    // --------------------------
    // i 天内只买了一次又卖了一次的最大收益
    // dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])
    // dp[i-1][2]：第 i 天没操作，顺延到 i - 1 天内进行了买卖各一次
    // dp[i-1][1] + prices[i]：第 i 天卖了，在第 i - 1 天内进行了一次买入操作
    dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i])
    // --------------------------
    // i 天内进行了买一次，卖一次，又买一次的最大收益
    // dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])
    // dp[i-1][3]：第 i 天没有操作，顺延到 i - 1 天内进行买卖买操作后的结果
    // dp[i-1][2] - prices[i]：第 i 天买了，在 i - 1 天内进行了一次买卖操作
    dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i])
    // --------------------------
    // i 天内进行了买一次，卖一次，又买一次，又卖一次的最大收益
    // dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])
    // dp[i-1][4]：第 i 天没操作，顺延到 i - 1 天内进行了买卖各两次
    // dp[i-1][3] + prices[i]：第 i 天卖了一次，并且在 i - 1 天内进行了买卖买操作
    dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i])
    // --------------------------
  }
  return dp[prices.length - 1][4]
};
```

## 🌟😻✔ 124 二叉树中的最大路径和【hard】

[ref](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

一般涉及到路径的问题，都可以从路径根节点下手，任一一条路径必然会有一个根节点，二叉树中以任意一个节点为根节点的最大路径节点总和的**最大值**即为答案。

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n) 空间复杂度取决于递归调用的层数，最差情况下为 O(n)
var maxPathSum = function(root) {
  let max = root.val
  function dfs(node) {
    let leftMax = 0
    let rightMax = 0
    if(node.left) {
      leftMax = dfs(node.left)
    }
    if(node.right) {
      rightMax = dfs(node.right)
    }
    const ret = Math.max(leftMax + node.val, rightMax + node.val, node.val)
    max = Math.max(ret, leftMax + rightMax + node.val, max)
    return ret
  }

  dfs(root)
  return max
};

```

## ?🌟😻✔ 128 最长连续序列【medium】

数组题

[ref](https://leetcode.cn/problems/longest-consecutive-sequence/)

![](https://qiniu1.lxfriday.xyz/feoffer/1653261522967_db2092bf-f1fd-4013-b0e6-67a1cfd5909f.png)

```js
// 别一看到 for 里面套着 while 就认为大于 O(n)
// 并不是所有的 value 都会进入 while 循环，只有作为区间左值的 value 才会进入 while
// for+while 的组合刚好可以把所有的数字统计一遍
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var longestConsecutive = function(nums) {
  const set = new Set(nums)
  let max = 0
  for(let num of set.values()) {
    if(!set.has(num - 1)) {
      let count = 1
      while(set.has(count + num)) {
        count++
      }
      max = Math.max(count, max)
    }
  }
  return max
};
```

## ?🌟😻✔ 131 分割回文串【medium】

[ref](https://leetcode.cn/problems/palindrome-partitioning/)

回溯、动态规划

```js
// 时间复杂度：O(N*2^N)
// 空间复杂度：O(N^2)
var partition = function(s) {
  const n = s.length
  const f = new Array(n).fill(true).map(_ => new Array(n).fill(true))

  for(let i=n-1;i>=0;i--) {
    for(let j=i+1;j<n;j++) {
      f[i][j] = s[i] === s[j] && f[i + 1][j - 1]
    }
  }

  const res = []

  function run(si, path) {
    if(si >= n) {
      res.push([...path])
    }
    for(let i=si;i<n;i++) {
      if(f[si][i]) {
        path.push(s.slice(si, i + 1))
        run(i + 1, path)
        path.pop()
      }
    }
  }

  run(0, [])

  return res
};
```

回溯

```js
var partition = function(s) {
  let result = []
  const map = new Map()
  function walk(target) {
    const len = target.length
    const res = []
    for(let i=1;i<=len;i++) {
      const first = target.slice(0, i)
      if(!map.has(first)) {
        map.set(first, isPalindrome(first))
      }
      if(map.get(first)) {
        const subPartition = walk(target.slice(i))
        if(!subPartition.length) {
          res.push([first])
        } else {
          for(let p of subPartition) {
            res.push([first, ...p])
          }
        }
      }
    }
    return res
  }

  result = walk(s)
  return result
};

function isPalindrome(str) {
  const len = str.length
  if(len === 0) return false
  for(let i=0;i<Math.floor(len + 1 / 2);i++) {
    if(str[i] !== str[len - i - 1]) return false
  }
  return true
}
```

## ?🌟😻✔ 132 分割回文串 II【hard】

[ref](https://leetcode.cn/problems/palindrome-partitioning-ii/)

动态规划

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var minCut = function(s) {
  const n = s.length
  const f = new Array(n).fill(true).map(_ => new Array(n).fill(true))
  for(let i=n - 1;i>=0;i--) {
    for(let j=i + 1;j < n;j++) {
      f[i][j] = s[i] === s[j] && f[i + 1][j - 1]
    }
  }
  const dp = new Array(n).fill(0)
  dp[0] = 1
  for(let j=1;j<n;j++) {
    let min = j + 1
    for(let i = j;i>=0;i--) {
      if(f[i][j]) {
        min = Math.min(min, (i - 1 >=0 ? dp[i - 1] : 0) + 1)
      }
    }
    dp[j] = min
  }
  return dp[n - 1] - 1
};
```

## 😻✔ 133 克隆图【medium】

[ref](https://leetcode.cn/problems/clone-graph/)

图、深度优先遍历、广度优先遍历、DFS、BFS

```js
// DFS
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function(node) {
  if(!node) return 
  const visited = new Map()
  function dfs (targetNode) {
    const newNode = new Node(targetNode.val)
    visited.set(targetNode, newNode);
    (targetNode.neighbors || []).forEach(neighborNode => {
      if(!visited.has(neighborNode)) {
        dfs(neighborNode)
      }
      newNode.neighbors.push(visited.get(neighborNode))
    })
  }
  dfs(node)
  return visited.get(node)
};

// BFS
var cloneGraph = function(node) {
  if(!node) return 
  const visited = new Map()
  const q = [node]
  visited.set(node, new Node(node.val));
  while(q.length) {
    const targetNode = q.shift();
    (targetNode.neighbors || []).forEach(neighborNode => {
      if(!visited.has(neighborNode)) {
        q.push(neighborNode)
        visited.set(neighborNode, new Node(neighborNode.val))
      }
      visited.get(targetNode).neighbors.push(visited.get(neighborNode))
    })
  }
  return visited.get(node)
};
```

## ?🌟😻✔ 135 分发糖果【hard】

[ref](https://leetcode.cn/problems/candy/)

贪心

![](https://qiniu1.lxfriday.xyz/feoffer/1653173511115_0db6c0f3-47bc-4bf7-8a84-ed7366d2f8ca.png)

给任何一个人发糖果都要考虑这个人和他左右两边人的发糖果数量。

- -> 从左往右看，如果右边人的评分大于左边，则右边人糖果的数量一定是大于左边人的，如果左边人糖果数最少为 l1，右边人糖果最少数则为 l1 + 1
  - 如果右边人的评分小于等于左边人，则右边人糖果数可以设为 1
- <- 从右往左看，如果左边人的评分大于右边，则左边人糖果的数量一定是大于右边人的，如果右边人糖果数最少为 r1，则左边人糖果数最少则为 r1 + 1
  - 如果左边人的评分小于等于右边人，则左边人糖果数可以设为 1


对于任意挨着的两个人，如果其评分分别为 `rate1 < rate2`，且 rate1 在 rate2 左边，则存在下面的关系：

- 第1个人糖果数：从左往右为 `l1`，从右往左为 `1`，其中 `l1 >= 1`
- 第2个人糖果数：从左往右为 `l1 + 1`，从右往左为 `r2`，其中 `l2 >= 1`

则必然会有这个关系存在 `max(l1, 1) < max(l1 + 1, l2)`

因为 `l1 >= 1`，则推出 `max(l1, 1) = l1`，而 `max(l1 + 1, l2) >= l1 + 1`，故 `max(l1 + 1, l2) > l1 = max(l1, 1)`

综合上述的推论就可以知道，只需要从左往右和从右往左扫描评分数组两次，然后综合每个位置上两个方向所需要的最小糖果数，就可以得到总的最少糖果数。

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var candy = function(ratings) {
  const len = ratings.length
  const leftDp = []
  const rightDp = []
  let sum = 0
  for(let i=0;i<len;i++) {
    if(i - 1 >= 0 && ratings[i] > ratings[i - 1]) {
      leftDp[i] = leftDp[i - 1] + 1
    } else {
      leftDp[i] = 1
    }
  }
  for(let i=len-1;i>=0;i--) {
    if(i + 1 < len && ratings[i] > ratings[i + 1]) {
      rightDp[i] = rightDp[i + 1] + 1
    }else {
      rightDp[i] = 1
    }
    sum += Math.max(leftDp[i], rightDp[i])
  }
  return sum
};
```

## ✔ 136 只出现一次的数字【easy】

[ref](https://leetcode.cn/problems/single-number/)

```js
// 要求时间空间复杂度是：O(n) O(1)
var singleNumber = function(nums) {
  let res = 0
  for(let i = 0; i < nums.length; i++) {
    res ^= nums[i]
  }
  return res
};
```

## 😻✔ 139 单词拆分【medium】

[ref](https://leetcode.cn/problems/word-break/)

动态规划

```js
// 动态规划
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var wordBreak = function(s, wordDict) {
  const wordSet = new Set(wordDict)
  const sLen = s.length
  const dp = new Array(sLen).fill(false)
  
  for(let i=0;i<sLen;i++) {
    for(let j=i; j>=0; j--) {
      if(wordSet.has(s.slice(j, i + 1))) {
        dp[i] = dp[i] || (j - 1 >= 0 ? dp[j - 1] : true)
      }
    }
  }

  return dp[sLen - 1]
};
```

## 😻✔ 141 环形链表【easy】

[ref](https://leetcode.cn/problems/linked-list-cycle/)

环形链表，双指针，快慢指针

```js
var hasCycle = function (head) {
  let p1 = head
  let p2 = head
  while (p2 && p2.next) {
    p1 = p1.next
    p2 = p2.next.next
    if (p1 === p2) return true
  }

  return false
}
```

## ??🌟😻✔ 142 环形链表 II【medium】

[ref](https://leetcode.cn/problems/linked-list-cycle-ii/)

链表、快慢指针、双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var detectCycle = function(head) {
  const myHead = new ListNode()
  myHead.next = head
  let slow = myHead, fast = myHead
  while(fast.next && fast.next.next) {
    slow = slow.next
    fast = fast.next.next
    if(slow === fast) {
      slow = slow.next
      let t = head
      while(t !== slow) {
        t = t.next
        slow = slow.next
      }
      return t
    }
  }
  return null
};
```

集合解法

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var detectCycle = function(head) {
  const s = new Set()
  while(head) {
    if(s.has(head)) return head
    s.add(head)
    head = head.next
  }
  return null
};
```

## ?🌟😻✔ 143 重排链表【medium】

[ref](https://leetcode.cn/problems/reorder-list/)

```js
// 快慢指针+链表反转
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var reorderList = function(head) {
  const beginNode = new ListNode()
  let tHead = beginNode
  let fast = beginNode
  let slow = beginNode
  beginNode.next = head
  while(fast.next && fast.next.next && slow.next) {
    slow = slow.next
    fast = fast.next.next
  }
  let left = head
  let right = slow.next
  slow.next = null
  right = reverse(right)
  while(left) {
    const lNode = left
    const rNode = right
    left = left.next
    right = right.next

    tHead.next = lNode
    lNode.next = rNode
    tHead = tHead.next.next
  }
  if(right) {
    tHead.next = right
    tHead = tHead.next
  }
  tHead.next = null
};

function reverse(head) {
  const myHead = new ListNode()
  while(head) {
    const prev = myHead.next
    const target = head
    head = head.next
    target.next = prev
    myHead.next = target
  }
  return myHead.next
}
```

```js
// 用数组存储节点，然后操作
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var reorderList = function(head) {
  let tHead = head
  let myHead = new ListNode()
  const leftNodes = []
  const rightNodes = []
  let count = 0
  while(tHead) {
    leftNodes.push(tHead)
    rightNodes.unshift(tHead)
    tHead = tHead.next
    count++
  }
  let showUseLeftNodes = true
  let leftIndex = 0
  let rightIndex = 0
  while(count > 0) {
    if(showUseLeftNodes) {
      myHead.next = leftNodes[leftIndex++]
      showUseLeftNodes = false
    } else {
      myHead.next = rightNodes[rightIndex++]
      showUseLeftNodes = true
    }
    myHead = myHead.next
    count--
  }
  myHead.next = null
};
```

```js
// 提取数字，然后进行重新赋值，不符合题目要求
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var reorderList = function(head) {
  const nums = []
  const reverseNums = []
  const resNums = []
  let tHead = head
  
  while(tHead) {
    nums.push(tHead.val)
    reverseNums.unshift(tHead.val)
    tHead = tHead.next
  }
  const len = nums.length
  let showAddReverse = false
  while(resNums.length < len) {
    if(!showAddReverse) {
      resNums.push(nums.shift())
      showAddReverse = true
    } else {
      resNums.push(reverseNums.shift())
      showAddReverse = false
    }
  }
  tHead = head
  let i = 0
  while(tHead) {
    tHead.val = resNums[i++]
    tHead = tHead.next
  }
};
```

## 😻✔ 146 LRU 缓存【medium】

[ref](https://leetcode.cn/problems/lru-cache/)

```js
var LRUCache = function(capacity) {
  this.capacity = capacity
  this.cache = new Map()
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if(!this.cache.has(key)) {
    return -1
  }
  const value = this.cache.get(key)
  this.moveToEnd(key, value)
  return value
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if(this.cache.has(key)) {
    this.cache.delete(key)
  } else if(this.cache.size === this.capacity) {
    this.cache.delete(this.cache.keys().next().value)
  }
  this.cache.set(key, value)
};

LRUCache.prototype.moveToEnd = function(key, value) {
  this.cache.delete(key)
  this.cache.set(key, value)
};
```

## ?🌟😻✔ 148 排序链表【medium】

[ref](https://leetcode.cn/problems/sort-list/)

链表归并排序

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var sortList = function(head) {
  const tHead = new ListNode()
  tHead.next = head
  let slow = tHead
  let fast = tHead
  while(fast.next && fast.next.next) {
    slow = slow.next
    fast = fast.next.next
  }
  if(slow === fast) return head
  const next = slow.next
  slow.next = null
  return merge(sortList(tHead.next), sortList(next))
};

function merge(list1, list2) {
  const myHead = new ListNode()
  let tHead = myHead
  while(list1 && list2) {
    if(list1.val < list2.val) {
      tHead.next = list1
      list1 = list1.next
    } else {
      tHead.next = list2
      list2 = list2.next
    }
    tHead = tHead.next
  }
  if(list1) {
    tHead.next = list1
  }
  if(list2) {
    tHead.next = list2
  }
  return myHead.next
}
```

## ??🌟😻✔ 207 课程表【medium】

[ref](https://leetcode.cn/problems/course-schedule/)

图、拓扑

```js
// 其中 N 为课程数，M 为先修课程的要求数
// 时间复杂度：O(M + N)
// 空间复杂度：O(M + N)
var canFinish = function(numCourses, prerequisites) {
  const n = prerequisites.length
  const pre = new Array(numCourses).fill(0)
  const aft = new Map()
  let count = 0
  for(let i=0;i<n;i++) {
    const target = prerequisites[i]
    pre[target[0]]++
    if(aft.has(target[1])) {
      aft.get(target[1]).push(target[0])
    } else {
      aft.set(target[1], [target[0]])
    }
  }
  let q = []
  for(let i=0;i<pre.length;i++) {
    if(pre[i] === 0) q.push(i)
  }

  while(q.length) {
    const target = q.shift()
    count ++
    const next = aft.get(target)

    if(next && next.length > 0) {
      for(let i=0;i<next.length;i++) {
        pre[next[i]]--
        if(pre[next[i]] === 0) {
          q.push(next[i])
        }
      }
    }
  }
  return count === numCourses
};

```

## 🌟😻✔ 151. 颠倒字符串中的单词【medium】

[ref](https://leetcode.cn/problems/reverse-words-in-a-string/)

```js
var reverseWords = function(s) {
    return s.trim().split(/\s+/).reverse().join(' ');
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var reverseWords = function(s) {
  const arr = s.split(' ').reverse()
  let res = ''
  for(let i=0;i<arr.length;i++) {
    if(arr[i] !== '') {
      if(!res.length) {
        res = arr[i]
      } else {
        res += (' ' + arr[i])
      }
    }
  }
  return res
};
```

## ??🌟😻✔ 152 乘积最大子数组【medium】

[ref](https://leetcode.cn/problems/maximum-product-subarray/)


动态规划

```js
// 数组版
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProduct = function(nums) {
  const len = nums.length
  const dpMax = [nums[0]]
  const dpMin = [nums[0]]
  for(let i=1;i<len;i++) {
    // 以 i 为结尾的非空连续子数组
    dpMax[i] = Math.max(nums[i], nums[i] * dpMax[i-1], nums[i] * dpMin[i-1])
    dpMin[i] = Math.min(nums[i], nums[i] * dpMax[i-1], nums[i] * dpMin[i-1])
  }
  return Math.max(...dpMax)
};
```

```js
// 空间复杂度优化版
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProduct = function(nums) {
  const len = nums.length
  let prevMax = nums[0]
  let prevMin = nums[0]
  let res = prevMax
  for(let i=1;i<len;i++) {
    // 以 i 为结尾的非空连续子数组
    const tmpPrevMax = prevMax
    const tmpPrevMin = prevMin

    prevMax = Math.max(nums[i], nums[i] * tmpPrevMax, nums[i] * tmpPrevMin)
    prevMin = Math.min(nums[i], nums[i] * tmpPrevMax, nums[i] * tmpPrevMin)
    res = Math.max(res, prevMax)
  }
  return res
};
```

## 🌟😻✔ 153 寻找旋转排序数组中的最小值【medium】

[ref](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

二分搜索

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var findMin = function(nums) {
  let l = 0,r = nums.length - 1
  const max = nums[nums.length - 1]
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] < max) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return nums[l]
};
```

## ?🌟😻✔ 154 寻找旋转排序数组中的最小值 II【hard】

[ref](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

二分搜索

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findMin = function(nums) {
  const len = nums.length
  let l = 0,r = len - 1
  let rMax = nums[r]
  while(nums[l] === nums[r]) {
    l++
  }
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] <= rMax) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return nums[r]
};
```

## ?🌟😻✔ 160 相交链表【easy】

[ref](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

```js
// 时间复杂度：O(M + N)
// 空间复杂度：O(1)
var getIntersectionNode = function(headA, headB) {
  let pA = headA
  let pB = headB
  while(pA !== pB) {
    pA = pA !== null ? pA.next : headB
    pB = pB !== null ? pB.next : headA
  }
  return pA
};
```

## ?🌟😻✔ 162 寻找峰值【medium】

[ref](https://leetcode.cn/problems/find-peak-element/)

二分法

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var findPeakElement = function(nums) {
  let l = 0
  let r = nums.length - 1
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] < nums[mid + 1]) {
      l = mid + 1
    } else {
      r = mid
    }
  }
  return l
};
```

## ✔ 165 比较版本号【medium】

[ref](https://leetcode.cn/problems/compare-version-numbers/)

```js
var compareVersion = function(version1, version2) {
  // 去除前导零
  let v1Arr = version1.split('.').map(_ => parseInt(_, 10))
  let v2Arr = version2.split('.').map(_ => parseInt(_, 10))
  // 补齐数组长度
  if(v1Arr.length > v2Arr.length) {
    v2Arr = v2Arr.concat(new Array(v1Arr.length - v2Arr.length).fill(0))
  } else {
    v1Arr = v1Arr.concat(new Array(v2Arr.length - v1Arr.length).fill(0))
  }
  for(let i=0;i<v1Arr.length;i++) {
    if(v1Arr[i] < v2Arr[i]) return -1
    else if(v1Arr[i] > v2Arr[i]) return 1
  }
  return 0
};

```

## ✔ 167 两数之和 II - 输入有序数组【medium】

[ref](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var twoSum = function(numbers, target) {
  let l = 0, r = numbers.length - 1
  while(l<r) {
    let s = numbers[l] + numbers[r]
    if(s === target) {
      return [l + 1, r + 1]
    } else if(s > target) {
      r--
    } else {
      l++
    }
  }
};
```

## ✔ 169 多数元素【easy】

[ref](https://leetcode.cn/problems/majority-element/)

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var majorityElement = function(nums) {
  const map = new Map()
  const len = nums.length
  for(let i=0;i<len;i++) {
    map.set(nums[i], map.has(nums[i])? map.get(nums[i]) + 1: 1)
    if(map.get(nums[i]) > len / 2) return nums[i] 
  }
};
```

## ?🌟😻✔ 179 最大数【medium】

[ref](https://leetcode.cn/problems/largest-number/)

数学理论

```js
var largestNumber = function(nums) {
  nums.sort((x, y) => (String(y) + String(x)) - (String(x) + String(y)))
  if (nums[0] === 0) return '0'
  return nums.join('');
};
```

## 🌟😻✔ 186. 翻转字符串里的单词 II【medium】

[ref](https://leetcode.cn/problems/reverse-words-in-a-string-ii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var reverseWords = function(s) {
  function reverse(i, j) {
    while(i < j) {
      const t = s[i]
      s[i] = s[j]
      s[j] = t
      i++
      j--
    }
  }

  reverse(0, s.length - 1)

  let l = 0

  for(let i=0;i<s.length;i++) {
    if(s[i] === ' ') {
      reverse(l, i - 1)
      l = i + 1
    }
    if(i === s.length - 1) {
      reverse(l, i)
    }
  }

  return s
};
```

## ??🌟😻✔ 188 买卖股票的最佳时机 IV【hard】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

动态规划

```js
// 时间复杂度：O(KN)
// 空间复杂度：O(KN)
var maxProfit = function(k, prices) {
  if(prices.length < 2) return 0
  const n = prices.length
  const buyDp = new Array(n).fill(0).map(_ => new Array(k + 1).fill(0))
  const sellDp = new Array(n).fill(0).map(_ => new Array(k + 1).fill(0))
  for(let j=0;j<=k;j++) {
    buyDp[0][j] = -prices[0]
  }
  for(let i=1;i<n;i++) {
    buyDp[i][0] = Math.max(-prices[i], buyDp[i-1][0])
  }

  for(let i = 1; i < n; i++) {
    for(let j = 1; j <= k; j++) {
      buyDp[i][j] = Math.max(buyDp[i-1][j], -prices[i] + sellDp[i-1][j])
      sellDp[i][j] = Math.max(sellDp[i-1][j], prices[i] + buyDp[i-1][j-1])
    }
  }

  return Math.max(...sellDp[n-1])
};
```

```js
// 时间复杂度：O(n*k)
// 空间复杂度：O(n*k)
var maxProfit = function(k, prices) {
  if(prices.length < 1) return 0
  const dp = new Array(prices.length).fill('').map(_ => new Array(2 * k + 1).fill(0))
  for(let j = 1;j <= k; j++) {
    dp[0][2 * j - 1] = -prices[0]
  }
  for(let i = 1; i < prices.length; i++) {
    for(let j = 1;j <= 2 * k; j++) {
      const isOdd = j % 2 === 1
      dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - 1] + (isOdd? - prices[i] : prices[i]))
    }
  }
  return Math.max(...dp[prices.length - 1])
};
```

## ?🌟😻✔ 189 轮转数组【medium】

[ref](https://leetcode.cn/problems/rotate-array/)

数组轮转、数组原地操作、规律题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var rotate = function(nums, k) {
  const n = nums.length
  k = k % n
  reverse(nums, 0, n - 1)
  reverse(nums, 0, k - 1)
  reverse(nums, k, n - 1)
};

function reverse(arr, i, j) {
  while(i < j) {
    const t = arr[i]
    arr[i] = arr[j]
    arr[j] = t
    i++
    j--
  }
}

// n = 8, k = 5
// [1,2,3,4,5,6,7,8] 
// [6,2,3,4,5,1,7,8] 
// [3,2,6,4,5,1,7,8] 
// [8,2,6,4,5,1,7,3] 
// [5,2,6,4,8,1,7,3] 
// [2,5,6,4,8,1,7,3] 
// [7,5,6,4,8,1,2,3] 
// [4,5,6,7,8,1,2,3] 

// n = 7, k = 3
// [1,2,3,4,5,6,7] 
// [4,2,3,1,5,6,7] 
// [7,2,3,1,5,6,4] 
// [3,2,7,1,5,6,4] 
// [6,2,7,1,5,3,4] 
// [2,6,7,1,5,3,4] 
// [5,6,7,1,2,3,4] 
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var rotate = function(nums, k) {
  const len = nums.length
  k = k % len
  let count = 0
  for(let i=0;i<len;i++) {
    let prevI = (i + k) % len
    let prevV = nums[prevI]
    nums[prevI] = nums[i]
    count++
    while(prevI !== i) {
      const targetI = (prevI + k) % len
      const targetV = nums[targetI]
      nums[targetI] = prevV
      prevI = targetI
      prevV = targetV
      count++
      if(count === len) return
    }
  }
};
```

## 😻✔ 198 打家劫舍【medium】

[ref](https://leetcode.cn/problems/house-robber/)

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var rob = function(nums) {
  if(nums.length === 1) return nums[0]
  if(nums.length === 2) return Math.max(nums[0], nums[1])
  let d0 = nums[0]
  let d1 = Math.max(nums[0], nums[1])
  for(let i = 2;i < nums.length; i++) {
    const t = d1
    d1 = Math.max(d0 + nums[i], d1)
    d0 = t
  }
  return d1
};
```
or
```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var rob = function(nums) {
  const dp = []
  dp[0] = nums[0]
  dp[1] = Math.max(nums[0], nums[1])
  for(let i = 2;i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1])
  }
  return dp[nums.length - 1]
};
```

## 😻✔ 199 二叉树的右视图【medium】

[ref](https://leetcode.cn/problems/binary-tree-right-side-view/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var rightSideView = function(root) {
  if(!root) return []
  const res = []
  let q = [root]
  let tmpQ = []

  while(q.length) {
    const node = q.pop()
    node.left && tmpQ.unshift(node.left)
    node.right && tmpQ.unshift(node.right)
    if(!q.length) {
      res.push(node.val)
      q = [...tmpQ]
      tmpQ = []
    }
  }

  return res
};
```

## 😻✔ 200 岛屿数量【medium】

[ref](https://leetcode.cn/problems/number-of-islands/)

深度优先搜索

```js
// 贪心标记法，DFS
// 时间复杂度：O(M*N)
// 空间复杂度：O(M*N)
var numIslands = function(grid) {
  const m = grid.length
  const n = grid[0].length
  let count = 0
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(used[i][j]) continue
      if(grid[i][j] === "1") {
        count++
        walk(i, j)
      }
    }
  }

  function walk(i, j) {
    if(used[i][j]) return
    if(grid[i][j] === "1") {
      used[i][j] = true
    } else {
      return  
    }
    (i - 1 >= 0) && walk(i - 1, j);
    (i + 1 <  m) && walk(i + 1, j);
    (j - 1 >= 0) && walk(i, j - 1);
    (j + 1 < n) && walk(i, j + 1);
  }

  return count
};
```

## ✔ 202 快乐数【easy】

[ref](https://leetcode.cn/problems/happy-number/)

```js
var isHappy = function(n) {
  const set = new Set()
  while(true) {
    let newN = 0
    n.toString().split('').forEach(v => {
      newN += Number(v) ** 2
    })
    if(newN === 1) {
      return true
    } else if(set.has(newN)) {
      return false
    } else {
      set.add(newN)
      n = newN
    }
  }
};

```

## ?🌟😻✔ 204 计数质数【medium】

[ref](https://leetcode.cn/problems/count-primes/)

埃氏筛法、质数统计

```js
var countPrimes = function(n) {
  let count = 0
  const p = new Array(n).fill(true)
  for(let i=2;i<n;i++) {
    if(p[i]) {
      count++
      for(let j = i * i;j<n;j += i) {
        p[j] = false
      }
    }
  }
  return count
};
 
```

## 🌟😻✔ 206 反转链表【easy】

[ref](https://leetcode.cn/problems/reverse-linked-list/)

链表

```js
var reverseList = function (head) {
  const t = new ListNode()
  while(head) {
    const prev = t.next
    t.next = head
    head = head.next
    t.next.next = prev
  }
  return t.next
```

## ??🌟😻✔ 208 实现 Trie (前缀树)【medium】

[ref](https://leetcode.cn/problems/implement-trie-prefix-tree/)

前缀树、字典树、trie

```js
var Trie = function() {
  this.tree = new TrieNode()
};

/** 
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function(word) {
  let curr = this.tree
  for(let i=0;i<word.length;i++) {
    const c = word[i]
    if(!curr[c]) {
      curr[c] = new TrieNode(c)
    }
    if(i === word.length - 1) {
      curr[c].isEnd = true
    }
    curr = curr[c]
  }
};

/** 
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function(word) {
  let curr = this.tree
  for(let i=0;i<word.length;i++) {
    const c = word[i]
    if(!curr[c]) return false
    curr = curr[c]
    if(i === word.length - 1) {
      return !!curr.isEnd
    }
  }
};

/** 
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function(prefix) {
  let curr = this.tree
  for(let i=0;i<prefix.length;i++) {
    const c = prefix[i]
    if(!curr[c]) return false
    curr = curr[c]
  }
  return true
};

class TrieNode {
  constructor(val, isEnd = false) {
    this.val = val
    this.isEnd = isEnd
  }
}
```

## 😻✔ 209 长度最小的子数组【medium】

[ref](https://leetcode.cn/problems/minimum-size-subarray-sum/)

滑动窗口


```js
// 双指针滑动窗口
// 时间复杂度：O(N) start end 最多移动 N 次
// 空间复杂度：O(1)
var minSubArrayLen = function(target, nums) {
  const len = nums.length
  let sum = 0
  let min = Number.MAX_SAFE_INTEGER
  for(let start=0,end=0;end<len;end++) {
    sum+=nums[end]
    while(sum>=target) {
      min = Math.min(end - start + 1, min)
      sum-=nums[start]
      start++
    }
  }
  return min === Number.MAX_SAFE_INTEGER ? 0 : min
};
```

```js
// 暴力解法
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var minSubArrayLen = function(target, nums) {
  let min = Number.MAX_SAFE_INTEGER
  for(let i=0;i<nums.length;i++) {
    let sum = 0
    for(let j=i;j>=0;j--) {
      sum += nums[j]
      if(sum >= target) {
        min = Math.min(min, i - j + 1)
        break
      }
    }
  }
  return min === Number.MAX_SAFE_INTEGER ? 0 : min
};
```

## ??🌟😻✔ 210 课程表 II【medium】

[ref](https://leetcode.cn/problems/course-schedule-ii/)

拓扑排序、图

```js
var findOrder = function(numCourses, prerequisites) {
  const pre = new Array(numCourses).fill(0)
  const aft = new Map()
  for(let i=0;i<prerequisites.length;i++) {
    const target = prerequisites[i]
    pre[target[0]]++
    if(aft.has(target[1])) {
      aft.get(target[1]).push(target[0])
    } else {
      aft.set(target[1], [target[0]])
    }
  }
  const q = []
  for(let i=0;i<pre.length;i++) {
    if(pre[i] === 0) q.push(i)
  }
  let count = 0
  const res = []
  while(q.length) {
    const target = q.shift()
    count++
    res.push(target)
    const next = aft.get(target)
    if(next && next.length) {
      for(let i=0;i<next.length;i++) {
        pre[next[i]]--
        if(pre[next[i]] === 0) {
          q.push(next[i])
        }
      }
    }
  }
  return count === numCourses ? res : []
};
```

## ?? 🌟😻✔ 211 添加与搜索单词 - 数据结构设计【medium】

[ref](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

字典树

![时空复杂度](http://qiniu1.lxfriday.xyz/feoffer/1659318737209_acbeaa0b-3502-4808-92de-623f0224d55a.png)

```js
var WordDictionary = function() {
  this.tree = new TrieNode()
};

/** 
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function(word) {
  let curr = this.tree
  for(let i=0;i<word.length;i++) {
    const c = word[i]
    if(!curr[c]) {
      curr[c] = new TrieNode(c)
    }
    if(i === word.length - 1) {
      curr[c].end = true
    }
    curr = curr[c]
  }
};

/** 
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function(word) {
  function searchFrom(curr, startIndex) {
    if(startIndex >= word.length) return curr.end
    const c = word[startIndex]
    if(c === '.') {
      // 只搜有的 key 不泛化的搜索 a-z
      for(let key of Object.keys(curr)) {
        if(key === 'val' || key === 'end') continue
        if(searchFrom(curr[key], startIndex + 1)) {
          return true
        }
      }
      return false
    } else if(curr[c] && curr[c].val === c) {
      return searchFrom(curr[c], startIndex + 1)
    }
    return false
  }
  return searchFrom(this.tree, 0)
};



/**
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */

class TrieNode {
  constructor(val) {
    this.val = val
    this.end = false
  }
}
```

## 🌟😻✔ 213 打家劫舍 II【medium】

[ref](https://leetcode.cn/problems/house-robber-ii/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var rob = function(nums) {
  const len = nums.length
  if(len === 1) return nums[0]
  const dp1 = new Array(len).fill(0)
  const dp2 = new Array(len - 1).fill(0)
  dp1[0] = nums[0]
  dp1[1] = Math.max(nums[0], nums[1])
  dp2[0] = nums[1]
  for(let i=2;i<len;i++) {
    dp1[i] = Math.max(dp1[i - 1], (i - 2 >=0 ? dp1[i - 2] : 0) + nums[i])
    dp2[i-1] = Math.max(dp2[i - 2], (i - 3 >=0 ? dp2[i - 3] : 0) + nums[i])
  }
  return Math.max(dp1[len - 2], dp2[len - 2])
};
```

## 🌟😻✔ 215 数组中的第K个最大元素【medium】

[ref](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

堆、小顶堆、第K大、大顶堆

```js
 // 小顶堆解法
 // 时间复杂度：O(nlogn)
 // 空间复杂度：O(logn)
var findKthLargest = function(nums, k) {
  const heap = new MinHeap()

  nums.forEach(n => {
      heap.insert(n)
    if(heap.size() > k) {
      heap.pop()
    }
  })
  return heap.peek()
};

class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    this.heap.pop()
    this.shiftDown(0)
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i] > this.heap[left]) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i] > this.heap[right]) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex] > this.heap[i]) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

```js
// 大顶堆解法
// 时间复杂度：O(nlogn)
// 空间复杂度：O(logn)
var findKthLargest = function(nums, k) {
  const maxHeap = new MaxHeap(k)
  for(let n of nums) {
    maxHeap.insert(n)
  }
  while (k > 1) {
    maxHeap.pop()
    k--
  }
  return maxHeap.peek()
};
// 大顶堆法，从大顶堆执行 pop() k - 1 次，则数组首个就是第 k 大
class MaxHeap{
  constructor() {
    this.heap = []
  }
  insert(n) {
    this.heap.push(n)
    this.up(this.heap.length - 1)
  }
  pop() {
    const target = this.heap[0]
    swap(this.heap, 0, this.heap.length - 1)
    this.heap.pop()
    this.down(0)
    return target
  }
  peek() {
    return this.heap[0]
  }
  get size () {
    return this.heap.length
  }
  up(index) {
    const parentIndex = Math.floor((index - 1) / 2)
    if(this.heap[index] > this.heap[parentIndex]) {
      swap(this.heap, index, parentIndex)
      this.up(parentIndex)
    }
  }
  down(index) {
    const lIndex = 2 * index + 1
    const rIndex = 2 * index + 2
    if(this.heap[index] < this.heap[lIndex]) {
      swap(this.heap, lIndex, index)
      this.down(lIndex)
    }
    if(this.heap[index] < this.heap[rIndex]) {
      swap(this.heap, rIndex, index)
      this.down(rIndex)
    }
  }
}
function swap(arr, i, j) {
  let t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

更优解、也是用大顶堆，但是没有创建新数组

```js
// 时间复杂度：O(nlogn)
// 空间复杂度：O(logn)
var findKthLargest = function(nums, k) {
  const len = nums.length
  buildMaxHeap(nums)
  for(let i = 0;i < k - 1; i++) {
    swap(nums, 0, len - 1 - i)
    maxHeapify(nums, 0, len - 2 - i)
  }
  return nums[0]
};

function buildMaxHeap(nums) {
  const len = nums.length
  for(let i = Math.floor(len / 2); i >= 0 ; i--) {
    maxHeapify(nums, i, len - 1)
  }
}

function maxHeapify(nums, i, endIndex) {
  const lIndex =  2 * i + 1
  const rIndex =  2 * i + 2
  if(lIndex <= endIndex && nums[i] < nums[lIndex]) {
    swap(nums, i, lIndex)
    maxHeapify(nums, lIndex, endIndex)
  }
  if(rIndex <= endIndex && nums[i] < nums[rIndex]) {
    swap(nums, i, rIndex)
    maxHeapify(nums, rIndex, endIndex)
  }
}

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

## ✔ 217 存在重复元素【easy】

[ref](https://leetcode.cn/problems/contains-duplicate/)

```js
var containsDuplicate = function(nums) {
  return [...new Set(nums)].length !== nums.length
};
```

## ?🌟😻✔ 221 最大正方形【medium】

[ref](https://leetcode.cn/problems/maximal-square/)

动态规划

```js
// 时间复杂度：O(M*N)
// 空间复杂度：O(M*N)
var maximalSquare = function(matrix) {
  const m = matrix.length
  const n = matrix[0].length
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  let max = 0

  for(let i = 1;i<m;i++) {
    dp[i][0] = parseInt(matrix[i][0], 10)
    max = Math.max(max, dp[i][0])
  }

  for(let j = 0;j<n;j++) {
    dp[0][j] = parseInt(matrix[0][j], 10)
    max = Math.max(max, dp[0][j])
  }

  for(let i = 1;i<m;i++) {
    for(let j = 1;j<n;j++) {
      if(matrix[i][j] === '1') {
        dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1
        max = Math.max(dp[i][j], max)
      }
    }
  }
  return max * max
};
````

## ?🌟😻✔ 224 基本计算器【hard】

[ref](https://leetcode.cn/problems/basic-calculator/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var calculate = function(s) {
  const len = s.length
  const signs = [1]
  let sign = 1
  let i=0
  let ret = 0
  while(i<len) {
    if(s[i] === ' ') {
      i++
    } else if(s[i] === '(') {
      signs.push(sign)
      i++
    } else if(s[i] === ')') {
      signs.pop()
      i++
    } else if(s[i] === '+') {
      sign = signs[signs.length - 1]
      i++
    } else if(s[i] === '-') {
      sign = -signs[signs.length - 1]
      i++
    } else {
      let num = 0
      while(i < len && !isNaN(Number(s[i])) && s[i] !== ' ') {
        num = 10 * num + Number(s[i])
        i++
      }
      ret += sign * num
    }
  }
  return ret
};
```

## ?🌟😻✔ 225 用队列实现栈【easy】

[ref](https://leetcode.cn/problems/implement-stack-using-queues/)

相关

- [232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

```js
var MyStack = function() {
  this.q = []
  this.preq = []
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
  this.preq.push(x)
  while(this.q.length){
    this.preq.push(this.q.shift())
  }
  while(this.preq.length){
    this.q.push(this.preq.shift())
  }
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
  return this.q.shift()
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
  return this.q[0]
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
  return !this.q.length && !this.preq.length
};
```

## 😻✔ 226 翻转二叉树【easy】

[ref](https://leetcode.cn/problems/invert-binary-tree/)

翻转二叉树实际就是把每个节点的子树全部翻转一次

二叉树、二叉树翻转、翻转二叉树、堆

```js
// 时间复杂度：O(n) 每个节点都访问到了
// 空间复杂度：O(h) h 是树的高度，h 最坏的情况是 n
var invertTree = function(root) {
  if(!root) return root
  return {
    val: root.val,
    left: invertTree(root.right),
    right: invertTree(root.left),
  }
};
``` 

解法2

```js
var invertTree = function(root) {
  if(!root) return root
  const head = new TreeNode(root.val)

  const dfs = (node, parent, isLeft) => {
    if(!node) return
    if(isLeft) {
      parent.right = new TreeNode(node.val)
      dfs(node.left, parent.right, true)
      dfs(node.right, parent.right, false)
    } else {
      parent.left = new TreeNode(node.val)
      dfs(node.left, parent.left, true)
      dfs(node.right, parent.left, false)
    }
  }

  dfs(root.left, head, true)
  dfs(root.right, head, false)

  return head
};
```

## ?🌟😻✔ 227. 基本计算器 II【medium】

[ref](https://leetcode.cn/problems/basic-calculator-ii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var calculate = function(s) {
  const len = s.length
  let sign = '+'
  let ret = 0
  let i = 0
  let tmp = 0
  while(i<len) {
    if(s[i] === ' ') {
      i++
    } else if (s[i] === '+') {
      sign = '+'
      ret += tmp
      tmp = 0
      i++
    } else if (s[i] === '-') {
      sign = '-'
      ret += tmp
      tmp = 0
      i++
    } else if (s[i] === '*') {
      sign = '*'
      i++
    } else if (s[i] === '/') {
      sign = '/'
      i++
    } else {
      let num = 0
      while(i < len && s[i] !== ' ' && !isNaN(Number(s[i]))) {
        num = num * 10 + Number(s[i])
        i++
      }
      if(sign === '+') {
        tmp = num
      } else if(sign === '-') {
        tmp = -num
      }else if(sign === '*') {
        tmp = tmp * num
      } else if(sign === '/') {
        tmp = tmp < 0 ?Math.ceil(tmp / num) : Math.floor(tmp / num)
      }
    }
  }
  ret += tmp
  return ret
};
```

## ?🌟😻✔ 230 二叉搜索树中第K小的元素【medium】

[ref](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

二叉搜索树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var kthSmallest = function(root, k) {
  let target
  function dfs(node, extraCount) {
    if(!node) return 0
    const leftCount = dfs(node.left, extraCount)
    const allCount = extraCount + leftCount + 1
    if(allCount === k) {
      target = node.val
    }
    const rightCount = dfs(node.right, allCount)
    return leftCount + 1 + rightCount
  }

  dfs(root, 0)
  return target
};
```

## ✔ 231 2 的幂【easy】

[ref](https://leetcode.cn/problems/power-of-two/)

```js
var isPowerOfTwo = function(n) {
  return n > 0 && (n & (n - 1)) === 0
};
```

## ✔ 232 用栈实现队列【easy】

[ref](https://leetcode.cn/problems/implement-queue-using-stacks/)

相关

- [225 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)


```js
var MyQueue = function() {
  this.stack = []
  this.prestack = []
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
  this.prestack.push(x)
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
  if(!this.stack.length) {
    while(this.prestack.length) {
      this.stack.push(this.prestack.pop())
    }
  }
  return this.stack.pop()
};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
  if(!this.stack.length) {
    while(this.prestack.length) {
      this.stack.push(this.prestack.pop())
    }
  }
  return this.stack[this.stack.length - 1]
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
  return !this.stack.length && !this.prestack.length
};
```


## 🌟😻✔ 235 二叉搜索树的最近公共祖先【easy】

[ref](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

二叉搜索树

```js
// 迭代
// 时间复杂度：O(N)
// 时间复杂度：O(1)
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  while(true) {
    if(root.val < p.val && root.val < q.val) {
      root = root.right
    } else if(root.val > p.val && root.val > q.val) {
      root = root.left
    } else {
      return root
    }
  }
};
```

```js
// 递归
var lowestCommonAncestor = function(root, p, q) {
  let min = Math.min(p.val, q.val)
  let max = Math.max(p.val, q.val)
  if(root.val < min) {
    return lowestCommonAncestor(root.right, p, q)
  } else if(root.val > max) {
    return lowestCommonAncestor(root.left, p, q)
  } else {
    return root
  }
};
```

## 🌟😻✔ 236 二叉树的最近公共祖先【medium】

[ref](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

二叉树

```js
// 时间复杂度:O(N)
// 空间复杂度:O(N)
var lowestCommonAncestor = function(root, p, q) {
  let target = root
  let targetDepth = 1
  function dfs(node, depth) {
    let count = 0
    if(node === p || node === q) {
      count ++
    }
    if(node.left) {
      count += dfs(node.left, depth + 1)
    }
    if(node.right) {
      count += dfs(node.right, depth + 1)
    }
    if(count === 2 && depth > targetDepth) {
      targetDepth = depth
      target = node
    }
    return count
  }
  dfs(root, 1)
  return target
};
```

## 🌟😻✔ 238 除自身以外数组的乘积【medium】

[ref](https://leetcode.cn/problems/product-of-array-except-self/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)  输出数组不计算在内
var productExceptSelf = function(nums) {
  const n = nums.length 
  let lm = 1
  let rm = 1
  const res = []
  for(let i=0;i<n;i++) {
    res[i] = lm
    lm *= nums[i]
  }
  for(let i=n-1;i>=0;i--) {
    res[i] = rm * res[i]
    rm *= nums[i]
  }
  return res
};

```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var productExceptSelf = function(nums) {
  const n = nums.length 
  const lp = []
  const rp = []
  let lm = 1
  let rm = 1
  const res = []
  for(let i=0;i<n;i++) {
    lp[i] = lm
    lm *= nums[i]
  }
  for(let i=n-1;i>=0;i--) {
    rp[i] = rm
    rm *= nums[i]
  }
  for(let i=0;i<n;i++) {
    res[i] = lp[i]*rp[i]
  }
  return res
};
```

## 🌟😻✔ 239 滑动窗口最大值【hard】

[ref](https://leetcode.cn/problems/sliding-window-maximum/)

优先队列、大顶堆、单调队列

```js
// 时间复杂度：O(nlogn)
// 空间复杂度：O(n)
var maxSlidingWindow = function(nums, k) {
  const len = nums.length
  const res = []
  const maxHeap = new MaxHeap()
  for(let i=0;i<k - 1;i++) {
    maxHeap.insert({
      index: i,
      val: nums[i]
    })
  }
  for(let i=k - 1;i<len;i++) {
    maxHeap.insert({
      index: i,
      val: nums[i]
    })
    while(maxHeap.peek().index < i + 1 - k) maxHeap.pop()
    res.push(maxHeap.peek().val)
  }
  return res
};

class MaxHeap {
  constructor() {
    this.heap = []
  }
  insert(target) {
    this.heap.push(target)
    this.shiftUp(this.size - 1)
  }
  pop() {
    this.swap(0, this.size - 1)
    this.heap.pop()
    this.shiftDown(0)
  }
  get size() {
    return this.heap.length
  }
  peek() {
    return this.heap[0]
  }
  shiftUp(i) {
    const parentIndex =  Math.floor((i - 1) / 2)
    if(parentIndex >= 0 && this.heap[parentIndex].val < this.heap[i].val) {
      this.swap(i, parentIndex)
      this.shiftUp(parentIndex)
    }
  }
  shiftDown(i) {
    const l = 2 * i + 1
    const r = 2 * i + 2
    let maxIndex = i
    if(l < this.size && this.heap[maxIndex].val < this.heap[l].val) {
      maxIndex = l
    }
    if(r < this.size && this.heap[maxIndex].val < this.heap[r].val) {
      maxIndex = r
    }
    if(maxIndex !== i) {
      this.swap(i, maxIndex)
      this.shiftDown(maxIndex)
    }
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
}
```

单调队列解法，比较难理解

```js
// 时间复杂度：O(n) 每个下标被放进队列1次，且出队列1次
// 空间复杂度：O(k) 
var maxSlidingWindow = function(nums, k) {
  const len = nums.length
  const q = []
  const res = []
  for(let i=0;i<k - 1;i++) {
    while(q.length && nums[q[q.length - 1]] <= nums[i]) {
      q.pop()
    }
    q.push(i)
  }
  for(let i=k - 1;i<len;i++) {
    while(q.length && nums[q[q.length - 1]] <= nums[i]) {
      q.pop()
    }
    q.push(i)
    while(q[0] < i - k + 1) {
      q.shift()
    }
    res.push(nums[q[0]])
  }
  return res
};
```

## 🌟😻✔ 240 搜索二维矩阵 II【medium】

[ref](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

```js
// 时间复杂度：O(m+n)
// 空间复杂度：O(1)
var searchMatrix = function(matrix, target) {
  const m = matrix.length, n = matrix[0].length
  let i = 0,j = n - 1
  while(i < m && j >=0) {
    if(matrix[i][j] === target) return true
    else if(target < matrix[i][j]) {
      j--
    } else {
      i++
    }
  }
  return false
};
```

## ✔ 252 会议室【easy】

[ref](https://leetcode.cn/problems/meeting-rooms/)

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var canAttendMeetings = function(intervals) {
  intervals.sort((a, b) => a[0] - b[0])
  for(let i=0;i<intervals.length - 1;i++) {
    if(intervals[i][1] > intervals[i+1][0]) return false
  }
  return true
};
```

## ?🌟😻✔ 253 会议室 II【medium】

[ref](https://leetcode.cn/problems/meeting-rooms-ii/)

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var minMeetingRooms = function(intervals) {
  const start = []  
  const end = []
  for(let i=0;i<intervals.length;i++) {
    start.push(intervals[i][0])
    end.push(intervals[i][1])
  }
  start.sort((a, b) => a - b)
  end.sort((a, b) => a - b)
  let max = 0
  let curr = 0

  while(start.length && end.length) {
    if(start[0] < end[0]) {
      curr++
      max = Math.max(max, curr)
      start.shift()
    } else {
      curr--
      end.shift()
    }
  }

  return max
};
```

## 🌟😻✔ 256 粉刷房子【medium】

[ref](https://leetcode.cn/problems/paint-house/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var minCost = function(costs) {
  let a = costs[0][0]
  let b = costs[0][1]
  let c = costs[0][2]
  for(let i=1;i<costs.length;i++) {
    const pa = a, pb = b, pc = c
    a = costs[i][0] + Math.min(pb, pc)
    b = costs[i][1] + Math.min(pa, pc)
    c = costs[i][2] + Math.min(pa, pb)
  }
  return Math.min(a, b, c)
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var minCost = function(costs) {
  const dp = new Array(costs.length).fill(0).map(_ => new Array(3).fill(0))
  dp[0][0] = costs[0][0]
  dp[0][1] = costs[0][1]
  dp[0][2] = costs[0][2]
  for(let i=1;i<costs.length;i++) {
    dp[i][0] = costs[i][0] + Math.min(dp[i-1][1], dp[i-1][2])
    dp[i][1] = costs[i][1] + Math.min(dp[i-1][0], dp[i-1][2])
    dp[i][2] = costs[i][2] + Math.min(dp[i-1][0], dp[i-1][1])
  }
  return Math.min(...dp[costs.length - 1])
};
```

## 🌟😻✔ 259 较小的三数之和【medium】

[ref](https://leetcode.cn/problems/3sum-smaller/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(logN)
var threeSumSmaller = function(nums, target) {
  const n = nums.length
  if(n < 3) return 0
  nums.sort((a, b) => a - b)
  let res = 0
  for(let i=0; i < n - 2; i++) {
    let l = i + 1, r = n - 1
    while(l < r) {
      const s = nums[i] + nums[l] + nums[r]
      if(s < target) {
        let tl = l
        while(tl < r && nums[i] + nums[tl] + nums[r] < target) {
          tl++
          res++
        }
        r--
      } else {
        r--
      }
    }
  }
  return res
};
```

## ✔ 263 丑数【easy】

[ref](https://leetcode.cn/problems/ugly-number/)

```js
var isUgly = function(n) {
  if(n === 0) return false
  if(n === 1) return true
  if(n % 2 === 0) return isUgly(n / 2)
  if(n % 3 === 0) return isUgly(n / 3)
  if(n % 5 === 0) return isUgly(n / 5)
  return false
};
```

## ?🌟😻✔ 264 丑数 II【medium】

[ref](https://leetcode.cn/problems/ugly-number-ii/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var nthUglyNumber = function(n) {
  const dp = new Array(n + 1).fill(1)
  let j2 = 1,j3 = 1,j5 = 1
  for(let i=2;i<=n;i++) {
    const v2 = dp[j2] * 2
    const v3 = dp[j3] * 3
    const v5 = dp[j5] * 5
    const min = Math.min(v2, v3, v5)

    if(min === v2) j2++
    if(min === v3) j3++
    if(min === v5) j5++
    dp[i] = min
  }

  return dp[n]
};
```

or 优先队列、小顶堆


```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var nthUglyNumber = function(n) {
  let c = 1
  n--
  const s = new Set()
  const minHeap = new MinHeap()
  while(n > 0) {
    if(!s.has(2 * c)) {
      s.add(2 * c)
      minHeap.insert(2 * c)
    }
    if(!s.has(3 * c)) {
      s.add(3 * c)
      minHeap.insert(3 * c)
    }
    if(!s.has(5 * c)) {
      s.add(5 * c)
      minHeap.insert(5 * c)
    }
    c = minHeap.pop()
    n--
  }
  return c
};

class MinHeap {
  constructor() {
    this.heap = []
  }
  insert(v){
    this.heap.push(v)
    this.shiftUp(this.heap.length - 1)
  }
  pop(){
    this.swap(0, this.heap.length - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  shiftUp(i){
    const parentIndex = Math.floor((i - 1) / 2)
    if(this.heap[i] < this.heap[parentIndex]) {
      this.swap(i, parentIndex)
      this.shiftUp(parentIndex)
    }
  }
  shiftDown(i){
    const leftIndex= 2 * i + 1
    const rightIndex= 2 * i + 2
    let minIndex = i
    if(this.heap[minIndex] > this.heap[leftIndex]) {
      minIndex = leftIndex
    }
    if(this.heap[minIndex] > this.heap[rightIndex]) {
      minIndex = rightIndex
    }
    if(minIndex !== i) {
      this.swap(i, minIndex)
      this.shiftDown(minIndex)
    }
  }
  swap(i,j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
}

```

## 🌟😻✔ 265 粉刷房子 II【hard】

[ref](https://leetcode.cn/problems/paint-house-ii/)

动态规划

极致优化方案

```js
// 时间复杂度：O(N*K)
// 空间复杂度：O(1)
var minCostII = function(costs) {
  const n = costs.length
  const k = costs[0].length
  let min1 = Number.MAX_SAFE_INTEGER, min1j = 0
  let min2 = Number.MAX_SAFE_INTEGER
  for(let j=0;j<k;j++) {
    if(costs[0][j] < min1) {
      min2 = min1
      min1 = costs[0][j]
      min1j = j
    } else if(costs[0][j] < min2) {
      min2 = costs[0][j]
    }
  }
  for(let i=1;i<n;i++) {
    let tmin1 = Number.MAX_SAFE_INTEGER, tmin1j = 0
    let tmin2 = Number.MAX_SAFE_INTEGER
    for(let j=0;j<k;j++) {
      let s
      if(j !== min1j) {
        s = costs[i][j] + min1
      } else {
        s = costs[i][j] + min2
      }
      if(s < tmin1) {
        tmin2 = tmin1
        tmin1 = s
        tmin1j = j
      } else if(s < tmin2) {
        tmin2 = s
      }
    }
    min1 = tmin1
    min1j = tmin1j
    min2 = tmin2
  }
  return min1
};

```

常规 dp

```js
// 时间复杂度：O(N*K^2)
// 空间复杂度：O(N*K)
var minCostII = function(costs) {
  const n = costs.length
  const k = costs[0].length
  const dp = new Array(n).fill(0).map(_ => new Array(k).fill(0))
  for(let j=0;j<k;j++) {
    dp[0][j] = costs[0][j]
  }
  for(let i=1;i<n;i++) {
    for(let j=0;j<k;j++) {
      let min = Number.MAX_SAFE_INTEGER
      for(let jj=0;jj<k;jj++) {
        if(jj !== j) {
          min = Math.min(min, dp[i-1][jj])
        }
      }
      dp[i][j] = costs[i][j] + min
    }
  }
  return Math.min(...dp[n-1])
};

```

## 🌟😻✔ 268 丢失的数字【easy】

[ref](https://leetcode.cn/problems/3sum-smaller/submissions/)

常规

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(logN)
var threeSumSmaller = function(nums, target) {
  const n = nums.length
  if(n < 3) return 0
  nums.sort((a, b) => a - b)
  let res = 0
  for(let i=0; i < n - 2; i++) {
    let l = i + 1, r = n - 1
    while(l < r) {
      const s = nums[i] + nums[l] + nums[r]
      if(s < target) {
        let tl = l
        while(tl < r && nums[i] + nums[tl] + nums[r] < target) {
          tl++
          res++
        }
        r--
      } else {
        r--
      }
    }
  }

  return res
};
```

二分

```js
// 时间复杂度：O(N^2*logN)
// 空间复杂度：O(logN)
var threeSumSmaller = function(nums, target) {
  const n = nums.length
  if(n < 3) return 0
  nums.sort((a, b) => a - b)
  let res = 0
  for(let i=0; i < n - 2; i++) {
    for(let j = i + 1;j<n-1;j++) {
      const t = target - nums[i] - nums[j]
      const ind = binarySearch(t, nums, j + 1, n - 1)
      res += ind - j
    }
  }

  return res
};

function binarySearch(t, nums, l, r) {
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] >= t) {
      r = mid - 1
    } else {
      l = mid + 1
    }
  }
  return l - 1
}

```


## 🌟😻✔ 276. 栅栏涂色【medium】

[ref](https://leetcode.cn/problems/paint-fence/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numWays = function(n, k) {
  let s = 0, nos = k
  for(let i=1;i<n;i++) {
    const ts = s, tnos = nos
    s = tnos
    nos = (ts + tnos) * (k - 1)
  }
  return s + nos
};
```

or

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var numWays = function(n, k) {
  const dp = new Array(n).fill(0).map(_ => new Array(2).fill(0))
  dp[0][0] = 0
  dp[0][1] = k
  for(let i=1;i<n;i++) {
    dp[i][0] = dp[i-1][1]
    dp[i][1] = (dp[i-1][0] + dp[i-1][1]) * (k - 1)
  }
  return dp[n-1][0] + dp[n-1][1]
};
```

## 🌟😻✔ 278 第一个错误的版本【easy】

[ref](https://leetcode.cn/problems/first-bad-version/)

二分查找

```js
var solution = function(isBadVersion) {
  /**
   * @param {integer} n Total versions
   * @return {integer} The first bad version
   */
  return function(n) {
      let r = n
      let l = 1
      while(l < r) {
        const mid = Math.floor((l + r) / 2)
        if(!isBadVersion(mid)) {
          l = mid + 1
        } else {
          r = mid
        }
      }
      return r
  };
};
```


## 🌟😻✔ 279 完全平方数【medium】

[ref](https://leetcode.cn/problems/perfect-squares/)

```js
var numSquares = function(n) {
  const dp = new Array(n + 1).fill(0)
  for(let i=0;i<=n;i++) {
    let min = i
    for(let j = 1;j * j <= i; j++) {
      min = Math.min(dp[i - j * j] + 1, min)
    }
    dp[i] = min
  }
  return dp[n]
};
```

## ✔ 283 移动零【easy】

[ref](https://leetcode.cn/problems/move-zeroes/)

数组

```js
var moveZeroes = function(nums) {
  let realIndex = 0
  for(let i=0;i<nums.length;i++) {
    if(nums[i] !== 0) {
      nums[realIndex++] = nums[i]
    }
  }
  while(realIndex<nums.length) {
    nums[realIndex++] = 0
  }
};
```

## ??🌟😻✔ 287 寻找重复数【medium】

[ref](https://leetcode.cn/problems/find-the-duplicate-number/)

双指针、快慢指针、环链表

参考
- [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findDuplicate = function(nums) {
  let slow = 0, fast = 0
  do {
    slow = nums[slow]
    fast = nums[nums[fast]]
  } while(slow !== fast)

  slow = 0
  while(slow !== fast) {
    slow = nums[slow]
    fast = nums[fast]
  }
  return slow
};
```

## ✔ 292 Nim 游戏【easy】

[ref](https://leetcode.cn/problems/nim-game/)

```js
var canWinNim = function(n) {
  return n % 4 === 0 ? false : true
};
```

## ?🌟😻✔ 295 数据流的中位数【hard】

[ref](https://leetcode.cn/problems/find-median-from-data-stream/)

优先队列、大顶堆、小顶堆

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(N)
var MedianFinder = function() {
  this.maxHeap = new MaxHeap() // 小的部分
  this.minHeap = new MinHeap() // 大的部分
};

MedianFinder.prototype.addNum = function(num) {
  if(
    this.maxHeap.size() === 0
    || num < this.maxHeap.peek()) {
      this.maxHeap.insert(num)
      if(this.maxHeap.size() > this.minHeap.size() + 1) {
        this.minHeap.insert(this.maxHeap.pop())
      }
  } else {
    this.minHeap.insert(num)
    if(this.minHeap.size() > this.maxHeap.size()) {
      this.maxHeap.insert(this.minHeap.pop())
    }
  }
};

MedianFinder.prototype.findMedian = function() {
  if(this.minHeap.size() === this.maxHeap.size()) {
    return (this.minHeap.peek() + this.maxHeap.peek()) / 2
  } else {
    return this.maxHeap.peek()
  }
};

// 小顶堆
class MinHeap {
  constructor(isMin) {
    this.heap = []
  }
  insert(v) {
    this.heap.push(v)
    this.shiftUp(this.heap.length - 1)
  }
  pop() {
    this.swap(0, this.heap.length - 1)
    const target = this.heap.pop()
    this.shiftDown(0)
    return target
  }
  shiftUp(i) {
    const parentIndex = Math.floor((i - 1) / 2)
    if(this.heap[i] < this.heap[parentIndex]) {
      this.swap(i, parentIndex)
      this.shiftUp(parentIndex)
    }
  }
  shiftDown(i) {
    const lIndex = 2 * i + 1
    const rIndex = 2 * i + 2
    let minIndex = i
    if(this.heap[lIndex] < this.heap[minIndex]) {
      minIndex = lIndex
    }
    if(this.heap[rIndex] < this.heap[minIndex]) {
      minIndex = rIndex
    }
    if(minIndex !== i) {
      this.swap(minIndex, i)
      this.shiftDown(minIndex)
    }
  }
  peek() {
    return this.heap[0]
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  size() {
    return this.heap.length
  }
}

// 大顶堆
class MaxHeap {
  constructor() {
    this.heap = []
  }
  insert(v) {
    this.heap.push(v)
    this.shiftUp(this.heap.length - 1)
  }
  pop() {
    this.swap(0, this.heap.length - 1)
    const target = this.heap.pop()
    this.shiftDown(0)
    return target
  }
  shiftUp(i) {
    const parentIndex = Math.floor((i - 1) / 2)
    if(this.heap[i] > this.heap[parentIndex]) {
      this.swap(i, parentIndex)
      this.shiftUp(parentIndex)
    }
  }
  shiftDown(i) {
    const lIndex = 2 * i + 1
    const rIndex = 2 * i + 2
    let maxIndex = i
    if(this.heap[lIndex] > this.heap[maxIndex]) {
      maxIndex = lIndex
    }
    if(this.heap[rIndex] > this.heap[maxIndex]) {
      maxIndex = rIndex
    }
    if(maxIndex !== i) {
      this.swap(maxIndex, i)
      this.shiftDown(maxIndex)
    }
  }
  peek() {
    return this.heap[0]
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  size() {
    return this.heap.length
  }
}
```

## 🌟😻✔ 297 二叉树的序列化与反序列化【hard】

[ref](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

```js

var serialize = function(root) {
  function dfs(node) {
    if(!node) return null
    return {
      v: node.val,
      l: dfs(node.left),
      r: dfs(node.right),
    }
  }
  const resObj = dfs(root)
  return JSON.stringify(resObj)
};

var deserialize = function(data) {
  const obj = JSON.parse(data)

  function dfs(o) {
    if(!o) return null
    const node = new TreeNode(o.v)
    node.left = dfs(o.l)
    node.right = dfs(o.r)
    return node
  }

  return dfs(obj)
};
```

## 😻✔ 298 二叉树最长连续序列【medium】

[ref](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/)

二叉树、深度优先遍历

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var longestConsecutive = function(root) {
  let max = 1

  function dfs(node, parentValue, len) {
    if(node.val === parentValue + 1) {
      len++
      max = Math.max(max, len)
    } else {
      len = 1
    }
    node.left && dfs(node.left, node.val, len)
    node.right && dfs(node.right, node.val, len)
  }

  dfs(root, undefined, 0)
  return max
};
```

## ??🌟😻✔ 301 删除无效的括号【hard】

[ref](https://leetcode.cn/problems/remove-invalid-parentheses/)

BFS

```js
var removeInvalidParentheses = function(s) {
  let q = new Set([s])
  while(true) {
    const nextQ = new Set()
    const valids = [...q].filter(isValid)
    if(valids.length) {
      return valids
    }
    for(let targetStr of q) {
      for(let i=0;i<targetStr.length;i++) {
        if('()'.includes(targetStr[i])) {
          nextQ.add(targetStr.slice(0, i) + targetStr.slice(i + 1))
        }
      }
    }
    q = nextQ
  }
};

function isValid(s) {
  let count = 0
  for(let i=0;i<s.length;i++) {
    if(s[i] === '(') {
      count++
    } else if(s[i] === ')') {
      count--
      if(count < 0) return false
    }
  }
  return count === 0
}

```

## ??🌟😻✔ 300 最长递增子序列【medium】

[ref](https://leetcode.cn/problems/longest-increasing-subsequence/)

动态规划

```js
// 时间复杂度：O(n^2)
// 空间复杂度：O(n)
var lengthOfLIS = function(nums) {
  let len = nums.length
  const dp = new Array(len).fill(1)
  for(let i=0;i<len;i++) {
    dp[i] = 1
    for(let j = i - 1; j>=0; j--) {
      if(nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1)
      }
    }
  }
  return Math.max(...dp)
};
```

更高效版

理论依据：在查找最长递增子序列的过程中，需要尽可能让长度为 x 的子序列的最大值最小，这样才能尽可能多的在后面补上新数字

dp[i] 代表长度为 i 的最长递增子序列的最后一个数的最小值

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var lengthOfLIS = function(nums) {
  const len = nums.length
  const dp = []
  let count = 0
  dp[count] = nums[0]
  for(let i=1;i<len;i++) {
    if(nums[i] > dp[count]) {
      dp[++count] = nums[i]
    } else {
      let l = 0, r = count
      while(l < r) {
        const mid = Math.floor((l + r) / 2)
        if(nums[i] > dp[mid]) {
          l = mid + 1
        } else {
          pos = mid
          r = mid
        }
      }
      dp[l] = nums[i]
    }
  }
  return count + 1
};
```

## ??🌟😻✔ 309 最佳买卖股票时机含冷冻期【medium】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

高效版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  const len = prices.length
  // 确定初始值
  let profitWithShare = -prices[0]
  let profitWithCooldown = 0
  let profitWithoutCooldown = 0

  for(let i = 1; i < len; i++) {
    const profitWithShareBefore = profitWithShare
    const profitWithCooldownBefore = profitWithCooldown
    const profitWithoutCooldownBefore = profitWithoutCooldown
    profitWithShare = Math.max(profitWithShareBefore, profitWithoutCooldownBefore - prices[i])
    profitWithCooldown = profitWithShareBefore + prices[i]
    profitWithoutCooldown = Math.max(profitWithoutCooldownBefore, profitWithCooldownBefore)
  }

  return Math.max(profitWithCooldown, profitWithoutCooldown)
};
```

数组版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProfit = function(prices) {
  // -------------------------------------
  // i 天结束之后会存在三种状态（注意，是 i 天结束）：
  // 0. 持有股票
  // 1. 不持有股票，且处于冷冻期
  // 2. 不持有股票，且不处于冷冻期
  // -------------------------------------
  // 三种状态的转移方程
  // -------------------------------------
  // 0. 持有股票：
  // i - 1 天结束的时候就持有股票
  // 或者 i 天买了股票（i - 1 天的时候不处于冷冻期）
  // dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2] - prices[i])
  // -------------------------------------
  // 1. 不持有股票，且处于冷冻期
  // i 天卖出了股票, i - 1 结束的时候持有股票
  // dp[i][1] = dp[i-1][0] + prices[i]
  // -------------------------------------
  // 2. 不持有股票，且不处于冷冻期
  // i - 1 天结束的时候就是不持有股票且不处于冷冻期
  // i - 1 天结束的时候处于冷冻期
  // dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1])
  // -------------------------------------
  // 综合下来 i 天结束之后，能获得的最大收益
  // Math.max(dp[i][0], d[i][1], dp[i][2])
  // 要注意一点，i 天结束之后，如果还持有股票，这肯定比 i 天结束之后不持有股票的收益低
  // 则最终结果 Math.max(d[i][1], dp[i][2])

  const len = prices.length
  // 确定初始值
  const dp = new Array(len).fill(1).map(_ => [])
  dp[0][0] = -prices[0]
  dp[0][1] = 0
  dp[0][2] = 0

  for(let i = 1; i < len; i++) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2] - prices[i])
    dp[i][1] = dp[i-1][0] + prices[i]
    dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1])
  }

  return Math.max(dp[len - 1][1], dp[len - 1][2])
};
```

## ??🌟😻✔ 312 戳气球【hard】

[ref](https://leetcode.cn/problems/burst-balloons/)

开区间动态规划

```js
// 时间复杂度：O(N^3)
// 空间复杂度：O(N^2)
var maxCoins = function(nums) {
  nums.unshift(1)
  nums.push(1)
  const n = nums.length
  const dp = new Array(n).fill(0).map(_ => new Array(n).fill(0))
  for(let i = n; i >=0 ; i--) {
    for(let j = i + 2; j < n; j++) {
      for(let k = i + 1; k < j; k++) {
        dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])
      }
    }
  }
  return dp[0][n-1]
};

```

## ?🌟😻✔ 313. 超级丑数【medium】

[ref](https://leetcode.cn/problems/super-ugly-number/)

```js
// 时间复杂度：O(n*m)
// 空间复杂度：O(n + m)
var nthSuperUglyNumber = function(n, primes) {
  const len = primes.length
  const baseCalc = new Array(len).fill(1)
  const dp = new Array(n + 1).fill(1)
  for(let i=2;i<=n;i++) {
    let min = Number.MAX_SAFE_INTEGER
    for(let j = 0;j<primes.length;j++) {
      min = Math.min(dp[baseCalc[j]] * primes[j], min)
    }
    for(let j = 0;j<primes.length;j++) {
      if(dp[baseCalc[j]] * primes[j] === min) {
        baseCalc[j]++
      }
    }

    dp[i] = min
  }
  return dp[n]
};
```

## ?🌟😻✔ 315 计算右侧小于当前元素的个数【hard】

[ref](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

逆序对、归并排序

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var countSmaller = function(nums) {
  for(let i=0;i<nums.length;i++) {
    nums[i] = {ind: i, val: nums[i]}
  }
  const ret = new Array(nums.length).fill(0)
  function mergeSort(nums, l, r) {
    l = typeof l === 'number' ? l : 0
    r = typeof r === 'number' ? r : nums.length - 1
    if(l === r) return [nums[l]]
    const mid = Math.floor((l + r) / 2)
    return merge(mergeSort(nums, l, mid), mergeSort(nums, mid + 1, r))
  }

  function merge(arr1, arr2) {
    const len1 = arr1.length
    const len2 = arr2.length
    let l1 = l2 = 0
    const res = []
    while(l1 < len1 && l2 < len2) {
      if(arr1[l1].val > arr2[l2].val) {
        ret[arr1[l1].ind] += len2 - l2
        res.push(arr1[l1++])
      } else {
        res.push(arr2[l2++])
      }
    }
    while(l1 < len1) {
      res.push(arr1[l1++])
    }
    while(l2 < len2) {
      res.push(arr2[l2++])
    }
    return res
  }

  mergeSort(nums)
  return ret
};
```

## ?🌟😻✔ 322 零钱兑换【medium】

[ref](https://leetcode.cn/problems/coin-change/)

动态规划、01背包

```js
// 动态规划
// N=coins.length S=amount
// 时间复杂度：O(S*N)
// 空间复杂度：O(S)
var coinChange = function(coins, amount) {
  const len = coins.length
  const dp = new Array(amount + 1).fill(amount + 1)
  dp[0] = 0
  for(let i=1;i<=amount;i++) {
    for(let j=0;j<coins.length;j++) {
      if(i - coins[j] >= 0) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1)
      }
    }
  }
  return dp[amount] > amount? -1 : dp[amount]
};
```

## ✔ 325 和等于 k 的最长子数组长度【medium】

[ref](https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxSubArrayLen = function(nums, k) {
  const n = nums.length
  const m = new Map()
  let sum = 0
  let max = 0
  for(let i=0;i<n;i++) {
    sum += nums[i]
    if(sum === k) {
      max = Math.max(max, i + 1)
    }
    if(m.has(sum - k)) {
      max = Math.max(max, i - m.get(sum - k))
    }
    if(!m.has(sum)) {
      m.set(sum, i)
    }
  }
  return max
};
```

## ?🌟😻✔ 327. 区间和的个数【hard】

[ref](https://leetcode.cn/problems/count-of-range-sum/)

归并排序、前缀树组、数组题

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var countRangeSum = function(nums, lower, upper) {
  const n = nums.length
  const sum = []
  let s = 0
  let count = 0

  for(let i = 0; i < n; i++) {
    s += nums[i]
    sum[i] = s
    if(s >= lower && s <= upper) count++
  }

  function mergeSort(l, r) {
    l = typeof l === 'number' ? l : 0
    r = typeof r === 'number' ? r : n - 1
    if(l === r) return [sum[l]]
    const mid = Math.floor((l + r) / 2)
    return merge(mergeSort(l, mid), mergeSort(mid + 1, r))
  }

  function merge(arr1, arr2) {
    const len1 = arr1.length, len2 = arr2.length

    let arr2l = 0, arr2r = 0
    for(let i = 0; i < len1; i++) {
      while(arr2l < len2 && arr2[arr2l] - arr1[i] < lower) {
        arr2l++
      }
      while(arr2r < len2 && arr2[arr2r] - arr1[i] <= upper) {
        arr2r++
      }
      count += arr2r - arr2l
    }

    const mergeRes = new Array(len1 + len2)
    let ind = 0
    let l1 = 0, l2 = 0
    while(l1 < len1 && l2 < len2) {
      if(arr1[l1] < arr2[l2]) {
        mergeRes[ind++] = arr1[l1++]
      } else {
        mergeRes[ind++] = arr2[l2++]
      }
    }
    while(l1 < len1) {
      mergeRes[ind++] = arr1[l1++]
    }
    while(l2 < len2) {
      mergeRes[ind++] = arr2[l2++]
    }
    return mergeRes
  }

  mergeSort()
  return count
};
```

## ?🌟😻✔ 329 矩阵中的最长递增路径【hard】

[ref](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)

记忆化深度优先

```js
// 时间复杂度：O(M*N)
// 空间复杂度：O(M*N)
var longestIncreasingPath = function(matrix) {
  const m = matrix.length
  const n = matrix[0].length
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(-1))
  let max = 0

  for(let i = 0; i < m; i++) {
    for(let j = 0; j < n; j++) {
      max = Math.max(max, find(i, j, -1))
    }
  }

  function find(i, j, prevValue) {
    if(
        i < m
        && i >= 0
        && j < n
        && j >= 0
        && !used[i][j]
        && matrix[i][j] > prevValue
      ) {
      if(dp[i][j] >= 0) return dp[i][j]
      used[i][j] = true
      const maxLen = Math.max(
        find(i - 1, j, matrix[i][j]),
        find(i + 1, j, matrix[i][j]),
        find(i, j - 1, matrix[i][j]),
        find(i, j + 1, matrix[i][j])
      ) + 1
      used[i][j] = false
      dp[i][j] = maxLen
      return maxLen
    }
    return 0
  }
  return max
};

```

## ??🌟😻✔ 336 回文对【hard】

[ref](https://leetcode.cn/problems/palindrome-pairs/)

```js
var palindromePairs = function(words) {
  const res = []
  const m = new Map()
  for(let i=0;i<words.length;i++) {
    m.set(words[i].split('').reverse().join(''), i)
  }
  for(let i=0;i<words.length;i++) {
    const curStr = words[i]
    if(is(curStr) && curStr !== '' && m.has('')) {
      res.push([i, m.get('')])
      res.push([m.get(''), i])
    }
    for(let j = 0;j<curStr.length;j++) {
      const lStr = curStr.slice(0, j + 1)
      const rStr = curStr.slice(j + 1)
      if(is(lStr) && m.has(rStr) && m.get(rStr) !== i && rStr !== '') {
        res.push([m.get(rStr), i])
      }
      if(is(rStr) && m.has(lStr) && m.get(lStr) !== i) {
        res.push([i, m.get(lStr)])
      }
    }
  }
  return res
};

function is(s) {
  let l = 0, r = s.length - 1
  while(l <= r) {
    if(s[l++] !== s[r--]) return false
  }
  return true
}
```

## ?🌟😻✔ 337 打家劫舍 III【medium】

[ref](https://leetcode.cn/problems/house-robber-iii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var rob = function(root) {
  const s = new Map()
  const notS = new Map()

  function dfs(node) {
    node.left && dfs(node.left)
    node.right && dfs(node.right)
    notS.set(node,(s.get(node.left) || 0) + (s.get(node.right) || 0))
    s.set(node, Math.max(
      node.val + ((notS.get(node.left) || 0) + (notS.get(node.right) || 0)),
      notS.get(node)
    ))
  }

  dfs(root)
  return s.get(root)
};
```

## ?😻✔ 338 比特位计数【easy】

[ref](https://leetcode.cn/problems/counting-bits/)

规律、模拟

```js
var countBits = function(n) {
  const res = [0]

  // 分奇数偶数讨论
  for(let i=1;i<=n;i++) {
    if(i % 2 === 0) {
      res[i] = res[i / 2]
    } else {
      res[i] = res[i - 1] + 1
    }
  }

  return res
};

```

## 😻✔ 343 整数拆分【medium】

[ref](https://leetcode.cn/problems/integer-break/)

动态规划、整数拆分

关联 [剑指 Offer 14- I. 剪绳子](#🌟😻✔-剑指-offer-14-i-剪绳子【medium】)

```js
var cuttingRope = function(n) {
  if(n <= 3) return n - 1
  let res = 1
  while(n > 4) {
    res *= 3
    n -= 3
  }
  return res * n
};
```

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var integerBreak = function(n) {
  const dp = new Array(n + 1).fill(1)
  dp[0] = 1
  dp[1] = 1
  dp[2] = 1
  for(let i=3;i<=n;i++) {
    for(j = 1;j<i;j++) {
      dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j])
    }
  }
  return dp[n]
};
```

## 😻✔ 347 前 K 个高频元素【medium】

[ref](https://leetcode.cn/problems/top-k-frequent-elements/)

堆、小顶堆、前K大

```js
// 时间复杂度：O(nlogk)
// 空间复杂度：O(n)
var topKFrequent = function(nums, k) {
  const map = new Map()
  const h = new MinHeap()
  for(let n of nums) {
    map.set(n, map.has(n) ? map.get(n) + 1 : 1)
  }

  map.forEach((frequence, num) => {
    h.insert({num, frequence})
    if(h.size() > k) {
      h.pop()
    }
  })

  return h.heap.map(_ => _.num)
};

class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    let p = this.heap.pop()
    this.shiftDown(0)
    return p
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i].frequence > this.heap[left].frequence) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i].frequence > this.heap[right].frequence) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex].frequence > this.heap[i].frequence) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

or

```js
// 时间复杂度：O(n*k) => O(n^2)
// 空间复杂度：O(k)
var topKFrequent = function(nums, k) {
  const map = new Map()
  const q = []
  for(let num of nums) {
    map.set(num, map.has(num)? map.get(num) + 1:1)
  }
  for(let [num, count] of map.entries()) {
    let index = q.length - 1
    while(q[index] && q[index].count < count) {
      q[index + 1] = q[index]
      index--
    }
    q[++index] = {num, count}
    if(q.length > k) q.pop()
  }
  return q.map(_ => _.num)
};
```

or 直接对次数排序

```js
// 时间复杂度：O(nlogn) 快排
// 空间复杂度：O(n)
var topKFrequent = function(nums, k) {
  const map = new Map()
  for(let n of nums) {
    map.set(n, map.has(n) ? map.get(n) + 1 : 1)
  }
  const mapArr = Array.from(map)
  mapArr.sort((a, b) => b[1] - a[1])
  return mapArr.slice(0, k).map(_ => _[0]) 
};
```

## 😻✔ 349 两个数组的交集【easy】

[ref](https://leetcode.cn/problems/intersection-of-two-arrays/)

```js
// 时间复杂度：O(M+N)
// 空间复杂度：O(M+N)
var intersection = function(nums1, nums2) {
  const s1 =new Set(nums1)
  const s2 =new Set(nums2)
  const res = []
  for(let v of s1.values()) {
    if(s2.has(v)) {
      res.push(v)
    }
  }
  return res
};
```

## ??🌟😻✔ 354 俄罗斯套娃信封问题【hard】

[ref](https://leetcode.cn/problems/russian-doll-envelopes/)

二分法、递增子序列

相关
- [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var maxEnvelopes = function(envelopes) {
  envelopes.sort((a, b) => {
    if(a[0] !== b[0]) {
      return a[0] - b[0]
    } else {
      return  b[1] - a[1]
    }
  })
  const len = envelopes.length
  const dp = []
  let count = 0
  dp[count] = envelopes[0]
  for(let i=1;i<len;i++) {
    if(envelopes[i][1] > dp[count][1]) {
      dp[++count] = envelopes[i]
    } else {
      let l = 0, r = count
      while(l < r) {
        const mid = Math.floor((l + r) / 2)
        if(envelopes[i][1] > dp[mid][1]) {
          l = mid + 1
        } else {
          r = mid
        }
      }
      dp[l] = envelopes[i]
    }
  }
  return count + 1
};

```

## 😻✔ 374 猜数字大小【easy】

[ref](https://leetcode.cn/problems/guess-number-higher-or-lower/)

二分搜索

```js
var guessNumber = function(n) {
  let l = 0
  let r = n
  while(l <= r) {
    const med = Math.floor((l + r) / 2)
    if(guess(med) === -1) {
      r = med - 1
    } else if(guess(med) === 1) {
      l = med + 1
    } else {
      return med
    }
  }
};
```



## ?🌟😻✔ 380 O(1) 时间插入、删除和获取随机元素【medium】

[ref](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

```js
var RandomizedSet = function() {
  this.map = new Map()
  this.vals = []
};

/** 
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.insert = function(val) {
  if(this.map.has(val)) return false
  this.vals.push(val)
  this.map.set(val, this.vals.length - 1)
  return true
};

/** 
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.remove = function(val) {
  if(!this.map.has(val)) return false
  const ind = this.map.get(val)
  this.vals[ind] = this.vals[this.vals.length - 1]
  this.vals.pop()
  this.map.delete(val)
  this.map.set(this.vals[ind], ind)
  return true
};

/**
 * @return {number}
 */
RandomizedSet.prototype.getRandom = function() {
  const size = this.vals.length
  const randomIndex = Math.floor(Math.random() * size)
  return this.vals[randomIndex]
};
```

## ✔ 383 赎金信【easy】

[ref](https://leetcode.cn/problems/ransom-note/)

```js
// 时间复杂度：O(M+N)
// 空间复杂度：O(N)
var canConstruct = function(ransomNote, magazine) {
  const map = new Map()
  for(let i=0;i<magazine.length;i++) {
    map.set(magazine[i], map.has(magazine[i]) ? map.get(magazine[i]) + 1: 1)
  }

  for(let i=0;i<ransomNote.length;i++) {
    if(!map.has(ransomNote[i]) || map.get(ransomNote[i]) === 0) return false
    map.set(ransomNote[i], map.get(ransomNote[i]) - 1)
  }
  return true
};
```

## ?🌟😻✔ 386 字典序排数【medium】

[ref](https://leetcode.cn/problems/lexicographical-numbers/)

字典树、字典序

```js
// 时间复杂度：O(N)
// 时间复杂度：O(1)
var lexicalOrder = function(n) {
  let k = 1
  const res = []
  while(res.length < n) {
    res.push(k)
    const small = 10 * k
    if(n >= small) {
      k = small
    } else {
      while(k % 10 === 9 || k + 1 > n) {
        k = Math.floor(k / 10)
      }
      k++
    }
  }

  return res
};
```

## ?🌟😻✔ 394 字符串解码【medium】

[ref](https://leetcode.cn/problems/decode-string/)

字符串题、递归

```js
var decodeString = function(s) {
  const len = s.length
  let res = ''
  for(let i=0;i<len;i++) {
    if(s[i] >= 'a' && s[i] <= 'z') {
      res+=s[i]
    } else if(s[i] >= '1' && s[i] <= '9') {
      let count = parseInt(s.slice(i), 10)
      i += String(count).length
      const j = searchEnd(s, i)
      const temp = decodeString(s.slice(i + 1, j))
      res+=gen(count, temp)
      i=j
    }
  }
  return res
};

// 生成字符串
function gen(count, temp) {
  let res = ''
  for(let i=0;i<count;i++) {
    res+=temp
  }
  return res
}

// 从 i 开始，搜索 i 的结束括号 j
function searchEnd(s, i) {
  let leftCount = 0
  while(i<s.length) {
    if(s[i] === '[') {
      leftCount++
    } else if(s[i] === ']') {
      leftCount--
    }
    if(leftCount === 0) {
      return i
    }
    i++
  }
}
```

## ?🌟😻✔ 400 第 N 位数字【medium】

[ref](https://leetcode.cn/problems/nth-digit/)

模拟法

```js
// 时间复杂度：O(log10n)
// 空间复杂度：O(1)
var findNthDigit = function(n) {
  let k = 1
  let count = 0
  while(count + 9 * k * 10 ** (k - 1) < n) {
    count += 9 * k * 10 ** (k - 1)
    k++
  }
  n -= count
  const targetNum = 10 ** (k - 1) + Math.floor((n - 1) / k)
  const targetIndex = (n - 1) % k
  return Math.floor(targetNum / 10 ** (k - targetIndex - 1)) % 10
};
```

## ?🌟😻✔ 402 移掉 K 位数字【medium】

[ref](https://leetcode.cn/problems/remove-k-digits/)

```js
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var removeKdigits = function(num, k) {
  const stack = []
  let l = 0
  while(l < num.length) {
    while(stack.length - 1 >= 0 && num[l] < stack[stack.length - 1] && k > 0) {
      stack.pop()
      k--
    }
    stack.push(num[l])
    l++
  }
  while(k > 0) {
    stack.pop()
    k--
  }
  while(stack[0] === '0') {
    stack.shift()
  }
  if(!stack.length) return '0'
  return stack.join('')
};
```

```js
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var removeKdigits = function(num, k) {
  let l = 0
  let stack = []
  while(l<num.length) {
    while(stack.length > 0 && k > 0 && stack[stack.length - 1] > num[l]) {
      stack.pop()
      k--
    }
    stack.push(num[l])
    l++
    while(stack[0] === '0') {
      stack.shift()
    }
  }
  // 或者 k=0
  // 或者 k>0&&stack 单调
  if(stack.length - k > 0) {
    stack = stack.slice(0, stack.length - k)
  } else {
    stack = []
  }
  return !stack.length ? '0': stack.join('')
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var removeKdigits = function(num, k) {
  let l = 0
  while(l<num.length && k > 0) {
    if(num[l] > num[l + 1]) {
      num = num.slice(0, l) + num.slice(l + 1)
      l--
      k--
    } else {
      l++
    }
    while(num[0]==='0') {
      num = num.slice(1)
    }
    if(k>=num.length) return '0'
  }
  num = num.slice(0, num.length - k)
  return num === ''? '0': num
};
```

## 🌟😻✔ 406 根据身高重建队列【medium】

[ref](https://leetcode.cn/problems/queue-reconstruction-by-height/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(logN)
var reconstructQueue = function(people) {
  people.sort((a, b) => {
    if(a[0] !== b[0]) {
      return b[0] - a[0]
    } else {
      return a[1] - b[1]
    }
  })
  let res = []
  for(let i=0;i<people.length;i++) {
    res.splice(people[i][1], 0, people[i])
  }
  return res
};

```

## ??🌟😻✔ 407 接雨水 II【hard】

[ref](https://leetcode.cn/problems/trapping-rain-water-ii/)

优先队列

```js
// 时间复杂度：O(MNlog(M+N))
// 空间复杂度：O(MN)
var trapRainWater = function(heightMap) {
  const m = heightMap.length
  const n = heightMap[0].length
  const used = new Array(m).fill(0).map(_ => new Array(n).fill(false))
  const heap = new MinHeap()
  let res = 0
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(!used[i][j] && (i === 0 || j === 0 || i === m - 1 || j === n - 1)) {
        used[i][j] = true
        heap.insert([heightMap[i][j], i, j])
      }
    }
  }

  const nexts = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  while(heap.size()) {
    const min = heap.pop()
    for(let i=0;i<nexts.length;i++) {
      const ni = min[1] + nexts[i][0]
      const nj = min[2] + nexts[i][1]
      if(ni >= 0 && ni < m && nj >=0 && nj < n && !used[ni][nj]) {
        used[ni][nj] = true
        res += Math.max(min[0] - heightMap[ni][nj], 0) 
        heap.insert([Math.max(heightMap[ni][nj], min[0]), ni, nj])
      }
    }
  }
  return res
};

class MinHeap {
  constructor() {
    this.heap = []
  }
  pop(){
    this.swap(0, this.heap.length - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  insert(t){
    this.heap.push(t)
    this.shiftUp(this.heap.length - 1)
  }
  swap(i, j){
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  shiftUp(i){
    const pi = Math.floor((i - 1) / 2)
    if(pi >= 0 && this.heap[i][0] < this.heap[pi][0]) {
      this.swap(i, pi)
      this.shiftUp(pi)
    }
  }
  shiftDown(i){
    const li = 2 * i + 1
    const ri = 2 * i + 2
    let mini = i
    if(li < this.size() && this.heap[li][0] < this.heap[mini][0]) {
      mini = li
    }
    if(ri < this.size() && this.heap[ri][0] < this.heap[mini][0]) {
      mini = ri
    }
    if(mini !== i) {
      this.swap(i, mini)
      this.shiftDown(mini)
    }
  }
  size(){
    return this.heap.length
  }
}
```

## 🌟😻✔ 415 字符串相加【easy】

[ref](https://leetcode.cn/problems/add-strings/)

```js
// 双指针法，不需要补充前导 0
// 时间复杂度：O(max(len1,len2))
// 空间复杂度：O(1)
var addStrings = function(num1, num2) {
  let i1 = num1.length - 1
  let i2 = num2.length - 1
  let sum = ''
  let add = 0
  while(i1 >= 0 || i2 >= 0) {
    const tmpSum = (i1 >= 0 ? +num1[i1] : 0) + (i2 >= 0 ? +num2[i2] : 0) + add
    sum = tmpSum % 10 + sum
    add = Math.floor(tmpSum / 10)
    i1--
    i2--
  }
  if(add > 0) {
    sum = 1 + sum
  }
  return sum
};
````

```js
// 常规方法，补充前导 0
// 时间复杂度：O(max(len1,len2))
// 空间复杂度：O(1)
var addStrings = function(num1, num2) {
  if(num1.length > num2.length) {
    num2 = new Array(num1.length - num2.length).fill('0').join('') + num2
  } else if(num1.length < num2.length) {
    num1 = new Array(num2.length - num1.length).fill('0').join('') + num1
  }
  let sum = ''
  let add = 0
  for(let i=num1.length - 1; i>=0; i--) {
    const tmpSum = parseInt(num1[i], 10) + parseInt(num2[i], 10) + add
    sum = (tmpSum % 10) + sum
    add = Math.floor(tmpSum / 10)
  }
  if(add > 0) {
    sum = 1 + sum
  }
  return sum
};
```

## ?🌟😻✔ 416 分割等和子集【medium】

[ref](https://leetcode.cn/problems/partition-equal-subset-sum/)

背包问题、动态规划

```js
// 时间复杂度：O(n*target)
// 空间复杂度：O(n*target)
var canPartition = function(nums) {
  const len = nums.length
  let sum = 0, maxNum = nums[0]
  for(let num of nums) {
    sum+=num
    maxNum = Math.max(maxNum, num)
  }
  if(sum % 2 ===1) {
    return false
  }
  const target = sum / 2
  if(maxNum > target) {
    return false
  }
  const dp = new Array(nums.length).fill(0).map(_ => new Array(target + 1).fill(false))
  for(let i=0;i<len;i++) {
    dp[i][0] = true
  }
  dp[0][nums[0]] = true
  for(let i=1;i<len;i++) {
    for(let j=0;j<=target;j++) {
      if(j >= nums[i]) {
        dp[i][j] = dp[i - 1][j] | dp[i - 1][j - nums[i]]
      } else {
        dp[i][j] = dp[i - 1][j]
      }
    }
  }

  return dp[len-1][target]
};
```


## 🌟😻✔ 417 太平洋大西洋水流问题【medium】

[ref](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

深度优先遍历、DFS、图、逆流而上

```js
var pacificAtlantic = function(heights) {
  const m = heights.length
  const n = heights[0].length
  const leftTopFlow = new Array(m).fill(1).map(() => new Array(n).fill(false))
  const rightBottomFlow = new Array(m).fill(1).map(() => new Array(n).fill(false))
  const res = []

  function dfs(i, j, flow) {
    flow[i][j] = true;
    [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]].forEach(([ni, nj]) => {
      if(
        ni >= 0 && ni < m &&
        nj >= 0 && nj < n &&
        !flow[ni][nj] &&
        heights[ni][nj] >= heights[i][j]
      ) {
        dfs(ni, nj, flow)
      }
    })
  }

  for(let i = 0;i < m; i++) {
    dfs(i, 0, leftTopFlow)
    dfs(i, n - 1, rightBottomFlow)
  }
  for(let j = 0;j < n; j++) {
    dfs(0, j, leftTopFlow)
    dfs(m - 1, j, rightBottomFlow)
  }

  for(let i = 0;i < m; i++) {
    for(let j = 0;j < n; j++) {
      if(leftTopFlow[i][j] && rightBottomFlow[i][j]) res.push([i, j])
    }
  }

  return res
};
```

## ??🌟😻✔ 424 替换后的最长重复字符【medium】

[ref](https://leetcode.cn/problems/longest-repeating-character-replacement/)

双指针、滑动窗口

```js
// 时间复杂度：O(N)
// 空间复杂度：O(∣Σ∣)，其中 ∣Σ∣ 是字符集的大小
var characterReplacement = function(s, k) {
  const nums = new Map()
  let l = r = 0
  let maxn = 0
  while(r < s.length) {
    nums.set(s[r], nums.has(s[r]) ? nums.get(s[r]) + 1 : 1)
    maxn = Math.max(maxn, nums.get(s[r]))
    if(r - l + 1 - maxn > k) {
      nums.set(s[l], nums.get(s[l]) - 1)
      l++
    }
    r++
  }
  return r - l
};

```

## ?🌟😻✔ 437. 路径总和 III【medium】

[ref](https://leetcode.cn/problems/path-sum-iii/)

前缀和

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var pathSum = function(root, targetSum) {
  if(!root) return 0
  const map = new Map()
  let count = 0
  function dfs(node, sum) {
    if(!node) return
    sum += node.val
    if(sum === targetSum) count++
    if(map.has(sum - targetSum)) {
      count += map.get(sum - targetSum)
    }
    map.set(sum, map.has(sum) ? map.get(sum) + 1: 1)
    dfs(node.left, sum)
    dfs(node.right, sum)
    map.set(sum, map.get(sum) - 1)
  }
  dfs(root, 0)
  return count
};
```

## 🌟😻✔ 438 找到字符串中所有字母异位词【medium】

[ref](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

滑动窗口、双指针

```js
// 时间复杂度：O(M+N) M=s.length N=p.length
// 空间复杂度：O(N)
var findAnagrams = function(s, p) {
  const pMap = new Map()
  let pCount = 0
  for(let i=0;i<p.length;i++) {
    pMap.set(p[i], pMap.has(p[i])?pMap.get(p[i]) + 1 : 1)
    if(pMap.get(p[i]) === 1) {
      pCount++
    }
  }
  let l = 0, r = 0
  const res = []
  let sCount = 0
  let sMap = new Map()
  while(r<s.length) {
    if(!pMap.has(s[r])) {
      r++
      l=r
      sCount = 0
      sMap = new Map()
    } else if(sMap.get(s[r]) === pMap.get(s[r])){
      while(l <= r&& s[l] !== s[r]) {
        sMap.set(s[l], sMap.get(s[l]) - 1)
        if(sMap.get(s[l]) + 1 === pMap.get(s[l])) sCount--
        l++
      }
      l++
      r++
    } else {
      sMap.set(s[r], sMap.has(s[r])?sMap.get(s[r]) + 1 : 1)
      if(sMap.get(s[r]) === pMap.get(s[r])) {
        sCount++
      }
      r++
    }
    if(sCount === pCount) {
      res.push(l)
    }
  }
  return res
};
```

## ?🌟😻✔ 440 字典序的第K小数字【hard】

[ref](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)

字典序、字典树

```js
// 字典序
// 时间复杂度：O()
// 空间复杂度：O()
var findKthNumber = function(n, k) {
  let s = 1
  k--
  while(k>0) {
    const count = getCount(s, n)
    if(count < k) {
      s++
      k-=count
    } else {
      s*=10
    }
    k--
  }
  return s
};

function getCount(s, n) {
  let min = 10 * s
  let max = 10 * s + 9
  let count = 0
  while(max <= n) {
    count += max - min + 1
    min = 10 * min
    max = 10 * max + 9
  }
  count += Math.max(0, n - min + 1)
  return count
}
```

## ?🌟😻✔ 448 找到所有数组中消失的数字【easy】

[ref](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findDisappearedNumbers = function(nums) {
  const n = nums.length
  for(let i=0;i<n;i++) {
    const num = nums[i] % (n + 1)
    nums[num - 1] += n + 1
  }
  const res = []
  for(let i=0;i<n;i++) {
    if(nums[i] < n + 1) res.push(i + 1)
  }
  return res
};
```

## ?🌟😻✔ 445 两数相加 II【medium】

[ref](https://leetcode.cn/problems/add-two-numbers-ii/)

链表

```js
// 时间复杂度：O(max(M, N))
// 空间复杂度：O(M + N)
var addTwoNumbers = function(l1, l2) {
  const s1 = [], s2 = []
  while(l1) {
    s1.push(l1.val)
    l1 = l1.next
  }
  while(l2) {
    s2.push(l2.val)
    l2 = l2.next
  }
  let add = 0
  let head = new ListNode()
  while(s1.length || s2.length) {
    const tmpS = (s1.length ? s1.pop() : 0) + (s2.length ? s2.pop() : 0) + add
    const newH = new ListNode(tmpS % 10)
    newH.next = head.next
    head.next = newH
    add = Math.floor(tmpS / 10)
  }
  if(add > 0) {
    const newH = new ListNode(add)
    newH.next = head.next
    head.next = newH
  }
  return head.next
};
```

## ?🌟😻✔ 454 四数相加 II【medium】

[ref](https://leetcode.cn/problems/4sum-ii/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var fourSumCount = function(nums1, nums2, nums3, nums4) {
  let c = 0
  const m = new Map()
  for(let i=0;i<nums1.length;i++) {
    for(let j=0;j<nums2.length;j++) {
      const s = nums1[i] + nums2[j]
      m.set(s, m.has(s)?m.get(s)+1: 1)
    }
  }

  for(let i=0;i<nums3.length;i++) {
    for(let j=0;j<nums4.length;j++) {
      const s = nums3[i] + nums4[j]
      if(m.has(-s)) {
        c += m.get(-s)
      }
    }
  }

  return c
};
```

## 😻✔ 455 分发饼干【easy】

[ref](https://leetcode.cn/problems/assign-cookies/)

贪心算法

```js
// 时间复杂度：O(nlogn) 排序时间复杂度
// 时间复杂度：O(logn) 排序空间复杂度
var findContentChildren = function(g, s) {
  g.sort((a, b) => a - b)
  s.sort((a, b) => a - b)

  let i = 0
  s.forEach((n) => {
    if(n >= g[i]) {
      i++
    }
  })
  return i
};
```

## ?🌟😻✔ 461 汉明距离【easy】

[ref](https://leetcode.cn/problems/hamming-distance/)

模拟、推断、规律

```js
var hammingDistance = function(x, y) {
  let res = 0
  while(x !== y) {
    if(x % 2 !== y % 2) res ++
    x = Math.floor(x / 2)
    y = Math.floor(y / 2)
  }
  return res
};

// 1   (0 0 0 1)
// 2   (0 0 1 0)
// 3   (0 0 1 1)
// 4   (0 1 0 0)
// 5   (0 1 0 1)
// 6   (0 1 1 0)

```

## ?🌟😻✔ 475 供暖器【medium】

[ref](https://leetcode.cn/problems/heaters/)

二分搜索

```js
// M = houses.length N = heaters.length
// 时间复杂度：O((M+N)*logN)
// 空间复杂度：O(logN)
var findRadius = function(houses, heaters) {
  heaters.sort((a, b) => a - b)
  let min = 0
  for(const house of houses) {
    const i = binarySearch(heaters, house)
    const j = i + 1
    const lDistance = i < 0 ? Number.MAX_SAFE_INTEGER :house - heaters[i]
    const rDistance = j >= heaters.length ? Number.MAX_SAFE_INTEGER :heaters[j] - house
    const curMin = Math.min(lDistance, rDistance)
    min = Math.max(min, curMin)
  }
  return min
};

function binarySearch(heaters, target) {
  if(target<heaters[0]) {
    return -1
  }
  let l = 0
  let r = heaters.length - 1
  while(l < r) {
    const mid = Math.floor((l + r + 1) / 2) 
    if(heaters[mid] > target) {
      r = mid - 1
    } else {
      l = mid
    }
  }
  return l
}
```

## ?🌟😻✔ 493. 翻转对【hard】

[ref](https://leetcode.cn/problems/reverse-pairs/)

数组题，归并排序

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var reversePairs = function(nums) {
  let count = 0
  function mergeSort(l, r) {
    l = typeof l === 'number' ? l : 0
    r = typeof r === 'number' ? r : nums.length - 1
    if(l === r) return [nums[l]]
    const mid = Math.floor((l + r) / 2)
    return merge(mergeSort(l, mid), mergeSort(mid + 1, r))
  }
  function merge(arr1, arr2) {
    const r = new Array(arr1.length + arr2.length)
    let ind = 0
    let l1 = 0, l2 = 0
    // 这里时间复杂度是 O(M+N) M=arr1.length N=arr2.length
    while(l1<arr1.length) {
      while(l2 < arr2.length && arr1[l1] > 2* arr2[l2]) {
        l2++
      }
      count += l2
      l1++
    }
    l1=0, l2=0
    while(l1 < arr1.length && l2 < arr2.length) {
      if(arr1[l1] < arr2[l2]) {
        r[ind++] = arr1[l1++]
      } else {
        r[ind++] = arr2[l2++]
      }
    }
    while(l1 < arr1.length) {
      r[ind++] = arr1[l1++]
    }
    while(l2 < arr2.length) {
      r[ind++] = arr2[l2++]
    }
    return r
  }
  mergeSort()
  return count
};

```

## 🌟😻✔ 494 目标和【medium】

[ref](https://leetcode.cn/problems/target-sum/)

动态规划、回溯

```js
// 时间复杂度：O(2**N)
// 空间复杂度：O(N)
var findTargetSumWays = function(nums, target) {
  let count = 0
  function search(i, sum) {
    if(i === nums.length) {
      if(sum === target) count++
      return
    }
    search(i + 1, sum + nums[i])
    search(i + 1, sum - nums[i])
  }
  search(0, 0)
  return count
};
```

## ？🌟😻✔ 516 最长回文子序列【medium】

[ref](https://leetcode.cn/problems/longest-palindromic-subsequence/)

```js
// 时间复杂度：O(N*2)
// 空间复杂度：O(N*2)
var longestPalindromeSubseq = function(s) {
  const len = s.length
  const dp = new Array(len).fill(0).map(_ => new Array(len).fill(0))
  for(let i=0;i<len;i++) {
    dp[i][i] = 1
  }
  for(let L = 2;L <= len;L++) {
    for(let i=0;i + L - 1<len;i++) {
      if(s[i] === s[i + L - 1]) {
        dp[i][i + L - 1] = (i + L - 2 >= i + 1 ? dp[i + 1][i + L - 2] : 0) + 2
      } else {
        dp[i][i + L - 1] = Math.max(dp[i][i + L - 2], dp[i + 1][i + L - 1])
      }
    }
  }
  return dp[0][len-1]
};
```

## ??🌟😻✔ 538 把二叉搜索树转换为累加树【medium】

[ref](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var convertBST = function(root) {
  convert(root, 0)
  return root
};

function convert(node, bigger) {
  if(!node) return 0
  const v = node.val
  const rightSum = convert(node.right, bigger)
  node.val = bigger + v + rightSum
  const leftSum = convert(node.left, node.val)
  return leftSum + v + rightSum
}
```

## 🌟😻✔ 540 有序数组中的单一元素【medium】

[ref](https://leetcode.cn/problems/single-element-in-a-sorted-array/)

二分搜索

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var singleNonDuplicate = function(nums) {
  const len = nums.length
  let l = 0,r=nums.length - 1
  while(l<r) {
    const mid = Math.floor((l + r) / 2)
    if(mid % 2 === 0) {
      if(mid + 1 < len && nums[mid] === nums[mid + 1]) {
        l = mid + 2
      } else {
        r = mid
      }
    } else {
      if(mid - 1 >= 0 && nums[mid] === nums[mid - 1]) {
        l = mid + 1
      } else {
        r = mid - 1
      }
    }
  }
  return nums[r]
};

```


## 🌟😻✔ 543 二叉树的直径【easy】

[ref](https://leetcode.cn/problems/diameter-of-binary-tree/)

二叉树

一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

二叉树的任何一条路径都会以某个节点作为根，而最长路径则是 Max(左子树深度 + 右子树深度) 。

```js
// 时间复杂度：O(n) n 是二叉树的节点数
// 空间复杂度：O(H) H 是二叉树的高度
var diameterOfBinaryTree = function(root) {
  let maxRes = 0

  function depth(node) {
    if(!node) return 0
    let lDepth = depth(node.left)
    let rDepth = depth(node.right)
    maxRes = Math.max(maxRes, lDepth + rDepth)
    return Math.max(lDepth, rDepth) + 1
  }
  depth(root)
  return maxRes
};
```

## ?🌟😻✔ 557 反转字符串中的单词 III【easy】

[ref](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)

双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var reverseWords = function(s) {
  const n = s.length
  let l = 0, r = 0
  let res = ''

  while(r < n) {
    if(s[r] === ' ') {
      res += ' '
      r++
      l=r
    } else if(r + 1 < n && s[r + 1] === ' ') {
      res += reverse(s.slice(l, r + 1))
      r++
      l = r
    } else {
      r++
    }
  }
  if(l !== r) {
    res += reverse(s.slice(l, r))
  }

  return res
};

function reverse(s) {
  let res = ''
  let r = s.length - 1
  while(r >= 0) {
    res += s[r]
    r--
  }
  return res
}
```

## ?🌟😻✔ 560 和为 K 的子数组【medium】

[ref](https://leetcode.cn/problems/subarray-sum-equals-k/)

巧妙设计一个统计 `0~i` 位置总和数量的 map。

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var subarraySum = function(nums, k) {
  const len = nums.length
  let sum = 0
  const map = new Map()
  let count = 0
  for(let i = 0; i < len; i++) {
    sum += nums[i]
    if(sum === k) count++
    if(map.has(sum - k)) {
      count += map.get(sum - k)
    }
    map.set(sum, map.has(sum)? map.get(sum) + 1: 1)
  }
  return count
};
```

## 😻✔ 567 字符串的排列【medium】

[ref](https://leetcode.cn/problems/permutation-in-string/)

滑动窗口

```js
// m = s1.length, n = s2.length
// 时间复杂度：O(m + n)
// 时间复杂度：O(m)
var checkInclusion = function(s1, s2) {
  if(s2.length < s1.length) return false
  const len = s1.length
  const map = new Map()
  let typeCount = 0
  for(let i=0;i<len;i++) {
    if(map.has(s1[i])) {
      map.set(s1[i], map.get(s1[i]) + 1)
    } else {
      map.set(s1[i], 1)
      typeCount ++
    }
  }
  for(let i=0;i<len;i++) {
    if(map.has(s2[i])) {
      map.set(s2[i], map.get(s2[i]) - 1)
      if(map.get(s2[i]) === 0) {
        typeCount--
      }
    }
  }
  if(typeCount === 0) return true
  for(let i=len;i<s2.length;i++) {
    if(map.has(s2[i])) {
      map.set(s2[i], map.get(s2[i]) - 1)
      if(map.get(s2[i]) === 0) {
        typeCount--
      }
    }
    if(map.has(s2[i - len])) {
      map.set(s2[i - len], map.get(s2[i - len]) + 1)
      if(map.get(s2[i - len]) === 1) {
        typeCount++
      }
    }
    if(typeCount === 0) return true
  }
  return false
};
```

## ✔ 575 分糖果【easy】

[ref](https://leetcode.cn/problems/distribute-candies/)

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var distributeCandies = function(candyType) {
  const set = new Set(candyType)
  return Math.min(candyType.length / 2, set.size)
};
```

## ?🌟😻✔ 581 最短无序连续子数组【medium】

[ref](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)

直接排序，双指针找到左右两侧首个不同的数字

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var findUnsortedSubarray = function(nums) {
  const numsSorted = [...nums].sort((a, b) => a - b)
  let l = 0, r = nums.length - 1
  while(l < nums.length || r >= 0) {
    if(nums[l] === numsSorted[l]) {
      l++
    }
    if(nums[r] === numsSorted[r]) {
      r--
    }
    if(nums[l] !== numsSorted[l] && nums[r] !== numsSorted[r]) return r - l + 1
  }
  return 0
};
```

确定无序子数组的上下边界

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findUnsortedSubarray = function(nums) {
  const n = nums.length
  let max = -Infinity, maxi = -1 
  let min = Infinity, mini = -1
  for(let i=0;i<n;i++) {
    if(nums[i] >= max) {
      max = nums[i]
    } else {
      maxi = i
    }

    const j = n - 1 - i
    if(nums[j] <= min) {
      min = nums[j]
    } else {
      mini = j
    }
  }
  return maxi !== -1 ? maxi - mini + 1 : 0
};
```

上面的解法比较难想到，下面的更容易理解

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var findUnsortedSubarray = function(nums) {
  const lArr = []
  for(let i=0;i<nums.length;i++) {
    while(lArr.length && nums[lArr[lArr.length - 1]] > nums[i]) {
      lArr.pop()
    }
    lArr.push(i)
  }
  const rArr = []
  for(let i=nums.length - 1;i>=0;i--) {
    while(rArr.length && nums[rArr[0]] < nums[i]) {
      rArr.shift()
    }
    rArr.unshift(i)
  }
  let l, r
  let has = false
  for(let i=0;i<nums.length;i++) {
    const t = lArr.shift()
    if(i !== t) {
      l = i
      has = true
      break
    }
  }
  for(let i=nums.length - 1;i>=0;i--) {
    const t = rArr.pop()
    if(i !== t) {
      r = i
      has = true
      break
    }
  }
  return has ? r - l + 1 : 0
};
```

## 🌟😻✔ 617 合并二叉树【easy】

[ref](https://leetcode.cn/problems/merge-two-binary-trees/)

```js
// 时间复杂度：O(min(M, N))
// 空间复杂度：O(min(M, N))
var mergeTrees = function(root1, root2) {
  function merge(node1, node2) {
    if(!node1) return node2
    if(!node2) return node1
    let sum = node1.val + node2.val
    const node = new TreeNode(sum)
    node.left = merge(node1.left, node2.left)
    node.right = merge(node1.right, node2.right)
    return node
  }
  return merge(root1, root2)
};
```

## ??🌟😻✔ 621 任务调度器【medium】

[ref](https://leetcode.cn/problems/task-scheduler/)

模拟

```js
// 模拟题，不要扯什么算法，就是直接模拟硬推
// 时间复杂度：O(N+K) K 是大写字母的种类
// 空间复杂度：O(K)
var leastInterval = function(tasks, n) {
  const taskCount = new Array(26).fill(0)
  for(let i=0;i<tasks.length;i++) {
    taskCount[tasks[i].charCodeAt(0) - 'A'.charCodeAt(0)]++
  }
  taskCount.sort((a, b) => b - a)
  let bucketCount = 1
  let i = 1
  while(i < taskCount.length && taskCount[0] === taskCount[i]) {
    bucketCount++
    i++
  }
  return Math.max(bucketCount + (n + 1) * (taskCount[0] - 1), tasks.length)
};

```

## ??🌟😻✔ 630 课程表 III【hard】

[ref](https://leetcode.cn/problems/course-schedule-iii/)

贪心、优先队列、堆

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var scheduleCourse = function(courses) {
  courses.sort((a, b) => a[1] - b[1])
  let sum = 0
  const heap = new MaxHeap()
  for(let i=0;i<courses.length;i++) {
    const target = courses[i]
    sum += target[0]
    heap.insert(target[0])
    if(sum > target[1]) {
      sum -= heap.pop()
    }
  }
  return heap.size()
};

class MaxHeap {
  constructor() {
    this.heap = []
  }
  size() {
    return this.heap.length
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  insert(v) {
    this.heap.push(v)
    this.shiftUp(this.heap.length - 1)
  }
  pop() {
    this.swap(0, this.heap.length - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  shiftUp(i) {
    const pi = Math.floor((i - 1) / 2)
    if(this.heap[i] > this.heap[pi]) {
      this.swap(i, pi)
      this.shiftUp(pi)
    }
  }
  shiftDown(i) {
    const li = 2 * i + 1
    const ri = 2 * i + 2
    let maxi = i
    if(this.heap[li] > this.heap[maxi]) {
      maxi = li
    }
    if(this.heap[ri] > this.heap[maxi]) {
      maxi = ri
    }
    if(maxi !== i) {
      this.swap(maxi, i)
      this.shiftDown(maxi)
    }
  }
}

```

## 🌟😻✔ 647 回文子串【medium】

[ref](https://leetcode.cn/problems/palindromic-substrings/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var countSubstrings = function(s) {
  const len = s.length
  const dp = new Array(len).fill(false).map(_ => new Array(len).fill(false))
  let count = 0
  for(let i=0;i<len;i++) {
    dp[i][i] = true
    count++
  }

  for(let L=2;L<=len;L++) {
    for(let i=0;i + L - 1<len;i++) {
      if(s[i] === s[i + L - 1]) {
        dp[i][i + L - 1] = i + L - 2 >= i + 1 ? dp[i + 1][i + L - 2] : true
        if(dp[i][i + L - 1]) count++
      }
    }
  }

  return count
};
```

## 🌟😻✔ 652 寻找重复的子树【medium】

[ref](https://leetcode.cn/problems/find-duplicate-subtrees/)

```js
var findDuplicateSubtrees = function(root) {
  const m = new Map()
  const res = []

  function dfs(node) {
    const hash = `${node.val}`
    let left = ','
    let right = ','
    if(node.left) {
      left += dfs(node.left)
    }
    if(node.right) {
      right += dfs(node.right)
    }
    const currHash = `${hash}${left}${right}`
    m.set(currHash, m.has(currHash) ? m.get(currHash) + 1:1)
    if(m.get(currHash) === 2) {
      res.push(node)
    }
    return currHash
  }
  dfs(root)
  return res
};
```

## 😻✔ 695 岛屿的最大面积【medium】

[ref](https://leetcode.cn/problems/max-area-of-island/)

```js
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var maxAreaOfIsland = function(grid) {
  const m = grid.length
  const n = grid[0].length
  const used = new Array(m).fill(false).map(() => new Array(n).fill(false))
  let max = 0

  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 1 && !used[i][j]) {
        max = Math.max(calc(i, j), max)
      }
    }
  }

  function calc(i, j) {
    let sum = 1
    used[i][j] = true
    if(i - 1 >= 0 && !used[i - 1][j] && grid[i - 1][j] === 1) {
      sum += calc(i - 1, j)
    }
    if(i + 1 <  m && !used[i + 1][j] && grid[i + 1][j] === 1) {
      sum += calc(i + 1, j)
    }
    if(j - 1 >= 0 && !used[i][j - 1] && grid[i][j - 1] === 1) {
      sum += calc(i,j - 1)
    }
    if(j + 1 < n  && !used[i][j + 1] && grid[i][j + 1] === 1) {
      sum += calc(i, j + 1)
    }
    return sum
  }

  return max
};
```

## ??🌟😻✔ 698 划分为k个相等的子集【medium】

[ref](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

相关

- ?? [🌟【medium】 416 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/) 背包问题


回溯

```js
var canPartitionKSubsets = function(nums, k) {
  let sum = 0
  let max = nums[0]
  const len = nums.length
  for(let i=0;i<len;i++) {
    sum += nums[i]
    max = Math.max(max, nums[i])
  }
  const target0 = sum / k
  if(Math.floor(target0) !== target0 || max > target0) return false
  nums.sort((a, b) => a - b)
  const used = new Array(len).fill(false)

  function dfs(n, s, startIndex) {
    if(s === target0) {
      // 每找到一次就会刷新 startIndex
      return dfs(n - 1, 0, 0)
    }
    // 只要找到 n - 1 个 符合条件的捅即可，剩余的一个自然会符合条件
    if(n === 1)  return true
    for(let i=startIndex;i<nums.length;i++) {
      if(s + nums[i] > target0) break
      if(used[i]) continue
      used[i] = true
      const r = dfs(n, s + nums[i], i + 1)
      used[i] = false
      if(r) {
        return true
      }
    }
    return false
  }
  return dfs(k, 0, 0)
};
```

## 😻✔ 704 二分查找【easy】

[ref](https://leetcode.cn/problems/binary-search/)

二分查找

```js
// 时间复杂度：O(logn)
// 时间复杂度：O(1)
var search = function(nums, target) {
  let l = 0
  let r = nums.length - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] < target) {
      l = mid + 1
    } else if(nums[mid] > target) {
      r = mid - 1
    } else {
      return mid
    }
  }
  return -1
};
```

## 😻✔ 707 设计链表【medium】

[ref](https://leetcode.cn/problems/design-linked-list/)

链表

```js
function Node(val, next) {
  this.val = val
  this.next = next || null
}

var MyLinkedList = function() {
 this.head = new Node()
 this.tail = new Node()
 this.size = 0
};

/** 
 * @param {number} index
 * @return {number}
 */
MyLinkedList.prototype.get = function(index) {
  if(index<0 || index>= this.size) return -1
  let tHead = this.head
  let i = 0
  while(tHead) {
    if(i === index) {
      return tHead.next.val
    } else {
      tHead = tHead.next
      i++
    }
  }
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtHead = function(val) {
  const first = this.head.next
  this.head.next = new Node(val, first)
  this.size++
  if(!first) {
    this.tail.next = this.head.next
  }
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtTail = function(val) {
  if(this.tail.next) {
    const newEnd = new Node(val)
    this.tail.next.next = newEnd
    this.tail.next = newEnd
  } else {
    const node = new Node(val)
    this.head.next = node
    this.tail.next = node
  }
  this.size++
};

/** 
 * @param {number} index 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtIndex = function(index, val) {
  if(index<0) {
    this.addAtHead(val)
    return
  }
  let i = 0
  let tHead = this.head
  while(tHead) {
    if(i === index) {
      const next = tHead.next
      tHead.next = new Node(val, next)
      if(index === this.size) {
        this.tail.next = tHead.next
      }
      this.size++
      break
    } else {
      tHead = tHead.next
      i++
    }
  }
};

/** 
 * @param {number} index
 * @return {void}
 */
MyLinkedList.prototype.deleteAtIndex = function(index) {
  if(index<0 || index>= this.size) return
  let i = 0
  let tHead = this.head
  while(tHead) {
    if(i === index) {
      const next = tHead.next.next
      tHead.next = next
      if(index === this.size - 1) {
        this.tail.next = tHead
      }
      this.size--
      break
    } else {
      tHead = tHead.next
      i++
    }
  }
};
```

## ?🌟😻✔ 713 乘积小于 K 的子数组【medium】

[ref](https://leetcode.cn/problems/subarray-product-less-than-k/submissions/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numSubarrayProductLessThanK = function(nums, k) {
  let count = 0
  let mul = 1
  let i = 0
  for(let j = 0;j<nums.length;j++) {
    mul*=nums[j]
    while(i<=j && mul>=k) {
      mul /= nums[i]
      i++
    }
    count+=j-i+1
  }
  return count
};
```

## 😻✔ 714 买卖股票的最佳时机含手续费【medium】

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices, fee) {
  let profitWithoutShare = 0
  let profitWithShare = -prices[0]
  for(let i = 1;i < prices.length; i++) {
    const profitWithoutShareBefore = profitWithoutShare
    const profitWithShareBefore = profitWithShare
    profitWithoutShare = Math.max(profitWithoutShareBefore, profitWithShareBefore + prices[i] - fee)
    profitWithShare = Math.max(profitWithShareBefore, profitWithoutShare - prices[i])
  }
  return profitWithoutShare
};
```

数组版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProfit = function(prices, fee) {
  // 0 不持有股票
  // 1 持有股票
  const len = prices.length
  const dp = new Array(len).fill(1).map(_ => [])
  dp[0][0] = 0
  dp[0][1] = -prices[0]
  for(let i = 1;i < prices.length; i++) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)
    dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i])
  }
  return dp[prices.length - 1][0]
};
```

## ?🌟😻✔ 763 划分字母区间【medium】

[ref](https://leetcode.cn/problems/partition-labels/)

字符串、区间、关联线段

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var partitionLabels = function(s) {
  const map = new Map()
  for(let i=0;i<s.length;i++) {
    map.set(s[i], i)
  }
  const res = []
  let endIndex = 0
  let beginIndex = 0
  for(let i=0;i<s.length;i++) {
    const w = s[i]
    endIndex = Math.max(map.get(w), endIndex)
    if(i === endIndex) {
      res.push(endIndex - beginIndex + 1)
      beginIndex = i + 1
    }
  }
  return res
};
```


## ?🌟😻✔ 739. 每日温度【medium】

[ref](https://leetcode.cn/problems/daily-temperatures/)

单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var dailyTemperatures = function(temperatures) {
  const len = temperatures.length
  const res = new Array(len).fill(0)
  const s = []
  for(let i = len - 1;i>=0;i--) {
    while(s.length && temperatures[s[s.length - 1]] <= temperatures[i]) {
      s.pop()
    }
    if(s.length) {
      res[i] = s[s.length - 1] - i
    } else {
      res[i] = 0
    }
    s.push(i)
  }
  return res
};
```

## ✔ 746 使用最小花费爬楼梯【easy】

[ref](https://leetcode.cn/problems/min-cost-climbing-stairs/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var minCostClimbingStairs = function(cost) {
  const len = cost.length
  const dp = new Array(len).fill(0)
  dp[0] = cost[0]
  dp[1] = cost[1]
  for(let i=2;i<len;i++) {
    dp[i] = cost[i] + Math.min(dp[i - 1], dp[i - 2])
  }
  return Math.min(dp[len - 1], dp[len - 2])
};
```

## 🌟✔ 796. 旋转字符串【easy】

[ref](https://leetcode.cn/problems/rotate-string/submissions/)

略有趣

```js
var rotateString = function(s, goal) {
  return s.length === goal.length && (s + s).includes(goal)
};
```

or

```js
var rotateString = function(s, goal) {
  for(let i=1;i<=s.length;i++) {
     if(s === goal) return true
     const sA = s.split('')
     sA.push(sA.shift())
     s = sA.join('')
  }
  return false
};
```

## ??🌟😻✔ 815 公交路线【hard】

[ref](https://leetcode.cn/problems/bus-routes/)

BFS、图

```js
var numBusesToDestination = function(routes, source, target) {
  // 还有这种恶心人的 case?，直接给我滚蛋
  if(source === target) return 0
  // 一个站点有哪几条公交线路经过
  const pointMap = new Map()
  // 公交路线交叉图
  const crossMap = new Map()
  // 能够从哪些公交路线开始
  const startArr = []
  // 能够结束于哪些公交路线
  const endSet = new Set()
  for(let i = 0;i < routes.length; i++) {
    const l = routes[i].length
    if(l === 1) continue
    for(let j = 0;j < l;j++) {
      if(routes[i][j] === target) {
        endSet.add(i)
      }
      if(routes[i][j] === source) {
        startArr.push(i)
      }
      if(pointMap.has(routes[i][j])) {
        pointMap.get(routes[i][j]).push(i)
      } else {
        pointMap.set(routes[i][j], [i])
      }
    }
  }
  // 没有开始的公交线路或者没有到达结束点的公交线路 直接 return
  if(!startArr.length || !endSet.size) return -1
  // 构建公交路线交叉图
  for(let rs of pointMap.values()) {
    for(let i=0;i<rs.length;i++) {
      for(let j=0;j<rs.length;j++) {
        if(i === j) continue
        if(crossMap.has(rs[i])) {
          crossMap.get(rs[i]).add(rs[j])
        } else {
          crossMap.set(rs[i], new Set([rs[j]]))
        }
      }
    }
  }
  // BFS 从开始线路往外扩展，搜到第一个结束线路即可认为结束了
  let q = startArr
  let next = []
  let min = 1
  const passed = new Set()
  while(q.length) {
    const cr = q.shift()
    if(endSet.has(cr)) return min
    if(!passed.has(cr)) {
      if(crossMap.has(cr)) {
        next = [...next, ...crossMap.get(cr)]
      }
      passed.add(cr)
    }
    if(!q.length && next.length > 0) {
      min++
      q = next
      next = []
    }
  }
  return -1
};

```

## ?🌟😻✔ 862 和至少为 K 的最短子数组【hard】

[ref](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)


单调队列、前缀数组、滑动窗口、双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var shortestSubarray = function(nums, k) {
  const len = nums.length
  let min = Number.MAX_SAFE_INTEGER
  let P = new Array(len + 1).fill(0) // 前缀数组
  let S = [] // 下标单调队列
 
  for(let i=0;i<len;i++) {
    P[i + 1] = P[i] + nums[i]
  }

  for(let i=0;i<len;i++) {
    while(S.length > 0 && P[i] < P[S[S.length - 1]]) {
      S.pop()
    }
    S.push(i)

    while(S.length && P[i] + nums[i] - P[S[0]] >= k) {
      min = Math.min(min, i - S.shift() + 1)
    }
  }

  return min === Number.MAX_SAFE_INTEGER ? -1 : min
};
```

or

```js
var shortestSubarray = function(nums, k) {
  const len = nums.length
  let l = 0
  let r = 0
  let min = Number.MAX_SAFE_INTEGER
  let sum = 0

  while(r < len) {
    sum += nums[r]
    if(sum >= k) {
      let tS = 0
      for(let j=r;j>=l;j--) {
        tS += nums[j]
        if(tS >= k) {
          l = j
          sum = tS
          break
        }
      }
      min = Math.min(r - l + 1, min)
    } else {
      while((nums[l] <= 0 || sum <= 0) && l <= r) {
        sum -= nums[l]
        l++
      }
    }
    r++
  }

  return min === Number.MAX_SAFE_INTEGER ? -1 : min
};
```

## ✔ ??🌟😻✔ 879 盈利计划【hard】

[ref](https://leetcode.cn/problems/profitable-schemes/)

动态规划、多维背包问题

```js
// 特殊的多维费用背包问题
var profitableSchemes = function(n, minProfit, group, profit) {
  const mod = 10 ** 9 + 7
  const len = group.length
  const dp = new Array(n + 1).fill(0)
              .map(_ => new Array(len + 1).fill(0)
              .map(__ => new Array(minProfit + 1).fill(0)))

  for(let i=0;i<=n;i++) {
    dp[i][0][0] = 1
  }

  for(let i=0;i<=n;i++) {
    for(let j=1;j<=len;j++) {
      const p = profit[j-1]
      const g = group[j-1]
      for(let k=0;k<=minProfit;k++) {
        dp[i][j][k] = dp[i][j - 1][k]
        if(i >= g) {
          dp[i][j][k] += dp[i - g][j - 1][Math.max(k - p, 0)]
          if(dp[i][j][k] >= mod) {
            dp[i][j][k] -= mod
          }
        }
      }
    }
  }
  return dp[n][len][minProfit]
};

```

## ✔ 933 最近的请求次数【easy】

[ref](https://leetcode.cn/problems/number-of-recent-calls/)

这个题的描述很容易看不懂，但是实现起来非常简单

关键词：队列

```js
var RecentCounter = function () {
  this.q = []
}
/**
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function (t) {
  this.q.push(t)
  while (t - this.q[0] > 3000) {
    this.q.shift()
  }
  return this.q.length
}
```


## 🌟✔ 977 有序数组的平方【easy】

[ref](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```js
// 时间复杂度：O(N)
// 时间复杂度：O(1)
var sortedSquares = function(nums) {
  const len = nums.length
  let l = 0, r = len - 1
  const res = []
  while(l<=r) {
    if(Math.abs(nums[l]) >= Math.abs(nums[r])) {
      res.unshift(nums[l] ** 2)
      l++
    } else {
      res.unshift(nums[r] ** 2)
      r--
    }
  }
  return res
};
```

## 🌟✔ 1103 分糖果 II【easy】

[ref](https://leetcode.cn/problems/distribute-candies-to-people/)

```js
var distributeCandies = function(candies, num_people) {
  const res = new Array(num_people).fill(0)
  let n = 1
  let index = 0
  while(candies) {
    if(candies <= n) {
      res[index] += candies
      candies = 0
    } else {
      res[index] += n
      candies -= n
    }
    n++
    index++
    if(index === num_people) index = 0
  }
  return res
};
```

## ?🌟😻✔ 1143 最长公共子序列【medium】

[ref](https://leetcode.cn/problems/longest-common-subsequence/)

子序列问题，动态规划

```js
var longestCommonSubsequence = function(text1, text2) {
  const m = text1.length
  const n = text2.length
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  for(let i=0;i<m;i++) {
    if(text1[i] === text2[0]) {
      dp[i][0] = 1
    } else {
      dp[i][0] = i - 1 >= 0 ?dp[i - 1][0] : 0
    }
  }
  for(let j=0;j<n;j++) {
    if(text1[0] === text2[j]) {
      dp[0][j] = 1
    } else {
      dp[0][j] = j - 1 >= 0 ?dp[0][j - 1] : 0
    }
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      if(text1[i] === text2[j]) {
        dp[i][j] = 1 + dp[i - 1][j - 1]
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
      }
    }
  }
  return dp[m - 1][n - 1]
};
```

## ✔ 1306 跳跃游戏 III【medium】

[ref](https://leetcode.cn/problems/jump-game-iii/)

广度优先遍历

```js
// BFS
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var canReach = function(arr, start) {
  if(arr[start] === 0) return true
  const len = arr.length
  const usedIndexes = []
  const nextIndexes = [start]
  while(nextIndexes.length > 0) {
    const targetIndex = nextIndexes.pop()
    if(arr[targetIndex] === 0) return true
    usedIndexes.push(targetIndex)
    if((targetIndex - arr[targetIndex] >= 0) && !usedIndexes.includes(targetIndex - arr[targetIndex])) {
      nextIndexes.push(targetIndex - arr[targetIndex])
    }
    if((targetIndex + arr[targetIndex] <= len - 1) && !usedIndexes.includes(targetIndex + arr[targetIndex])) {
      nextIndexes.push(targetIndex + arr[targetIndex])
    }
  }
  return false
};
```

深度优先遍历

```js
// DFS
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var canReach = function(arr, start) {
  if(arr[start] === 0) return true
  const usedIndexes = []
  usedIndexes.push(start)

  function jump(index) {
    if(arr[index] === 0) {
      usedIndexes.push(index)
      return true
    }
    if(index < 0 || index >= arr.length || usedIndexes.includes(index)) {
      return false
    }
    usedIndexes.push(index)
    return jump(index - arr[index]) || jump(index + arr[index])
  }

  return jump(start - arr[start]) || jump(start + arr[start])
};

```

## ??🌟😻✔ 1411 给 N x 3 网格图涂色的方案数【hard】

[ref](https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/)

数学推导题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numOfWays = function(n) {
  let f0 = 6, f1 = 6
  for(let i=1;i<n;i++) {
    const nf0 = (3*f0 + 2*f1) % 1000000007
    const nf1 = (2*f0 + 2*f1) % 1000000007
    f0 = nf0
    f1 = nf1
  }

  return (f0 + f1) % 1000000007
};

// 0 1 2
// 0 2 1
// 1 0 2
// 1 2 0
// 2 0 1
// 2 1 0

// 0 1 0
// 0 2 0
// 1 0 1
// 1 2 1
// 2 0 2
// 2 1 2

// -----
// A B A

// B A B
// C A C
// B C B

// B A C
// C A B
// -----

// -----
// A B C

// B A B
// B C B

// B C A
// C A B
// -----
// f0 = 6, f1 = 6

// nf0 = 3*f0 + 2*f1
// nf1 = 2*f0 + 2*f1

```

## ✔ 1446. 连续字符【easy】

[ref](https://leetcode.cn/problems/consecutive-characters/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxPower = function(s) {
  let max = 1
  let len = 1
  for(let i=1;i<s.length;i++) {
    if(s[i] === s[i - 1]) {
      len++
      max = Math.max(max, len)
    } else {
      len = 1
    }
  }
  return max
};
```

## 🌟😻✔ 剑指 Offer 04. 二维数组中的查找【medium】

[ref](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

```js
// 普通版
var findNumberIn2DArray = function(matrix, target) {
  if(!matrix.length) return false
  const m = matrix.length
  const n = matrix[0].length
  for(let j = n - 1; j >= 0; j--) {
    if(target === matrix[0][j]) {
      return true
    } else if(target < matrix[0][j]) {
      continue
    } else {
      for(let i = 1; i < m; i++) {
        if(matrix[i][j] === target) {
          return true
        } else if(matrix[i][j] < target) {
          continue
        } else {
          break
        }
      }
    }
  }
  return false
};
```

```js
// 高效版
// 时间复杂度：O(m+n)
// 空间复杂度：O(1)
var findNumberIn2DArray = function(matrix, target) {
  if(!matrix.length || !matrix[0].length) return false
  const m  = matrix.length
  const n  = matrix[0].length
  let i = 0
  let j = n - 1
  while(i < m && j >= 0) {
    if(matrix[i][j] === target) {
      return true
    } else if(matrix[i][j] > target) {
      j--
    } else {
      i++
    }
  }
  return false
};
```

## ✔ 剑指 Offer 05. 替换空格【easy】

[ref](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var replaceSpace = function(s) {
  let res = ''
  for(let c of s) {
    if(c === ' ') {
      res+='%20'
    } else {
      res+=c
    }
  }
  return res
};
```

## ✔ 剑指 Offer 06. 从尾到头打印链表【easy】

[ref](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

```js
var reversePrint = function(head) {
  const res = []
  while(head) {
    res.unshift(head.val)
    head = head.next
  }
  return res
};
```

## ✔ 剑指 Offer 09. 用两个栈实现队列【easy】

[ref](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```js
var CQueue = function() {
  this.inStack = []
  this.outStack = []
};

/** 
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
  this.inStack.push(value)
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
  // 必须要把 outStack 出干净之后才能再次从 instack 中拿数据
  if(!this.outStack.length) {
    if(this.inStack.length) {
      this.toOut()
      return this.outStack.pop()
    }
    return -1
  }
  return this.outStack.pop()
};

CQueue.prototype.toOut = function() {
  while(this.inStack.length) {
    this.outStack.push(this.inStack.pop())
  }
}
```

## ?🌟😻✔ 剑指 Offer 10- II. 青蛙跳台阶问题【easy】

[ref](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

动态规划、斐波拉契数列

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numWays = function(n) {
  if(n === 1 || n === 0) return 1
  let prev1 = 1
  let prev2 = 2
  for(let i=3;i<=n;i++) {
    const prev1Bf = prev1
    const prev2Bf = prev2
    prev2 = (prev1Bf + prev2Bf) % 1000000007
    prev1 = prev2Bf
  }
  return prev2
};

```

## 🌟😻✔ 剑指 Offer 12. 矩阵中的路径【medium】

[ref](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)

回溯

```js
// 时间复杂度：O(MN*3**L) L=word.length
// 空间复杂度：O(MN)
var exist = function(board, word) {
  const m = board.length
  const n = board[0].length

  function find(i, j, startIndex) {
    if(i < 0 || i >= m || j < 0 || j >= n || used[i][j] || board[i][j] !== word[startIndex]) return false
    if(startIndex === word.length - 1) return true
    used[i][j] = true

    const res = find(i + 1, j, startIndex + 1)
      || find(i - 1, j, startIndex + 1)
      || find(i, j + 1, startIndex + 1)
      || find(i, j - 1, startIndex + 1)

    used[i][j] = false
    return res
  }

  const used = new Array(m).fill(false).map(_ =>  new Array(n).fill(false))

  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(find(i, j, 0)) return true
    }
  }

  return false
};
```

## 😻✔ 剑指 Offer 13. 机器人的运动范围【medium】

[ref](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

动态规划、递归

```js
// 动态规划、递推
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var movingCount = function(m, n, k) {
  const dp = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  dp[0][0] = true
  let count = 1
  for(let i=1;i<m;i++) {
    dp[i][0] = sum(i, 0) <= k && dp[i - 1][0]
    dp[i][0] && count++
  }
  for(let j=1;j<n;j++) {
    dp[0][j] = sum(0, j) <= k && dp[0][j - 1]
    dp[0][j] && count++
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      dp[i][j] = sum(i, j) <= k && (
        i - 1 >= 0 && dp[i - 1][j] ||
        j - 1 >= 0 && dp[i][j - 1]
      )
      dp[i][j] && count++
    }
  }
  return count
};

function sum(i, j) {
  let s = 0
  while(i>0) {
    s += i % 10
    i = Math.floor(i / 10)
  }
  while(j > 0) {
    s += j % 10
    j = Math.floor(j / 10)
  }
  return s
}
```

```js
// 递归
// 时间复杂度：O(mn)
// 空间复杂度：O(mn)
var movingCount = function(m, n, k) {
  let count = 0
  const walked = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  function walk(i, j) {
    if(i < m && j < n && sum(i, j) <= k && !walked[i][j]) {
      walked[i][j] = true
      count++
      walk(i + 1, j)
      walk(i, j + 1)
    }
  }
  walk(0, 0)
  return count
};

function sum(i, j) {
  let s = 0
  while(i > 0) {
    s += i % 10
    i = Math.floor(i / 10)
  }
  while(j > 0) {
    s += j % 10
    j = Math.floor(j / 10)
  }
  return s
}
```

## ??🌟😻✔ 剑指 Offer 14- I. 剪绳子【medium】

[ref](https://leetcode.cn/problems/jian-sheng-zi-lcof/)

动态规划、数学规律

```js
var cuttingRope = function(n) {
  if(n <= 3) return n - 1
  let res = 1
  while(n > 4) {
    res *= 3
    n -= 3
  }
  return res * n
};
```

```js
// 数学规律解法
// 时间复杂度：O(1)
// 时间复杂度：O(1)
var cuttingRope = function(n) {
  if(n <= 3) return n - 1
  const a = Math.floor(n / 3), b = n % 3
  if(b === 0) return 3 ** a
  if(b === 1) return (3 ** (a - 1)) * 4
  return (3 ** a) * 2
};
```

```js
// 动态规划思路
// 时间复杂度：O(N^2)
// 时间复杂度：O(N)
var cuttingRope = function(n) {
  const dp = new Array(n + 1).fill(1)
  for(let i=2;i<=n;i++) {
    for(let j=1;j<i;j++) {
      dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j])
    }
  }
  return dp[n]
};
```

## ???🌟😻✔ 剑指 Offer 14- II. 剪绳子 II【medium】

[ref](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/)

数学规律

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var cuttingRope = function(n) {
  const mod = 1000000007
  if(n <= 3) return n - 1
  let res = 1
  while(n > 4) {
    res = (res * 3) % mod
    n -= 3
  }
  return (res * n) % mod
};

// 10 => 3 3 4 => 36
// 9  => 3 3 3 => 27
// 8  => 3 3 2 => 18
// 7  => 3 4 => 12
// 6  => 3 3 => 9
// 5  => 3 2 => 6
// 4  => 3 1 or 2 2 => 4
// 3  => 2 1 => 2
// 2  => 1 1 => 1

```

## ??🌟😻✔ 剑指 Offer 15. 二进制中1的个数【easy】

[ref](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/submissions/)

二进制、二进制运算

```js
// 循环检查每一位上1的个数
// 时间复杂度：O(K) k=32
// 空间复杂度：O(1)
var hammingWeight = function(n) {
  let count = 0
  for(let i=0;i<32;i++) {
    if(n & (1 << i)) count++
  }
  return count
};
// 1 << 32 === 1
```

```js
// 循环检查每一位上1的个数
// 时间复杂度：O(logN) logN <= 32
// 空间复杂度：O(1)
var hammingWeight = function(n) {
  let count = 0
  // 每循环一次都会清理掉从右往左的第一个1
  while(n) {
    n &= n - 1
    count++
  }
  return count
};
```

## ??🌟😻✔ 剑指 Offer 16. 数值的整数次方【medium】

[ref](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

快速幂、规律题

```js
// 快速幂
// 时间复杂度：O(logN)
// 空间复杂度：O(logN)
var myPow = function(x, n) {
  function pow(x, n) {
    if(n === 0) return 1
    if(n === 1) return x
    const y = pow(x, Math.floor(n / 2))
    const res =  y * y * (n % 2 === 0 ? 1 : x)
    return res
  }
  return n < 0? 1 / pow(x, -n): pow(x, n)
};

```


## ✔ 剑指 Offer 18. 删除链表的节点【easy】

[ref](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var deleteNode = function(head, val) {
  const myHead = new ListNode()
  myHead.next = head
  let thead = myHead
  while(thead.next) {
    if(thead.next.val === val) {
      thead.next = thead.next.next
      return myHead.next
    } else {
      thead = thead.next
    }
  }
  return myHead.next
};

```

## ??🌟😻✔ 剑指 Offer 19. 正则表达式匹配【hard】

[ref](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

动态规划

```js
// 动态规划
// 时间复杂度：O(M*N)
// 空间复杂度：O(M*N)
var isMatch = function(s, p) {
  const m = s.length, n = p.length
  const dp = new Array(m + 1).fill(0).map(_ => new Array(n + 1).fill(false))

  dp[0][0] = true

  for(let j=2;j<=n;j++) {
    if(p[j-1] === '*') {
      dp[0][j] = dp[0][j-2]
    }
  }
  
  for(let i=1;i<=m;i++) {
    for(let j=1;j<=n;j++) {
      if(p[j - 1] === '.' || s[i - 1] === p[j - 1]) {
        dp[i][j] = dp[i-1][j-1]
      } else if(p[j-1] === '*') {
        dp[i][j] = dp[i][j-2]
        if(p[j - 2] === '.' || p[j - 2] === s[i - 1]) {
          dp[i][j] = dp[i][j] || dp[i-1][j]
        }
      }
    }
  }

  return dp[m][n]
};

```

## ?? 🌟😻✔ 剑指 Offer 20. 表示数值的字符串【medium】

[ref](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

模拟、规律

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var isNumber = function(s) {
  // 去除首尾空格，之后不要再让我看到空格了啊，看到反手就是false
  s = s.trim().toLowerCase()
  if(!s.length) return false
  // 根据 e 直接拆分
  const sSplit = s.split('e')
  // 只有一个元素，那就不是科学计数法
  if(sSplit.length === 1) {
    return checkLeft(sSplit[0])
  } else if(sSplit.length === 2) {
    // 有两个元素，那可能是科学计数法
    return checkLeft(sSplit[0]) && checkRight(sSplit[1])
  }
  // 反手 false
  return false
};

// 检测e左侧部分
function checkLeft(s) {
  if(!s.length) return false
  let i=0
  let hasDot = false
  // 去除首正负号，之后不要让我看到符号了啊
  if(s[0] === '+' || s[0] === '-') {
    s = s.slice(1)
    // 好小子，难道只有符号没数字？
    if(!s.length) return false
  }
  while(i<s.length) {
    if(s[i] === '.') {
      // 难不成有几个 '.'?
      // 难不成s === '.'?
      if(hasDot || s.length === 1) return false
      hasDot = true
      i++
    // 我只要数字，别的我统统不要
    } else if(s[i] !== ' ' && s[i] >= 0 && s[i] <= 9) {
      i++
    } else {
      return false
    }
  }
  return true
}

// 检测整数部分
function checkRight(s) {
  if(!s.length) return false
  let i = 0
  // 去除首正负号，之后不要让我看到符号了啊
  if(s[0] === '+' || s[0] === '-') {
    s = s.slice(1)
    // 好小子，难道只有符号没数字？
    if(!s.length) return false
  }
  while(i<s.length) {
    // 思路清晰，我只要数字，别来其他幺蛾子
    // ' ' == 0 这点要注意，得排除
    if(s[i] !== ' ' && s[i] >= 0 && s[i] <= 9) {
      i++
    } else {
      return false
    }
  }
  return true
}
```

## 😻✔ 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面【easy】

[ref](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var exchange = function(nums) {
  let l = 0
  for(let i=0;i<nums.length;i++) {
    if(nums[i] % 2 === 1) {
      swap(nums, l, i)
      l++
    }
  }
  return nums
};

function swap(nums, i, j) {
  const t = nums[i]
  nums[i] = nums[j]
  nums[j] = t
}
```

## 😻✔ 剑指 Offer 22 链表中倒数第k个节点【easy】

[ref](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

链表

```js
var getKthFromEnd = function(head, k) {
  let tail = head
  for(let i=0;i<k;i++) {
    tail = tail.next
  }
  while(tail) {
    tail = tail.next
    head = head.next
  }
  return head
};
```

## ✔ 剑指 Offer 25 合并两个排序的链表【easy】

[ref](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

```js
var mergeTwoLists = function(l1, l2) {
  const head = new ListNode()
  let tHead = head
  while(l1 && l2) {
    if(l1.val < l2.val) {
      tHead.next = l1
      l1 = l1.next
    } else {
      tHead.next = l2
      l2 = l2.next
    }
    tHead = tHead.next
  }
  if(l1) {
    tHead.next = l1
  }
  if(l2) {
    tHead.next = l2
  }
  return head.next
};
```

## 😻✔ 剑指 Offer 26 树的子结构【medium】

[ref](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

二叉树

```js
// M=A.length N=A.length
// 时间复杂度：O(MN)
// 空间复杂度：O(M)
var isSubStructure = function(A, B) {
  if(!A || !B) return false
  return isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)
};

function isSub(A, B) {
  if(!B) return true
  if(!A) return false
  if(A.val !== B.val) return false
  return isSub(A.left, B.left) && isSub(A.right, B.right)
}
```

## 🌟😻✔ 剑指 Offer 27. 二叉树的镜像【easy】

[ref]()https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/

二叉树、镜像二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var mirrorTree = function(root) {
  if(!root) return null
  function create(node1, node2) {
    if(node1.left) {
      node2.right = new TreeNode(node1.left.val)
      create(node1.left, node2.right)
    }
    if(node1.right) {
      node2.left = new TreeNode(node1.right.val)
      create(node1.right, node2.left)
    }
  }
  const newRoot = new TreeNode(root.val)
  create(root, newRoot)
  return newRoot
};
```

## ?🌟😻✔ 剑指 Offer 28. 对称的二叉树【easy】

[ref](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)

二叉树、对称二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var isSymmetric = function(root) {
  if(!root) return true
  return compare(root.left, root.right)  
};

function compare(lnode, rnode) {
  if(!lnode && !rnode) return true
  if(lnode && rnode && lnode.val === rnode.val) {
    return compare(lnode.left, rnode.right) && compare(lnode.right, rnode.left)
  }
  return false
}
```

## ?🌟😻✔ 剑指 Offer 29. 顺时针打印矩阵【medium】

[ref](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

```js
// 时间复杂度：O(M*N)
// 时间复杂度：O(1)
var spiralOrder = function(matrix) {
  if(!matrix.length || !matrix[0].length) return []
  const m = matrix.length
  const n = matrix[0].length
  const len = m * n
  const res = []

  for(let i=0;i<Math.floor((m + 1) / 2);i++) {
    for(let j = i;j<=n - i - 1;j++) {
      res.push(matrix[i][j])
      if(res.length === len) return res 
    }
    for(let j = i + 1;j<m - i - 1;j++) {
      res.push(matrix[j][n - i - 1])
      if(res.length === len) return res
    }
    for(let j =n - i - 1;j>i;j--) {
      res.push(matrix[m - i - 1][j])
      if(res.length === len) return res
    }
    for(let j =m - i - 1;j>i;j--) {
      res.push(matrix[j][i])
      if(res.length === len) return res
    }
  }
};

// 1 2  3  4
// 5 6  7  8
// 9 10 11 12
// m=4 n=3
```

## ??🌟😻✔ 剑指 Offer 31. 栈的压入、弹出序列【medium】

[ref](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var validateStackSequences = function(pushed, popped) {
  let j=0
  const stack = []
  for(let i=0;i<pushed.length;i++) {
    stack.push(pushed[i])
    while(stack.length && stack[stack.length - 1] === popped[j]) {
      stack.pop()
      j++
    }
  }
  return stack.length === 0
};

```

## 🌟😻✔ 剑指 Offer 32 - I. 从上到下打印二叉树【medium】

[ref](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

BFS

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var levelOrder = function(root) {
  if(!root) return []
  const q = [root]
  const res = []
  while(q.length) {
    const t = q.shift()
    res.push(t.val)
    if(t.left) q.push(t.left)
    if(t.right) q.push(t.right)
  }
  return res
};
```

## 🌟😻✔ 剑指 Offer 32 - II. 从上到下打印二叉树 II【easy】

[ref](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

二叉树、BFS

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var levelOrder = function(root) {
  if(!root) return []
  let q = [root]
  let tq = []
  const res = []
  let tres = []
  while(q.length) {
    const node = q.shift()
    tres.push(node.val)
    node.left && tq.push(node.left)
    node.right && tq.push(node.right)
    if(!q.length) {
      q = tq
      tq = []
      res.push(tres)
      tres = []
    }
  }
  return res
};
```

## ? 🌟😻✔ 剑指 Offer 32 - III. 从上到下打印二叉树 III【medium】

[ref](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

二叉树、BFS

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var levelOrder = function(root) {
  if(!root) return []
  let tq = []
  let fromLeft = true
  let q = [root]
  const res = []
  let tres = []
  while(q.length) {
    const node = q.shift()
    if(fromLeft) {
      tres.push(node.val)
    } else {
      tres.unshift(node.val)
    }
    node.left && tq.push(node.left)
    node.right && tq.push(node.right)
    if(!q.length) {
      res.push(tres)
      tres = []
      q = tq
      tq = []
      fromLeft = !fromLeft
    }
  }
  return res
};
```

## ?? 🌟😻✔ 剑指 Offer 33. 二叉搜索树的后序遍历序列【medium】

[ref](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

二叉搜索树、后序遍历

```js
var verifyPostorder = function(postorder) {
  function verify(i, j) {
    if(i >= j) return true
    let l = i
    while(postorder[l] < postorder[j]) {
      l++
    }
    let leftMaxI = l
    while(postorder[l] > postorder[j]) {
      l++
    }
    return l === j && verify(i, leftMaxI - 1) && verify(leftMaxI, j - 1)
  }

  return verify(0, postorder.length - 1)
};
```

## ? 🌟😻✔ 剑指 Offer 34. 二叉树中和为某一值的路径【medium】

[ref](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

二叉树、二叉树路径和

```js
// 时间复杂度：O(N^2)
// 时间复杂度：O(N)
var pathSum = function(root, target) {
  if(!root) return []
  const res = []
  function dfs(node, path, sum) {
    if(!node.left && !node.right) {
      if(target === sum + node.val ) {
        res.push([...path, node.val])
      }
      return
    }
    path.push(node.val)
    node.left && dfs(node.left, path, sum + node.val)
    node.right && dfs(node.right, path, sum + node.val)
    path.pop()
  }
  dfs(root, [], 0)
  return res
};
```

## ?? 🌟😻✔ 剑指 Offer 35. 复杂链表的复制【medium】

[ref](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

链表

```js
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

// 时间复杂度：O(N)
// 空间复杂度：O(N)
var copyRandomList = function(head) {
  const map = new Map()
  function copyNode(node) {
    if(!node) return null
    if(map.has(node)) {
      return map.get(node)
    }
    const newNode = new Node(node.val)
    map.set(node, newNode)
    newNode.next = copyNode(node.next)
    newNode.random = copyNode(node.random)
    return newNode
  }

  return copyNode(head)
};
```

更优解

```js
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var copyRandomList = function(head) {
  if(!head) return null
  const theHead = head
  while(head) {
    const newNode = new Node(head.val)
    const next = head.next
    head.next = newNode
    newNode.next = next
    head = next
  }
  head = theHead
  while(head) {
    const next = head.next
    next.random = head.random? head.random.next : null 
    head = next.next
  }
  head = theHead
  const newHead = new Node()
  let tHead = newHead
  while(head) {
    const copyNode = head.next
    head.next = copyNode.next
    head = head.next
    tHead.next = copyNode
    tHead = tHead.next
  }
  return newHead.next
};
```

## ?? 🌟😻✔ 剑指 Offer 36. 二叉搜索树与双向链表【medium】

[ref](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

二叉搜索树、双向链表

最优解

```js
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var treeToDoublyList = function(root) {
  let head = null, prev = null
  if(!root) return null
  function dfs(node) {
    if(!node) return
    dfs(node.left)
    if(!head) {
      head = node
    } else {
      prev.right = node
      node.left = prev
    }
    prev = node
    dfs(node.right)
  }
  dfs(root)
  prev.right = head
  head.left = prev
  return head
};
```

略差解

```js
var treeToDoublyList = function(root) {
  if(!root) return null
  function dfs(node) {
    if(!node) return [null, null]
    let [leftMin, leftMax] = dfs(node.left) 
    const [rightMin, rightMax] = dfs(node.right)
    if(leftMax) {
      leftMax.right = node
      node.left = leftMax
    }
    if(rightMin) {
      node.right = rightMin
      rightMin.left = node
    }
    return [leftMin ? leftMin : node, rightMax ? rightMax : node]
  }

  const [minNode, maxNode] = dfs(root)

  minNode.left = maxNode
  maxNode.right = minNode
  return minNode
};
```

## ??🌟😻✔ 剑指 Offer 37. 序列化二叉树【hard】

[ref](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/)

二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
  return reserialize(root, '')
};

function reserialize(node, str) {
  if(!node) {
    str += 'null,'
    return str
  }
  str += node.val + ','
  str = reserialize(node.left, str)
  str = reserialize(node.right, str)
  return str
}

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
  return redeserialize(data.split(','), {i:0})
};

function redeserialize(datalist, indObj) {
  if(datalist[indObj.i] === 'null') {
    indObj.i++
    return null
  }
  const node = new TreeNode(parseInt(datalist[indObj.i], 10))
  indObj.i++
  node.left = redeserialize(datalist, indObj)
  node.right = redeserialize(datalist, indObj)
  return node
}
```

## ✔ 剑指 Offer 39. 数组中出现次数超过一半的数字【easy】

[ref](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

哈希表

```js
var majorityElement = function(nums) {
  const n = nums.length
  const map = new Map()
  for(let i=0;i<nums.length;i++) {
    map.set(nums[i], map.has(nums[i]) ? map.get(nums[i]) + 1 : 1)
    if(map.get(nums[i]) > n / 2) {
      return nums[i]
    }
  }
};
```

## 🌟😻✔ 剑指 Offer 40 最小的k个数【medium】

[ref](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

单调队列、小顶堆

```js
// 时间复杂度：O(N^2)
// 时间复杂度：O(N)
var getLeastNumbers = function(arr, k) {
  const res = []
  for(let i=0;i<arr.length;i++) {
    res.push(arr[i])
    let j = res.length - 1
    while(j - 1 >= 0 && res[j] < res[j - 1]) {
      swap(res, j, j - 1)
      j--
    }
    if(res.length > k) res.pop()
  }
  return res
};
function swap(arr, i, j) {
  let t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

## ??🌟😻✔ 剑指 Offer 43. 1～n 整数中 1 出现的次数【hard】

[ref](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/submissions/)

规律题

```js
// 规律题
// 参考 https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/jin-hu-shuang-bai-javascriptai-hao-zhe-by-tang_cha/
var countDigitOne = function(n) {
  const prevArr = [0, 1, 20, 300, 4000, 50000, 600000, 7000000, 80000000, 900000000]
  let count = 0
  let str = '' + n
  const len = str.length
  let i=0
  while(i < len) {
    const targetNum = str[i]
    const numCount = len - i - 1
    count += targetNum * prevArr[numCount]
    if(targetNum === '1') {
      count++
      if(i !== len - 1) {
        count += Number(str.slice(i + 1))
      }
    }
    if(targetNum > 1) {
      count += 10 ** numCount
    }
    i++
  }
  return count
};

// // 位数        1 的个数               总1的个数
// 0               0                       0 (0~0)
// 1               1                       1  => (0~9)
// 2               11 + 8 => 19            20 => 10 ^ 1 + 10 * 1 (0~99)
// 3               100 + 20*9              300 => 10 ^ 2 + 10 * 20 (0~999)
// 4                                       4000 => 10 ^ 3 + 10 * 300 (0~9999)
// 5                                       50000 => 10 ^ 4 + 10 * 4000 (0~99999)
// 6                                       600000 => 10 ^ 5 + 10 * 50000 (0~999999)
// 7                                       7000000 => 10 ^ 6 + 10 * 550000
// 8                                       80000000 => 10 ^ 6 + 10 * 550000
// 9                                       900000000 => 10 ^ 6 + 10 * 550000

// 54321
// 0-50000
// 0-4000
// 0-300
// 0-20
// 0-1
```

## ??🌟😻✔ 剑指 Offer 44. 数字序列中某一位的数字【medium】

[ref](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

规律题、数学规律

```js
// 时间复杂度：O(logN)  logN 是目标数字 fullnum 的位数 
// 空间复杂度：O(logN)
var findNthDigit = function(n) {
  n++
  let count = 1
  // 位数
  let k = 1
  while(count + k * 9 * 10 ** (k - 1) < n) {
    count += k * 9 * 10 ** (k - 1)
    k++
  }
  n -= count
  // 对应位数的首个数字
  const targetFullNum = 10 ** (k - 1) + Math.floor((n - 1) / k)
  n -= Math.floor((n - 1) / k) * k
  return targetFullNum.toString()[n - 1]
};
// 1 0-9 10 => 10
// 2 10-99 2*9*10 => 180
// 3 100-999 3*9*100 => 2700

```

## ?🌟😻✔ 剑指 Offer 45 把数组排成最小的数【medium】

[ref](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

同 [#179 最大数](https://leetcode.cn/problems/largest-number/)

```js
var minNumber = function(nums) {
  return nums.sort((x, y) => ('' + x + y) - ('' + y + x)).join('')
};
```

## 🌟😻✔ 剑指 Offer 45 把数组排成最小的数【medium】

[ref](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/)

动态规划

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(1) 直接在给定的 grid 上进行的更改，没有创建额外的空间
var maxValue = function(grid) {
  if(grid.length === 0 || grid[0].length === 0) return 0
  const m = grid.length
  const n = grid[0].length
  for(let i=1;i<m;i++) {
    grid[i][0] += grid[i - 1][0]
  }
  for(let j=1;j<n;j++) {
    grid[0][j] += grid[0][j - 1]
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      grid[i][j] += Math.max(grid[i-1][j], grid[i][j - 1])
    }
  }
  return grid[m-1][n-1]
};
```

## ??🌟😻✔ 剑指 Offer 49. 丑数【medium】

[ref](https://leetcode.cn/problems/chou-shu-lcof/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var nthUglyNumber = function(n) {
  const dp = new Array(n + 1).fill(1)
  let l2 = 1, l3 = 1, l5 = 1
  for(let i=2;i<=n;i++) {
    const p2 = dp[l2] * 2
    const p3 = dp[l3] * 3
    const p5 = dp[l5] * 5
    const min = Math.min(p2, p3, p5)
    if(min === p2) {
      l2++
    }

    if(min === p3) {
      l3++
    }

    if(min === p5) {
      l5++
    }
    dp[i] = min
  }
  return dp[n]
};

```

## ✔ 剑指 Offer 50 第一个只出现一次的字符【easy】

[ref](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var firstUniqChar = function(s) {
  const map = new Map()
  for(let i=0;i<s.length;i++) {
    map.set(s[i], map.has(s[i])? map.get(s[i]) + 1 : 1)
  }
  for(let i=0;i<s.length;i++) {
    if(map.get(s[i]) === 1) return s[i]
  }
  return ' '
};
```

## 🌟😻✔ 剑指 Offer 51 数组中的逆序对【hard】

[ref](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

归并排序

```js
// 时间复杂度：O(nlogn)
// 空间复杂度：O(n)
/**
 * @param {number[]} nums
 * @return {number}
 */
var reversePairs = function(nums) {
  let total = 0
  /**
  * @param {number[]} arr
  * @return {number[]}
  */
  function mergeSort(arr, l, r) {
    if (r === l) return [arr[l]]
    if (r < l) return []
    const mid = Math.floor((l + r) / 2)
    return merge(mergeSort(arr, l, mid), mergeSort(arr, mid + 1, r))
  }

  /**
  * @param {number[]} arr1
  * @param {number[]} arr2
  * @return {number[]}
  */
  function merge(arr1, arr2) {
    const res = []
    const len1 = arr1.length
    const len2 = arr2.length
    let l1 = 0
    let l2 = 0
    while(l1 < len1 && l2 < len2) {
      if(arr1[l1] <= arr2[l2]) {
        res.push(arr1[l1++])
      } else {
        total += len1 - l1
        res.push(arr2[l2++])
      }
    }
    while(l1 < len1) {
      res.push(arr1[l1++])
    }
    while(l2<len2) {
      res.push(arr2[l2++])
    }
    return res
  }

  mergeSort(nums, 0, nums.length - 1)
  return total
};
```

## ?? 🌟😻✔ 剑指 Offer 52. 两个链表的第一个公共节点【easy】

[ref](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

链表、链表公共节点

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var getIntersectionNode = function(headA, headB) {
  let pA = headA  
  let pB = headB
  while(pA !== pB) {
    pA = pA ? pA.next : headB
    pB = pB ? pB.next : headA
  }
  return pA
};
```

## ?? 🌟😻✔ 剑指 Offer 53 - I. 在排序数组中查找数字 I【easy】

[ref](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

二分搜索

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var search = function(nums, target) {
  const n = nums.length
  let lIndex = binarySearch(nums, target, true)
  let rIndex = binarySearch(nums, target, false) - 1
  if(
    lIndex >= 0 && lIndex < n &&
    rIndex >= 0 && rIndex < n &&
    lIndex <= rIndex &&
    nums[lIndex] === target &&
    nums[rIndex] === target
  ) {
    return rIndex - lIndex + 1
  }
  return 0
};

function binarySearch(nums, target, isLeft) {
  let l = 0, r = nums.length - 1
  while(l <= r) {
    const mid = (l + r) >> 1
    if(nums[mid] > target || (isLeft && nums[mid] >= target)) {
      r = mid - 1
    } else {
      l = mid + 1
    }
  }
  return l
}
```

## ?? 🌟😻✔ 剑指 Offer 53 - II. 0～n-1中缺失的数字【easy】

[ref](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)

二分查找

```js
// 二分
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var missingNumber = function(nums) {
  let l = 0, r = nums.length - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] !== mid) {
      r = mid - 1
    } else {
      l = mid + 1
    }
  }
  return ++r
};
```

```js
// 常规遍历
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var missingNumber = function(nums) {
  for(let i=0;i<nums.length;i++) {
    if(nums[i] !== i) {
      return i
    }
  }
  return nums.length
};
```

## 🌟😻✔ 剑指 Offer 54. 二叉搜索树的第k大节点【easy】

[ref](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

二叉搜索树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var kthLargest = function(root, k) {
  let target
  let count = 0
  function dfs(node) {
    node.right && dfs(node.right)
    count++
    if(count === k) {
      target = node.val
    }
    node.left && dfs(node.left)
  }
  dfs(root)
  return target
};
```

## 🌟😻✔ 剑指 Offer 55 - I. 二叉树的深度【easy】

[ref](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/)

二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxDepth = function(root) {
  let max = 0
  function dfs(node, h) {
    if(!node) {
      max = Math.max(max, h)
      return
    }
    dfs(node.left, h + 1)
    dfs(node.right, h + 1)
  }
  dfs(root, 0)
  return max
};
```

## 🌟😻✔ 剑指 Offer 55 - II. 平衡二叉树【easy】

[ref](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/)

二叉树、平衡二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var isBalanced = function(root) {
  let is = true
  function dfs(node) {
    if(!node) return 0
    const lh = dfs(node.left)
    const rh = dfs(node.right)
    if(Math.abs(lh - rh) > 1) {
      is = false
    }
    return Math.max(lh, rh) + 1
  }
  dfs(root)
  return is
};
```

## ?? 🌟😻✔ 剑指 Offer 56 - I. 数组中数字出现的次数【medium】

[ref](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

二进制、与或非、位运算

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var singleNumbers = function(nums) {
  let x = 0, a, b, first = 1;
  for(let val of nums) {
    x ^= val; // 对原数组所有数进行异或操作，最后的 x = a ^ b，  a 和 b 是要返回的两个数字
  }

  // 从 x 中任意找一个1，因为 1 代表着是 a 和 b 肯定不同的位置，为了方便，找到最低位的 1 即可
  while((first & x) === 0) {
    first <<= 1;
  }

  // 然后通过 first 对原数组进行分组，二进制串中在这一位为 1 或 0 的分为两组，因此相同数字肯定被分到一组，a 和 b 肯定一个是1， 一个是0，所以被分到两组
  for(let val of nums) {
    if(val & first) {
      // 这里最终异或完是 val 跟 a 的从最右侧开始数，一样长度的数，都是一样的
      a ^= val;
    } else {
      // 这里最终异或完是 val 跟 a 的从最右侧开始数，一样长度的数，除了最低位1那里不一样，右侧都一样的
      b ^= val;
    }
  }
  return [a, b];
};
```

## ?? 🌟😻✔ 剑指 Offer 56 - II. 数组中数字出现的次数 II【medium】

[ref](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

二进制、位运算、规律题

```js
// ref https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/jian-zhi-56-shu-zu-zhong-shu-zi-chu-xian-rgt7/
// 利用三个相同数的特性，在二进制表示中，每一位上三个相同数的二进制位对3取余数必为0
// 把所有数的二进制位相加，所有位对3取余数，则得到落单的那个数的二进制表示，再转换为十进制即可
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var singleNumber = function(nums) {
  const dp = new Array(32).fill(0)
  for(let i = 0; i < nums.length; i++) {
    let j = 0
    while(nums[i]) {
      dp[j] += nums[i] % 2
      nums[i] >>= 1
      j++
    }
  }
  let res = 0
  for(let i = 0; i < 32; i++) {
    res += (1 << i) * (dp[i] % 3)
  }
  return res
};
```

## ✔ 剑指 Offer 57. 和为s的两个数字【easy】

[ref](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var twoSum = function(nums, target) {
  let l = 0, r = nums.length - 1
  while(l < r) {
    const s = nums[l] + nums[r]
    if(s === target) {
      break
    } else if(s > target) {
      r--
    } else {
      l++
    }
  }
  return [nums[l], nums[r]]
};
```

## ?? 🌟😻✔ 剑指 Offer 57 - II. 和为s的连续正数序列【easy】

[ref](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

双指针、滑动窗口

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findContinuousSequence = function(target) {
  let l = 1, r = 2
  let sum = 1
  const max = Math.ceil(target / 2)
  const res = []
  while(r <= max) {
    sum += r
    while(l < r && sum > target) {
      sum -= l
      l++
    }
    if(sum === target) {
      const t = []
      for(let j=l;j<=r;j++) {
        t.push(j)
      }
      res.push(t)
    }
    r++
  }
  return res
};
```


## ✔ 剑指 Offer 58 - I. 翻转单词顺序【easy】

[ref](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var reverseWords = function(s) {
  let res = ''
  const arr = s.split(' ').reverse()
  for(let str of arr) {
    if(str !== '') {
      res = res + str + ' '
    }
  }
  return res.slice(0, res.length - 1)
};
```

## ✔ 剑指 Offer 58 - II. 左旋转字符串【easy】

[ref](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```js
var reverseLeftWords = function(s, n) {
  return s.slice(n) + s.slice(0, n)
};
```

## 🌟😻✔ 剑指 Offer 59 - I. 滑动窗口的最大值【hard】

[ref](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(K)
var maxSlidingWindow = function(nums, k) {
  if(!nums.length || k === 0) return []
  const q = []
  for(let i=0;i<k;i++) {
    while(q.length && q[q.length - 1] < nums[i]) {
      q.pop()
    }
    q.push(nums[i])
  }
  const res = [q[0]]
  for(let i=k;i<nums.length;i++) {
    while(q.length && q[q.length - 1] < nums[i]) {
      q.pop()
    }
    q.push(nums[i])
    if(q[0] === nums[i - k]) {
      q.shift()
    }
    res.push(q[0])
  }
  return res
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(K)
var maxSlidingWindow = function(nums, k) {
  if(!nums.length) return []
  const res = []
  const q = []
  for(let i=0;i<k-1;i++) {
    while(q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop()
    }
    q.push(i)
  }
  for(let i=k-1;i<nums.length;i++) {
    while(q.length && q[0] <= i - k) {
      q.shift()
    }
    while(q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop()
    }
    q.push(i)
    res.push(nums[q[0]])
  }
  return res
};
```

## ?? 🌟😻✔ 剑指 Offer 59 - II. 队列的最大值【medium】

[ref](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)

队列、栈、单调数组、双端队列

```js
var MaxQueue = function() {
  this.q = []
  this.dq = []
};

/**
 * @return {number}
 */
MaxQueue.prototype.max_value = function() {
  if(!this.q.length) return -1
  return this.dq[0]
};

/** 
 * @param {number} value
 * @return {void}
 */
MaxQueue.prototype.push_back = function(value) {
  while(this.dq.length && value > this.dq[this.dq.length - 1]) {
    this.dq.pop()
  }
  this.dq.push(value)
  this.q.push(value)
};

/**
 * @return {number}
 */
MaxQueue.prototype.pop_front = function() {
  if(!this.q.length) return -1
  const t = this.q.shift()
  if(t === this.dq[0]) {
    this.dq.shift()
  }
  return t
};
```

or 双指针

```js
// 求滑动窗口最大值的变种题
// 设计一个数组，用双指针表示当前 push、pop 到哪一位了，即可实现队列效果
// maxQ 是一个单调下标数组，当push操作新添加一个值的时候，让 maxQ 中所有比该数小的数对应的下标全部出栈，最后让当前值的下标入栈
// 由于是一个可变宽度的滑动窗口，故获取最大下标之前，要先看是否还存在合理下标
// 对于每一个新push的数，其下标必然是处于 maxQ 的末尾
// 只要 l、r 区间内还存在符合条件的下标，则必然 maxQ 中会有值
var MaxQueue = function() {
  this.l = 0
  this.r = -1
  this.baseArr = []
  this.maxQ = []
};

/**
 * @return {number}
 */
MaxQueue.prototype.max_value = function() {
  if(this.l > this.r) return -1
  while(this.maxQ.length && this.maxQ[0] < this.l) {
    this.maxQ.shift()
  }
  return this.baseArr[this.maxQ[0]]
};

/** 
 * @param {number} value
 * @return {void}
 */
MaxQueue.prototype.push_back = function(value) {
  this.baseArr[++this.r] = value
  while(this.maxQ.length && this.baseArr[this.maxQ[this.maxQ.length - 1]] <= value) {
    this.maxQ.pop()
  }
  this.maxQ.push(this.r)
};

/**
 * @return {number}
 */
MaxQueue.prototype.pop_front = function() {
  if(this.l > this.r) return -1
  return this.baseArr[this.l++]
};
```

## ?? 🌟😻✔ 剑指 Offer 60. n个骰子的点数【medium】

[ref](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var dicesProbability = function(n) {
  let dp = [1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6]
  for(let i=2;i<=n;i++) {
    const tmp = new Array(5 * i + 1).fill(0)
    for(let j = 0; j < dp.length; j++) {
      for(let k = 0; k < 6; k++) {
        tmp[j + k] += dp[j] / 6
      }
    }
    dp = tmp
  }

  return dp
};
```

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var dicesProbability = function(n) {
  const min = n
  const max = 6 * n
  const dp = new Array(n + 1).fill(0).map(_ => new Array(max + 1).fill(0))
  dp[1][1] = 1 / 6
  dp[1][2] = 1 / 6
  dp[1][3] = 1 / 6
  dp[1][4] = 1 / 6
  dp[1][5] = 1 / 6
  dp[1][6] = 1 / 6

  for(let i=2;i<=n;i++) {
    const iMin = i
    const iMax = i * 6
    for(let j = iMin; j <= iMax; j++) {
      dp[i][j] = 
          (j - 1 >= i - 1 && j - 1 <= 6 * (i - 1) ? dp[i - 1][j - 1] : 0)
        + (j - 2 >= i - 1 && j - 2 <= 6 * (i - 1) ? dp[i - 1][j - 2] : 0)
        + (j - 3 >= i - 1 && j - 3 <= 6 * (i - 1) ? dp[i - 1][j - 3] : 0)
        + (j - 4 >= i - 1 && j - 4 <= 6 * (i - 1) ? dp[i - 1][j - 4] : 0)
        + (j - 5 >= i - 1 && j - 5 <= 6 * (i - 1) ? dp[i - 1][j - 5] : 0)
        + (j - 6 >= i - 1 && j - 6 <= 6 * (i - 1) ? dp[i - 1][j - 6] : 0)
      dp[i][j] *= 1 / 6
    }
  }

  return dp[n].slice(min, max + 1)
};

//    1        2         3      4       5      6
// [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]

// 2                   3               4              5            6          7       8         9      10     11     12
// f(1) * f(1)   f(1) * f(2)      f(1) * f(3)    f(1) * f(4)     1  5       1   6   2   6
//               f(2) * f(1)      f(2) * f(2)    f(2) * f(3)     2  4       2   5   3   5
//                                f(3) * f(1)    f(3) * f(2)     3  3       3   4   4   4
//                                               f(4) * f(1)     4  2       4   3   5   3
//                                                               5  1       5   2   6   2
//                                                                          6   1

// 3          4             5      
// 1*1*1     1*1*2        1 1 3
//                        1 2 2

// f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)
```

## ? 🌟😻✔ 剑指 Offer 61. 扑克牌中的顺子【easy】

[ref](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

```js
var isStraight = function(nums) {
  nums.sort((a, b) => a - b)
  let kingCount = 0
  let l = 0
  while(l < nums.length && nums[l] === 0) {
    kingCount++
    l++
  }
  if(kingCount === 5) return true
  let prev = nums[l]
  l++
  while(l < nums.length) {
    if(nums[l] === prev) {
      return false
    } else if(nums[l] - prev - 1 <= kingCount) {
      kingCount -= nums[l] - prev - 1
      prev = nums[l]
      l++
    } else {
      return false
    }
  }
  return true
};
```

## ??? 🌟😻✔ 剑指 Offer 62. 圆圈中最后剩下的数字【easy】

[ref](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

规律题、约瑟夫环、直接背结论

- [约瑟夫环——公式法（递推公式）](https://blog.csdn.net/u011500062/article/details/72855826)

```js
// 约瑟夫环、根据结果反推、直接背递推公式
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var lastRemaining = function(n, m) {
  let ans = 0
  for(let i=2;i<=n;i++) {
    ans = (ans + m) % i
  }
  return ans
};

// 0 1 2 3 4 5 m = 6   3
// 0 1 2 3 4           3
// 1 2 3 4             2
// 3 4 1               0
// 3 4                 0
// 3                   0

// nextX = (x + m) % nextLen
// 0
// 0 = (0 + 6) % 2
// 0 = (0 + 6) % 3
// 2 = (0 + 6) % 4
// 3 = (2 + 6) % 5
// 3 = (3 + 6) % 6

```

## 🌟😻✔ 剑指 Offer 63 股票的最大利润【easy】

[ref](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  if(prices.length < 2) return 0
  let max = 0
  let min = prices[0]
  for(let i=1;i<prices.length;i++) {
    max = Math.max(max, prices[i] - min)

    if(prices[i] < min) {
      min = prices[i]
    }
  }
  return max
};
```

## ? 🌟😻✔ 剑指 Offer 64. 求1+2+…+n【medium】

[ref](https://leetcode.cn/problems/qiu-12n-lcof/)

求和、非常规求和

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var sumNums = function(n) {
  let res = n
  n && (res += sumNums(n - 1))
  return res 
};
```

## ??🌟😻✔ 剑指 Offer 65. 不用加减乘除做加法【easy】

[ref](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

二进制、位运算

参考

- [面试题65. 不用加减乘除做加法（位运算，清晰图解）](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/)

```js
// 时间复杂度：O(1)
// 空间复杂度：O(1)
var add = function(a, b) {
  while(b !== 0) {
    const t = (a & b) << 1
    a ^= b
    b = t
  }
  return a
};
// a=3
// 11
// b=2
// 10

// a=100
// b=1

// a=0
// b=101
```

## 🌟😻✔ 剑指 Offer 66. 构建乘积数组【medium】

[ref](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/)

数组题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var constructArr = function(nums) {
  const n = nums.length
  const rp = new Array(n)
  rp[n - 1] = 1
  for(let i = n-2; i >=0; i--) {
    rp[i] = rp[i + 1] * nums[i + 1]
  }
  let lMul = 1
  for(let i=0;i<n;i++) {
    rp[i] = lMul * rp[i]
    lMul *= nums[i]
  }
  return rp
};
```

## ??🌟😻✔ 剑指 Offer 67. 把字符串转换成整数【medium】

[ref](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

字符串、字符串转换为整数

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var strToInt = function(str) {
  const max = 2 ** 31 - 1
  const min = -(2 ** 31)
  while(str.length && str[0] === ' ') {
    str = str.slice(1)
  }
  if(str[0] === '+' || str[0] === '-' || (str[0] >=0 && str[0] <= 9)) {
    let neg = 1
    let i=0
    if(str[i] === '+') {
      neg *= 1
      i++
    } else if(str[i] === '-') {
      neg *= -1
      i++
    }
    if(str[i] === '+' || str[i] === '-') return 0
    let num = 0
    while(str[i] !== ' ' && str[i] >=0 && str[i] <= 9) {
      if((10 * num + neg * Number(str[i])) >= max) return max
      if((10 * num + neg * Number(str[i])) <= min) return min
      num = 10 * num + neg * Number(str[i])
      i++
    }
    return num
  }
  return 0
};

```

## 🌟😻✔ 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先【easy】

[ref](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/submissions/)

二叉搜索树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var lowestCommonAncestor = function(root, p, q) {
  while(true) {
    if(root.val < p.val && root.val < q.val) {
      root = root.right
    } else if(root.val > p.val && root.val > q.val) {
      root = root.left
    } else {
      return root
    }
  }
};
```

## 🌟😻✔ 剑指 Offer 68 - II. 二叉树的最近公共祖先【easy】

[ref](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var lowestCommonAncestor = function(root, p, q) {
  let target
  function dfs(node) {
    if(!node) return false
    const isTarget = node === p || node === q
    let lfind = dfs(node.left)
    let rfind = dfs(node.right)
    if(lfind && rfind || isTarget && (lfind || rfind)) {
      target = node
    }
    return lfind || rfind || isTarget
  }

  dfs(root)
  return target
};  
```

## 🌟😻✔ 面试题 02.05 链表求和【medium】

[ref](https://leetcode.cn/problems/sum-lists-lcci/)

链表

```js
var addTwoNumbers = function(l1, l2) {
  let add = 0
  const head = new ListNode()
  let tHead = head
  while(l1 || l2) {
    const tS = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + add
    add = Math.floor(tS / 10)
    tHead.next = new ListNode(tS % 10)
    tHead = tHead.next
    l1 && (l1 = l1.next)
    l2 && (l2 = l2.next)
  }
  if(add > 0) {
    tHead.next = new ListNode(add)
  }
  return head.next
};
```
