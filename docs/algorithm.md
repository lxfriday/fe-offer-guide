<div class="finished-info-wrapper">
  å®Œæˆåº¦ <span class="finished-info">500 / 500 -> 100%<span>
</div>

# ç®—æ³•çŸ¥åä»“åº“

- [ã€å¾®è½¯ã€‘å®«æ°´ä¸‰å¶](https://github.com/SharingSource/LogicStack-LeetCode)
- [è·¯è¥¿æ³•](https://github.com/azl397985856/leetcode)

# åˆ·é¢˜æŒ‡å—

åˆ·é¢˜çš„æ—¶å€™è¦æŒ‰ç…§å¤§æ¦‚çš„é¢˜ç›®åˆ†ç±»æ¥åˆ·ï¼Œæ¯ä¸ªæ–¹é¢éƒ½è¦æœ‰æ‰€äº†è§£ã€‚

- [åŸºç¡€ç®—æ³•](#ğŸ˜»âœ”-åŸºç¡€ç®—æ³•)
- æ ˆ
- é˜Ÿåˆ—
- é“¾è¡¨
- é›†åˆ
- å­—å…¸
- æ ‘
- å †
- å›¾
- æœç´¢ã€æ’åº
- åˆ†æ²»æ³•
- åŠ¨æ€è§„åˆ’
- è´ªå¿ƒç®—æ³•
- å›æº¯ç®—æ³•

## æ ˆã€é˜Ÿåˆ—

- [20 æœ‰æ•ˆçš„æ‹¬å·](https://leetcode.cn/problems/valid-parentheses/)
- [933 æœ€è¿‘çš„è¯·æ±‚æ¬¡æ•°](https://leetcode.cn/problems/number-of-recent-calls/)

## é“¾è¡¨

- [2 ä¸¤æ•°ç›¸åŠ ](https://leetcode.cn/problems/add-two-numbers/)
- [21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists/)
- [23 åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/)
- [83 åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ ](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)
- [141 ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle/)
- [206 åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)


## é›†åˆ

- [349 ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†](https://leetcode.cn/problems/intersection-of-two-arrays/)

## å­—å…¸ã€æ»‘åŠ¨çª—å£ã€åŒæŒ‡é’ˆ

- [1 ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum/)
- [3 æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
- [76 æœ€å°è¦†ç›–å­ä¸²](https://leetcode.cn/problems/minimum-window-substring/)

## æ ‘ã€æ·±åº¦ä¼˜å…ˆã€å¹¿åº¦ä¼˜å…ˆ

- [94 äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
- [100 ç›¸åŒçš„æ ‘](https://leetcode.cn/problems/same-tree/)
- [101 å¯¹ç§°äºŒå‰æ ‘](https://leetcode.cn/problems/symmetric-tree/)
- [102 äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
- [104 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
- [111 äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
- [112 è·¯å¾„æ€»å’Œ](https://leetcode.cn/problems/path-sum/)
- [226 ç¿»è½¬äºŒå‰æ ‘](https://leetcode.cn/problems/invert-binary-tree/)

## å †

- [23 åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/)
- [215 æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
- [226 ç¿»è½¬äºŒå‰æ ‘](https://leetcode.cn/problems/invert-binary-tree/)
- [347 å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode.cn/problems/top-k-frequent-elements/)

## å›¾ã€æ·±åº¦ä¼˜å…ˆã€å¹¿åº¦ä¼˜å…ˆ

- [113 å…‹éš†å›¾](https://leetcode.cn/problems/clone-graph/)
- [417 å¤ªå¹³æ´‹å¤§è¥¿æ´‹æ°´æµé—®é¢˜](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

## æœç´¢ã€æ’åº

- [374 çŒœæ•°å­—å¤§å°](https://leetcode.cn/problems/guess-number-higher-or-lower/)

## åˆ†æ²»æ³•

åˆ†æ”¯çš„ç‰¹å¾æ˜¯ï¼šå…ˆæ‹†åˆ†ã€å†è§£å†³ã€ååˆå¹¶

å°†ä¸€ä¸ªé—®é¢˜æ‹†åˆ†æˆå¾ˆå¤šä¸ªå’ŒåŸé—®é¢˜ç›¸ä¼¼çš„å°é—®é¢˜ï¼Œé€’å½’è§£å†³å°é—®é¢˜ï¼Œå†å°†ç»“æœåˆå¹¶ä»¥è§£å†³åŸæ¥çš„é—®é¢˜

- [100 ç›¸åŒçš„æ ‘](https://leetcode.cn/problems/same-tree/)
- [226 ç¿»è½¬äºŒå‰æ ‘](https://leetcode.cn/problems/invert-binary-tree/)

## åŠ¨æ€è§„åˆ’

åŠ¨æ€è§„åˆ’çš„ç‰¹å¾æ˜¯ï¼šæŸä¸ªç»“æœä¼šä¾èµ–å‰é¢çš„ç»“æœï¼Œæˆ–è€…å‰é¢çš„å‡ ä¸ªç»“æœä¹‹é—´æœ‰å…³è”

- [70 çˆ¬æ¥¼æ¢¯](https://leetcode.cn/problems/climbing-stairs/)
- [198 æ‰“å®¶åŠ«èˆ](https://leetcode.cn/problems/house-robber/)

## è´ªå¿ƒç®—æ³•
## å›æº¯ç®—æ³•


# ğŸ˜»âœ” åŸºç¡€ç®—æ³• 

å¸¸è§å¤æ‚åº¦æ›²çº¿ï¼š

![](https://qiniu1.lxfriday.xyz/feoffer/1652356442444_09edc6aa-6dfe-41aa-bd02-b9f3097b3717.png)

æ’åºç®—æ³•æ’åºæµç¨‹å›¾è§£ï¼š

[https://visualgo.net/zh/sorting](https://visualgo.net/zh/sorting)

## ğŸ˜»âœ” æ’åºç®—æ³• 

ref

- [ä¸°å¯Œå›¾ä¾‹è®²è§£åå¤§ç»å…¸æ’åºç®—æ³•](https://juejin.im/post/5d9033fa5188257f6f1ba46b)
- [æ’åºç®—æ³•](https://github.com/lxfriday/give-me-job/tree/7c193c8279/algorithm/%E6%8E%92%E5%BA%8F)

![æ’åºç®—æ³•ä¸€è§ˆ](https://qiniu1.lxfriday.xyz/feoffer/sort.png)

### ğŸ˜»âœ” å†’æ³¡æ’åº 

![](https://qiniu1.lxfriday.xyz/feoffer/bubbleSort.png)

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function bubbleSort(arr) {
  const length = arr.length
  if (length <= 1) return arr
  for (let i = 0; i < length; i++) {
    let changed = false // æ²¡æœ‰æ•°æ®äº¤æ¢åˆ™è¡¨ç¤ºå·²ç»æœ‰åºäº†
    for (let j = 0; j < length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
        changed = true
      }
    }
    if (!changed) break
  }
  return arr
}
```

### ğŸ˜»âœ” é€‰æ‹©æ’åº 

![](https://qiniu1.lxfriday.xyz/feoffer/ec43f415-5224-bd9b-ad33-0ee480cd19e7.png)

![](https://qiniu1.lxfriday.xyz/feoffer/selectionSort.gif)

æ ¸å¿ƒæ€æƒ³ï¼šè¿›è¡Œ n è½®ï¼Œæ¯è½®æ‰¾å‡ºæœ€å°çš„æ”¾åœ¨è¿™ä¸€è½®çš„åˆå§‹ä½ç½®

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function selectionSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  for (let i = 0; i < len; i++) {
    let min = i
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[min]) min = j
    }
    swap(arr, i, min)
  }

  return arr
}
```

### ğŸ˜»âœ” æ’å…¥æ’åº 

![](https://qiniu1.lxfriday.xyz/feoffer/6e79c1d5-2896-68bc-ebc0-280ee2881035.png)

![](https://qiniu1.lxfriday.xyz/feoffer/insertionSort.gif)

```javascript
function insertionSort(arr) {
  const len = arr.length
  if (len <= 1) return arr

  for (let i = 1; i < len; i++) {
    const cur = arr[i]
    let j = i - 1
    for (; j >= 0; j--) {
      if (arr[j] > cur) {
        arr[j + 1] = arr[j]
      } else {
        break
      }
    }
    arr[j + 1] = cur
  }

  return arr
}
```

### ğŸ˜»âœ” å¿«é€Ÿæ’åº 

![](https://qiniu1.lxfriday.xyz/feoffer/008ba6a2-d847-8894-a3b4-70b09a1b44b8.png)

![](https://qiniu1.lxfriday.xyz/feoffer/quicksort.gif)

å•è·¯å¿«æ’

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function partition(arr, left, right) {
  let pivot = left
  let index = pivot + 1
  for (let i = index; i <= right; i++) {
    if (arr[i] < arr[pivot]) {
      swap(arr, i, index)
      index++
    }
  }
  swap(arr, pivot, index - 1)
  return index - 1
}

function quickSort(arr, l, r) {
  const len = arr.length
  const left = typeof l === 'number' ? l : 0
  const right = typeof r === 'number' ? r : len - 1
  let partitionIndex = 0
  if (left < right) {
    partitionIndex = partition(arr, left, right)
    quickSort(arr, left, partitionIndex - 1)
    quickSort(arr, partitionIndex + 1, right)
  }

  return arr
}
```

æ›´å¥½ç†è§£çš„å¿«æ’

```js
function partition2(arr) {
  if (arr.length <= 1) return arr
  const target = arr[0]
  const leftArr = []
  const rightArr = []
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < target) {
      leftArr.push(arr[i])
    } else {
      rightArr.push(arr[i])
    }
  }
  return [...partition2(leftArr), target, ...partition2(rightArr)]
}

function quickSort2(arr) {
  return partition2(arr)
}
```

### ğŸ˜»âœ” å½’å¹¶æ’åº 

![](https://qiniu1.lxfriday.xyz/feoffer/3ccf988e-b992-84f0-a622-dd03c51123c9.png)

![](https://qiniu1.lxfriday.xyz/feoffer/d3de0b1f-7827-e3b9-eeb7-1993e03e0372.png)

![](https://qiniu1.lxfriday.xyz/feoffer/16d7b507ece11c9d.gif)

å½’å¹¶æ’åºï¼ˆè‹±è¯­ï¼šMerge sortï¼Œæˆ– mergesortï¼‰ï¼Œæ˜¯åˆ›å»ºåœ¨å½’å¹¶æ“ä½œä¸Šçš„ä¸€ç§æœ‰æ•ˆçš„æ’åºç®—æ³•ï¼Œæ•ˆç‡ä¸º O(nlogn)ã€‚1945 å¹´ç”±çº¦ç¿°Â·å†¯Â·è¯ºä¼Šæ›¼é¦–æ¬¡æå‡ºã€‚è¯¥ç®—æ³•æ˜¯é‡‡ç”¨ åˆ†æ²»æ³•ï¼ˆDivide and Conquerï¼‰ çš„ä¸€ä¸ªéå¸¸å…¸å‹çš„åº”ç”¨ï¼Œä¸”å„å±‚åˆ†æ²»é€’å½’å¯ä»¥åŒæ—¶è¿›è¡Œã€‚

é‡‡ç”¨åˆ†æ²»æ³•:

1. åˆ†å‰²ï¼šé€’å½’åœ°æŠŠå½“å‰åºåˆ—å¹³å‡åˆ†å‰²æˆä¸¤åŠã€‚
1. é›†æˆï¼šåœ¨ä¿æŒå…ƒç´ é¡ºåºçš„åŒæ—¶å°†ä¸Šä¸€æ­¥å¾—åˆ°çš„å­åºåˆ—é›†æˆåˆ°ä¸€èµ·ï¼ˆå½’å¹¶ï¼‰ã€‚

```javascript
function merge(arr1, arr2) {
  const res = []
  while (arr1.length && arr2.length) {
    if (arr1[0] < arr2[0]) {
      res.push(arr1.shift())
    } else {
      res.push(arr2.shift())
    }
  }
  while (arr1.length) {
    res.push(arr1.shift())
  }
  while (arr2.length) {
    res.push(arr2.shift())
  }

  return res
}

function mergeSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  const m = Math.floor(len / 2)
  const arr1 = arr.slice(0, m)
  const arr2 = arr.slice(m)
  return merge(mergeSort(arr1), mergeSort(arr2))
}
```

### ğŸ˜»âœ” å¸Œå°”æ’åº 

![](https://qiniu1.lxfriday.xyz/feoffer/907976b2-e3b0-91fc-0b6d-3ead3ee08c1c.png)

![](https://qiniu1.lxfriday.xyz/feoffer/16d7b4ce200763d6.gif)

å¸Œå°”æ’åºï¼Œä¹Ÿç§°é€’å‡å¢é‡æ’åºç®—æ³•ï¼Œæ˜¯æ’å…¥æ’åºçš„ä¸€ç§æ›´é«˜æ•ˆçš„æ”¹è¿›ç‰ˆæœ¬ã€‚å¸Œå°”æ’åºæ˜¯éç¨³å®šæ’åºç®—æ³•ã€‚

å¸Œå°”æ’åºæ˜¯åŸºäºæ’å…¥æ’åºçš„ä»¥ä¸‹ä¸¤ç‚¹æ€§è´¨è€Œæå‡ºæ”¹è¿›æ–¹æ³•çš„ï¼š

- æ’å…¥æ’åºåœ¨å¯¹å‡ ä¹å·²ç»æ’å¥½åºçš„æ•°æ®æ“ä½œæ—¶ï¼Œæ•ˆç‡é«˜ï¼Œå³å¯ä»¥è¾¾åˆ°çº¿æ€§æ’åºçš„æ•ˆç‡
- ä½†æ’å…¥æ’åºä¸€èˆ¬æ¥è¯´æ˜¯ä½æ•ˆçš„ï¼Œå› ä¸ºæ’å…¥æ’åºæ¯æ¬¡åªèƒ½å°†æ•°æ®ç§»åŠ¨ä¸€ä½

å¸Œå°”æ’åºé€šè¿‡å°†æ¯”è¾ƒçš„å…¨éƒ¨å…ƒç´ åˆ†ä¸ºå‡ ä¸ªåŒºåŸŸæ¥æå‡æ’å…¥æ’åºçš„æ€§èƒ½ã€‚è¿™æ ·å¯ä»¥è®©ä¸€ä¸ªå…ƒç´ å¯ä»¥ä¸€æ¬¡æ€§åœ°æœæœ€ç»ˆä½ç½®å‰è¿›ä¸€å¤§æ­¥ã€‚ç„¶åç®—æ³•å†å–è¶Šæ¥è¶Šå°çš„æ­¥é•¿è¿›è¡Œæ’åºï¼Œç®—æ³•çš„æœ€åä¸€æ­¥å°±æ˜¯æ™®é€šçš„æ’å…¥æ’åºï¼Œä½†æ˜¯åˆ°äº†è¿™æ­¥ï¼Œéœ€æ’åºçš„æ•°æ®å‡ ä¹æ˜¯å·²æ’å¥½çš„äº†ï¼ˆæ­¤æ—¶æ’å…¥æ’åºè¾ƒå¿«ï¼‰ã€‚

```javascript
function shellSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  // gap ä¸æ–­ç¼©å°ï¼Œæœ€åå˜æˆ 1
  for (let gap = len >> 1; gap > 0; gap >>= 1) {
    // gap ç¡®å®šä¹‹åï¼Œä» gap ä½ç½®å¼€å§‹å‘åå¾ªç¯
    for (let i = gap; i < len; i++) {
      const temp = arr[i]
      let j = i - gap
      // i æ¯è½®å¾ªç¯ä¸­éœ€è¦ä»å·¦å¾€å³åšæ’æ’
      for (; j >= 0 && arr[j] > temp; j -= gap) {
        arr[j + gap] = arr[j]
      }
      arr[j + gap] = temp
    }
  }

  return arr
}
```

### ğŸ˜»âœ” å †æ’åº(heap-sort) 

![å †æ’åº](https://qiniu1.lxfriday.xyz/feoffer/heapSort2.png)
![å †æ’åº](https://qiniu1.lxfriday.xyz/feoffer/heapSort.gif)

å †(Heap)æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­ä¸€ç±»ç‰¹æ®Šçš„æ•°æ®ç»“æ„çš„ç»Ÿç§°ã€‚å †é€šå¸¸æ˜¯ä¸€ä¸ªå¯ä»¥è¢«çœ‹åšä¸€æ£µå®Œå…¨äºŒå‰æ ‘çš„æ•°ç»„å¯¹è±¡ã€‚å…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šå­˜åœ¨ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œå¯¹ä»¥ 0 å¼€å§‹çš„å †æ•°ç»„ï¼Œæœ‰å¦‚ä¸‹è§„åˆ™ï¼š

1. çˆ¶èŠ‚ç‚¹ `i` çš„**å·¦**å­èŠ‚ç‚¹åœ¨ä½ç½® `2 * i + 1`
1. çˆ¶èŠ‚ç‚¹ `i` çš„**å³**å­èŠ‚ç‚¹åœ¨ä½ç½® `2 * i + 2`
1. å­èŠ‚ç‚¹ `i` çš„çˆ¶èŠ‚ç‚¹åœ¨ä½ç½® `Math.floor((i - 1) / 2)`

å¤§é¡¶å †ï¼šæ‰€æœ‰èŠ‚ç‚¹ `i` çš„å€¼æ¯”å…¶å·¦å³å­èŠ‚ç‚¹éƒ½å¤§çš„å †

å°é¡¶å †ï¼šæ‰€æœ‰èŠ‚ç‚¹ `i` çš„å€¼æ¯”å…¶å·¦å³å­èŠ‚ç‚¹éƒ½å°çš„å †

å †æ’åºçš„é‡è¦è¿‡ç¨‹ï¼ˆä»¥å¤§é¡¶å †å®ç°ä»å°åˆ°å¤§ä¸ºä¾‹ï¼‰ï¼š

1. æ„å»ºå¤§é¡¶å †
1. æŠŠ 0 å’Œæœ€åä¸€ä½äº¤æ¢ï¼ˆæ— åºæ•°ç»„çš„æœ€åä¸€ä½ï¼‰
1. ä» 0 ä½é‡æ–°æ„å»ºå¤§é¡¶å †
1. é‡å¤æ­¥éª¤ 2ã€3

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
// æ„å»ºå¤§é¡¶å †çš„æ ¸å¿ƒé€’å½’ç®—æ³•
function heapifyMax(arr, i, len) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let max = i
  if (left < len && arr[left] > arr[max]) {
    max = left
  }
  if (right < len && arr[right] > arr[max]) {
    max = right
  }
  if (i != max) {
    swap(arr, max, i)
    heapifyMax(arr, max, len)
  }
}
// æ„å»ºå°é¡¶å †çš„æ ¸å¿ƒé€’å½’ç®—æ³•
function heapifyMin(arr, i, len) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let min = i
  if (left < len && arr[left] < arr[min]) {
    min = left
  }
  if (right < len && arr[right] < arr[min]) {
    min = right
  }
  if (i != min) {
    swap(arr, min, i)
    heapifyMin(arr, min, len)
  }
}

function buildMaxHeap(arr) {
  const len = arr.length
  for (let i = Math.floor(len / 2); i >= 0; i--) {
    heapifyMax(arr, i, len)
  }
}

function buildMinHeap(arr) {
  const len = arr.length
  for (let i = Math.floor(len / 2); i >= 0; i--) {
    heapifyMin(arr, i, len)
  }
}

// asc ä¸º true è¡¨ç¤ºä»å°åˆ°å¤§ï¼Œfalse ä¸ºä»å¤§åˆ°å°
function heapSort(arr, asc = false) {
  if (asc) {
    // ä½¿ç”¨å¤§é¡¶å †å®ç°ä»å°åˆ°å¤§æ’åº
    buildMaxHeap(arr)
    const len = arr.length
    for (let i = len - 1; i > 0; i--) {
      swap(arr, 0, i)
      heapifyMax(arr, 0, i)
    }
  } else {
    // ä½¿ç”¨å°é¡¶å †å®ç°ä»å¤§åˆ°å°æ’åº
    buildMinHeap(arr)
    const len = arr.length
    for (let i = len - 1; i > 0; i--) {
      swap(arr, 0, i)
      heapifyMin(arr, 0, i)
    }
  }
  return arr
}
```

### ğŸ˜»âœ” è®¡æ•°æ’åº(counting-sort) 

![è®¡æ•°æ’åº](https://qiniu1.lxfriday.xyz/feoffer/countingSort.png)

**é™å®šä¸ºéè´Ÿæ•°**

è®¡æ•°æ’åºæ˜¯ä¸€ç§ç¨³å®šçš„çº¿æ€§æ—¶é—´æ’åºç®—æ³•ã€‚è®¡æ•°æ’åºä½¿ç”¨ä¸€ä¸ªé¢å¤–çš„æ•°ç»„ `C` ï¼Œå…¶ä¸­ç¬¬ `i` ä¸ªå…ƒç´ æ˜¯å¾…æ’åºæ•°ç»„ `A` ä¸­å€¼ç­‰äº `i` çš„å…ƒç´ çš„ä¸ªæ•°ã€‚ç„¶åæ ¹æ®æ•°ç»„ `C` æ¥å°† `A` ä¸­çš„å…ƒç´ æ’åˆ°æ­£ç¡®çš„ä½ç½®ã€‚

å½“è¾“å…¥çš„å…ƒç´ æ˜¯ `n` ä¸ª `0` åˆ° `k` ä¹‹é—´çš„æ•´æ•°æ—¶ï¼Œå®ƒçš„è¿è¡Œæ—¶é—´æ˜¯ `t(n+k)`ã€‚**è®¡æ•°æ’åºä¸æ˜¯æ¯”è¾ƒæ’åºï¼Œæ’åºçš„é€Ÿåº¦å¿«äºä»»ä½•æ¯”è¾ƒæ’åºç®—æ³•ã€‚**

ç”±äºç”¨æ¥è®¡æ•°çš„æ•°ç»„ `C` çš„é•¿åº¦å–å†³äºå¾…æ’åºæ•°ç»„ä¸­æ•°æ®çš„èŒƒå›´ï¼ˆç­‰äºå¾…æ’åºæ•°ç»„çš„æœ€å¤§å€¼ä¸æœ€å°å€¼çš„å·®åŠ ä¸Š 1ï¼‰ï¼Œè¿™ä½¿å¾—è®¡æ•°æ’åºå¯¹äºæ•°æ®èŒƒå›´å¾ˆå¤§çš„æ•°ç»„ï¼Œéœ€è¦å¤§é‡æ—¶é—´å’Œå†…å­˜ã€‚

```javascript
function countingSort(arr) {
  const len = arr.length
  if (len < 2) return arr
  const bucket = []
  let sortIndex = 0

  for (let i = 0; i < len; i++) {
    if (bucket[arr[i]]) {
      bucket[arr[i]] += 1
    } else {
      bucket[arr[i]] = 1
    }
  }

  for (let i = 0; i < bucket.length; i++) {
    for (let j = bucket[i]; j > 0; j--) {
      arr[sortIndex++] = i
    }
  }
  return arr
}
```

### ğŸ˜»âœ” åŸºæ•°æ’åº(radix-sort) 

![åŸºæ•°æ’åº](https://qiniu1.lxfriday.xyz/feoffer/radixSort.png)

**é™å®šä¸ºéè´Ÿæ•°**

åŸºæ•°æ’åºåŸç†æ˜¯å°†æ•´æ•°æŒ‰ä½æ•°åˆ‡å‰²æˆä¸åŒçš„æ•°å­—ï¼Œç„¶åæŒ‰æ¯ä¸ªä½æ•°åˆ†åˆ«æ¯”è¾ƒã€‚

å®ƒæ˜¯è¿™æ ·å®ç°çš„ï¼šå°†æ‰€æœ‰å¾…æ¯”è¾ƒæ•°å€¼ï¼ˆæ­£æ•´æ•°ï¼‰ç»Ÿä¸€ä¸ºåŒæ ·çš„æ•°å­—é•¿åº¦ï¼Œæ•°å­—è¾ƒçŸ­çš„æ•°å‰é¢è¡¥é›¶ã€‚ç„¶åï¼Œä»æœ€ä½ä½å¼€å§‹ï¼Œä¾æ¬¡è¿›è¡Œä¸€æ¬¡æ’åºã€‚è¿™æ ·ä»æœ€ä½ä½æ’åºä¸€ç›´åˆ°æœ€é«˜ä½æ’åºå®Œæˆä»¥åï¼Œæ•°åˆ—å°±å˜æˆä¸€ä¸ªæœ‰åºåºåˆ—ã€‚

åŸºæ•°æ’åºçš„æ–¹å¼å¯ä»¥é‡‡ç”¨ **LSDï¼ˆLeast significant digitalï¼‰** æˆ– **MSDï¼ˆMost significant digitalï¼‰**ï¼ŒLSD çš„æ’åºæ–¹å¼ç”±é”®å€¼çš„æœ€å³è¾¹å¼€å§‹ï¼Œè€Œ MSD åˆ™ç›¸åï¼Œç”±é”®å€¼çš„æœ€å·¦è¾¹å¼€å§‹ã€‚

åŸºæ•°æ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯ `O(k*n)`ï¼Œå…¶ä¸­ `n` æ˜¯æ’åºå…ƒç´ ä¸ªæ•°ï¼Œ`k` æ˜¯æ•°å­—ä½æ•°ã€‚è¿™ä¸æ˜¯è¯´è¿™ä¸ªæ—¶é—´å¤æ‚åº¦ä¸€å®šä¼˜äº `O(nlogn)`ï¼Œ`k` çš„å¤§å°å–å†³äºæ•°å­—ä½çš„é€‰æ‹©ï¼ˆæ¯”å¦‚æ¯”ç‰¹ä½æ•°ï¼‰ï¼Œå’Œå¾…æ’åºæ•°æ®æ‰€å±æ•°æ®ç±»å‹çš„å…¨é›†çš„å¤§å°ï¼›`k` å†³å®šäº†è¿›è¡Œå¤šå°‘è½®å¤„ç†ï¼Œè€Œ `n` æ˜¯æ¯è½®å¤„ç†çš„æ“ä½œæ•°ç›®ã€‚

LSD å®ç°

```javascript
function radixSort(arr) {
  const len = arr.length
  // å¾—åˆ°æœ€å¤§å€¼
  const max = Math.max(...arr)
  let bucket = []
  // è·å–æœ€å¤§å€¼çš„ä½æ•°
  let digit = `${max}`.length
  let start = 1
  // å¾…æ“ä½œçš„æ–°æ•°ç»„
  let res = arr.slice()

  while (digit > 0) {
    // æ¯è½®å‘å·¦ç§»åŠ¨ä¸€ä½
    start *= 10
    for (let i = 0; i < len; i++) {
      const j = res[i] % start
      // å’Œè®¡æ•°æ’åºç±»ä¼¼
      if (!bucket[j]) {
        bucket[j] = []
      }
      // bucket æ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„
      bucket[j].push(res[i])
    }

    // æ‹¼æ¥å‰ res è®¾ä¸ºç©ºæ•°ç»„
    res = []
    for (let i = 0; i < bucket.length; i++) {
      if (bucket[i] !== undefined) {
        // res æ‹¼æ¥ bucket[i] æ•°ç»„
        res = res.concat(bucket[i])
      }
    }
    // ç»“æŸä¹‹å bucket é‡ç½®
    bucket = []
    digit--
  }

  return res
}
```

### ğŸ˜»âœ” æ¡¶æ’åºã€ç®±æ’åº(bucket-sort) 

![æ¡¶æ’åº](https://qiniu1.lxfriday.xyz/feoffer/bucketSort.png)

æ¡¶æ’åºå·¥ä½œåŸç†æ˜¯å°†æ•°ç»„åˆ†åˆ°æœ‰é™æ•°é‡çš„æ¡¶é‡Œï¼Œæ¯ä¸ªæ¡¶å†ä¸ªåˆ«æ’åºï¼ˆæœ‰å¯èƒ½å†ä½¿ç”¨åˆ«çš„æ’åºç®—æ³•æˆ–æ˜¯ä»¥é€’å½’æ–¹å¼ç»§ç»­ä½¿ç”¨æ¡¶æ’åºè¿›è¡Œæ’åºï¼‰ã€‚

æ¡¶æ’åºä»¥ä¸‹åˆ—æ­¥éª¤è¿›è¡Œï¼š

1. è®¾ç½®æ¡¶ä¸ªæ•° `size`ï¼Œè®¡ç®—æ¯ä¸ªæ¡¶çš„å­˜å‚¨èŒƒå›´ï¼›
1. éå†æ•°ç»„ï¼ŒæŠŠæ•°å­—æ”¾åˆ°å¯¹åº”çš„æ¡¶ä¸­ï¼›
1. å¯¹æ­¥éª¤ 2 æ”¾æ–°æ•°å­—çš„æ¡¶æ•°ç»„æ’åºï¼›
1. æ•°ç»„éå†å®Œä¹‹åï¼ŒæŠŠæ¡¶ä¸­çš„æ•°å­—ä¾æ¬¡å–å‡ºæ”¾åˆ°æœ€ç»ˆçš„æ•°ç»„ä¸­ï¼›

```javascript
function swap(arr, i, j) {
  ;[arr[i], arr[j]] = [arr[j], arr[i]]
}

/**
 * @param {array} arr å¾…æ’åºçš„æ•°ç»„
 * @param {number} size æ¡¶çš„ä¸ªæ•°
 */
function bucketSort(arr, size = 5) {
  const len = arr.length
  // å–åˆ°æœ€å°å€¼
  const min = Math.min(...arr)
  // å–å¾—æœ€å¤§å€¼
  const max = Math.max(...arr)
  // æ¯ä¸ªæ¡¶çš„èŒƒå›´
  const bucketSize = Math.floor((max - min) / size) + 1
  const res = []
  // æ€»å…±çš„æ¡¶å®¹å™¨
  const bucket = []

  for (let i = 0; i < len; i++) {
    // arr[i] åˆ†å¸ƒåœ¨æ¡¶ j
    const j = Math.floor((arr[i] - min) / bucketSize)

    // æ¡¶ä¸å­˜åœ¨åˆ™åˆ›å»º
    if (bucket[j] === undefined) {
      bucket[j] = []
    }
    // å°† arr[i] æ¨å…¥æ¡¶ä¸­
    bucket[j].push(arr[i])
    let l = bucket[j].length - 1
    while (l > 0) {
      // å¯¹ä¸ªåˆ«æ¡¶ä½¿ç”¨å†’æ³¡
      // è‹¥ arr[i] åœ¨æ¡¶å†…ä¸æ˜¯æœ€å°ï¼Œåˆ™å‘å‰ç§»åŠ¨
      bucket[j][l] < bucket[j][l - 1] && swap(bucket[j], l, l - 1)
      l--
    }
  }

  // æŠŠ bucket äºŒç»´æ•°ç»„ä¸­çš„æ•°æ®å…¨éƒ¨æ‹¿å‡ºæ¥
  for (let i = 0; i < bucket.length; i++) {
    if (bucket[i] !== undefined) {
      for (let j = 0; j < bucket[i].length; j++) {
        res.push(bucket[i][j])
      }
    }
  }
  return res
}
```

## âœ” æœç´¢ç®—æ³•

### ğŸ˜»âœ” äºŒåˆ†æœç´¢ç®—æ³• 

äºŒåˆ†æœç´¢ç®—æ³•çš„å‰ææ˜¯ç›®æ ‡æ•°ç»„å·²ç»æ’å¥½åºäº†ã€‚

```js
function binarySearch(arr, target) {
  let l = 0
  let r = arr.length - 1
  while (l <= r) {
    const med = Math.floor((l + r) / 2)
    if (target < arr[med]) {
      r = med - 1
    } else if (target > arr[med]) {
      l = med + 1
    } else {
      return med
    }
  }
  return -1
}
```

## ğŸ˜»âœ” LRU ç¼“å­˜ç®—æ³• 

ref

- [https://juejin.im/post/5d77b68951882520d46abd18](https://juejin.im/post/5d77b68951882520d46abd18)

> è¿ç”¨ä½ æ‰€æŒæ¡çš„æ•°æ®ç»“æ„ï¼Œè®¾è®¡å’Œå®ç°ä¸€ä¸ª LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜æœºåˆ¶ã€‚å®ƒåº”è¯¥æ”¯æŒä»¥ä¸‹æ“ä½œï¼š è·å–æ•°æ® get å’Œ å†™å…¥æ•°æ® put ã€‚è·å–æ•°æ® get(key) - å¦‚æœå¯†é’¥ (key) å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è·å–å¯†é’¥çš„å€¼ï¼ˆæ€»æ˜¯æ­£æ•°ï¼‰ï¼Œå¦åˆ™è¿”å› -1ã€‚å†™å…¥æ•°æ® put(key, value) - å¦‚æœå¯†é’¥ä¸å­˜åœ¨ï¼Œåˆ™å†™å…¥å…¶æ•°æ®å€¼ã€‚å½“ç¼“å­˜å®¹é‡è¾¾åˆ°ä¸Šé™æ—¶ï¼Œå®ƒåº”è¯¥åœ¨å†™å…¥æ–°æ•°æ®ä¹‹å‰åˆ é™¤æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„æ•°æ®å€¼ï¼Œä»è€Œä¸ºæ–°çš„æ•°æ®å€¼ç•™å‡ºç©ºé—´ã€‚

ç¼“å­˜çš„å¤§å°æœ‰é™ï¼Œå½“ç¼“å­˜è¢«ç”¨æ»¡æ—¶ï¼Œå“ªäº›æ•°æ®åº”è¯¥è¢«æ¸…ç†å‡ºå»ï¼Œå“ªäº›æ•°æ®åº”è¯¥è¢«ä¿ç•™ï¼Ÿè¿™å°±éœ€è¦ç¼“å­˜æ·˜æ±°ç­–ç•¥æ¥å†³å®šã€‚å¸¸è§çš„ç­–ç•¥æœ‰ä¸‰ç§ï¼š**å…ˆè¿›å…ˆå‡ºç­–ç•¥** FIFOï¼ˆFirst Inï¼ŒFirst Outï¼‰ã€**æœ€å°‘ä½¿ç”¨ç­–ç•¥** LFUï¼ˆLeast Frequently Usedï¼‰ã€**æœ€è¿‘æœ€å°‘ä½¿ç”¨ç­–ç•¥** LRUï¼ˆLeast Recently Usedï¼‰ã€‚

æœ€è¿‘æœ€å°‘ï¼Œè¶Šæ˜¯æœ€è¿‘ä½¿ç”¨å°±è¶Šæ˜¯ä¸ä¼šè¢«æ¸…é™¤ï¼Œè€Œæœ€è¿œä½¿ç”¨çš„å°†ä¼šé€æ¸è¢«æ¨åˆ°ä¸¢å¼ƒç«¯ï¼Œå¦‚æœä¸€ç›´ä¸è¢«ä½¿ç”¨ï¼Œæ•°æ®ä¸æ–­å­˜å…¥æ—¶å°†ä¼šä¸¢å¼ƒå®ƒä»¬ã€‚

ä½¿ç”¨ ES6 Map å®ç°

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity
    this.cache = new Map()
  }
  put(k, v) {
    if (this.cache.has(k)) this.cache.delete(k)
    else if (this.cache.size >= this.capacity)
      this.cache.delete(this.cache.keys().next().value)
    this.cache.set(k, v)
  }
  get(k) {
    const v = this.cache.get(k)
    if (v === undefined) return -1
    else this.moveToEnd(k, v)
    return v
  }
  moveToEnd(k, v) {
    this.cache.delete(k)
    this.cache.set(k, v)
  }
}
```

åŒå‘é“¾è¡¨å®ç°

```javascript
class LinkedListNode {
  constructor(k, v, prev, next) {
    this.key = k
    this.value = v
    // å‰å‘èŠ‚ç‚¹
    this.prev = prev
    // åå‘èŠ‚ç‚¹
    this.next = next
  }
}

class LRUCache {
  constructor(capacity) {
    // å®¹é‡
    this.capacity = capacity
    this.cache = {}
    // å®é™…å­˜å‚¨çš„å®¹é‡
    this.size = 0
    // å“¨å…µå¤´ç»“ç‚¹
    this.head = new LinkedListNode()
    // å“¨å…µå°¾ç»“ç‚¹
    this.tail = new LinkedListNode()

    this.head.next = this.tail
    this.tail.prev = this.head
  }

  // åˆ é™¤èŠ‚ç‚¹
  removeNode(node) {
    const prev = node.prev
    const next = node.next

    prev.next = next
    next.prev = prev
  }

  // æ–°å¢ä¸€ä¸ªèŠ‚ç‚¹
  addNode(node) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
  }
  // åˆ é™¤å°¾ç»“ç‚¹
  popTail() {
    const res = this.tail.prev
    this.removeNode(res)
    return res
  }

  put(k, v) {
    const node = this.cache[k]
    if (!node) {
      const n = new LinkedListNode(k, v)
      this.cache[k] = n
      this.addNode(n)
      if (this.size >= this.capacity) {
        const deleteNode = this.popTail()
        delete this.cache[deleteNode.key]
      } else {
        this.size += 1
      }
    } else {
      this.removeNode(node)
      node.value = v
      this.addNode(node)
    }
  }

  get(k) {
    const node = this.cache[k]
    if (!node) return -1
    else {
      this.removeNode(node)
      this.addNode(node)
      return node.value
    }
  }
}
```

## ğŸ˜»âœ” æ–æ³¢æ‹‰å¥‘æ•°åˆ— 

```
1 1 2 3 5 8 13 21 34 55 89
```

**å°¾é€’å½’**

ç°åœ¨æµè§ˆå™¨å’Œ NodeJS å·²ç»ç¦ç”¨äº†å°¾é€’å½’ä¼˜åŒ–ï¼Œæ‰€ä»¥ä»…ä»…æ˜¯å°¾é€’å½’ï¼Œå¹¶ä¸ä¼šèµ·åˆ°ä¼˜åŒ–çš„ä½œç”¨ã€‚

```javascript
function Fibonacci(n, prev1 = 1, prev2 = 0) {
  if (n === 1) return prev1
  return Fibonacci(n - 1, prev1 + prev2, prev1)
}
```

**è¿­ä»£**

```javascript
function Fibonacci(n) {
  const init = [1, 0]
  for (let i = 1; i < n; i++) {
    ;[init[0], init[1]] = [init[0] + init[1], init[0]]
  }
  return init[0]
}
```

## ğŸ˜»âœ” å› å¼åˆ†è§£ 

å®ç°ä¸€ä¸ª `calc` æ–¹æ³•ï¼Œå¯ä»¥å°†è¾“å…¥çš„æ•°æ‹†è§£ä¸ºå°½å¯èƒ½å¤šçš„ä¹˜æ•°ï¼Œæ‰€æœ‰æ•°ç›¸ä¹˜ç­‰äºè¾“å…¥æ•°ã€‚

```javascript
calc(2) // [2]
calc(8) // [2, 2, 2]
calc(24) // [2, 2, 2, 3]
calc(30) // [2, 3, 5]
```

```javascript
function calc(n) {
  const res = []
  let prev = n
  let i = 2

  while (i <= prev) {
    if (prev % i === 0) {
      res.push(i)
      prev /= i
      i = 2
    } else if (i < prev) {
      i++
    } else if (i === prev) {
      res.push(i)
    }
  }
  console.log(res)

  return res
}
```

# from - å…¶ä»–

## âœ” ä»æ•°ç»„ä¸­æ‰¾å‡ºå’Œä¸ºæŸä¸ªå€¼çš„ä¸¤æ•°ä¸‹æ ‡

> ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡ºå’Œä¸ºç›®æ ‡å€¼çš„é‚£ä¸¤ä¸ªæ•´æ•°ï¼Œå¹¶è¿”å›ä»–ä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œä½ ä¸èƒ½é‡å¤åˆ©ç”¨è¿™ä¸ªæ•°ç»„ä¸­åŒæ ·çš„å…ƒç´ ã€‚ ç¤ºä¾‹: ç»™å®š nums = [2, 7, 11, 15], target = 9 å› ä¸º nums[0] + nums[1] = 2 + 7 = 9 æ‰€ä»¥è¿”å› [0, 1]ã€‚

åˆå§‹ä»£ç ï¼š

```javascript
const twoSum = (nums, target) => {}
```

---

è§£æ³• 1 - `Map`ï¼š

```javascript
const twoSum = (nums, target) => {
  const map = new Map()
  for (let i = 0, len = nums.length; i < len; i++) {
    if (map.get(nums[i])) {
      return [map.get(nums[i]), i]
    }
    map.set(target - nums[i], i)
  }
}
```

è§£æ³• 2 - ä¸¤æ¬¡å¾ªç¯ï¼š

```javascript
const twoSum = (nums, target) => {
  for (let i = 0, len = nums.length; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      if (nums[i] + nums[j] === target) return [i, j]
    }
  }
}
```

# leetcode åˆ·é¢˜è®°å½•

## ğŸ˜»âœ” 1 ä¸¤æ•°ä¹‹å’Œã€easyã€‘

[ref](https://leetcode.cn/problems/two-sum/)

Mapã€å­—å…¸

```js
var twoSum = function (nums, target) {
  // for (var i = 0; i < nums.length; i++) {
  //   for (var j = i + 1; j < nums.length; j++) {
  //     if (nums[i] + nums[j] === target) return [i, j]
  //   }
  // }
  const m = new Map()
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i]
    const other = target - num
    if (m.has(other)) {
      return [m.get(other), i]
    } else {
      m.set(num, i)
    }
  }
}
```

## ğŸ˜»âœ” 2 ä¸¤æ•°ç›¸åŠ ã€meidumã€‘

[ref](https://leetcode.cn/problems/add-two-numbers/)

é“¾è¡¨

```js
var addTwoNumbers = function (l1, l2) {
  const head = new ListNode()
  let curr = head
  let add = 0
  let sum = 0
  while (l1 || l2) {
    sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + add
    add = Math.floor(sum / 10)
    curr.next = new ListNode(sum - 10 * add)
    l1 = l1 && l1.next
    l2 = l2 && l2.next
    curr = curr.next
  }
  if (add > 0) {
    curr.next = new ListNode(1)
  }

  return head.next
}

function ListNode(val, next) {
  this.val = val === undefined ? 0 : val
  this.next = next === undefined ? null : next
}
```

## ğŸ˜»âœ” 3 æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²ã€meidumã€‘

[ref](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

æ»‘åŠ¨çª—å£ã€å­—å…¸

```js
var lengthOfLongestSubstring = function (s) {
  let maxLen = 0
  let currStr = ''
  for (let i = 0; i < s.length; i++) {
    const indInCurrStr = currStr.indexOf(s[i])
    let len
    if (indInCurrStr === -1) {
      currStr += s[i]
      len = currStr.length
    } else {
      len = currStr.length
      currStr = currStr.slice(indInCurrStr + 1) + s[i]
    }
    maxLen = len > maxLen ? len : maxLen
  }
  return maxLen
}
```

or

```js
var lengthOfLongestSubstring = function (s) {
  let l = 0
  let max = 0
  const m = new Map()
  for (let r = 0; r < s.length; r++) {
    if (m.has(s[r]) && m.get(s[r]) >= l) {
      l = m.get(s[r]) + 1
    }
    m.set(s[r], r)
    max = Math.max(max, r - l + 1)
  }
  return max
}
```

## ğŸ˜»âœ” 20 æœ‰æ•ˆçš„æ‹¬å·ã€easyã€‘

[ref](https://leetcode.cn/problems/valid-parentheses/)

å…³é”®è¯ï¼šæ ˆ

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
  const leftValues = '({['
  const map = {
    '(': ')',
    '{': '}',
    '[': ']',
  }
  const stack = []
  for (let i = 0; i < s.length; i++) {
    if (leftValues.includes(s[i])) {
      stack.push(s[i])
    } else {
      const lastValue = stack.pop()
      if (map[lastValue] !== s[i]) return false
    }
  }
  return !stack.length
}
```

## ğŸ˜»âœ” 21 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ã€easyã€‘

[ref](https://leetcode.cn/problems/merge-two-sorted-lists/)

é“¾è¡¨

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(n) n=list1.length + list2.length
// ç©ºé—´å¤æ‚åº¦ï¼šO(1)
var mergeTwoLists = function(list1, list2) {
  const head = new ListNode()
  let th = head
  while(list1 && list2) {
    if(list1.val < list2.val) {
      th.next = list1
      list1 = list1.next
    } else {
      th.next = list2
      list2 = list2.next
    }
    th = th.next
  }
  if(list1) {
    th.next = list1
  }
  if(list2) {
    th.next = list2
  }
  return head.next
};
```

## ğŸ˜»âœ” 23 åˆå¹¶Kä¸ªå‡åºé“¾è¡¨ã€hardã€‘

[ref](https://leetcode.cn/problems/merge-k-sorted-lists/)

é“¾è¡¨ã€å †

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(nlogk)
// ç©ºé—´å¤æ‚åº¦ï¼šO(k)
// k æ˜¯ list.lenght
// n æ˜¯æ‰€æœ‰é“¾è¡¨èŠ‚ç‚¹çš„ä¸ªæ•°
var mergeKLists = function(lists) {
  const head = new ListNode()
  let th = head
  const h = new MinHeap()
  for(let list of lists) {
    list && h.insert(list)
  }

  while(h.size()) {
    let hPop = h.pop()
    th.next = hPop
    th = th.next
    if(hPop.next) h.insert(hPop.next)
  }

  return head.next
};
class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    let p = this.heap.pop()
    this.shiftDown(0)
    return p
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i].val > this.heap[left].val) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i].val > this.heap[right].val) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex].val > this.heap[i].val) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

æˆ–è€…

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)
// ç©ºé—´å¤æ‚åº¦ï¼šO(n)
var mergeKLists = function(lists) {
  const head = new ListNode()
  let th = head
  const h = new MinHeap() // å°é¡¶å †
  for(let list of lists) {
    while(list) {
      h.insert(list.val)
      list = list.next
    }
  }

  while(h.size()) {
    th.next = new ListNode(h.pop())
    th = th.next
  }

  return head.next
};
class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    this.heap.pop()
    this.shiftDown(0)
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i] > this.heap[left]) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i] > this.heap[right]) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex] > this.heap[i]) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

æ›´ä¼˜è§£



## ğŸ˜»âœ” 65 æœ‰æ•ˆçš„æ•°å­—ã€hardã€‘

[ref](https://leetcode.cn/problems/valid-number/)

```js
var isNumber = function(s) {
  // if(s === 'Infinity' || s === '+Infinity' || s === '-Infinity') return false
  // const num = Number(s)
  // if(isNaN(num)) return false
  // return true
  // æ¨¡æ‹Ÿæ³•
  let numLeft = ''
  let numRight = ''
  s = s.trim().toLowerCase()
 if(s.includes('e')) {
    const sSplit = s.split('e')
    if(sSplit.length > 2) { return false }
    [numLeft, numRight] = sSplit
    if(validateNumLeft(numLeft) && validateNumRight(numRight)) return true
  } else {
    numLeft = s
    if(validateNumLeft(numLeft)) return true
  }
  return false
};

function validateNumLeft(numLeft) {
  if('-+'.includes(numLeft[0])) {
    numLeft = numLeft.slice(1)
    if(numLeft.includes('-') || numLeft.includes('+')) return false
  }
  if(!numLeft.length) return false
  let numLeftSplit
  if(numLeft.includes('.')) {
    numLeftSplit = numLeft.split('.')
    if(numLeftSplit.length > 2 ) return false
    if(!numLeftSplit[0].length && isNumStr(numLeftSplit[1])) return true
    if(!numLeftSplit[1].length && isNumStr(numLeftSplit[0])) return true
    if(isNumStr(numLeftSplit[0]) && isNumStr(numLeftSplit[1])) return true
    return false
  } else {
    return isNumStr(numLeft)
  }
}

function validateNumRight(numRight) {
  if(numRight[0] === '-' || numRight[0] === '+') {
    numRight = numRight.slice(1)
  }
  return isNumStr(numRight)
}

function isNumStr(numStr) {
  if(!numStr.length) return false
  for(let c of numStr) {
    if(!(c >= '0' && c <= '9')) return false
  }
  return true
}
```

## ğŸ˜»âœ” 70 çˆ¬æ¥¼æ¢¯ã€easyã€‘

[ref](https://leetcode.cn/problems/climbing-stairs/)

åŠ¨æ€è§„åˆ’

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)
// ç©ºé—´å¤æ‚åº¦ï¼šO(1)
var climbStairs = function(n) {
  if(n === 1) return 1
  if(n === 2) return 2
  d1 = 1
  d2 = 2
  for(let i = 3; i <= n; i++) {
    const tmpD2 = d2
    d2 = d1 + d2
    d1 = tmpD2
  }
  return d2
};
```

æ•°ç»„è§£

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)
// ç©ºé—´å¤æ‚åº¦ï¼šO(n)
var climbStairs = function(n) {
  const d = []
  d[1] = 1
  d[2] = 2
  for(let i = 3; i <= n; i++) {
    d[i] = d[i - 1] + d[i - 2]
  }
  return d[n]
};
````

## ğŸ˜»âœ” 76 æœ€å°è¦†ç›–å­ä¸²ã€hardã€‘

[ref](https://leetcode.cn/problems/minimum-window-substring/)

åŒæŒ‡é’ˆã€æ»‘åŠ¨çª—å£

```js
var minWindow = function(s, t) {
  const need = new Map()
  let needType = 0
  for(let c of t) {
    if(need.has(c)) {
      need.set(c, need.get(c) + 1)
    } else {
      need.set(c, 1)
      needType += 1
    }
  }

  let l = 0
  let minStr = ''
  for(let r = 0;r < s.length; r++) {
    const c = s[r]
    if(need.has(c)) {
      need.set(c, need.get(c) - 1)
      if(need.get(c) === 0) needType -= 1 
    }
    while(needType === 0) {
      if(!minStr.length || s.slice(l, r + 1).length < minStr.length) minStr = s.slice(l, r + 1)
      if(need.has(s[l])) {
        need.set(s[l], need.get(s[l]) + 1)
        if(need.get(s[l]) === 1) {
          needType += 1
        }
      }
      l++
    }
  }
  return minStr
};
```

## âœ” 83 åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ ã€easyã€‘

[ref](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

é“¾è¡¨

```js
var deleteDuplicates = function (head) {
  let t = head
  while (t && t.next) {
    const tNext = t.next
    if (t.val !== tNext.val) {
      t = t.next
    } else {
      t.next = tNext.next
    }
  }
  return head
}
```

## ğŸ˜»âœ” 94 äºŒå‰æ ‘çš„ä¸­åºéå†ã€easyã€‘

[ref](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

äºŒå‰æ ‘ã€ä¸­åºéå†ã€DFSã€æ·±åº¦ä¼˜å…ˆéå†

```js
var inorderTraversal = function (root) {
  const res = []
  const dfs = node => {
    if (!node) return
    dfs(node.left)
    res.push(node.val)
    dfs(node.right)
  }
  dfs(root)
  return res
}1
```

## ğŸ˜»âœ” 100 ç›¸åŒçš„æ ‘ã€easyã€‘

[ref](https://leetcode.cn/problems/same-tree/)

äºŒå‰æ ‘ã€æ ‘

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)
// ç©ºé—´å¤æ‚åº¦ï¼šO(logn)~O(n)
var isSameTree = function(p, q) {
  if(!p && !q) return true
  if(p && q && p.val === q.val) {
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
  }
  return false
};
```

## ğŸ˜»âœ” 101 å¯¹ç§°äºŒå‰æ ‘ã€easyã€‘

[ref](https://leetcode.cn/problems/symmetric-tree/)

äºŒå‰æ ‘

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)
// ç©ºé—´å¤æ‚åº¦ï¼šO(logn)~O(n)
var isSymmetric = function(root) {
  if(!root) return true
  const isMirror = (l, r) => {
    if(!l && !r) return true
    if(l && r && l.val === r.val) {
      return isMirror(l.left, r.right) && isMirror(l.right, r.left)
    }
    return false
  }
  return isMirror(root.left, root.right)
};
```

## ğŸ˜»âœ” 102 äºŒå‰æ ‘çš„å±‚åºéå†ã€mediumã€‘

[ref](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

äºŒå‰æ ‘ã€BFSã€å¹¿åº¦ä¼˜å…ˆéå†ã€å±‚åºéå†

```js
var levelOrder = function (root) {
  if (!root) return []
  const q = [[root, 0]]
  const res = []
  while (q.length) {
    const [node, depth] = q.shift()
    res[depth] ? res[depth].push(node.val) : (res[depth] = [node.val])
    node.left && q.push([node.left, depth + 1])
    node.right && q.push([node.right, depth + 1])
  }

  return res
}
```

## ğŸ˜»âœ” 104 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ã€easyã€‘

[ref](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

äºŒå‰æ ‘ã€æ·±åº¦ä¼˜å…ˆéå†ã€DFS

```js
var maxDepth = function (root) {
  let maxLen = 0
  const dfs = (node, l) => {
    if (!node) return
    maxLen = Math.max(maxLen, l)
    dfs(node.left, l + 1)
    dfs(node.right, l + 1)
  }
  dfs(root, 1)
  return maxLen
}
```

## ğŸ˜»âœ” 111 äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ã€easyã€‘

[ref](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

äºŒå‰æ ‘ã€å¹¿åº¦ä¼˜å…ˆéå†ã€BFS

```js
var minDepth = function (root) {
  if (!root) return 0
  const q = [[root, 1]]
  while (q.length) {
    const [node, depth] = q.shift()
    if (!node.left && !node.right) return depth
    node.left && q.push([node.left, depth + 1])
    node.right && q.push([node.right, depth + 1])
  }
}
```

## ğŸ˜»âœ” 112 è·¯å¾„æ€»å’Œã€easyã€‘

[ref](https://leetcode.cn/problems/path-sum/)

äºŒå‰æ ‘ã€äºŒå‰æ ‘çš„è·¯å¾„æ€»å’Œã€DFSã€æ·±åº¦ä¼˜å…ˆéå†

```js
var hasPathSum = function (root, targetSum) {
  if (!root) return false
  let has = false
  const dfs = (node, sum) => {
    if (!node.left && !node.right) {
      if (node.val + sum === targetSum) {
        has = true
      }
    }
    node.left && dfs(node.left, node.val + sum)
    node.right && dfs(node.right, node.val + sum)
  }

  dfs(root, 0)
  return has
}
```

## ğŸ˜»âœ” 113 å…‹éš†å›¾ã€mediumã€‘

[ref](https://leetcode.cn/problems/clone-graph/)

å›¾ã€æ·±åº¦ä¼˜å…ˆéå†ã€å¹¿åº¦ä¼˜å…ˆéå†ã€DFSã€BFS

```js
// DFS
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function(node) {
  if(!node) return 
  const visited = new Map()
  function dfs (targetNode) {
    const newNode = new Node(targetNode.val)
    visited.set(targetNode, newNode);
    (targetNode.neighbors || []).forEach(neighborNode => {
      if(!visited.has(neighborNode)) {
        dfs(neighborNode)
      }
      newNode.neighbors.push(visited.get(neighborNode))
    })
  }
  dfs(node)
  return visited.get(node)
};

// BFS
var cloneGraph = function(node) {
  if(!node) return 
  const visited = new Map()
  const q = [node]
  visited.set(node, new Node(node.val));
  while(q.length) {
    const targetNode = q.shift();
    (targetNode.neighbors || []).forEach(neighborNode => {
      if(!visited.has(neighborNode)) {
        q.push(neighborNode)
        visited.set(neighborNode, new Node(neighborNode.val))
      }
      visited.get(targetNode).neighbors.push(visited.get(neighborNode))
    })
  }
  return visited.get(node)
};
```

## ğŸ˜»âœ” 141 ç¯å½¢é“¾è¡¨ã€easyã€‘

[ref](https://leetcode.cn/problems/linked-list-cycle/)

ç¯å½¢é“¾è¡¨ï¼ŒåŒæŒ‡é’ˆï¼Œå¿«æ…¢æŒ‡é’ˆ

```js
var hasCycle = function (head) {
  let p1 = head
  let p2 = head
  while (p2 && p2.next) {
    p1 = p1.next
    p2 = p2.next.next
    if (p1 === p2) return true
  }

  return false
}
```

## ğŸ˜»âœ” 198 æ‰“å®¶åŠ«èˆã€mediumã€‘

[ref](https://leetcode.cn/problems/house-robber/)

åŠ¨æ€è§„åˆ’

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)
// ç©ºé—´å¤æ‚åº¦ï¼šO(1)
var rob = function(nums) {
  if(nums.length === 1) return nums[0]
  if(nums.length === 2) return Math.max(nums[0], nums[1])
  let d0 = nums[0]
  let d1 = Math.max(nums[0], nums[1])
  for(let i = 2;i < nums.length; i++) {
    const t = d1
    d1 = Math.max(d0 + nums[i], d1)
    d0 = t
  }
  return d1
};
```
or
```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(n)
// ç©ºé—´å¤æ‚åº¦ï¼šO(n)
var rob = function(nums) {
  const dp = []
  dp[0] = nums[0]
  dp[1] = Math.max(nums[0], nums[1])
  for(let i = 2;i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1])
  }
  return dp[nums.length - 1]
};
```

## ğŸ˜»âœ” 206 åè½¬é“¾è¡¨ã€easyã€‘

[ref](https://leetcode.cn/problems/reverse-linked-list/)

é“¾è¡¨

```js
var reverseList = function (head) {
  if (head === null) return head
  let curr = head
  let next = head.next
  curr.next = null
  while (next) {
    const n = next.next
    next.next = curr
    curr = next
    next = n
  }
  return curr
}
```

## ğŸ˜»âœ” 215 æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ã€mediumã€‘

[ref](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

å †ã€å°é¡¶å †ã€ç¬¬Kå¤§

```js
 // æ—¶é—´å¤æ‚åº¦ï¼šO(nlogk)
 // ç©ºé—´å¤æ‚åº¦ï¼šO(k)
var findKthLargest = function(nums, k) {
  const heap = new MinHeap()

  nums.forEach(n => {
      heap.insert(n)
    if(heap.size() > k) {
      heap.pop()
    }
  })
  return heap.peek()
};

class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    this.heap.pop()
    this.shiftDown(0)
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i] > this.heap[left]) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i] > this.heap[right]) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex] > this.heap[i]) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

## ğŸ˜»âœ” 226 ç¿»è½¬äºŒå‰æ ‘ã€easyã€‘

[ref](https://leetcode.cn/problems/invert-binary-tree/)

ç¿»è½¬äºŒå‰æ ‘å®é™…å°±æ˜¯æŠŠæ¯ä¸ªèŠ‚ç‚¹çš„å­æ ‘å…¨éƒ¨ç¿»è½¬ä¸€æ¬¡

äºŒå‰æ ‘ã€äºŒå‰æ ‘ç¿»è½¬ã€ç¿»è½¬äºŒå‰æ ‘ã€å †

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(n) æ¯ä¸ªèŠ‚ç‚¹éƒ½è®¿é—®åˆ°äº†
// ç©ºé—´å¤æ‚åº¦ï¼šO(h) h æ˜¯æ ‘çš„é«˜åº¦ï¼Œh æœ€åçš„æƒ…å†µæ˜¯ n
var invertTree = function(root) {
  if(!root) return root
  return {
    val: root.val,
    left: invertTree(root.right),
    right: invertTree(root.left),
  }
};
``` 

è§£æ³•2

```js
var invertTree = function(root) {
  if(!root) return root
  const head = new TreeNode(root.val)

  const dfs = (node, parent, isLeft) => {
    if(!node) return
    if(isLeft) {
      parent.right = new TreeNode(node.val)
      dfs(node.left, parent.right, true)
      dfs(node.right, parent.right, false)
    } else {
      parent.left = new TreeNode(node.val)
      dfs(node.left, parent.left, true)
      dfs(node.right, parent.left, false)
    }
  }

  dfs(root.left, head, true)
  dfs(root.right, head, false)

  return head
};
```

## ğŸ˜»âœ” 347 å‰ K ä¸ªé«˜é¢‘å…ƒç´ ã€mediumã€‘

[ref](https://leetcode.cn/problems/top-k-frequent-elements/)

å †ã€å°é¡¶å †ã€å‰Kå¤§

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(nlogk)
// ç©ºé—´å¤æ‚åº¦ï¼šO(n)
var topKFrequent = function(nums, k) {
  const map = new Map()
  const h = new MinHeap()
  for(let n of nums) {
    map.set(n, map.has(n) ? map.get(n) + 1 : 1)
  }

  map.forEach((frequence, num) => {
    h.insert({num, frequence})
    if(h.size() > k) {
      h.pop()
    }
  })

  return h.heap.map(_ => _.num)
};

class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    let p = this.heap.pop()
    this.shiftDown(0)
    return p
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i].frequence > this.heap[left].frequence) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i].frequence > this.heap[right].frequence) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex].frequence > this.heap[i].frequence) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

è¿˜æœ‰ä¸€ä¸ªè§£æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ç¨å¾®å·®ç‚¹

```js
// æ—¶é—´å¤æ‚åº¦ï¼šO(nlogn) å¿«æ’
// ç©ºé—´å¤æ‚åº¦ï¼šO(n)
var topKFrequent = function(nums, k) {
  const map = new Map()
  for(let n of nums) {
    map.set(n, map.has(n) ? map.get(n) + 1 : 1)
  }
  const mapArr = Array.from(map)
  mapArr.sort((a, b) => b[1] - a[1])
  return mapArr.slice(0, k).map(_ => _[0]) 
};
```

## ğŸ˜»âœ” 374 çŒœæ•°å­—å¤§å°ã€easyã€‘

[ref](https://leetcode.cn/problems/guess-number-higher-or-lower/)

äºŒåˆ†æœç´¢

```js
var guessNumber = function(n) {
  let l = 0
  let r = n
  while(l <= r) {
    const med = Math.floor((l + r) / 2)
    if(guess(med) === -1) {
      r = med - 1
    } else if(guess(med) === 1) {
      l = med + 1
    } else {
      return med
    }
  }
};
```

## ğŸ˜»âœ” 349 ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†ã€easyã€‘

[ref](https://leetcode.cn/problems/intersection-of-two-arrays/)

é›†åˆ

```js
var intersection = function (nums1, nums2) {
  return [...new Set(nums1.filter(v => nums2.includes(v)))]
}
```


## ğŸ˜»âœ” 417 å¤ªå¹³æ´‹å¤§è¥¿æ´‹æ°´æµé—®é¢˜ã€mediumã€‘

[ref](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

æ·±åº¦ä¼˜å…ˆéå†ã€DFSã€å›¾ã€é€†æµè€Œä¸Š

```js
var pacificAtlantic = function(heights) {
  const m = heights.length
  const n = heights[0].length
  const leftTopFlow = new Array(m).fill(1).map(() => new Array(n).fill(false))
  const rightBottomFlow = new Array(m).fill(1).map(() => new Array(n).fill(false))
  const res = []

  function dfs(i, j, flow) {
    flow[i][j] = true;
    [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]].forEach(([ni, nj]) => {
      if(
        ni >= 0 && ni < m &&
        nj >= 0 && nj < n &&
        !flow[ni][nj] &&
        heights[ni][nj] >= heights[i][j]
      ) {
        dfs(ni, nj, flow)
      }
    })
  }

  for(let i = 0;i < m; i++) {
    dfs(i, 0, leftTopFlow)
    dfs(i, n - 1, rightBottomFlow)
  }
  for(let j = 0;j < n; j++) {
    dfs(0, j, leftTopFlow)
    dfs(m - 1, j, rightBottomFlow)
  }

  for(let i = 0;i < m; i++) {
    for(let j = 0;j < n; j++) {
      if(leftTopFlow[i][j] && rightBottomFlow[i][j]) res.push([i, j])
    }
  }

  return res
};
```

## âœ” 933 æœ€è¿‘çš„è¯·æ±‚æ¬¡æ•°ã€easyã€‘

[ref](https://leetcode.cn/problems/number-of-recent-calls/)

è¿™ä¸ªé¢˜çš„æè¿°å¾ˆå®¹æ˜“çœ‹ä¸æ‡‚ï¼Œä½†æ˜¯å®ç°èµ·æ¥éå¸¸ç®€å•

å…³é”®è¯ï¼šé˜Ÿåˆ—

```js
var RecentCounter = function () {
  this.q = []
}
/**
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function (t) {
  this.q.push(t)
  while (t - this.q[0] > 3000) {
    this.q.shift()
  }
  return this.q.length
}
```

