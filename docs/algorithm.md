<div class="finished-info-wrapper">
  完成度 <span class="finished-info">500 / 500 -> 100%<span>
</div>

# lack

## 滚动哈希

- [算法合集：滚动哈希——干脆叫前缀和得了](https://blog.csdn.net/mlgseminent/article/details/120583944)
  - [187. 重复的DNA序列](https://leetcode.cn/problems/repeated-dna-sequences/)

# ✔ 算法知名仓库

- [【微软】宫水三叶](https://github.com/SharingSource/LogicStack-LeetCode)
- [路西法](https://github.com/azl397985856/leetcode)
- [Krahets](https://leetcode.cn/u/jyd/)
- [全栈潇晨](https://xiaochen1024.com/)

# 大佬面试技巧

- [meta川 内推｜字节跳动｜多项岗位｜北京+上海](https://leetcode.cn/circle/discuss/fKBJcm/)

# 随便记录

- [LeetCode平台值得做的题目分类列表与参考难度](https://zhuanlan.zhihu.com/p/453897447)

## 经典题

- ?? [🌟【medium】743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/) 最短路、最短路问题、Floyd 算法、Dijkstra 算法、深度优先搜索

## 后续回顾

- ??[🌟【medium】470. 用 Rand7() 实现 Rand10()](https://leetcode.cn/problems/implement-rand10-using-rand7/) 概率、随机数
- ??? [🌟【hard】115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/) 动态规划
- ??? [🌟【hard】857. 雇佣 K 名工人的最低成本](https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/) 优先队列、大顶堆、堆
- 🌟【medium】[399. 除法求值](https://leetcode.cn/problems/evaluate-division/) Floyd 算法
- ?? [🌟【medium】227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/) 模拟
- ???[🌟【hard】940. 不同的子序列 II](https://leetcode.cn/problems/distinct-subsequences-ii/) 子序列、动态规划
- ???[🌟【easy】459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/) 模拟、字符串、KMP

# 刷题日记

- 20221017(10)
  - [🌟【medium】904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/) 滑动窗口
  - [🌟【easy】1122. 数组的相对排序](https://leetcode.cn/problems/relative-sort-array/) 计数排序
  - [🌟【easy】1021. 删除最外层的括号](https://leetcode.cn/problems/remove-outermost-parentheses/) 模拟
  - [🌟【easy】697. 数组的度](https://leetcode.cn/problems/degree-of-an-array/) 数组题、模拟
  - [🌟【easy】441. 排列硬币](https://leetcode.cn/problems/arranging-coins/) 二分搜索
  - [🌟【easy】1013. 将数组分成和相等的三个部分](https://leetcode.cn/problems/partition-array-into-three-parts-with-equal-sum/) 数组题，前缀和
  - [🌟【easy】476. 数字的补数](https://leetcode.cn/problems/number-complement/) 二进制、位运算
  - [🌟【easy】1160. 拼写单词](https://leetcode.cn/problems/find-words-that-can-be-formed-by-characters/) 哈希表
  - ?[🌟【medium】969. 煎饼排序](https://leetcode.cn/problems/pancake-sorting/) 模拟、排序
  - [🌟【medium】690. 员工的重要性](https://leetcode.cn/problems/employee-importance/) 图、广度优先搜索
- 20221016(10)
  - [🌟【medium】886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/) 图、广度优先搜索、深度优先搜索
  - [🌟【easy】733. 图像渲染](https://leetcode.cn/problems/flood-fill/) 图、深度优先搜索
  - [🌟【easy】1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/) 堆、大顶堆、优先队列
  - [🌟【easy】680. 验证回文串 II](https://leetcode.cn/problems/valid-palindrome-ii/) 字符串、回文串、双指针
  - [【easy】1672. 最富有客户的资产总量](https://leetcode.cn/problems/richest-customer-wealth/) 数组、矩阵
  - ???[🌟【easy】459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/) 模拟、字符串、KMP
  - [【easy】832. 翻转图像](https://leetcode.cn/problems/flipping-an-image/) 矩阵
  - [【easy】434. 字符串中的单词数](https://leetcode.cn/problems/number-of-segments-in-a-string/) 字符串
  - ?[🌟【meidum】1014. 最佳观光组合](https://leetcode.cn/problems/best-sightseeing-pair/) 数组题、规律、脑筋急转弯、贪心
  - ?[🌟【meidum】397. 整数替换](https://leetcode.cn/problems/integer-replacement/) 递归、规律、模拟
- 20221015(15)
  - [【medium】1441. 用栈操作构建数组](https://leetcode.cn/problems/build-an-array-with-stack-operations/) 模拟、栈
  - [【easy】1365. 有多少小于当前数字的数字](https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/) 哈希表、桶排序
  - [【easy】520. 检测大写字母](https://leetcode.cn/problems/detect-capital/) 字符串
  - [【easy】1342. 将数字变成 0 的操作次数](https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/) 数字
  - ?[🌟【easy】572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/) 二叉树
  - ?[🌟【easy】495. 提莫攻击](https://leetcode.cn/problems/teemo-attacking/) 数组、区间问题
  - [🌟【easy】566. 重塑矩阵](https://leetcode.cn/problems/reshape-the-matrix/) 矩阵
  - [🌟【easy】674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/) 数组、序列、递增序列
  - [🌟【easy】860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/) 贪心
  - [🌟【easy】1431. 拥有最多糖果的孩子](https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/) 模拟
  - [🌟【medium】1706. 球会落何处](https://leetcode.cn/problems/where-will-the-ball-fall/) 模拟
  - [🌟【medium】845. 数组中的最长山脉](https://leetcode.cn/problems/longest-mountain-in-array/) 模拟、数组题#
  - ???[🌟【hard】940. 不同的子序列 II](https://leetcode.cn/problems/distinct-subsequences-ii/) 子序列、动态规划
  - ???[🌟【hard】剑指 Offer II 094. 最少回文分割](https://leetcode.cn/problems/omKAoA/) 动态规划、回文串
  - ?[🌟【hard】剑指 Offer II 117. 相似的字符串](https://leetcode.cn/problems/H6lPxb/) 图、广度优先搜索
- 20221014(22)
  - [【easy】203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/) 链表
  - [【easy】876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/) 链表、快慢指针、双指针
  - [【easy】392. 判断子序列](https://leetcode.cn/problems/is-subsequence/) 字符串、子序列、双指针
  - [【easy】1480. 一维数组的动态和](https://leetcode.cn/problems/running-sum-of-1d-array/) 数组题、累加
  - [🌟【easy】409. 最长回文串](https://leetcode.cn/problems/longest-palindrome/) 字符串、回文串
  - [🌟【easy】404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/) 二叉树
  - [🌟【easy】257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/) 二叉树
  - [🌟【easy】219. 存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/) 数组题
  - [🌟【easy】844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/) 字符串、双指针、栈
  - [🌟【easy】290. 单词规律](https://leetcode.cn/problems/word-pattern/) 哈希表
  - [🌟【easy】414. 第三大的数](https://leetcode.cn/problems/third-maximum-number/) 数组题
  - [🌟【easy】389. 找不同](https://leetcode.cn/problems/find-the-difference/) 字符串题、哈希表
  - [【easy】1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/) 栈
  - [🌟【easy】905. 按奇偶排序数组](https://leetcode.cn/problems/sort-array-by-parity/) 排序、数组题
  - [【easy】771. 宝石与石头](https://leetcode.cn/problems/jewels-and-stones/) 字符串、哈希表
  - [🌟【easy】205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/) 字符串、哈希表
  - [🌟【easy】1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/) 贪心
  - [🌟【easy】345. 反转字符串中的元音字母](https://leetcode.cn/problems/reverse-vowels-of-a-string/) 字符串、双指针
  - [🌟【easy】1221. 分割平衡字符串](https://leetcode.cn/problems/split-a-string-in-balanced-strings/) 字符串
  - [🌟【easy】1137. 第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/) 模拟
  - [🌟【easy】258. 各位相加](https://leetcode.cn/problems/add-digits/) 模拟、数学问题、数论
  - [🌟【easy】541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/) 字符串、模拟
- 20221013(6)
  - [🌟【medium】1305. 两棵二叉搜索树中的所有元素](https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/) 二叉搜索树
  - ???[🌟【medium】1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/) 动态规划、01背包、背包问题
  - [🌟【easy】110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/) 二叉树、平衡二叉树
  - [🌟【easy】144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/) 二叉树、前序遍历、先序遍历
  - [🌟【easy】145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/) 二叉树、后序遍历
  - ??[🌟【easy】168. Excel表列名称](https://leetcode.cn/problems/excel-sheet-column-title/) 模拟题
- 20221012(8)
  - [🌟【medium】817. 链表组件](https://leetcode.cn/problems/linked-list-components/) 链表
  - ?[🌟【medium】1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/) 矩阵、广度优先搜索
  - [🌟【medium】807. 保持城市天际线](https://leetcode.cn/problems/max-increase-to-keep-city-skyline/) 矩阵、模拟
  - ?? [🌟【medium】1190. 反转每对括号间的子串](https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/) 栈、括号问题
  - ?? [🌟【medium】863. 二叉树中所有距离为 K 的结点](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/) 二叉树、图、广度优先搜索、深度优先搜索
  - [🌟【medium】433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/) 广度优先搜索、BFS、DFS
  - ?[🌟【medium】468. 验证IP地址](https://leetcode.cn/problems/validate-ip-address/) 字符串题
  - ?[🌟【medium】532. 数组中的 k-diff 数对](https://leetcode.cn/problems/k-diff-pairs-in-an-array/) 哈希表
- 20221011(6)
  - [🌟【easy】1790. 仅执行一次字符串交换能否使两个字符串相等](https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/) 数组题、模拟
  - ?[🌟【medium】986. 区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/) 区间问题、区间交集
  - ?? [🌟【medium】673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/) 动态规划、递增子序列
  - ? [🌟【medium】945. 使数组唯一的最小增量](https://leetcode.cn/problems/minimum-increment-to-make-array-unique/) 排序、数组题
  - ?? [🌟【medium】792. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/) 二分搜索、哈希表
  - ??? [🌟【hard】115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/) 动态规划
- 20221010(8)
  - ??[🌟【medium】678. 有效的括号字符串](https://leetcode.cn/problems/valid-parenthesis-string/) 栈
  - ??[🌟【medium】470. 用 Rand7() 实现 Rand10()](https://leetcode.cn/problems/implement-rand10-using-rand7/) 概率、随机数
  - ??[🌟【medium】222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/) 二叉树、二分搜索
  - ??[🌟【medium】881. 救生艇](https://leetcode.cn/problems/boats-to-save-people/) 贪心
  - ??[🌟【medium】593. 有效的正方形](https://leetcode.cn/problems/valid-square/) 模拟、哈希表
  - ??[🌟【medium】1024. 视频拼接](https://leetcode.cn/problems/video-stitching/) 贪心、数组、排序
  - ??[🌟【medium】611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/) 二分搜索、排序
  - ???[🌟【hard】801. 使序列递增的最小交换次数](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/) 动态规划
- 20221009(13)
  - [🌟【medium】856. 括号的分数](https://leetcode.cn/problems/score-of-parentheses/) 递归、栈
  - [🌟【easy】面试题 16.05. 阶乘尾数](https://leetcode.cn/problems/factorial-zeros-lcci/) 模拟
  - [🌟【easy】面试题 16.11. 跳水板](https://leetcode.cn/problems/diving-board-lcci/) 模拟
  - [🌟【easy】面试题 16.15. 珠玑妙算](https://leetcode.cn/problems/master-mind-lcci/) 模拟
  - [🌟【easy】面试题 16.17. 连续数列](https://leetcode.cn/problems/contiguous-sequence-lcci/) 动态规划、数组题
  - [🌟【easy】面试题 17.01. 不用加号的加法](https://leetcode.cn/problems/add-without-plus-lcci/) 二进制、位运算
  - [🌟【easy】面试题 17.04. 消失的数字](https://leetcode.cn/problems/missing-number-lcci/) 数组原地操作
  - ?[🌟【easy】面试题 17.10. 主要元素](https://leetcode.cn/problems/find-majority-element-lcci/) 摩尔排序
  - [🌟【easy】面试题 17.12. BiNode](https://leetcode.cn/problems/binode-lcci/) 二叉搜索树
  - [🌟【easy】面试题 17.16. 按摩师](https://leetcode.cn/problems/the-masseuse-lcci/) 动态规划
  - [🌟【hard】剑指 Offer II 108. 单词演变](https://leetcode.cn/problems/om3reC/) 图、广度优先搜索
  - ? [🌟【hard】剑指 Offer II 112. 最长递增路径](https://leetcode.cn/problems/fpTFWP/) 图、广度优先搜索、深度优先搜索、记忆化搜索
  - ?? [🌟【hard】剑指 Offer II 114. 外星文字典](https://leetcode.cn/problems/Jf1JuT/) 图、拓扑排序、广度优先搜索
- 20221008(16)
  - [🌟【medium】870. 优势洗牌](https://leetcode.cn/problems/advantage-shuffle/) 数组题、排序
  - [🌟【easy】面试题 03.02. 栈的最小值](https://leetcode.cn/problems/min-stack-lcci/) 设计题、栈
  - [🌟【easy】面试题 03.04. 化栈为队](https://leetcode.cn/problems/implement-queue-using-stacks-lcci/) 设计题、栈
  - [🌟【easy】面试题 03.06. 动物收容所](https://leetcode.cn/problems/animal-shelter-lcci/) 设计题、队列
  - [🌟【easy】面试题 04.02. 最小高度树](https://leetcode.cn/problems/minimum-height-tree-lcci/) 二叉树、二叉搜索树
  - [🌟【easy】面试题 04.04. 检查平衡性](https://leetcode.cn/problems/check-balance-lcci/) 二叉树
  - ?[🌟【easy】面试题 05.01. 插入](https://leetcode.cn/problems/insert-into-bits-lcci/) 二进制、位运算
  - ??[🌟【easy】面试题 05.03. 翻转数位](https://leetcode.cn/problems/reverse-bits-lcci/) 二进制、位运算
  - ?[🌟【easy】面试题 05.06. 整数转换](https://leetcode.cn/problems/convert-integer-lcci/) 二进制、位运算
  - ?[🌟【easy】面试题 05.07. 配对交换](https://leetcode.cn/problems/exchange-lcci/) 二进制、位运算
  - [🌟【easy】面试题 08.01. 三步问题](https://leetcode.cn/problems/three-steps-problem-lcci/) 动态规划
  - [🌟【easy】面试题 08.03. 魔术索引](https://leetcode.cn/problems/magic-index-lcci/) 数组题
  - ??[🌟【easy】面试题 08.06. 汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/) 栈、递归
  - [🌟【easy】面试题 08.10. 颜色填充](https://leetcode.cn/problems/color-fill-lcci/) 矩阵
  - [🌟【easy】面试题 10.01. 合并排序的数组](https://leetcode.cn/problems/sorted-merge-lcci/) 归并排除、原地排序
  - ?[🌟【easy】面试题 10.05. 稀疏数组搜索](https://leetcode.cn/problems/sparse-array-search-lcci/) 二分搜索、稀疏数组
- 20221007(16)
  - [🌟【easy】1800. 最大升序子数组和](https://leetcode.cn/problems/maximum-ascending-subarray-sum/) 数组题
  - ?[🌟【medium】面试题 17.17. 多次搜索](https://leetcode.cn/problems/multi-search-lcci/) 字典树
  - [🌟【medium】面试题 17.18. 最短超串](https://leetcode.cn/problems/shortest-supersequence-lcci/) 滑动窗口
  - ?[🌟【medium】面试题 17.22. 单词转换](https://leetcode.cn/problems/word-transformer-lcci/) 图、深度优先搜索
  - ?[🌟【medium】面试题 17.23. 最大黑方阵](https://leetcode.cn/problems/max-black-square-lcci/) 矩阵
  - [🌟【easy】面试题 01.03. URL化](https://leetcode.cn/problems/string-to-url-lcci/) 字符串
  - [🌟【easy】面试题 01.04. 回文排列](https://leetcode.cn/problems/palindrome-permutation-lcci/) 哈希表
  - [🌟【easy】面试题 01.06. 字符串压缩](https://leetcode.cn/problems/compress-string-lcci/) 字符串
  - [🌟【easy】面试题 02.01. 移除重复节点](https://leetcode.cn/problems/remove-duplicate-node-lcci/) 链表
  - [🌟【easy】面试题 02.02. 返回倒数第 k 个节点](https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/) 链表
  - [🌟【easy】面试题 02.03. 删除中间节点](https://leetcode.cn/problems/delete-middle-node-lcci/) 链表
  - [🌟【easy】面试题 02.06. 回文链表](https://leetcode.cn/problems/palindrome-linked-list-lcci/) 链表、反转链表
  - ? [🌟【easy】面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/) 链表、相交链表
  - [🌟【easy】面试题 03.01. 三合一](https://leetcode.cn/problems/three-in-one-lcci/) 设计题
  - [🌟【hard】剑指 Offer II 051. 节点之和最大的路径](https://leetcode.cn/problems/jC7MId/) 二叉树
  - [🌟【hard】剑指 Offer II 078. 合并排序链表](https://leetcode.cn/problems/vvXgSW/) 归并排序、链表
- 20221006(11)
  - [🌟【medium】面试题 16.21. 交换和](https://leetcode.cn/problems/sum-swap-lcci/) 模拟
  - [🌟【medium】面试题 16.24. 数对和](https://leetcode.cn/problems/pairs-with-sum-lcci/) 哈希表、数组
  - ?[🌟【medium】面试题 16.25. LRU 缓存](https://leetcode.cn/problems/lru-cache-lcci/) LRU、设计题
  - ?[🌟【medium】面试题 16.26. 计算器](https://leetcode.cn/problems/calculator-lcci/) 模拟、计算器
  - ?[🌟【medium】面试题 17.05.  字母与数字](https://leetcode.cn/problems/find-longest-subarray-lcci/) 前缀和
  - ?[🌟【medium】面试题 17.07. 婴儿名字](https://leetcode.cn/problems/baby-names-lcci/) 图、广度优先搜索
  - ?[🌟【medium】面试题 17.08. 马戏团人塔](https://leetcode.cn/problems/circus-tower-lcci/) 二分搜索、俄罗斯套娃问题
  - ?[🌟【medium】面试题 17.11. 单词距离](https://leetcode.cn/problems/find-closest-lcci/) 模拟
  - ??[🌟【medium】面试题 17.13. 恢复空格](https://leetcode.cn/problems/re-space-lcci/) 动态规划、背包问题、完全背包
  - ??[🌟【medium】面试题 17.15. 最长单词](https://leetcode.cn/problems/longest-word-lcci/) 递归、哈希表、数组
  - ???[🌟【hard】927. 三等分](https://leetcode.cn/problems/three-equal-parts/) 模拟
- 20221005(11)
  - [🌟【medium】811. 子域名访问计数](https://leetcode.cn/problems/subdomain-visit-count/) 哈希表
  - [🌟【medium】面试题 16.04. 井字游戏](https://leetcode.cn/problems/tic-tac-toe-lcci/) 模拟
  - [🌟【medium】面试题 16.06. 最小差](https://leetcode.cn/problems/smallest-difference-lcci/) 二分搜索
  - ?[🌟【medium】面试题 16.10. 生存人数](https://leetcode.cn/problems/living-people-lcci/) 差分
  - ?[🌟【medium】面试题 16.13. 平分正方形](https://leetcode.cn/problems/bisect-squares-lcci/) 模拟
  - ?[🌟【medium】面试题 16.14. 最佳直线](https://leetcode.cn/problems/best-line-lcci/) 模拟、暴力查找
  - ??[🌟【medium】面试题 16.16. 部分排序](https://leetcode.cn/problems/sub-sort-lcci/) 单调栈
  - [🌟【medium】面试题 16.19. 水域大小](https://leetcode.cn/problems/pond-sizes-lcci/) DFS、深度优先搜索
  - [🌟【medium】面试题 16.20. T9键盘](https://leetcode.cn/problems/t9-lcci/) 哈希表
  - ? [🌟【hard】剑指 Offer II 040. 矩阵中最大的矩形](https://leetcode.cn/problems/PLYXKQ/) 单调栈
  - ?? [🌟【hard】剑指 Offer II 048. 序列化与反序列化二叉树](https://leetcode.cn/problems/h54YBf/) 二叉树、二叉树序列化
- 20221004(12)
  - [🌟【medium】921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/) 栈
  - [🌟【medium】面试题 08.09. 括号](https://leetcode.cn/problems/bracket-lcci/) 回溯法、深度优先搜索
  - [🌟【medium】面试题 08.11. 硬币](https://leetcode.cn/problems/coin-lcci/) 动态规划、背包问题、完全背包
  - ?[🌟【medium】面试题 08.14. 布尔运算](https://leetcode.cn/problems/boolean-evaluation-lcci/) 枚举、模拟、DFS、递归
  - [🌟【medium】面试题 10.02. 变位词组](https://leetcode.cn/problems/group-anagrams-lcci/) 哈希表
  - ??[🌟【medium】面试题 10.03. 搜索旋转数组](https://leetcode.cn/problems/search-rotate-array-lcci/) 二分搜索
  - [🌟【medium】面试题 10.09. 排序矩阵查找](https://leetcode.cn/problems/sorted-matrix-search-lcci/) 矩阵搜索
  - [🌟【medium】面试题 10.10. 数字流的秩](https://leetcode.cn/problems/rank-from-stream-lcci/) 二分搜索
  - [🌟【medium】面试题 10.11. 峰与谷](https://leetcode.cn/problems/peaks-and-valleys-lcci/) 模拟
  - ? [🌟【medium】面试题 16.01. 交换数字](https://leetcode.cn/problems/swap-numbers-lcci/) 二进制、位运算
  - [🌟【medium】面试题 16.02. 单词频率](https://leetcode.cn/problems/words-frequency-lcci/) 字典树、哈希表
  - ??[🌟【hard】剑指 Offer II 039. 直方图最大矩形面积](https://leetcode.cn/problems/0ynMMM/) 单调栈
- 20221003(11)
  - [🌟【medium】面试题 04.06. 后继者](https://leetcode.cn/problems/successor-lcci/) 中继后续
  - [🌟【medium】面试题 04.08. 首个共同祖先](https://leetcode.cn/problems/first-common-ancestor-lcci/) 二叉树
  - [🌟【easy】1784. 检查二进制字符串字段](https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/) 简单模拟
  - [🌟【medium】面试题 04.10. 检查子树](https://leetcode.cn/problems/check-subtree-lcci/) 二叉树
  - [🌟【medium】面试题 04.12. 求和路径](https://leetcode.cn/problems/paths-with-sum-lcci/?favorite=xb9lfcwi) 二叉树、前缀和
  - [🌟【medium】面试题 05.02. 二进制数转字符串](https://leetcode.cn/problems/bianry-number-to-string-lcci/?favorite=xb9lfcwi) 二进制
  - [🌟【medium】面试题 08.02. 迷路的机器人](https://leetcode.cn/problems/robot-in-a-grid-lcci/) 深度优先搜索
  - [🌟【medium】面试题 08.04. 幂集](https://leetcode.cn/problems/power-set-lcci/) 深度优先搜索、回溯法、子集
  - [🌟【medium】面试题 08.05. 递归乘法](https://leetcode.cn/problems/recursive-mulitply-lcci/) 模拟运算
  - [🌟【medium】面试题 08.07. 无重复字符串的排列组合](https://leetcode.cn/problems/permutation-i-lcci/) 回溯法、排列
  - [🌟【medium】面试题 08.08. 有重复字符串的排列组合](https://leetcode.cn/problems/permutation-ii-lcci/) 回溯法、排列
- 20221002(8)
  - ?? [🌟【medium】777. 在LR字符串中交换相邻字符](https://leetcode.cn/problems/swap-adjacent-in-lr-string/) 双指针
  - [🌟【medium】面试题 02.04. 分割链表](https://leetcode.cn/problems/partition-list-lcci/) 链表
  - [🌟【medium】面试题 02.08. 环路检测](https://leetcode.cn/problems/linked-list-cycle-lcci/) 链表、环形链表
  - ? [🌟【medium】面试题 03.03. 堆盘子](https://leetcode.cn/problems/stack-of-plates-lcci/) 栈
  - ? [🌟【medium】面试题 03.05. 栈排序](https://leetcode.cn/problems/sort-of-stacks-lcci/) 栈
  - [🌟【medium】面试题 04.01. 节点间通路](https://leetcode.cn/problems/route-between-nodes-lcci/) 广度优先搜索
  - [🌟【medium】面试题 04.03. 特定深度节点链表](https://leetcode.cn/problems/list-of-depth-lcci/) 广度优先搜索
  - [🌟【medium】面试题 04.05. 合法二叉搜索树](https://leetcode.cn/problems/legal-binary-search-tree-lcci/) 二叉搜索树
- 20221001(12)
  - [🌟【easy】剑指 Offer II 041. 滑动窗口的平均值](https://leetcode.cn/problems/qIsx9U/) 滑动窗口
  - [🌟【easy】剑指 Offer II 042. 最近请求次数](https://leetcode.cn/problems/H8086Q/) 双端队列、二分搜索
  - [🌟【easy】剑指 Offer II 052. 展平二叉搜索树](https://leetcode.cn/problems/NYBBNL/) 二叉搜索树、中序遍历
  - [🌟【easy】剑指 Offer II 056. 二叉搜索树中两个节点之和](https://leetcode.cn/problems/opLdQZ/) 二叉搜索树、中序遍历
  - [🌟【easy】剑指 Offer II 059. 数据流的第 K 大数值](https://leetcode.cn/problems/jBjn9C/) 优先队列
  - [🌟【easy】剑指 Offer II 068. 查找插入位置](https://leetcode.cn/problems/N6YdxV/) 二分搜索
  - [🌟【easy】剑指 Offer II 069. 山峰数组的顶部](https://leetcode.cn/problems/B1IidL/) 二分搜索
  - [🌟【easy】剑指 Offer II 072. 求平方根](https://leetcode.cn/problems/jJ0w9p/) 二分搜索
  - ? [🌟【easy】剑指 Offer II 075. 数组相对排序](https://leetcode.cn/problems/0H97ZC/) 排序
  - [🌟【easy】剑指 Offer II 088. 爬楼梯的最少成本](https://leetcode.cn/problems/GzCJIP/) 动态规划
  - ? [🌟【easy】剑指 Offer II 101. 分割等和子集](https://leetcode.cn/problems/NUPfPr/) 动态规划、01背包、背包问题
  - ?? [🌟【hard】剑指 Offer II 017. 含有所有字符的最短字符串](https://leetcode.cn/problems/M1oyTv/) 滑动窗口
- 20220930(10)
  - [🌟【easy】剑指 Offer II 006. 排序数组中两个数字之和](https://leetcode.cn/problems/kLl5u1/) 哈希表、双指针
  - [🌟【easy】剑指 Offer II 012. 左右两边子数组的和相等](https://leetcode.cn/problems/tvdfij/) 常规数组题
  - [🌟【easy】剑指 Offer II 018. 有效的回文](https://leetcode.cn/problems/XltzEq/) 回文串
  - [🌟【easy】剑指 Offer II 019. 最多删除一个字符得到回文](https://leetcode.cn/problems/RQku0D/) 双指针
  - [🌟【easy】剑指 Offer II 023. 两个链表的第一个重合节点](https://leetcode.cn/problems/3u1WK4/) 链表
  - [🌟【easy】剑指 Offer II 024. 反转链表](https://leetcode.cn/problems/UHnkqh/) 链表
  - ? [🌟【easy】剑指 Offer II 027. 回文链表](https://leetcode.cn/problems/aMhZSa/) 链表、回文链表
  - [🌟【easy】剑指 Offer II 032. 有效的变位词](https://leetcode.cn/problems/dKk3P7/) 哈希表
  - ? [🌟【easy】剑指 Offer II 034. 外星语言是否排序](https://leetcode.cn/problems/lwyVBB/) 哈希表
  - [🌟【easy】1694. 重新格式化电话号码](https://leetcode.cn/problems/reformat-phone-number/) 模拟
- 20220929(10)
  - [🌟【easy】面试题 01.09. 字符串轮转](https://leetcode.cn/problems/string-rotation-lcci/) 字符串题、字符串旋转
  - [🌟【meidum】剑指 Offer II 111. 计算除法](https://leetcode.cn/problems/vlzXQL/) Floyd 算法
  - ?[🌟【meidum】剑指 Offer II 113. 课程顺序](https://leetcode.cn/problems/QA2IGt/) 拓扑排序、广度优先搜索
  - ?[🌟【meidum】剑指 Offer II 115. 重建序列](https://leetcode.cn/problems/ur2n8P/) 拓扑排序、广度优先搜索
  - ?[🌟【meidum】剑指 Offer II 116. 省份数量](https://leetcode.cn/problems/bLyHh0/) 图、深度优先搜索
  - ?[🌟【meidum】剑指 Offer II 118. 多余的边](https://leetcode.cn/problems/7LpjUW/) 并查集
  - ?[🌟【meidum】剑指 Offer II 119. 最长连续序列](https://leetcode.cn/problems/WhsWhI/) 哈希表
  - [🌟【meidum】面试题 01.08. 零矩阵](https://leetcode.cn/problems/zero-matrix-lcci/) 哈希表、矩阵
  - [🌟【easy】剑指 Offer II 002. 二进制加法](https://leetcode.cn/problems/JFETK5/) 字符串运算
  - [🌟【easy】剑指 Offer II 003. 前 n 个数字二进制中 1 的个数](https://leetcode.cn/problems/w3tCBm/) 二进制
- 20220928(11)
  - [🌟【medium】面试题 17.09. 第 k 个数](https://leetcode.cn/problems/get-kth-magic-number-lcci/) 动态规划
  - [🌟【medium】剑指 Offer II 100. 三角形中最小路径之和](https://leetcode.cn/problems/IlPe0q/) 动态规划
  - ?? [🌟【medium】剑指 Offer II 102. 加减的目标值](https://leetcode.cn/problems/YaVDxD/) 动态规划、回溯法、01背包、背包问题
  - ?? [🌟【medium】剑指 Offer II 103. 最少的硬币数目](https://leetcode.cn/problems/gaM7Ch/) 动态规划、背包问题、无序背包
  - ?? [🌟【medium】剑指 Offer II 104. 排列的数目](https://leetcode.cn/problems/D0F0SV/) 动态规划、背包问题、有序背包
  - [🌟【medium】剑指 Offer II 105. 岛屿的最大面积](https://leetcode.cn/problems/ZL6zAn/) 矩阵、深度优先搜索、广度优先搜索
  - ? [🌟【medium】剑指 Offer II 106. 二分图](https://leetcode.cn/problems/vEAB3K/) 图、深度优先搜索、广度优先搜索
  - [🌟【medium】剑指 Offer II 107. 矩阵中的距离](https://leetcode.cn/problems/2bCMpM/) 广度优先搜索、多源广度优先
  - [🌟【medium】剑指 Offer II 109. 开密码锁](https://leetcode.cn/problems/zlDJc7/) 广度优先搜索
  - [🌟【medium】剑指 Offer II 110. 所有路径](https://leetcode.cn/problems/bP4bmD/) 回溯法
  - [🌟【medium】11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) 贪心、双指针
- 20220927(10)
  - [🌟【easy】面试题 01.02. 判定是否互为字符重排](https://leetcode.cn/problems/check-permutation-lcci/) 哈希表
  - [🌟【medium】剑指 Offer II 089. 房屋偷盗](https://leetcode.cn/problems/Gu0c2T/) 动态规划
  - [🌟【medium】剑指 Offer II 090. 环形房屋偷盗](https://leetcode.cn/problems/PzWKhm/) 动态规划
  - [🌟【medium】剑指 Offer II 091. 粉刷房子](https://leetcode.cn/problems/JEj789/) 动态规划
  - [🌟【medium】剑指 Offer II 092. 翻转字符](https://leetcode.cn/problems/cyJERH/) 动态规划
  - ?? [🌟【medium】剑指 Offer II 093. 最长斐波那契数列](https://leetcode.cn/problems/Q91FMA/) 动态规划
  - ? [🌟【medium】剑指 Offer II 095. 最长公共子序列](https://leetcode.cn/problems/qJnOS7/) 动态规划
  - [🌟【medium】剑指 Offer II 098. 路径的数目](https://leetcode.cn/problems/2AoeFn/) 动态规划
  - [🌟【medium】剑指 Offer II 096. 字符串交织](https://leetcode.cn/problems/IY6buf/) 动态规划
  - [🌟【medium】剑指 Offer II 099. 最小路径之和](https://leetcode.cn/problems/0i0mDW/) 动态规划
- 20220926(11)
  - ? [🌟【medium】剑指 Offer II 077. 链表排序](https://leetcode.cn/problems/7WHec2/) 归并排序、分治法
  - [🌟【medium】剑指 Offer II 079. 所有子集](https://leetcode.cn/problems/TVdhkn/) 回溯法
  - [🌟【medium】剑指 Offer II 080. 含有 k 个元素的组合](https://leetcode.cn/problems/uUsW3B/) 回溯法
  - [🌟【medium】剑指 Offer II 081. 允许重复选择元素的组合](https://leetcode.cn/problems/Ygoe9J/) 回溯法
  - [🌟【medium】剑指 Offer II 082. 含有重复元素集合的组合](https://leetcode.cn/problems/4sjJUc/) 回溯法
  - [🌟【medium】剑指 Offer II 083. 没有重复元素集合的全排列](https://leetcode.cn/problems/VvJkup/) 回溯法
  - [🌟【medium】剑指 Offer II 084. 含有重复元素集合的全排列](https://leetcode.cn/problems/7p8L0Z/) 回溯法
  - ? [🌟【medium】剑指 Offer II 085. 生成匹配的括号](https://leetcode.cn/problems/IDBivT/) 回溯法
  - ? [🌟【medium】剑指 Offer II 086. 分割回文子字符串](https://leetcode.cn/problems/M99OJA/) 回溯法、动态规划、回文串
  - [🌟【hard】面试题 17.19. 消失的两个数字](https://leetcode.cn/problems/missing-two-lcci/) 模拟题
  - ? [🌟【medium】剑指 Offer II 087. 复原 IP ](https://leetcode.cn/problems/0on3uN/) 回溯法
- 20220925(6)
  - ? [🌟【medium】788. 旋转数字](https://leetcode.cn/problems/rotated-digits/) 模拟
  - ??? [🌟【medium】剑指 Offer II 067. 最大的异或](https://leetcode.cn/problems/ms70jA/) 字典树、贪心
  - ? [🌟【medium】剑指 Offer II 071. 按权重生成随机数](https://leetcode.cn/problems/cuyjEf/) 二分搜索
  - ? [🌟【medium】剑指 Offer II 073. 狒狒吃香蕉](https://leetcode.cn/problems/nZZqjQ/) 二分搜索
  - [🌟【medium】剑指 Offer II 074. 合并区间](https://leetcode.cn/problems/SsGoHC/) 区间合并问题
  - [🌟【medium】剑指 Offer II 076. 数组中的第 k 大的数字](https://leetcode.cn/problems/xx4gT2/?favorite=e8X3pBZi) 快速选择
- 20220924(9)
  - ? [🌟【medium】剑指 Offer II 058. 日程表](https://leetcode.cn/problems/fi9suh/?favorite=e8X3pBZi) 二分搜索
  - [🌟【medium】剑指 Offer II 060. 出现频率最高的 k 个数字](https://leetcode.cn/problems/g5c51o/) 快速选择
  - ?? [🌟【medium】剑指 Offer II 061. 和最小的 k 个数对](https://leetcode.cn/problems/qn8gGX/) 优先队列
  - [🌟【medium】剑指 Offer II 062. 实现前缀树](https://leetcode.cn/problems/QC3q1f/) 字典树
  - [🌟【medium】剑指 Offer II 063. 替换单词](https://leetcode.cn/problems/UhWRSj/) 字典树
  - [🌟【medium】剑指 Offer II 064. 神奇的字典](https://leetcode.cn/problems/US1pGT/) 字典树
  - [🌟【medium】剑指 Offer II 065. 最短的单词编码](https://leetcode.cn/problems/iSwD2y/) 字典树
  - [🌟【medium】剑指 Offer II 066. 单词之和](https://leetcode.cn/problems/z1R5dt/) 字典树、前缀树
  - [🌟【medium】剑指 Offer II 070. 排序数组中只出现一次的数字](https://leetcode.cn/problems/skFtm2/) 二分搜索
- 20220923(10)
  - [🌟【medium】707. 设计链表](https://leetcode.cn/problems/design-linked-list/) 设计题、链表
  - [🌟【medium】剑指 Offer II 046. 二叉树的右侧视图](https://leetcode.cn/problems/WNC0Lk/) 二叉树、深度优先搜索、广度优先搜素
  - [🌟【medium】剑指 Offer II 047. 二叉树剪枝](https://leetcode.cn/problems/pOCWxh/) 二叉树、深度优先搜索、广度优先搜素
  - [🌟【medium】剑指 Offer II 049. 从根节点到叶节点的路径数字之和](https://leetcode.cn/problems/3Etpl5/) 二叉树、深度优先搜索、广度优先搜素
  - [🌟【medium】剑指 Offer II 050. 向下的路径节点之和](https://leetcode.cn/problems/6eUYwP/) 二叉树、深度优先搜索、前缀和
  - [🌟【medium】剑指 Offer II 053. 二叉搜索树中的中序后继](https://leetcode.cn/problems/P5rCT8/) 二叉搜索树、中序遍历
  - ? [🌟【medium】剑指 Offer II 054. 所有大于等于节点的值之和](https://leetcode.cn/problems/w6cpku/) 二叉搜索树、反向中序遍历
  - ? [🌟【medium】剑指 Offer II 055. 二叉搜索树迭代器](https://leetcode.cn/problems/kTOapQ/) 二叉树、迭代器
  - [🌟【easy】1652. 拆炸弹](https://leetcode.cn/problems/defuse-the-bomb/) 数组题
  - ??? [🌟【medium】剑指 Offer II 057. 值和下标之差都在给定的范围内](https://leetcode.cn/problems/7WqeDu/) 桶排序、滑动窗口
- 20220922(10)
  - [🌟【easy】1640. 能否连接形成数组](https://leetcode.cn/problems/check-array-formation-through-concatenation/) 哈希表
  - ? [🌟【hard】460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/) 设计题、LFU
  - [🌟【medium】剑指 Offer II 033. 变位词组](https://leetcode.cn/problems/sfvd7V/) 排序、哈希表
  - [🌟【medium】剑指 Offer II 035. 最小时间差](https://leetcode.cn/problems/569nqc/) 排序
  - [🌟【medium】剑指 Offer II 036. 后缀表达式](https://leetcode.cn/problems/8Zf90G/) 逆波兰、栈
  - [🌟【medium】剑指 Offer II 037. 小行星碰撞](https://leetcode.cn/problems/XagZNi/) 栈
  - [🌟【medium】剑指 Offer II 038. 每日温度](https://leetcode.cn/problems/iIQa4I/) 单调栈
  - ?? [🌟【medium】剑指 Offer II 043. 往完全二叉树添加节点](https://leetcode.cn/problems/NaqhDT/) 队列
  - [🌟【medium】剑指 Offer II 044. 二叉树每层的最大值](https://leetcode.cn/problems/hPov7L/) 二叉树、广度优先搜索
  - [🌟【medium】剑指 Offer II 045. 二叉树最底层最左边的值](https://leetcode.cn/problems/LwUNpT/) 二叉树、广度优先搜索
- 20220921(5)
  - ??? [🌟【hard】854. 相似度为 K 的字符串](https://leetcode.cn/problems/k-similar-strings/) 深度优先搜素、广度优先搜索
  - [🌟【medium】752. 打开转盘锁](https://leetcode.cn/problems/open-the-lock/) 广度优先搜索
  - [🌟【medium】剑指 Offer II 029. 排序的循环链表](https://leetcode.cn/problems/4ueAj6/) 环形链表、链表
  - [🌟【medium】剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器](https://leetcode.cn/problems/FortPu/) 设计题、哈希表
  - [🌟【medium】剑指 Offer II 031. 最近最少使用缓存](https://leetcode.cn/problems/OrIXps/) 设计题、LRU
- 20220920(3)
  - ?? [🌟【medium】698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/) 回溯法
  - [🌟【medium】剑指 Offer II 028. 展平多级双向链表](https://leetcode.cn/problems/Qv1Da2/) 深度优先搜索
  - [🌟【medium】剑指 Offer II 026. 重排链表](https://leetcode.cn/problems/LGjMqU/) 链表
- 20220919(8)
  - [🌟【easy】1636. 按照频率将数组升序排序](https://leetcode.cn/problems/sort-array-by-increasing-frequency/) 排序
  - [🌟【medium】剑指 Offer II 014. 字符串中的变位词](https://leetcode.cn/problems/MPnaiL/) 滑动窗口
  - ? [🌟【medium】剑指 Offer II 015. 字符串中的所有变位词](https://leetcode.cn/problems/VabMRr/) 滑动窗口
  - [🌟【medium】剑指 Offer II 016. 不含重复字符的最长子字符串](https://leetcode.cn/problems/wtcaE1/) 滑动窗口
  - [🌟【medium】剑指 Offer II 020. 回文子字符串的个数](https://leetcode.cn/problems/a7VOhD/?favorite=e8X3pBZi) 回文串、动态规划
  - [🌟【medium】剑指 Offer II 021. 删除链表的倒数第 n 个结点回文子字符串的个数](https://leetcode.cn/problems/SLwz0R/) 链表
  - ? [🌟【medium】剑指 Offer II 022. 链表中环的入口节点](https://leetcode.cn/problems/c32eOV/) 链表、环形链表
  - [🌟【medium】剑指 Offer II 025. 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/) 链表
- 20220918(8)
  - [🌟【medium】剑指 Offer II 008. 和大于等于 target 的最短子数组](https://leetcode.cn/problems/2VG8Kg/) 双指针、滑动窗口
  - [🌟【medium】剑指 Offer II 009. 乘积小于 K 的子数组](https://leetcode.cn/problems/ZVAVXX/) 双指针、滑动窗口
  - [🌟【medium】剑指 Offer II 010. 和为 k 的子数组](https://leetcode.cn/problems/QTMn0o/) 前缀和
  - ??? [🌟【hard】827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/) 矩阵、深度优先搜索
  - ? [🌟【hard】41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/) 数组题、数组原地操作
  - ? [🌟【medium】剑指 Offer II 011. 0 和 1 个数相同的子数组](https://leetcode.cn/problems/A1NYOS/) 前缀和
  - [🌟【medium】剑指 Offer II 013. 二维子矩阵的和](https://leetcode.cn/problems/O4NDxx/) 前缀和
  - ?? [🌟【medium】剑指 Offer II 014. 字符串中的变位词](https://leetcode.cn/problems/MPnaiL/) 滑动窗口、哈希表
- 20220917(7)
  - [🌟【medium】146. LRU 缓存](https://leetcode.cn/problems/lru-cache/) 数据结构实现
  - ??? [🌟【hard】460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/) 数据结构实现
  - [🌟【medium】150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/) 逆波兰式
  - ?? [🌟【medium】227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/) 模拟
  - ? [🌟【medium】剑指 Offer II 004. 只出现一次的数字](https://leetcode.cn/problems/WGki4K/) 位运算
  - ? [🌟【medium】剑指 Offer II 005. 单词长度的最大乘积](https://leetcode.cn/problems/aseY1I/) 位运算
  - ?? [🌟【medium】剑指 Offer II 007. 数组中和为 0 的三个数](https://leetcode.cn/problems/1fGaJU/) 排序、双指针
- 20220916(8)
  - ??? [🌟【hard】850. 矩形面积 II](https://leetcode.cn/problems/rectangle-area-ii/) 扫描线
  - ? [🌟【medium】223. 矩形面积](https://leetcode.cn/problems/rectangle-area/) 扫描线
  - ??? [🌟【hard】218. 天际线问题](https://leetcode.cn/problems/the-skyline-problem/) 排序、优先队列、大顶堆、扫描线
  - ? [🌟【easy】836. 矩形重叠](https://leetcode.cn/problems/rectangle-overlap/) 规律、模拟、反推
  - [🌟【medium】712. 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/) 动态规划
  - [🌟【medium】300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) 单调栈
  - [🌟【hard】72. 编辑距离](https://leetcode.cn/problems/edit-distance/) 动态规划
  - [🌟【easy】1624. 两个相同字符之间的最长子字符串](https://leetcode.cn/problems/largest-substring-between-two-equal-characters/) 双指针
- 20220915(5)
  - ? [🌟【medium】672. 灯泡开关 Ⅱ](https://leetcode.cn/problems/bulb-switcher-ii/) 模拟、规律
  - ? [🌟【medium】319. 灯泡开关](https://leetcode.cn/problems/bulb-switcher/) 模拟、规律
  - ? [🌟【medium】161. 相隔为 1 的编辑距离](https://leetcode.cn/problems/one-edit-distance/) 双指针、动态规划
  - ? [🌟【medium】1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/) 动态规划
  - ? [🌟【medium】583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/) 动态规划
- 20220914(7)
  - [🌟【easy】1619. 删除某些元素后的数组均值](https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/) 常规题
  - ? [🌟【medium】676. 实现一个魔法字典](https://leetcode.cn/problems/implement-magic-dictionary/) 字典树、前缀树
  - ? [🌟【medium】720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/) 字典树、前缀树
  - [🌟【medium】841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/) 图、深度优先搜索、广度优先搜索
  - ?? [🌟【hard】745. 前缀和后缀搜索](https://leetcode.cn/problems/prefix-and-suffix-search/) 字典树、前缀树、后缀树
  - ?[🌟【medium】743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/) 最短路
  - ?[🌟【hard】269. 火星词典](https://leetcode.cn/problems/alien-dictionary/) 图、深度优先搜索、广度优先搜索
- 20220913(10)
  - [🌟【medium】670. 最大交换](https://leetcode.cn/problems/maximum-swap/) 规律、模拟
  - [🌟【medium】152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/) 动态规划
  - [🌟【medium】325. 和等于 k 的最长子数组长度](https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/) 前缀、前缀和
  - ? [🌟【medium】53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/) 数组、子数组
  - [🌟【medium】978. 最长湍流子数组](https://leetcode.cn/problems/longest-turbulent-subarray/) 数组、子数组
  - [🌟【medium】743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/) Floyd 算法、最短路径、最短路问题
  - ? [🌟【medium】648. 单词替换](https://leetcode.cn/problems/replace-words/) 字典树
  - ? [🌟【medium】208. 实现 Trie (前缀树)](https://leetcode.cn/problems/replace-words/) 字典树、前缀树
  - ? [🌟【medium】211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/) 字典树、前缀树
  - ? [🌟【medium】676. 实现一个魔法字典](https://leetcode.cn/problems/implement-magic-dictionary/) 字典树、前缀树
- 20220912(8)
  - [🌟【easy】1608. 特殊数组的特征值](https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/) 桶排序、计数排序、排序
  - ?? [🌟【medium】399. 除法求值](https://leetcode.cn/problems/evaluate-division/) Floyd 算法
  - [🌟【medium】1104. 二叉树寻路](https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/) 二叉树
  - ?? [🌟【medium】523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/) 前缀和、同余定理
  - ? [🌟【medium】713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/) 滑动窗口
  - [🌟【easy】724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/) 数组
  - ? [🌟【medium】974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/) 前缀、前缀和、前缀树组
  - [🌟【medium】560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/) 前缀和
- 20220911(6)
  - [🌟【medium】931. 下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/) 动态规划、滚动数组
  - ?? [🌟【medium】743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/) 最短路、最短路问题、Floyd 算法、Dijkstra 算法、深度优先搜索
  - ? [🌟【medium】650. 只有两个键的键盘](https://leetcode.cn/problems/2-keys-keyboard/) 动态规划
  - ? [🌟【medium】991. 坏了的计算器](https://leetcode.cn/problems/broken-calculator/) 贪心
  - ? [🌟【medium】735. 行星碰撞](https://leetcode.cn/problems/asteroid-collision/) 栈
  - ??? [🌟【hard】857. 雇佣 K 名工人的最低成本](https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/) 优先队列、大顶堆、堆
- 20220910(6)
  - ? [🌟【medium】669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/) 二叉搜索树、深度优先搜索
  - ?? [🌟【medium】97. 交错字符串](https://leetcode.cn/problems/interleaving-string/) 动态规划
  - [🌟【medium】990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/) 并查集
  - [🌟【medium】781. 森林中的兔子](https://leetcode.cn/problems/rabbits-in-forest/) 贪心
  - [🌟【medium】904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/) 双指针、滑动窗口
  - [🌟【medium】814. 二叉树剪枝](https://leetcode.cn/problems/binary-tree-pruning/) 二叉树、二叉树减枝
- 20220909(4)
  - ? [🌟【medium】210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 图、拓扑
  - ? [🌟【hard】630. 课程表 III](https://leetcode.cn/problems/course-schedule-iii/) 优先队列、大顶堆、排序
  - ? [🌟【medium】261. 以图判树](https://leetcode.cn/problems/graph-valid-tree/) 并查集、广度优先搜索
  - ? [🌟【medium】973. 最接近原点的 K 个点](https://leetcode.cn/problems/k-closest-points-to-origin/) 优先队列、快速选择、分治法、堆、前K个问题
- 20220908(4)
  - ? [🌟【medium】667. 优美的排列 II](https://leetcode.cn/problems/beautiful-arrangement-ii/) 规律、模拟
  - ? [🌟【hard】60. 排列序列](https://leetcode.cn/problems/permutation-sequence/) 回溯法、排列组合、规律题
  - ? [🌟【medium】207. 课程表](https://leetcode.cn/problems/course-schedule/) 图、拓扑
  - [【easy】1598. 文件夹操作日志搜集器](https://leetcode.cn/problems/crawler-log-folder/) 常规题
- 20220907(7)
  - ? [🌟【hard】60. 排列序列](https://leetcode.cn/problems/permutation-sequence/) 回溯法、排列组合、规律题
  - ? [🌟【hard】440. 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/) 字典树
  - [🌟【medium】1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/) 二分搜索
  - [🌟【medium】875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/) 二分搜索
  - [🌟【hard】1231. 分享巧克力](https://leetcode.cn/problems/divide-chocolate/) 二分搜索
  - ? [🌟【medium】316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/) 单调栈
  - ? [🌟【medium】526. 优美的排列](https://leetcode.cn/problems/beautiful-arrangement/) 回溯法、排列组合
- 20220906(7)
  - ??? [🌟【hard】828. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/) 字符串、哈希表
  - ? [🌟【medium】907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/) 数组、单调栈
  - ? [🌟【medium】2104. 子数组范围和](https://leetcode.cn/problems/sum-of-subarray-ranges/) 数组、单调栈
  - ? [🌟【medium】453. 最小操作次数使数组元素相等](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/) 模拟、规律题
  - ? [🌟【medium】430. 扁平化多级双向链表](https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/) 链表、双向链表
  - [🌟【easy】1592. 重新排列单词间的空格](https://leetcode.cn/problems/rearrange-spaces-between-words/) 字符串、双指针
  - [🌟【medium】114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) 二叉树、链表
- 20220905(3)
  - [🌟【medium】31. 下一个排列](https://leetcode.cn/problems/next-permutation/) 双指针
  - [🌟【easy】266. 回文排列](https://leetcode.cn/problems/palindrome-permutation/) 字符串、回文
  - [🌟【medium】267. 回文排列 II](https://leetcode.cn/problems/palindrome-permutation-ii/) 字符串、回文、回溯法
- 20220904(10)
  - [【easy】1582. 二进制矩阵中的特殊位置](https://leetcode.cn/problems/special-positions-in-a-binary-matrix/) 矩阵
  - [🌟【medium】77. 组合](https://leetcode.cn/problems/combinations/) 回溯法、排列组合
  - ? [🌟【medium】39. 组合总和](https://leetcode.cn/problems/combination-sum/) 回溯法、排列组合
  - ? [🌟【medium】40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/) 回溯法、排列组合
  - [🌟【medium】216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/) 回溯法、排列组合
  - ?? [🌟【medium】377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/) 动态规划、排列组合、背包问题
  - [🌟【medium】17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/) 回溯法
  - ? [🌟【easy】401. 二进制手表](https://leetcode.cn/problems/binary-watch/) 回溯法、枚举
  - ? [🌟【medium】254. 因子的组合](https://leetcode.cn/problems/factor-combinations/) 回溯法、排列组合
  - [🌟【medium】46. 全排列](https://leetcode.cn/problems/permutations/) 回溯法、排列组合
- 20220903(8)
  - [🌟【medium】646. 最长数对链](https://leetcode.cn/problems/maximum-length-of-pair-chain/) 贪心、区间问题
  - ? [🌟【medium】491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/) 数组题、排列组合
  - ? [🌟【medium】300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) 二分搜索、动态规划
  - ? [🌟【medium】334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/) 贪心、动态规划、二分搜索
  - ? [🌟【medium】1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/) 字符串、动态规划
  - ? [🌟【medium】583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/) 字符串、动态规划
  - ? [🌟【medium】712. 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/) 动态规划、公共子序列、字符串
  - [🌟【easy】1150. 检查一个数是否在数组中占绝大多数](https://leetcode.cn/problems/check-if-a-number-is-majority-element-in-a-sorted-array/) 二分搜索
- 20220902(8)
  - [🌟【medium】687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/) 二叉树、深度优先搜索
  - ? [🌟【hard】428. 序列化和反序列化 N 叉树](https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/) 二叉树、N叉树、N叉树序列化
  - [🌟【hard】297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/) 二叉树、序列化
  - [🌟【hard】815. 公交路线](https://leetcode.cn/problems/bus-routes/) 图、广度优先搜索、拓扑
  - [🌟【medium】684. 冗余连接](https://leetcode.cn/problems/redundant-connection/) 并查集、图、树、拓扑
  - ??? [🌟【hard】685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/) 并查集、广度优先搜索、图、拓扑
  - ? [🌟【easy】169. 多数元素](https://leetcode.cn/problems/majority-element/) 摩尔投票法、数组题
  - ? [🌟【medium】229. 多数元素 II](https://leetcode.cn/problems/majority-element-ii/) 数组题、摩尔投票法
- 20220901(8)
  - [🌟【easy】1475. 商品折扣后的最终价格](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/) 单调栈
  - ? [🌟【medium】738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/) 强规律题、数组、字符串
  - [🌟【hard】297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/) 二叉树、序列化
  - [🌟【medium】449. 序列化和反序列化二叉搜索树](https://leetcode.cn/problems/serialize-and-deserialize-bst/) 二叉树、序列化
  - [🌟【medium】652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/) 二叉树、二叉树序列化
  - [🌟【easy】606. 根据二叉树创建字符串](https://leetcode.cn/problems/construct-string-from-binary-tree/) 二叉树、二叉树序列化
  - ? [🌟【medium】536. 从字符串生成二叉树](https://leetcode.cn/problems/construct-binary-tree-from-string/) 二叉树、二叉树序列化
  - ? [🌟【hard】428. 序列化和反序列化 N 叉树](https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/) 二叉树、N叉树、N叉树序列化
- 20220831(2)
  - [🌟【medium】946. 验证栈序列](https://leetcode.cn/problems/validate-stack-sequences/) 栈
  - [🌟【medium】402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/) 规律题
- 20220830(11)
  - [🌟【medium】654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/) 二叉树
  - [🌟【medium】998. 最大二叉树 II](https://leetcode.cn/problems/maximum-binary-tree-ii/) 二叉树
  - [🌟【medium】695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/) 矩阵、深度优先搜索
  - [【easy】463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/) 矩阵
  - [🌟【medium】1034. 边界着色](https://leetcode.cn/problems/coloring-a-border/) 矩阵、深度优先搜索、广度优先搜索
  - [🌟【medium】417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/) 矩阵、深度优先搜索、广度优先搜索
  - ? [🌟【medium】694. 不同岛屿的数量](https://leetcode.cn/problems/number-of-distinct-islands/) 矩阵、深度优先搜索、哈希表、集合
  - ??? [🌟【hard】711. 不同岛屿的数量 II](https://leetcode.cn/problems/number-of-distinct-islands-ii/) 深度优先搜索、哈希表、排序、集合
  - [🌟【medium】443. 压缩字符串](https://leetcode.cn/problems/string-compression/) 数组、字符串、数组原地操作
  - [🌟【medium】38. 外观数列](https://leetcode.cn/problems/count-and-say/) 字符串
  - ? [🌟【medium】271. 字符串的编码与解码](https://leetcode.cn/problems/encode-and-decode-strings/) 字符串、数组
- 20220829(11)
  - [【easy】1470. 重新排列数组](https://leetcode.cn/problems/shuffle-the-array/) 数组
  - [🌟【medium】284. 顶端迭代器](https://leetcode.cn/problems/peeking-iterator/) 迭代器
  - [🌟【medium】281. 锯齿迭代器](https://leetcode.cn/problems/zigzag-iterator/) 迭代器
  - ?? [🌟【medium】684. 冗余连接](https://leetcode.cn/problems/redundant-connection/) 并查集、图
  - [🌟【medium】547. 省份数量](https://leetcode.cn/problems/number-of-provinces/) 深度优先、广度优先、图
  - ? [🌟【medium】721. 账户合并](https://leetcode.cn/problems/accounts-merge/) 深度优先、广度优先、图
  - [🌟【easy】734. 句子相似性](https://leetcode.cn/problems/sentence-similarity/) 哈希表、集合
  - [🌟【medium】737. 句子相似性 II](https://leetcode.cn/problems/sentence-similarity-ii/) 图、广度优先搜索
  - [🌟【medium】200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/) 矩阵、深度优先搜索
  - [🌟【medium】130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/) 矩阵、深度优先搜索
  - [🌟【medium】323. 无向图中连通分量的数目](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/) 图、广度优先搜索、并查集
- 20220828(11)
  - [🌟【medium】187. 重复的DNA序列](https://leetcode.cn/problems/repeated-dna-sequences/) 哈希表
  - ? [🌟【medium】784. 字母大小写全排列](https://leetcode.cn/problems/letter-case-permutation/) 排列组合、回溯
  - [🌟【medium】78. 子集](https://leetcode.cn/problems/subsets/) 回溯、子集
  - [🌟【medium】1087. 花括号展开](https://leetcode.cn/problems/brace-expansion/) 回溯、排列
  - ??? [🌟【hard】793. 阶乘函数后 K 个零](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/) 阶乘、二分搜索
  - [🌟【medium】641. 设计循环双端队列](https://leetcode.cn/problems/design-circular-deque/) 队列、循环队列、双端队列、循环双端队列
  - [🌟【medium】150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/) 逆波兰表达式、栈
  - ? [🌟【medium】299. 猜数字游戏](https://leetcode.cn/problems/bulls-and-cows/) 数组、哈希表、字符串
  - ? [🌟【medium】173. 二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/) 迭代器、二叉搜索树
  - [🌟【medium】251. 展开二维向量](https://leetcode.cn/problems/flatten-2d-vector/) 迭代器、向量
  - [🌟【medium】341. 扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator/) 迭代器、向量
- 20220827(2)
  - ? [🌟【medium】662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/) 二叉树、广度优先搜索
  - ? [🌟【medium】875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/) 二分搜索
- 20220826(7)
  - ? [🌟【medium】357. 统计各位数字都不同的数字个数](https://leetcode.cn/problems/count-numbers-with-unique-digits/) 排列组合、数学问题
  - [🌟【medium】1052. 爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/) 前缀树组
  - ? [🌟【medium】718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/) 动态规划
  - [🌟【medium】209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) 双指针
  - ?? [🌟【medium】474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/) 动态规划、背包问题
  - ? [🌟【medium】面试题 17.14. 最小K个数](https://leetcode.cn/problems/smallest-k-lcci/) 堆、优先队列、快速选择、前k个问题
  - ? [🌟【medium】740. 删除并获得点数](https://leetcode.cn/problems/delete-and-earn/) 动态规划
- 20220825(6)
  - ? [🌟【medium】658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/) 二分搜索
  - ? [🌟【medium】241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/) 递归、字符串、DFS
  - [🌟【medium】524. 通过删除字母匹配到字典里最长单词](https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/) 双指针、字符串
  - [🌟【medium】720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/) 哈希表
  - ? [🌟【medium】622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/) 队列、循环队列
  - [【easy】1464. 数组中两元素的最大乘积](https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/) 常规题
- 20220824(7)
  - [🌟【easy】1460. 通过翻转子数组使两个数组相等](https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-sub-arrays/) 数组、桶排序、哈希表
  - [【easy】485. 最大连续 1 的个数](https://leetcode.cn/problems/max-consecutive-ones/) 常规题
  - ? [🌟【medium】487. 最大连续1的个数 II](https://leetcode.cn/problems/max-consecutive-ones-ii/) 双指针、滑动窗口
  - ? [🌟【medium】1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/) 双指针、滑动窗口
  - [🌟【medium】442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/) 数组题
  - ? [🌟【medium】95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/) 二叉搜索树
  - ? [🌟【medium】96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/) 二叉搜索树
- 20220823(7)
  - ??? [🌟【hard】782. 变为棋盘](https://leetcode.cn/problems/transform-to-chessboard/) 矩阵、模拟
  - ? [🌟【medium】287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) 循环链表，二分搜索
  - ? [🌟【medium】142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) 循环链表
  - [🌟【medium】515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/) 二叉树
  - ? [🌟【medium】633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/) 二分搜索、规律
  - [【easy】367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/) 规律、数学、平方
  - ? [🌟【medium】692. 前K个高频单词](https://leetcode.cn/problems/top-k-frequent-words/) 优先队列、堆、小顶堆、前k个问题
- 20220822(12)
  - [🌟【medium】655. 输出二叉树](https://leetcode.cn/problems/print-binary-tree/) 二叉树
  - [🌟【medium】109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/) 二叉搜索树
  - [🌟【medium】429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/) 树、N叉树
  - [🌟【easy】589. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/) 树、N叉树
  - ? [🌟【medium】498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/) 规律、模拟
  - ? [🌟【medium】147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/) 链表、插入排序、排序
  - [🌟【medium】708. 循环有序列表的插入](https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/) 链表
  - [🌟【medium】1094. 拼车](https://leetcode.cn/problems/car-pooling/) 上下车问题、差分
  - [🌟【medium】542. 01 矩阵](https://leetcode.cn/problems/01-matrix/) 广度优先搜索、多起点问题
  - ? [🌟【medium】260. 只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/) 位运算
  - ?? [🌟【medium】137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/) 位运算
  - [🌟【easy】136. 只出现一次的数字](https://leetcode.cn/problems/single-number/) 位运算
- 20220821(13)
  - [🌟【easy】1455. 检查单词是否为句中其他单词的前缀](https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/) 
  - ? [🌟【medium】665. 非递减数列](https://leetcode.cn/problems/non-decreasing-array/) 贪心
  - [🌟【medium】701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/) 二叉搜索树
  - [🌟【easy】700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/) 二叉搜索树
  - ? [🌟【medium】752. 打开转盘锁](https://leetcode.cn/problems/open-the-lock/) 广度优先搜索
  - ? [🌟【medium】322. 零钱兑换](https://leetcode.cn/problems/coin-change/) 动态规划
  - ?? [🌟【medium】518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/) 动态规划、背包问题
  - [🌟【medium】264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/) 动态规划
  - [🌟【medium】313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/) 动态规划
  - [🌟【medium】204. 计数质数](https://leetcode.cn/problems/count-primes/) 动态规划
  - ? [🌟【medium】852. 山脉数组的峰顶索引](https://leetcode.cn/problems/count-primes/) 二分搜索
  - [🌟【medium】162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/) 二分搜索
  - ?? [🌟【medium】983. 最低票价](https://leetcode.cn/problems/minimum-cost-for-tickets/) 动态规划
- 20220820(10)
  - [🌟【medium】654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/) 二叉树、二叉树构建
  - ? [🌟【medium】998. 最大二叉树 II](https://leetcode.cn/problems/maximum-binary-tree-ii/) 二叉树、二叉树构建
  - ? [🌟【medium】451. 根据字符出现频率排序](https://leetcode.cn/problems/sort-characters-by-frequency/) 桶排序、桶排序衍生算法
  - ? [🌟【medium】347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/) 堆排序、排序、桶排序
  - ? [🌟【medium】785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/) 图、深度优先搜索、广度优先搜索
  - [🌟【medium】116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) 二叉树
  - ?? [🌟【medium】117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/) 二叉树
  - ?? [🌟【medium】面试题 01.07. 旋转矩阵](https://leetcode.cn/problems/rotate-matrix-lcci/) 矩阵、原地旋转矩阵
  - [🌟【easy】303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/) 前缀数组
  - ? [🌟【medium】304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/) 前缀数组、二维前缀数组
- 20220819(10)
  - ? [🌟【easy】1450. 在既定时间做作业的学生人数](https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/) 区间、区间权重累加、差分、二分搜索
  - ? [🌟【medium】435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/) 贪心
  - [🌟【medium】413. 等差数列划分](https://leetcode.cn/problems/arithmetic-slices/) 动态规划
  - [🌟【medium】513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/) 广度优先搜索、层序遍历
  - [🌟【medium】280. 摆动排序](https://leetcode.cn/problems/wiggle-sort/) 摆动排序
  - ? [🌟【medium】376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/) 摆动排序、贪心
  - ? [🌟【medium】324. 摆动排序 II](https://leetcode.cn/problems/wiggle-sort-ii/) 摆动排序
  - ??? [🌟【medium】215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/) 快排、快速排序、快速选择、快排相关算法
  - ? [🌟【medium】75. 颜色分类](https://leetcode.cn/problems/sort-colors/) 数组、双指针
  - ? [🌟【medium】452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/) 贪心
- 20220818(11)
  - ??? [🌟【hard】1224. 最大相等频率](https://leetcode.cn/problems/maximum-equal-frequency/) 哈希表、规律题
  - ? [🌟【medium】450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/) 二叉搜索树
  - [🌟【medium】216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/) 回溯
  - [🌟【medium】129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/) 二叉树
  - [🌟【hard】124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/) 二叉树
  - ? [🌟【medium】988. 从叶结点开始的最小字符串](https://leetcode.cn/problems/smallest-string-starting-from-leaf/) 二叉树
  - ? [🌟【medium】797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/) 图、深度有优先搜索 时间复杂度分析比较麻烦
  - ? [🌟【medium】106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/all-paths-from-source-to-target/) 二叉树、二叉树构建
  - [【easy】496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/) 常规题
  - ? [🌟【medium】503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/) 单调栈
  - ? [🌟【medium】1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/) 差分、扫描线、区间问题
- 20220817(12)
  - [🌟【medium】1302. 层数最深叶子节点的和](https://leetcode.cn/problems/deepest-leaves-sum/) 层序遍历、广度优先搜索、深度优先搜索、BFS、DFS
  - ??? [🌟【hard】218. 天际线问题](https://leetcode.cn/problems/the-skyline-problem/) 排序、优先队列、大顶堆
  - ? [🌟【hard】149. 直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/) 暴力解法
  - ? [🌟【easy】1979. 找出数组的最大公约数](https://leetcode.cn/problems/find-greatest-common-divisor-of-array/) 公约数
  - [🌟【medium】120. 三角形最小路径和](https://leetcode.cn/problems/triangle/) 动态规划
  - ? [🌟【medium】994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/) 广度优先搜索
  - ? [🌟【medium】286. 墙与门](https://leetcode.cn/problems/walls-and-gates/) 广度优先搜索、多源广度优先搜索
  - [🌟【medium】107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/) 二叉树、层序遍历、广度优先搜索、BFS
  - ? [🌟【medium】80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/) 数组原地操作
  - ? [🌟【medium】547. 省份数量](https://leetcode.cn/problems/number-of-provinces/) 深度优先、广度优先
  - [🌟【medium】86. 分隔链表](https://leetcode.cn/problems/partition-list/) 链表
  - ??? [🌟【hard】269. 火星词典](https://leetcode.cn/problems/alien-dictionary/) 拓扑排序、深度优先搜索
- 20220816(7)
  - [🌟【easy】1656. 设计有序流](https://leetcode.cn/problems/design-an-ordered-stream/) 哈希表、数组
  - [🌟【medium】371. 两整数之和](https://leetcode.cn/problems/sum-of-two-integers/) 位运算
  - [🌟【medium】251. 展开二维向量](https://leetcode.cn/problems/flatten-2d-vector/)
  - [🌟【easy】252. 会议室](https://leetcode.cn/problems/meeting-rooms/)
  - ? [🌟【medium】253. 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/) 二分搜索、排序、单调栈、上下车问题、重叠区间问题
  - ? [🌟【medium】285. 二叉搜索树中的中序后继](https://leetcode.cn/problems/inorder-successor-in-bst/) 二叉搜索树
  - [🌟【easy】326. 3 的幂](https://leetcode.cn/problems/power-of-three/) 进制转换
- 20220815(11)
  - [🌟【medium】641. 设计循环双端队列](https://leetcode.cn/problems/design-circular-deque/) 队列、循环队列、双端队列、循环双端队列
  - ? [🌟【medium】725. 分隔链表](https://leetcode.cn/problems/split-linked-list-in-parts/) 链表
  - ? [🌟【medium】280. 摆动排序](https://leetcode.cn/problems/wiggle-sort/) 摆动排序
  - [🌟【medium】334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/) 数组题、贪心
  - ?? [🌟【medium】300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) 动态规划、二分搜索
  - [🌟【easy】387. 字符串中的第一个唯一字符](https://leetcode.cn/problems/first-unique-character-in-a-string/) 哈希表
  - [🌟【medium】341. 扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator/) 递归、扁平化数组
  - ? [🌟【medium】384. 打乱数组](https://leetcode.cn/problems/shuffle-an-array/) 洗牌算法
  - [🌟【medium】289. 生命游戏](https://leetcode.cn/problems/game-of-life/) 矩阵、原地算法
  - ? [🌟【hard】354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/) 递增子序列问题、二分搜索
  - [🌟【medium】340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/) 滑动窗口、字符串
- 20220814(11)
  - [🌟【easy】1422. 分割字符串的最大得分](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/) 字符串
  - ?? [🌟【medium】166. 分数到小数](https://leetcode.cn/problems/fraction-to-recurring-decimal/) 哈希表、模拟运算
  - [🌟【medium】43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/) 字符串
  - ?? [🌟【hard】212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/) 字典树、回溯
  - ?? [🌟【easy】191. 位1的个数](https://leetcode.cn/problems/number-of-1-bits/) 位运算
  - ?? [🌟【easy】190. 颠倒二进制位](https://leetcode.cn/problems/reverse-bits/) 位运算
  - [🌟【easy】412. Fizz Buzz](https://leetcode.cn/problems/fizz-buzz/) 常规题
  - [【medium】62 不同路径](https://leetcode.cn/problems/unique-paths/) 动态规划
  - [🌟【medium】63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/) 动态规划
  - [🌟【hard】980. 不同路径 III](https://leetcode.cn/problems/unique-paths-iii/) 回溯法
  - ? [🌟【medium】328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/) 链表操作
- 20220813(2)
  - ? [🌟【medium】769. 最多能完成排序的块](https://leetcode.cn/problems/max-chunks-to-make-sorted/)
  - ? [🌟【hard】768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/) 排序、哈希表、单调栈
- 20220812(7)
  - [🌟【medium】1282. 用户分组](https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/) 哈希表
  - ? [🌟【medium】172. 阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/) 规律题
  - ?? [🌟【hard】127. 单词接龙](https://leetcode.cn/problems/word-ladder/) 图、BFS、广度优先搜索
  - ? [🌟【hard】815. 公交路线](https://leetcode.cn/problems/bus-routes/) 图、BFS、广度优先搜索
  - ??? [🌟【hard】126. 单词接龙 II](https://leetcode.cn/problems/word-ladder-ii/) 图、BFS、广度优先搜索
  - ? [🌟【medium】139. 单词拆分](https://leetcode.cn/problems/word-break/) 动态规划
  - [🌟【hard】140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/) 回溯法
- 20220811(7)
  - [🌟【easy】108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) 二叉搜索树、平衡二叉树
  - ?? [🌟【hard】639. 解码方法 II](https://leetcode.cn/problems/decode-ways-ii/) 枚举、模拟、字符串
  - ? [🌟【medium】116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) 二叉树、规律题
  - [🌟【easy】125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/) 回文串
  - ?? [🌟【medium】150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/) 栈、数组题、字符串、逆波兰表达式、逆波兰
  - [🌟【easy】163. 缺失的区间](https://leetcode.cn/problems/missing-ranges/) 区间
  - ? [🌟【easy】171. Excel 表列序号](https://leetcode.cn/problems/excel-sheet-column-number/) 进制转换
- 20220810(11)
  - [🌟【medium】640. 求解方程](https://leetcode.cn/problems/solve-the-equation/) 模拟
  - [🌟【easy】350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/) 哈希表、map
  - ? [🌟【medium】138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/) 链表、复制链表
  - ?? [🌟【medium】395. 至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/) 分治法
  - [【easy】242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/) 哈希表
  - [🌟【medium】130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/) 矩阵、深度优先搜索
  - ?? [🌟【hard】149. 直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/) 数学题、模拟
  - [🌟【medium】38. 外观数列](https://leetcode.cn/problems/count-and-say/) 字符串、模拟
  - ?? [🌟【medium】91. 解码方法](https://leetcode.cn/problems/decode-ways/) 动态规划、模拟、字符串题
  - [🌟【easy】1417. 重新格式化字符串](https://leetcode.cn/problems/reformat-the-string/) 字符串题
  - ? [🌟【medium】378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) 分治法、归并排序、优先队列、小顶堆、二分搜索
- 20220809(10)
  - ?? [🌟【medium】剑指 Offer 67. 把字符串转换成整数](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/) 字符互转为整数
  - ? [🌟【medium】剑指 Offer 64. 求1+2+…+n](https://leetcode.cn/problems/qiu-12n-lcof/) 求和、非常规求和
  - [🌟【easy】剑指 Offer 27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/) 二叉树、二叉树镜像构造
  - ??? [🌟【medium】剑指 Offer 14- II. 剪绳子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/) 整数拆分、取模
  - ?? [🌟【medium】剑指 Offer 16. 数值的整数次方](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/) 快速幂、规律题
  - ?? [🌟【easy】剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/) 链表、链表公共节点
  - ?? [🌟【easy】剑指 Offer 15. 二进制中1的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/) 二进制、二进制运算
  - ?? [🌟【hard】233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/) 规律、数学规律
  - ?? [🌟【medium】剑指 Offer 44. 数字序列中某一位的数字](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/) 规律、数学规律
  - ?? [🌟【medium】剑指 Offer 20. 表示数值的字符串](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/) 规律、模拟
- 20220808(9)
  - [🌟【medium】剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/) 二叉树、二叉树的最近公共祖先
  - [🌟【easy】剑指 Offer 55 - I. 二叉树的深度](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/) 二叉树、二叉树的深度
  - [🌟【easy】剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/) 二叉搜索树
  - ?? [🌟【easy】剑指 Offer 65. 不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/) 二进制、位运算
  - [🌟【easy】剑指 Offer 55 - II. 平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/) 二叉树、平衡二叉树
  - ? [🌟【medium】剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) 二叉树、二叉树路径和
  - [🌟【medium】437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 二叉树、二叉树中的路径和
  - [【easy】剑指 Offer 57. 和为s的两个数字](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/) 双指针
  - ? [🌟【easy】剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/) 二叉树、对称二叉树
- 20220807(11)
  - [🌟【medium】剑指 Offer 47. 礼物的最大价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/) 动态规划
  - [🌟【medium】剑指 Offer 66. 构建乘积数组](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/) 数组题
  - ?? [🌟【medium】剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) 二分搜索
  - ? [🌟【medium】剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/) 二叉树、BFS
  - [【easy】剑指 Offer 18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/) 链表
  - ?? [🌟【medium】剑指 Offer 59 - II. 队列的最大值](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/) 队列、栈、单调数组、双端队列
  - [🌟【hard】剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) 双端队列、滑动窗口
  - [🌟【hard】剑指 Offer 37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/) 二叉树、二叉树序列化
  - ?? [🌟【medium】剑指 Offer 35. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) 链表
  - [🌟【easy】剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) 二叉搜索树
  - [🌟【easy】剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/) 二叉树、BFS
- 20220806(10)
  - ?? [🌟【medium】剑指 Offer 14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/) 动态规划
  - ?? [🌟【medium】剑指 Offer 60. n个骰子的点数](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/) 动态规划
  - ?? [🌟【medium】剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/) 二进制、与或非、位运算
  - ?? [🌟【medium】剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/) 二进制、位运算、规律题
  - [🌟【medium】剑指 Offer 12. 矩阵中的路径](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/) 回溯法
  - ?? [🌟【medium】剑指 Offer 31. 栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/) 栈
  - [🌟【easy】剑指 Offer 58 - I. 翻转单词顺序](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)
  - [🌟【medium】151. 颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)
  - [🌟【medium】186. 翻转字符串里的单词 II](https://leetcode.cn/problems/reverse-words-in-a-string-ii/)
  - ?? [🌟【medium】189. 轮转数组](https://leetcode.cn/problems/rotate-array/) 规律题
- 20220805(9)
  - ?? [🌟【easy】剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/) 双指针、滑动窗口
  - ?? [🌟【hard】剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/) 规律题
  - ?? [🌟【easy】剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/) 规律题、约瑟夫环、直接背结论
  - ?? [🌟【medium】剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/) 二叉搜索树、后序遍历
  - [🌟【easy】剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/) 哈希表
  - [🌟【medium】剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/) BFS
  - [【easy】剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)
  - ?? [🌟【medium】剑指 Offer 49. 丑数](https://leetcode.cn/problems/chou-shu-lcof/) 动态规划
  - ? [🌟【medium】313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/) 动态规划
- 20220804(7)
  - [🌟【medium】122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/) 动态规划
  - [🌟【hard】123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/) 动态规划
  - ?? [🌟【hard】188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/) 动态规划
  - ?? [🌟【medium】309 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/) 动态规划
  - ? [🌟【easy】剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/) 动态规划
  - ? [🌟【easy】剑指 Offer 61. 扑克牌中的顺子](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/) 规律题
  - [🌟【easy】剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/) 数组题
- 20220803(3)
  - [🌟【hard】剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) 单调队列
  - ?? [🌟【hard】剑指 Offer 19. 正则表达式匹配](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/) 动态规划
  - ?? [🌟【easy】剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/) 二分搜索
- 20220802(4)
  - ?? [🌟【medium】剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) 二叉搜索树、双向链表、链表
  - [🌟【hard】剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) 归并排序
  - ?? [🌟【hard】剑指 Offer 41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/) 优先队列、大顶堆、小顶堆
  - ?? [🌟【hard】剑指 Offer 37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/) 二叉树
- 20220801(7)
  - ?? [🌟【medium】211 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/) 字典树
  - ? [🌟【medium】230 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) 二叉搜索树
  - ? [🌟【easy】557 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/) 双指针、字符串
  - [🌟【easy】235 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/) 二叉树、二叉搜索树
  - [🌟【easy】292 Nim 游戏](https://leetcode.cn/problems/nim-game/) 规律题
  - [🌟【easy】231 2 的幂](https://leetcode.cn/problems/power-of-two/) 规律题
  - ?? [🌟【medium】89 格雷编码](https://leetcode.cn/problems/gray-code/) 规律题
- 20220731(9)
  - ? [🌟【medium】538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/) 二叉树、二叉搜索树、累加树
  - ? [🌟【easy】338 比特位计数](https://leetcode.cn/problems/counting-bits/) 规律、模拟
  - ? [🌟【easy】461 汉明距离](https://leetcode.cn/problems/hamming-distance/) 规律、模拟
  - ? [🌟【easy】112 路径总和](https://leetcode.cn/problems/path-sum/) 二叉树
  - [🌟【medium】113 路径总和 II](https://leetcode.cn/problems/path-sum-ii/) 二叉树
  - ? [🌟【medium】437 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 前缀和
  - ?? [🌟【medium】208 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/) 前缀树、字典树、trie
  - ? [🌟【medium】386 字典序排数](https://leetcode.cn/problems/lexicographical-numbers/) 前缀树、字典树
  - ? [🌟【hard】440 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/) 字典树
- 20220730(7)
  - ?? [🌟【medium】287 寻找重复数](https://leetcode.cn/problems/linked-list-cycle-ii/) 快慢指针、双指针
  - ? [🌟【easy】448 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)
  - ? [🌟【hard】41 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
  - ?? [🌟【hard】312. 戳气球](https://leetcode.cn/problems/burst-balloons/) 开区间动态规划
  - [🌟【easy】617 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)
  - [🌟【medium】438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) 双指针、滑动窗口
  - ? [🌟【medium】114 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) 二叉树、链表
- 20220729(8)
  - ? [🌟【medium】581 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)
  - ? [🌟【hard】407 接雨水 II](https://leetcode.cn/problems/trapping-rain-water-ii/) 优先队列
  - ? [🌟【medium】21 任务调度器](https://leetcode.cn/problems/task-scheduler/) 模拟推断
  - [🌟【easy】20 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 栈
  - [🌟【medium】22 括号生成](https://leetcode.cn/problems/generate-parentheses/) 回溯
  - ? [🌟【hard】32 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/) 动态规划
  - ?? [🌟【hard】301 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/) BFS
  - ?? [🌟【medium】142 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) 链表、快慢指针、双指针
- 20220728(8)
  - [🌟【easy】234 回文链表](https://leetcode.cn/problems/palindrome-linked-list/) 快慢指针、链表
  - ?? [🌟【medium】207 课程表](https://leetcode.cn/problems/course-schedule/) 图、拓扑排序、BFS
  - ?? [🌟【medium】210 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 图、拓扑排序、BFS
  - ?? [🌟【hard】630 课程表 III](https://leetcode.cn/problems/course-schedule-iii/) 贪心、优先队列、堆
  - ?? [🌟【medium】11 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) 双指针
  - [🌟【hard】42 接雨水](https://leetcode.cn/problems/trapping-rain-water/) 动态规划、双指针、单调栈
  - [🌟【hard】815 公交路线](https://leetcode.cn/problems/bus-routes/) 图、BFS
  - ? [🌟【medium】98 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) 二叉树、二叉搜索树、DFS
- 20220727(5)
  - [🌟【easy】9 回文数](https://leetcode.cn/problems/palindrome-number/)
  - [🌟【medium】5 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
  - ? [🌟【medium】516 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)
  - [🌟【medium】647 回文子串](https://leetcode.cn/problems/palindromic-substrings/)
  - ? [🌟【hard】336 回文对](https://leetcode.cn/problems/palindrome-pairs/)
- 20220726(4)
  - [🌟【medium】406 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)
  - ? [🌟【hard】315 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/) 归并排序
  - ? [🌟【hard】493 翻转对](https://leetcode.cn/problems/reverse-pairs/) 归并排序
  - ? [🌟【hard】327 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/) 归并排序
- 20220725(6)
  - [🌟【medium】256 粉刷房子](https://leetcode.cn/problems/paint-house/)
  - [🌟【hard】265 粉刷房子 II](https://leetcode.cn/problems/paint-house-ii/)
  - [🌟【medium】276 栅栏涂色](https://leetcode.cn/problems/paint-fence/)
  - [🌟【hard】239 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)
  - [🌟【hard】25 K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
  - [🌟【easy】1446 连续字符](https://leetcode.cn/problems/consecutive-characters/)
- 20220724(9)
  - [🌟【medium】560 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)
  - ? [🌟【medium】713 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)
  - ?? [🌟【medium】152 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)
  - [🌟【medium】325 和等于 k 的最长子数组长度](https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/)
  - [🌟【medium】198 打家劫舍](https://leetcode.cn/problems/house-robber/)
  - [🌟【medium】213 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
  - [🌟【medium】337 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)
  - [🌟【medium】238 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)
  - ? [🌟【medium】454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)
- 20220723(10)
  - [🌟【hard】131 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)
  - ? [🌟【hard】132 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)
  - ? [🌟【easy】232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)
  - ? [🌟【easy】225 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)
  - [🌟【easy】1 两数之和](https://leetcode.cn/problems/two-sum/)
  - ? [🌟【medium】15 三数之和](https://leetcode.cn/problems/3sum/)
  - [🌟【medium】18 四数之和](https://leetcode.cn/problems/4sum/)
  - [🌟【medium】16 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)
  - [🌟【medium】259 较小的三数之和](https://leetcode.cn/problems/3sum-smaller/)
  - [🌟【medium】259 较小的三数之和](https://leetcode.cn/problems/3sum-smaller/)
- 20220722(6)
  - [🌟【medium】33 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
  - [🌟【medium】81 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)
  - [🌟【medium】153 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
  - [🌟【hard】154 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)
  - [🌟【easy】796 旋转字符串](https://leetcode.cn/problems/rotate-string/)
  - [🌟【easy】509 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)
- 20220721(7)
  - ?? [🌟【hard】 879 盈利计划](https://leetcode.cn/problems/profitable-schemes/)
  - [🌟【medium】279 完全平方数](https://leetcode.cn/problems/profitable-schemes/)
  - [🌟【medium】204 计数质数](https://leetcode.cn/problems/count-primes/)
  - ? [🌟【easy】263 丑数](https://leetcode.cn/problems/ugly-number/)
  - ? [🌟【medium】264 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)
  - ? [🌟【medium】313 超级丑数](https://leetcode.cn/problems/super-ugly-number/)
  - [🌟【hard】23 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
- 20220720(3)
  - ?? [🌟【hard】 815 公交路线](https://leetcode.cn/problems/bus-routes/) BFS
  - ?? [🌟【medium】 416 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/) 背包问题
  - ?? [🌟【medium】 698 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)
- 20220719(1)
  - ?? [🌟【hard】 1411 给 N x 3 网格图涂色的方案数](https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/)
- 20220718(2)
  - ?? [🌟【medium】 300 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
  - ?? [🌟【hard】 354 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)
- 20220717(2)
  - ?? [🌟【medium】 424 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)
  - ? [🌟【hard】 295 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)
- 20220716(2)
  - ? [🌟【hard】 862 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)
  - [🌟【hard】 297 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)
- 20220715(4)
  - ? [🌟【medium】 253 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/)
  - [【easy】 252 会议室](https://leetcode.cn/problems/meeting-rooms/)
  - [🌟【medium】 56 合并区间](https://leetcode.cn/problems/merge-intervals/)
  - [🌟【medium】 77 组合](https://leetcode.cn/problems/combinations/)
- 20220714(3)
  - ? [🌟【medium】 386 字典序排数](https://leetcode.cn/problems/lexicographical-numbers/)
  - [🌟【medium】 面试题 02.05 链表求和](https://leetcode.cn/problems/sum-lists-lcci/)
  - [🌟【easy】 剑指 Offer 25 合并两个排序的链表](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)
- 20220713(2)
  - ? [🌟【medium】 162 寻找峰值](https://leetcode.cn/problems/find-peak-element/)
  - [🌟【hard】 面试题 17.21 直方图的水量](https://leetcode.cn/problems/volume-of-histogram-lcci/)
- 20220712(3)
  - ? [🌟【medium】 445 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)
  - ? [🌟【hard】 224 基本计算器](https://leetcode.cn/problems/basic-calculator/)
  - ? [🌟【medium】 227 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)
- 20220711(2)
  - [🌟【easy】 415 字符串相加](https://leetcode.cn/problems/add-strings/)
  - ? [🌟【easy】 160 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
- 20220708(3)
  - ? [🌟【medium】 221 最大正方形](https://leetcode.cn/problems/maximal-square/)
  - [🌟【medium】 113 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)
  - ? [🌟【hard】 329 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)
- 20220703(6)
  - ? [🌟【hard】 315 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)
  - ? [🌟【hard】 剑指 Offer 51 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)
  - ? [🌟【medium】 148 排序链表](https://leetcode.cn/problems/sort-list/)
  - [🌟【easy】 剑指 Offer 50 第一个只出现一次的字符](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)
  - [🌟【medium】 199 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
  - ? [🌟【medium】 103 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)
- 20220702(3)
  - [🌟【medium】 5 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
  - [🌟【medium】 516 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)
  - [🌟【medium】 647 回文子串](https://leetcode.cn/problems/palindromic-substrings/)
- 20220701(1)
  - [【easy】 746 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)
- 20220630(1)
  - [🌟【medium】 240 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)
- 20220629(2)
  - [🌟【medium】 494 目标和](https://leetcode.cn/problems/target-sum/)
  - [【medium】 165 比较版本号](https://leetcode.cn/problems/compare-version-numbers/)
- 20220628(1)
  - [🌟【easy】 268 丢失的数字](https://leetcode.cn/problems/missing-number/)
- 20220627(1)
  - ? [🌟【medium】 79 单词搜索](https://leetcode.cn/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/)
- 20220624(1)
  - ? [🌟【medium】 380 O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)
- 20220623(4)
  - 🌟【medium】[213 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
  - ? [🌟【medium】 337 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)
  - [🌟【medium】 剑指 Offer 40 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)
  - [【medium】 695 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)
- 20220620(1)
  - 🌟【medium】[763 划分字母区间](https://leetcode.cn/problems/partition-labels/)
- 20220616(2)
  - ? [🌟【hard】 51 N 皇后](https://leetcode.cn/problems/n-queens/)
  - ? [🌟【hard】 37 解数独](https://leetcode.cn/problems/sudoku-solver/)
- 20220611(1)
  - ? [🌟【medium】 1143 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)
- 20220610(5)
  - ? [🌟【hard】 85 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)
  - ? [🌟【medium】 剑指 Offer 45 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)
  - ? [🌟【medium】 739 每日温度](https://leetcode.cn/problems/daily-temperatures/)
  - ? [🌟【hard】 440 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)
  - [【medium】 62 不同路径](https://leetcode.cn/problems/unique-paths/)
- 20220609(5)
  - [【medium】 343 整数拆分](https://leetcode.cn/problems/integer-break/)
  - ? [🌟【hard】 84 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 
  - ? [🌟【medium】 179 最大数](https://leetcode.cn/problems/largest-number/)
  - ? [🌟【medium】 189 轮转数组](https://leetcode.cn/problems/rotate-array/)
  - [🌟【easy】 202. 快乐数](https://leetcode.cn/problems/happy-number/)
- 20220608(2)
  - [🌟【medium】 82 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)
  - [🌟【hard】 41 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
- 20220607(8)
  - [🌟【hard】 154 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)
  - ? [🌟【medium】 剑指 Offer 29 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)
  - [🌟【easy】 977 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)
  - [🌟【medium】 652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)
  - ? [🌟【01背包】【medium】 322 零钱兑换](https://leetcode.cn/problems/coin-change/)
  - [【medium】 102 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
  - [【medium】 102 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
  - ? [🌟【medium】 131 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)
- 20220606(5)
  - ? [🌟【medium】 394 字符串解码](https://leetcode.cn/problems/decode-string/)
  - [🌟【easy】 118 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)
  - [【medium】 17 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
  - [【medium】 167 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)
  - [🌟【medium】 153 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
- 20220605(5)
  - ? [🌟【medium】 540 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/) 二分
  - [【medium】 24 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) 
  - ? [🌟【medium】 209 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) 滑动窗口、双指针、前缀数组
  - ? [🌟【hard】 41 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/) 哈希
  - 【medium】 [139 单词拆分](https://leetcode.cn/problems/word-break/)
- 20220604(2)
  - ? [🌟【medium】 475 供暖器](https://leetcode.cn/problems/heaters/)
  - ? [🌟【medium】【01背包】 416 分割等和子集 ](https://leetcode.cn/problems/partition-equal-subset-sum/)
- 20220602(1)
  - ? [🌟【medium】 279 完全平方数](https://leetcode.cn/problems/perfect-squares/)

# 刷题指南

刷题的时候要按照大概的题目分类来刷，每个方面都要有所了解。

- [基础算法](#😻✔-基础算法)
- 栈
- 队列
- 链表
- 集合
- 字典
- 树
- 堆
- 图
- 搜索、排序
- 分治法
- 动态规划
- 贪心算法
- 回溯算法
- 模拟
- trie、字典树

## 二进制、进制转换相关、位运算

- 🌟【medium】[剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/) 二进制、与或非、位运算
- 🌟【medium】[剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/) 二进制、位运算、规律题
- 🌟【easy】[剑指 Offer 65. 不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/) 二进制、位运算、规律题
- 🌟【easy】[剑指 Offer 15. 二进制中1的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/) 二进制、二进制运算
- 🌟【easy】[191. 位1的个数](https://leetcode.cn/problems/number-of-1-bits/) 位运算
- 🌟【easy】[190. 颠倒二进制位](https://leetcode.cn/problems/reverse-bits/) 位运算
- 🌟【easy】[326. 3 的幂](https://leetcode.cn/problems/power-of-three/) 进制转换
- ?? 🌟【medium】[137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/) 位运算
- ? 🌟【medium】[剑指 Offer II 005. 单词长度的最大乘积](https://leetcode.cn/problems/aseY1I/) 位运算
- 🌟【medium】[面试题 05.02. 二进制数转字符串](https://leetcode.cn/problems/bianry-number-to-string-lcci/?favorite=xb9lfcwi) 二进制
- ? 🌟【medium】[面试题 16.01. 交换数字](https://leetcode.cn/problems/swap-numbers-lcci/) 二进制、位运算
- ?🌟【easy】[面试题 05.01. 插入](https://leetcode.cn/problems/insert-into-bits-lcci/) 二进制、位运算
- ??🌟【easy】[面试题 05.03. 翻转数位](https://leetcode.cn/problems/reverse-bits-lcci/) 二进制、位运算
- ?🌟【easy】[面试题 05.06. 整数转换](https://leetcode.cn/problems/convert-integer-lcci/) 二进制、位运算
- ?🌟【easy】[面试题 05.07. 配对交换](https://leetcode.cn/problems/exchange-lcci/) 二进制、位运算
- 🌟【easy】[面试题 17.01. 不用加号的加法](https://leetcode.cn/problems/add-without-plus-lcci/) 二进制、位运算
- 🌟【easy】[476. 数字的补数](https://leetcode.cn/problems/number-complement/) 二进制、位运算

## 数字大小、数字、数学、数学规律

- 🌟【medium】[179 最大数](https://leetcode.cn/problems/largest-number/)
- 🌟【medium】[剑指 Offer 45 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)
- 🌟【medium】[633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/) 二分搜索、规律
- 【easy】[367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/) 规律、数学、平方
- 🌟【medium】[357. 统计各位数字都不同的数字个数](https://leetcode.cn/problems/count-numbers-with-unique-digits/) 排列组合、数学问题

## 前缀、前缀和、前缀和数组

- 🌟【medium】[437 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 前缀和
- 🌟【easy】[303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/) 前缀数组
- 🌟【medium】[304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/) 前缀数组、二维前缀数组
- 🌟【medium】[1052. 爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/) 前缀树组
- ?? 🌟【medium】[523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/) 前缀和、同余定理
- ? 🌟【medium】[974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/) 前缀、前缀和、前缀树组
- 🌟【medium】[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/) 前缀和
- 🌟【medium】[325. 和等于 k 的最长子数组长度](https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/) 前缀、前缀和
- ? 🌟【medium】[剑指 Offer II 011. 0 和 1 个数相同的子数组](https://leetcode.cn/problems/A1NYOS/) 前缀和
- ?🌟【medium】[面试题 17.05.  字母与数字](https://leetcode.cn/problems/find-longest-subarray-lcci/) 前缀和

## trie、字典树

初识字典树

- [【图解算法】模板+变式——带你彻底搞懂字典树(Trie树)](https://blog.csdn.net/m0_46202073/article/details/107253959)

---

- 🌟【medium】[386 字典序排数](https://leetcode.cn/problems/lexicographical-numbers/)
- 🌟【hard】[440 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)
- 🌟【medium】[208 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/) 前缀树、字典树、trie
- 🌟【medium】[211 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/) 字典树
- 🌟【hard】[212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/) 字典树、回溯
- ? 🌟【medium】[648. 单词替换](https://leetcode.cn/problems/replace-words/) 字典树
- ? 🌟【medium】[676. 实现一个魔法字典](https://leetcode.cn/problems/implement-magic-dictionary/) 字典树、前缀树
- ? 🌟【medium】[720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/) 字典树、前缀树
- ?? 🌟【hard】[745. 前缀和后缀搜索](https://leetcode.cn/problems/prefix-and-suffix-search/) 字典树、前缀树、后缀树
- 🌟【medium】[剑指 Offer II 065. 最短的单词编码](https://leetcode.cn/problems/iSwD2y/) 字典树
- ??? 🌟【medium】[剑指 Offer II 067. 最大的异或](https://leetcode.cn/problems/ms70jA/) 字典树、贪心
- ?🌟【medium】[面试题 17.17. 多次搜索](https://leetcode.cn/problems/multi-search-lcci/) 字典树

## 字符串题

- 🌟【medium】[8 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)
- 🌟【medium】[394 字符串解码](https://leetcode.cn/problems/decode-string/)
- 🌟【medium】[763 划分字母区间](https://leetcode.cn/problems/partition-labels/)
- 🌟【easy】[415 字符串相加](https://leetcode.cn/problems/add-strings/)
- 🌟【hard】[224 基本计算器](https://leetcode.cn/problems/basic-calculator/)
- 🌟【medium】[227 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)
- 🌟【hard】[301 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/) BFS
- 🌟【easy】[20 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 栈
- 🌟【medium】[22 括号生成](https://leetcode.cn/problems/generate-parentheses/) 回溯
- 🌟【hard】[32 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/) 动态规划
- 🌟【easy】[557 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/) 双指针、字符串
- 🌟【medium】[剑指 Offer 67. 把字符串转换成整数](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/) 字符互转为整数
- 🌟【medium】[640. 求解方程](https://leetcode.cn/problems/solve-the-equation/) 模拟
- 🌟【medium】[38. 外观数列](https://leetcode.cn/problems/count-and-say/) 字符串、模拟
- 🌟【medium】[91. 解码方法](https://leetcode.cn/problems/decode-ways/) 动态规划、模拟、字符串题
- 🌟【easy】[1417. 重新格式化字符串](https://leetcode.cn/problems/reformat-the-string/) 字符串题
- 🌟【hard】[639. 解码方法 II](https://leetcode.cn/problems/decode-ways-ii/) 枚举、模拟、字符串
- 🌟【medium】[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/) 栈、数组题、字符串、逆波兰表达式、逆波兰
- 🌟【easy】[171. Excel 表列序号](https://leetcode.cn/problems/excel-sheet-column-number/) 进制转换
- 🌟【easy】[1422. 分割字符串的最大得分](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/) 字符串
- 🌟【medium】[43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/) 字符串
- 🌟【medium】[241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/) 递归、字符串、DFS
- 🌟【medium】[524. 通过删除字母匹配到字典里最长单词](https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/) 双指针、字符串
- ? 🌟【medium】[299. 猜数字游戏](https://leetcode.cn/problems/bulls-and-cows/) 数组、哈希表、字符串
- 🌟【easy】[266. 回文排列](https://leetcode.cn/problems/palindrome-permutation/) 字符串、回文
- ??? 🌟【hard】[828. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/) 字符串、哈希表
- 🌟【easy】[1592. 重新排列单词间的空格](https://leetcode.cn/problems/rearrange-spaces-between-words/) 字符串、双指针
- 🌟【easy】[面试题 01.09. 字符串轮转](https://leetcode.cn/problems/string-rotation-lcci/) 字符串题、字符串旋转
- ?🌟【medium】[468. 验证IP地址](https://leetcode.cn/problems/validate-ip-address/) 字符串题
- 🌟【easy】[409. 最长回文串](https://leetcode.cn/problems/longest-palindrome/) 字符串、回文串
- ???🌟【easy】[459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/) 模拟、字符串、KMP

回文串相关

- 🌟【medium】[5 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
- 🌟【easy】[9 回文数](https://leetcode.cn/problems/palindrome-number/)
- 🌟【medium】[516 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)
- 🌟【medium】[647 回文子串](https://leetcode.cn/problems/palindromic-substrings/)
- 🌟【hard】[336 回文对](https://leetcode.cn/problems/palindrome-pairs/)
- 🌟【easy】[125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/) 回文串
- 🌟【easy】[266. 回文排列](https://leetcode.cn/problems/palindrome-permutation/) 字符串、回文
- 🌟【medium】[267. 回文排列 II](https://leetcode.cn/problems/palindrome-permutation-ii/) 字符串、回文、回溯法
- ???🌟【hard】[剑指 Offer II 094. 最少回文分割](https://leetcode.cn/problems/omKAoA/) 动态规划、回文串
- 🌟【easy】[680. 验证回文串 II](https://leetcode.cn/problems/valid-palindrome-ii/) 字符串、回文串

## 数组题 

- 🌟【medium】[128 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)
- 🌟【medium】[33 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
- 🌟【medium】[560 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)
- 🌟【medium】[剑指 Offer 04 二维数组中的查找](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)
- 🌟【medium】[48 旋转图像](https://leetcode.cn/problems/rotate-image/)
- 🌟【medium】[209 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
- 🌟【hard】[41 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
- 🌟【medium】[剑指 Offer 29 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)
- 🌟【easy】[977 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/) 
- 🌟【hard】[84 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 
- 🌟【medium】[189 轮转数组](https://leetcode.cn/problems/rotate-array/)
- 🌟【hard】[85 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)
- 🌟【medium】[739 每日温度](https://leetcode.cn/problems/daily-temperatures/)
- 🌟【medium】[240 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)
- 🌟【medium】[221 最大正方形](https://leetcode.cn/problems/maximal-square/)
- 🌟【hard】[329 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)
- 🌟【hard】[862 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)
- 🌟【hard】[315 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)
- 🌟【hard】[493 翻转对](https://leetcode.cn/problems/reverse-pairs/)
- 🌟【hard】[327 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/) 归并排序
- 🌟【easy】[剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)
- 🌟【medium】[剑指 Offer 66. 构建乘积数组](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/) 数组题
- 🌟【medium】[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/) 栈、数组题、字符串、逆波兰表达式、逆波兰
- 🌟【medium】[334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/) 数组题、贪心
- 🌟【medium】[80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/) 数组原地操作
- 🌟【medium】[280. 摆动排序](https://leetcode.cn/problems/wiggle-sort/) 摆动排序
- 🌟【medium】[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/) 摆动排序、贪心
- 🌟【medium】[324. 摆动排序 II](https://leetcode.cn/problems/wiggle-sort-ii/) 摆动排序
- 🌟【medium】[75. 颜色分类](https://leetcode.cn/problems/sort-colors/) 数组、双指针
- 🌟【medium】[1094. 拼车](https://leetcode.cn/problems/car-pooling/) 上下车问题、差分
- 🌟【medium】[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) 循环链表，二分搜索
- 🌟【easy】[1460. 通过翻转子数组使两个数组相等](https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-sub-arrays/) 数组、桶排序、哈希表
- 🌟【medium】[442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/) 数组题
- ? 🌟【medium】[299. 猜数字游戏](https://leetcode.cn/problems/bulls-and-cows/) 数组、哈希表、字符串
- 🌟【medium】[443. 压缩字符串](https://leetcode.cn/problems/string-compression/) 数组、字符串、数组原地操作
- ? 🌟【medium】[738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/) 强规律题、数组、字符串
- ? 🌟【easy】[169. 多数元素](https://leetcode.cn/problems/majority-element/) 摩尔投票法
- 🌟【medium】[978. 最长湍流子数组](https://leetcode.cn/problems/longest-turbulent-subarray/) 数组、子数组
- 🌟【easy】[1652. 拆炸弹](https://leetcode.cn/problems/defuse-the-bomb/) 数组题
- 🌟【medium】[面试题 16.24. 数对和](https://leetcode.cn/problems/pairs-with-sum-lcci/) 哈希表、数组
- ??🌟【medium】[面试题 17.15. 最长单词](https://leetcode.cn/problems/longest-word-lcci/) 递归、哈希表、数组
- 🌟【easy】[1800. 最大升序子数组和](https://leetcode.cn/problems/maximum-ascending-subarray-sum/) 数组题
- 🌟【medium】[870. 优势洗牌](https://leetcode.cn/problems/advantage-shuffle/) 数组题、排序
- 🌟【easy】[面试题 17.04. 消失的数字](https://leetcode.cn/problems/missing-number-lcci/) 数组原地操作
- ?🌟【easy】[面试题 17.10. 主要元素 消失的数字](https://leetcode.cn/problems/find-majority-element-lcci/) 摩尔排序
- ?? 🌟【medium】[945. 使数组唯一的最小增量](https://leetcode.cn/problems/minimum-increment-to-make-array-unique/) 排序、数组题
- 🌟【easy】[414. 第三大的数](https://leetcode.cn/problems/third-maximum-number/) 数组题
- ?🌟【easy】[495. 提莫攻击](https://leetcode.cn/problems/teemo-attacking/) 数组、区间问题
- 🌟【medium】[845. 数组中的最长山脉](https://leetcode.cn/problems/longest-mountain-in-array/) 模拟、数组题#
- ?🌟【meidum】[1014. 最佳观光组合](https://leetcode.cn/problems/best-sightseeing-pair/) 数组题、规律、脑筋急转弯

### 排列组合

- 🌟【medium】 [46 全排列](https://leetcode.cn/problems/permutations/)
- 🌟【medium】 [47 全排列 II](https://leetcode.cn/problems/permutations-ii/)
- 🌟【medium】 [78 子集](https://leetcode.cn/problems/subsets/)
- ? 🌟【medium】[491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/) 数组题、排列组合
- [🌟【medium】77. 组合](https://leetcode.cn/problems/combinations/) 回溯法、排列组合
- ? [🌟【medium】39. 组合总和](https://leetcode.cn/problems/combination-sum/) 回溯法、排列组合
- ? [🌟【medium】40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/) 回溯法、排列组合
- [🌟【medium】216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/) 回溯法、排列组合
- ?? [🌟【medium】377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/) 动态规划、排列组合、背包问题
- [🌟【medium】17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/) 回溯法
- ? [🌟【easy】401. 二进制手表](https://leetcode.cn/problems/binary-watch/) 回溯法、枚举
- ? [🌟【medium】254. 因子的组合](https://leetcode.cn/problems/factor-combinations/) 回溯法、排列组合
- ? 🌟【hard】[60. 排列序列](https://leetcode.cn/problems/permutation-sequence/) 回溯法、排列组合、规律题

## 模拟、规律

- 🌟【medium】[400 第 N 位数字](https://leetcode.cn/problems/nth-digit/)
- 🌟【medium】[21 任务调度器](https://leetcode.cn/problems/task-scheduler/)
- 🌟【hard】 [440 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)
- 🌟【easy】[338 比特位计数](https://leetcode.cn/problems/counting-bits/) 规律、模拟
- 🌟【medium】[21 任务调度器](https://leetcode.cn/problems/task-scheduler/) 模拟推断
- 🌟【easy】[461 汉明距离【easy】](https://leetcode.cn/problems/hamming-distance/) 规律、模拟
- 🌟【hard】[1411 给 N x 3 网格图涂色的方案数](https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/)
- 🌟【easy】[剑指 Offer 61. 扑克牌中的顺子](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/) 规律题
- 🌟【hard】[剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/) 规律题
- 🌟【easy】[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/) 规律题、约瑟夫环、直接背结论
- 🌟【medium】[剑指 Offer 60. n个骰子的点数](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/) 动态规划
- ??? 🌟【medium】[剑指 Offer 14- II. 剪绳子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/) 整数拆分、取模
- 🌟【medium】[剑指 Offer 16. 数值的整数次方](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/) 快速幂、规律题
- 🌟【medium】[剑指 Offer 64. 求1+2+…+n](https://leetcode.cn/problems/qiu-12n-lcof/) 求和、非常规求和
- 🌟【medium】[剑指 Offer 44. 数字序列中某一位的数字](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/) 规律、数学规律
- 🌟【medium】[剑指 Offer 20. 表示数值的字符串](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/) 规律、模拟
- 🌟【medium】[640. 求解方程](https://leetcode.cn/problems/solve-the-equation/) 模拟
- 🌟【hard】[149. 直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/) 数学题、模拟
- 🌟【medium】[38. 外观数列](https://leetcode.cn/problems/count-and-say/) 字符串、模拟
- 🌟【hard】[639. 解码方法 II](https://leetcode.cn/problems/decode-ways-ii/) 枚举、模拟、字符串
- 🌟【medium】[116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) 二叉树、规律题
- 🌟【medium】[172. 阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/) 规律题
- 🌟【medium】[384. 打乱数组](https://leetcode.cn/problems/shuffle-an-array/) 洗牌算法
- ??? 🌟【hard】[1224. 最大相等频率](https://leetcode.cn/problems/maximum-equal-frequency/) 哈希表、规律题
- ??? 🌟【hard】[782. 变为棋盘](https://leetcode.cn/problems/transform-to-chessboard/) 矩阵、模拟
- 🌟【medium】[633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/) 二分搜索、规律
- ? 🌟【easy】[401. 二进制手表](https://leetcode.cn/problems/binary-watch/) 回溯法、枚举
- ? 🌟【medium】[453. 最小操作次数使数组元素相等](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/) 模拟、规律题
- ? 🌟【medium】[667. 优美的排列 II](https://leetcode.cn/problems/beautiful-arrangement-ii/) 规律、模拟
- ? 🌟【medium】[650. 只有两个键的键盘](https://leetcode.cn/problems/2-keys-keyboard/) 动态规划
- 🌟【medium】[670. 最大交换](https://leetcode.cn/problems/maximum-swap/) 规律、模拟
- ? 🌟【medium】[672. 灯泡开关 Ⅱ](https://leetcode.cn/problems/bulb-switcher-ii/) 模拟、规律
- ? 🌟【easy】[836. 矩形重叠](https://leetcode.cn/problems/rectangle-overlap/) 规律、模拟、反推
- 🌟【hard】[面试题 17.19. 消失的两个数字](https://leetcode.cn/problems/missing-two-lcci/) 模拟题
- 🌟【easy】[1694. 重新格式化电话号码](https://leetcode.cn/problems/reformat-phone-number/) 模拟
- ?🌟【medium】[面试题 08.14. 布尔运算](https://leetcode.cn/problems/boolean-evaluation-lcci/) 枚举、模拟、DFS、递归
- ?🌟【medium】[面试题 16.13. 平分正方形](https://leetcode.cn/problems/bisect-squares-lcci/) 模拟
- ?🌟【medium】[面试题 16.14. 最佳直线](https://leetcode.cn/problems/best-line-lcci/) 模拟、暴力查找
- ?🌟【medium】[面试题 17.11. 单词距离](https://leetcode.cn/problems/find-closest-lcci/) 模拟
- ???🌟【medium】[927. 三等分](https://leetcode.cn/problems/three-equal-parts/) 模拟
- ??🌟【medium】[593. 有效的正方形](https://leetcode.cn/problems/valid-square/) 模拟、哈希表
- 🌟【easy】[258. 各位相加](https://leetcode.cn/problems/add-digits/) 模拟、数学问题、数论
- ?🌟【meidum】[397. 整数替换](https://leetcode.cn/problems/integer-replacement/) 递归、规律、模拟

### 模拟运算

- 🌟【medium】[166. 分数到小数](https://leetcode.cn/problems/fraction-to-recurring-decimal/) 哈希表、模拟运算
- 🌟【easy】[剑指 Offer 65. 不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/) 二进制、位运算
- 🌟【medium】[43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/) 字符串

## 区间问题、上下车问题、差分

- 🌟【medium】[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/) 贪心
- 🌟【medium】[1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/) 差分、扫描线、区间问题
- 🌟【easy】[1450. 在既定时间做作业的学生人数](https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/) 区间、区间权重累加、差分、二分搜索
- 🌟【medium】[253. 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/) 二分搜索、排序、单调栈、上下车问题、重叠区间问题
- 🌟【medium】[1094. 拼车](https://leetcode.cn/problems/car-pooling/) 上下车问题、差分

### 扫描线

- 🌟【medium】[1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/) 差分、扫描线、区间问题
- ??? 🌟【hard】[218. 天际线问题](https://leetcode.cn/problems/the-skyline-problem/) 排序、优先队列、大顶堆、扫描线
- ??? 🌟【hard】[850. 矩形面积 II](https://leetcode.cn/problems/rectangle-area-ii/) 扫描线

## 栈

- 【easy】 [20 有效的括号](https://leetcode.cn/problems/valid-parentheses/)
- 【easy】 [933 最近的请求次数](https://leetcode.cn/problems/number-of-recent-calls/)
- 🌟【easy】[20 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 栈
- 🌟【easy】[232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)
- 🌟【easy】[225 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)
- 🌟【medium】[剑指 Offer 31. 栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/) 栈
- 🌟【medium】[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/) 栈、数组题、字符串、逆波兰表达式、逆波兰
- 🌟【medium】[946. 验证栈序列](https://leetcode.cn/problems/validate-stack-sequences/) 栈
- ? 🌟【medium】[735. 行星碰撞](https://leetcode.cn/problems/asteroid-collision/) 栈
- ?🌟【medium】[面试题 03.03. 堆盘子](https://leetcode.cn/problems/stack-of-plates-lcci/) 栈
- ?🌟【medium】[面试题 03.05. 栈排序](https://leetcode.cn/problems/sort-of-stacks-lcci/) 栈
- 🌟【medium】[921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/) 栈
- 🌟【easy】[面试题 03.02. 栈的最小值](https://leetcode.cn/problems/min-stack-lcci/) 设计题、栈
- ??🌟【easy】[面试题 08.06. 汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/) 栈、递归
- 🌟【medium】[856. 括号的分数](https://leetcode.cn/problems/score-of-parentheses/) 递归、栈
- ??🌟【medium】[678. 有效的括号字符串](https://leetcode.cn/problems/valid-parenthesis-string/) 栈
- ?? [🌟【medium】1190. 反转每对括号间的子串](https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/) 栈、括号问题
- 🌟【easy】[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/) 字符串、双指针、栈
- 🌟【easy】[1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/) 栈

### 单调栈

- 🌟【hard】[84 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 
- 🌟【hard】[85 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)
- 🌟【medium】[739 每日温度](https://leetcode.cn/problems/daily-temperatures/)
- 🌟【medium】[剑指 Offer 59 - II. 队列的最大值](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/) 队列、栈、单调数组、双端队列
- 🌟【hard】[768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/) 排序、哈希表、单调栈
- 🌟【medium】[253. 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/) 二分搜索、排序、单调栈、上下车问题、重叠区间问题
- 🌟【medium】[503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/) 单调栈
- 🌟【easy】[1475. 商品折扣后的最终价格](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/) 单调栈
- ?🌟【medium】[907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/) 数组、单调栈
- ?🌟【medium】[2104. 子数组范围和](https://leetcode.cn/problems/sum-of-subarray-ranges/) 数组、单调栈
- ? 🌟【medium】[316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/) 单调栈
- ??🌟【medium】[面试题 16.16. 部分排序](https://leetcode.cn/problems/sub-sort-lcci/) 单调栈

## 队列

- 🌟【easy】[232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)
- 🌟【easy】[225 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)
- ? 🌟【medium】[622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/) 队列、循环队列
- 🌟【medium】[641. 设计循环双端队列](https://leetcode.cn/problems/design-circular-deque/) 队列、循环队列、双端队列、循环双端队列
- ?? 🌟【medium】[剑指 Offer II 043. 往完全二叉树添加节点](https://leetcode.cn/problems/NaqhDT/) 队列

## 链表

- 【medium】 [2 两数相加](https://leetcode.cn/problems/add-two-numbers/)
- 【easy】 [21 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
- 【hard】 [23 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
- 【easy】 [83 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)
- 【easy】 [141 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
- 【easy】 [206 反转链表](https://leetcode.cn/problems/reverse-linked-list/)
- 🌟【hard】[K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
- 🌟【medium】[143 重排链表](https://leetcode.cn/problems/reorder-list/)
- 【medium】[24 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)
- 🌟【medium】[82 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)
- 🌟【medium】[445 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)
- 🌟【easy】[234 回文链表](https://leetcode.cn/problems/palindrome-linked-list/) 快慢指针、链表
- 【easy】[剑指 Offer 18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/) 链表
- 🌟【medium】[剑指 Offer 35. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) 链表
- 🌟【easy】[剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/) 链表、链表公共节点
- 🌟【medium】[328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/) 链表操作
- 🌟【medium】[86. 分隔链表](https://leetcode.cn/problems/partition-list/) 链表
- 🌟【medium】[147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/) 链表、插入排序、排序
- 🌟【medium】[708. 循环有序列表的插入](https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/) 链表
- 🌟【medium】[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) 循环链表
- ? 🌟【medium】[430. 扁平化多级双向链表](https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/) 链表、双向链表

## 集合

- 【easy】 [349 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

## 字典、滑动窗口、双指针

- 【easy】 [1 两数之和](https://leetcode.cn/problems/two-sum/)
- 【medium】 [3 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
- 【hard】 [76 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)
- 【medium】 [567 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)
- 🌟【hard】 [440 字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)
- 【medium】[167 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)
- 🌟【medium】[713 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)
- 🌟【medium】[11 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) 双指针
- 🌟【medium】[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) 双指针、滑动窗口
- 🌟【easy】[557 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/) 双指针、字符串
- 🌟【easy】[剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/) 双指针、滑动窗口
- 【easy】[剑指 Offer 57. 和为s的两个数字](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/) 双指针
- 🌟【medium】[487. 最大连续1的个数 II](https://leetcode.cn/problems/max-consecutive-ones/) 双指针、滑动窗口
- 🌟【medium】[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/) 双指针、滑动窗口
- 🌟【medium】[524. 通过删除字母匹配到字典里最长单词](https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/) 双指针、字符串
- 🌟【medium】[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/) 双指针、滑动窗口
- ? 🌟【medium】[161. 相隔为 1 的编辑距离](https://leetcode.cn/problems/one-edit-distance/) 双指针、动态规划
- ?? 🌟【medium】[剑指 Offer II 007. 数组中和为 0 的三个数](https://leetcode.cn/problems/1fGaJU/) 排序、双指针
- 🌟【medium】[剑指 Offer II 008. 和大于等于 target 的最短子数组](https://leetcode.cn/problems/2VG8Kg/) 双指针、滑动窗口
- ?? 🌟【medium】[剑指 Offer II 014. 字符串中的变位词](https://leetcode.cn/problems/MPnaiL/) 滑动窗口、哈希表
- ?? 🌟【medium】[剑指 Offer II 015. 字符串中的所有变位词](https://leetcode.cn/problems/VabMRr/) 滑动窗口
- ??? 🌟【medium】[剑指 Offer II 057. 值和下标之差都在给定的范围内](https://leetcode.cn/problems/7WqeDu/) 桶排序、滑动窗口
- ?? 🌟【medium】[777. 在LR字符串中交换相邻字符](https://leetcode.cn/problems/swap-adjacent-in-lr-string/) 双指针

## 树、深度优先、广度优先

- 【easy】 [94 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
- 【easy】 [100 相同的树](https://leetcode.cn/problems/same-tree/)
- 【easy】 [101 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
- 【medium】 [102 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
- 【easy】 [104 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
- 【easy】 [111 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
- 【easy】 [112 路径总和](https://leetcode.cn/problems/path-sum/)
- 【easy】 [226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
- 🌟【easy】 [543 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
- 【medium】 [298 二叉树最长连续序列](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/)
- 【medium】 [236 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
- 【medium】 [剑指 Offer 26 树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)
- 🌟【medium】 [652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)
- 🌟【medium】 [113 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)
- 🌟【medium】[98 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) 二叉树、二叉搜索树、DFS
- 🌟【easy】[617 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)
- 🌟【medium】[114 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/) 二叉树、链表
- 🌟【hard】[剑指 Offer 37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/) 二叉树
- 🌟【medium】[剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/) 二叉树、BFS
- 🌟【easy】[剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/) 二叉树、BFS
- 🌟【medium】[剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/) 二叉树、二叉树的最近公共祖先
- 🌟【easy】[剑指 Offer 55 - II. 平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/) 二叉树、平衡二叉树
- 🌟【medium】[剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) 二叉树、二叉树路径和
- 🌟【medium】[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 二叉树、二叉树中的路径和
- 🌟【easy】[剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/) 二叉树、对称二叉树
- 🌟【easy】[剑指 Offer 27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/) 二叉树、二叉树镜像构造
- 🌟【medium】[116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) 二叉树、规律题
- 🌟【medium】[1302. 层数最深叶子节点的和](https://leetcode.cn/problems/deepest-leaves-sum/) 层序遍历、广度优先搜索、深度优先搜索、BFS、DFS
- 🌟【medium】[107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/) 二叉树、层序遍历、广度优先搜索、BFS
- 🌟【medium】[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/) 二叉树
- 🌟【hard】[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/) 二叉树
- 🌟【medium】[988. 从叶结点开始的最小字符串](https://leetcode.cn/problems/smallest-string-starting-from-leaf/) 二叉树
- 🌟【medium】[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/all-paths-from-source-to-target/) 二叉树、二叉树构建
- 🌟【medium】[513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/) 广度优先搜索、层序遍历
- 🌟【medium】[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/) 二叉树、二叉树构建
- 🌟【medium】[998. 最大二叉树 II](https://leetcode.cn/problems/maximum-binary-tree-ii/) 二叉树、二叉树构建
- 🌟【medium】[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/) 二叉树
- 🌟【medium】[655. 输出二叉树](https://leetcode.cn/problems/print-binary-tree/) 二叉树
- 🌟【medium】[429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/) 树、N叉树
- 🌟【easy】[589. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/) 树、N叉树
- 🌟【medium】[241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/) 递归、字符串、DFS
- ? 🌟【medium】[662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/) 二叉树、广度优先搜索
- 🌟【medium】[687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/) 二叉树、深度优先搜索
- ? 🌟【medium】[430. 扁平化多级双向链表](https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/) 链表、双向链表
- 🌟【medium】[814. 二叉树剪枝](https://leetcode.cn/problems/binary-tree-pruning/) 二叉树、二叉树减枝
- 🌟【medium】[1104. 二叉树寻路](https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/) 二叉树
- ?? 🌟【medium】[863. 二叉树中所有距离为 K 的结点](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/) 二叉树、图、广度优先搜索、深度优先搜索
- ?🌟【easy】[572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/) 二叉树

### 树的序列化

- ? 🌟【medium】[536. 从字符串生成二叉树](https://leetcode.cn/problems/construct-binary-tree-from-string/) 二叉树、二叉树序列化
- ? 🌟【hard】[428. 序列化和反序列化 N 叉树](https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/) 二叉树、N叉树、N叉树序列化
- 🌟【hard】[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/) 二叉树、序列化
- 🌟【medium】[449. 序列化和反序列化二叉搜索树](https://leetcode.cn/problems/serialize-and-deserialize-bst/) 二叉树、序列化
- 🌟【medium】[652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/) 二叉树、二叉树序列化
- 🌟【easy】[606. 根据二叉树创建字符串](https://leetcode.cn/problems/construct-string-from-binary-tree/) 二叉树、二叉树序列化

### 二叉搜索树

- 🌟【medium】[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/) 二叉树、二叉搜索树、累加树
- 🌟【medium】[230 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/) 二叉搜索树
- 🌟【easy】[235 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/) 二叉树、二叉搜索树
- 🌟【medium】[剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/) 二叉搜索树、双向链表、链表
- 🌟【medium】 [96 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)
- 🌟【medium】[剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/) 二叉搜索树、后序遍历
- 🌟【easy】[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) 二叉搜索树
- 🌟【easy】[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/) 二叉搜索树、平衡二叉树
- 🌟【medium】[285. 二叉搜索树中的中序后继](https://leetcode.cn/problems/inorder-successor-in-bst/) 二叉搜索树
- 🌟【medium】[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/) 二叉搜索树
- 🌟【medium】[701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/) 二叉搜索树
- 🌟【medium】[109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/) 二叉搜索树
- 🌟【medium】[95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/) 二叉搜索树
- 🌟【medium】[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/) 二叉搜索树
- ? 🌟【medium】[173. 二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/) 迭代器、二叉搜索树
- ? 🌟【medium】[669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/) 二叉搜索树、深度优先搜索
- 🌟【easy】[面试题 17.12. BiNode](https://leetcode.cn/problems/binode-lcci/) 二叉搜索树
- 🌟【medium】[1305. 两棵二叉搜索树中的所有元素](https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/) 二叉搜索树

## 堆、小顶堆、大顶堆、优先队列

- 【hard】 [23 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
- 🌟【medium】 [215 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
- 【easy】 [226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
- 【easy】 [347 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)
- 🌟【hard】[630 课程表 III](https://leetcode.cn/problems/course-schedule-iii/) 贪心、优先队列、堆
- 🌟【medium】[378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) 分治法、归并排序、优先队列、小顶堆、二分搜索
- ??? 🌟【hard】[218. 天际线问题](https://leetcode.cn/problems/the-skyline-problem/) 排序、优先队列、大顶堆
- 🌟【medium】[692. 前K个高频单词](https://leetcode.cn/problems/top-k-frequent-words/) 优先队列、堆、小顶堆、前k个问题
- ? 🌟【medium】[面试题 17.14. 最小K个数](https://leetcode.cn/problems/smallest-k-lcci/) 堆、优先队列、快速选择、前k个问题
- ? 🌟【medium】[973. 最接近原点的 K 个点](https://leetcode.cn/problems/k-closest-points-to-origin/) 优先队列、快速选择、分治法、堆、前K个问题
- ?? 🌟【medium】[剑指 Offer II 061. 和最小的 k 个数对](https://leetcode.cn/problems/qn8gGX/) 优先队列
- 🌟【easy】[1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/) 堆、大顶堆、优先队列

### 矩阵、深度优先、广度优先
- [🌟【medium】1034. 边界着色](https://leetcode.cn/problems/coloring-a-border/) 矩阵、深度优先搜索、广度优先搜索
- 【medium】 [417 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)
- 【medium】 [200 岛屿数量](https://leetcode.cn/problems/number-of-islands/)
- 🌟【medium】[130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/) 矩阵、深度优先搜索
- 🌟【medium】[289. 生命游戏](https://leetcode.cn/problems/game-of-life/) 矩阵、原地算法
- 🌟【medium】[994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/) 广度优先搜索
- 🌟【medium】[286. 墙与门](https://leetcode.cn/problems/walls-and-gates/) 广度优先搜索、多源广度优先搜索
- 🌟【medium】[面试题 01.07. 旋转矩阵](https://leetcode.cn/problems/rotate-matrix-lcci/) 矩阵、原地旋转矩阵
- 🌟【medium】[304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/) 矩阵、前缀数组、二维前缀数组
- 🌟【medium】[542. 01 矩阵](https://leetcode.cn/problems/01-matrix/) 广度优先搜索、多起点问题
- ? 🌟【medium】[694. 不同岛屿的数量](https://leetcode.cn/problems/number-of-distinct-islands/) 矩阵、深度优先搜索、哈希表、集合
- ??? 🌟【hard】[711. 不同岛屿的数量 II](https://leetcode.cn/problems/number-of-distinct-islands-ii/) 深度优先搜索、哈希表、排序、集合
- ??? 🌟【hard】[827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/) 矩阵、深度优先搜索
- 🌟【medium】[面试题 16.19. 水域大小](https://leetcode.cn/problems/pond-sizes-lcci/) DFS、深度优先搜索
- ?🌟【medium】[面试题 17.23. 最大黑方阵](https://leetcode.cn/problems/max-black-square-lcci/) 矩阵
- ? 🌟【hard】[剑指 Offer II 112. 最长递增路径](https://leetcode.cn/problems/fpTFWP/) 图、广度优先搜索、深度优先搜索、记忆化搜索
- ?🌟【medium】[1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/) 矩阵、广度优先搜索

### 图、深度优先、广度优先
- 【medium】 [133 克隆图](https://leetcode.cn/problems/clone-graph/)
- 🌟【hard】 [815 公交路线](https://leetcode.cn/problems/bus-routes/)
- 🌟【medium】 [207 课程表](https://leetcode.cn/problems/course-schedule/) 图、拓扑排序
- 🌟【medium】[210 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 图、拓扑排序
- 🌟【hard】[127. 单词接龙](https://leetcode.cn/problems/word-ladder/) 图、BFS、广度优先搜索
- ??? 🌟【hard】[269. 火星词典](https://leetcode.cn/problems/alien-dictionary/) 拓扑排序、深度优先搜索
- 🌟【medium】[797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/) 图、深度有优先搜索 时间复杂度分析比较麻烦
- 🌟【medium】[785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/) 图、深度优先搜索、广度优先搜索
- 🌟【medium】[752. 打开转盘锁](https://leetcode.cn/problems/open-the-lock/) 广度优先搜索
- 🌟【medium】[547. 省份数量](https://leetcode.cn/problems/number-of-provinces/) 深度优先、广度优先
- ? 🌟【medium】[721. 账户合并](https://leetcode.cn/problems/accounts-merge/) 深度优先、广度优先、图
- 🌟【medium】[737. 句子相似性 II](https://leetcode.cn/problems/sentence-similarity-ii/) 图、广度优先搜索
- 🌟【medium】[323. 无向图中连通分量的数目](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/) 图、广度优先搜索、并查集
- ? 🌟【medium】[261. 以图判树](https://leetcode.cn/problems/graph-valid-tree/) 并查集、广度优先搜索
- 🌟【medium】[841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/) 图、深度优先搜索、广度优先搜索
- ?🌟【medium】[面试题 17.07. 婴儿名字](https://leetcode.cn/problems/baby-names-lcci/) 图、广度优先搜索
- ?🌟【medium】[面试题 17.22. 单词转换](https://leetcode.cn/problems/word-transformer-lcci/) 图、深度优先搜索
- 🌟【hard】[剑指 Offer II 108. 单词演变](https://leetcode.cn/problems/om3reC/) 图、广度优先搜索
- 🌟【medium】[433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/) 广度优先搜索、BFS、DFS
- ?🌟【hard】[剑指 Offer II 117. 相似的字符串](https://leetcode.cn/problems/H6lPxb/) 图、广度优先搜索
- 🌟【medium】[886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/) 图、广度优先搜索、深度优先搜索
- 🌟【medium】[690. 员工的重要性](https://leetcode.cn/problems/employee-importance/) 图、广度优先搜索

### 并查集

- ?? 🌟【medium】[684. 冗余连接](https://leetcode.cn/problems/redundant-connection/) 并查集、图、树、拓扑
- ??? 🌟【hard】[685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/) 并查集、广度优先搜索、图、树、拓扑
- ? 🌟【medium】[261. 以图判树](https://leetcode.cn/problems/graph-valid-tree/) 并查集、广度优先搜索
- 🌟【medium】[990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/) 并查集
## 搜索、排序

- 【easy】 [374 猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)

## 分治法

特征是：先拆分、再解决、后合并

将一个问题拆分成很多个和原问题相似的小问题，递归解决小问题，再将结果合并以解决原来的问题

- 【easy】[100 相同的树](https://leetcode.cn/problems/same-tree/)
- 【easy】[226 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
- ?? 🌟【medium】[395. 至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/) 分治法
- 🌟【medium】[378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) 分治法、归并排序、优先队列、小顶堆、二分搜索
- ? 🌟【medium】[973. 最接近原点的 K 个点](https://leetcode.cn/problems/k-closest-points-to-origin/) 优先队列、快速选择、分治法、堆、前K个问题

## 动态规划

特征是：某个结果会依赖前面的结果，或者前面的几个结果之间有关联


- 【easy】 [70 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
- 【easy】[121 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
- 【medium】 [122 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
- 【hard】 [123 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)
- 【hard】 [188 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)
- 【medium】 [714 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
- 【medium】 [198 打家劫舍](https://leetcode.cn/problems/house-robber/)
- 【medium】 [309 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
- 【hard】 [42 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
- 🌟【medium】 [53 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
- 🌟【medium】 [300 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
- 🌟【hard】 [72 编辑距离](https://leetcode.cn/problems/edit-distance/)
- 🌟【hard】 [10 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)
- 🌟【hard】 [32 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)
- 🌟【medium】 [152 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)
- 🌟【medium】 [剑指 Offer 13 机器人的运动范围](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)
- 🌟【01背包】【medium】 [416 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
- 【medium】 [139 单词拆分](https://leetcode.cn/problems/word-break/)
- 【medium】 [剑指 Offer 46 把数字翻译成字符串](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)
- 【medium】 [343 整数拆分](https://leetcode.cn/problems/integer-break/)
- 【medium】 [62 不同路径](https://leetcode.cn/problems/unique-paths/)
- ? 🌟【medium】 [1143 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)
- 🌟【medium】 [213 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
- 🌟【medium】 [337 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)
- 🌟【hard】[879 盈利计划](https://leetcode.cn/problems/profitable-schemes/)
- 🌟【medium】[313 超级丑数](https://leetcode.cn/problems/super-ugly-number/)
- 🌟【medium】[256 粉刷房子](https://leetcode.cn/problems/paint-house/)
- 🌟【hard】[312. 戳气球](https://leetcode.cn/problems/burst-balloons/) 开区间动态规划
- 🌟【medium】[剑指 Offer 14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/) 动态规划
- 🌟【medium】[剑指 Offer 47. 礼物的最大价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/) 动态规划
- 🌟【medium】[91. 解码方法](https://leetcode.cn/problems/decode-ways/) 动态规划、模拟、字符串题
- 🌟【medium】[120. 三角形最小路径和](https://leetcode.cn/problems/triangle/) 动态规划
- 🌟【medium】[413. 等差数列划分](https://leetcode.cn/problems/arithmetic-slices/) 动态规划
- 🌟【medium】[983. 最低票价](https://leetcode.cn/problems/minimum-cost-for-tickets/) 动态规划
- ? 🌟【medium】[718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/) 动态规划
- ? 🌟【medium】[740. 删除并获得点数](https://leetcode.cn/problems/delete-and-earn/) 动态规划
- ? 🌟【medium】[334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/) 贪心、动态规划、二分搜索
- ? 🌟【medium】[583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/) 字符串、动态规划
- ? 🌟【medium】[712. 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/) 动态规划、公共子序列、字符串
- ?? 🌟【medium】[377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/) 动态规划、排列组合
- ?? 🌟【medium】[97. 交错字符串](https://leetcode.cn/problems/interleaving-string/) 动态规划
- 🌟【medium】[931. 下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/) 动态规划、滚动数组
- ? 🌟【medium】[650. 只有两个键的键盘](https://leetcode.cn/problems/2-keys-keyboard/) 动态规划
- ? 🌟【medium】[161. 相隔为 1 的编辑距离](https://leetcode.cn/problems/one-edit-distance/) 双指针、动态规划
- ? 🌟【medium】[1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/) 动态规划
- ?? 🌟【medium】[剑指 Offer II 093. 最长斐波那契数列](https://leetcode.cn/problems/Q91FMA/) 动态规划
- 🌟【medium】[64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/) 动态规划
- ???🌟【hard】[801. 使序列递增的最小交换次数](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/) 动态规划
- ?? 🌟【medium】[673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/) 动态规划、递增子序列
- ??? 🌟【hard】[115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/) 动态规划
- ???🌟【hard】[940. 不同的子序列 II](https://leetcode.cn/problems/distinct-subsequences-ii/) 子序列、动态规划

### 动态规划 - 背包问题

- 🌟【hard】[879 盈利计划](https://leetcode.cn/problems/profitable-schemes/) 多维费用背包
- 🌟【medium】[322 零钱兑换](https://leetcode.cn/problems/coin-change/) 【01背包】
- 🌟【medium】[416 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/) 背包问题
- 🌟【medium】[698 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)
- 🌟【medium】[279 完全平方数](https://leetcode.cn/problems/perfect-squares/)
- 🌟【medium】[518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/) 动态规划、背包问题
- ?? 🌟【medium】[474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/) 动态规划、背包问题
- ?? 🌟【medium】[剑指 Offer II 102. 加减的目标值](https://leetcode.cn/problems/YaVDxD/) 动态规划、回溯法、01背包、背包问题
- ?? [🌟【medium】剑指 Offer II 103. 最少的硬币数目](https://leetcode.cn/problems/gaM7Ch/) 动态规划、背包问题
- ?? [🌟【medium】剑指 Offer II 104. 排列的数目](https://leetcode.cn/problems/D0F0SV/) 动态规划、背包问题、有序背包
- ? 🌟【easy】[剑指 Offer II 101. 分割等和子集](https://leetcode.cn/problems/NUPfPr/) 动态规划、01背包、背包问题
- 🌟【medium】[面试题 08.11. 硬币](https://leetcode.cn/problems/coin-lcci/) 动态规划、背包问题、完全背包
- ??🌟【medium】[面试题 17.13. 恢复空格](https://leetcode.cn/problems/re-space-lcci/) 动态规划、背包问题、完全背包
- ???🌟【medium】[1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/) 动态规划、01背包、背包问题

## 贪心思想

特征是：期盼通过每个阶段的局部最优选择，从而达到全局的最优，结果并不一定是最优。

- 【medium】 [5 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
- 【easy】 [455 分发饼干](https://leetcode.cn/problems/assign-cookies/)
- 🌟【hard】 [135 分发糖果](https://leetcode.cn/problems/candy/)
- 🌟【hard】[630 课程表 III](https://leetcode.cn/problems/course-schedule-iii/) 贪心、优先队列、堆
- 🌟【medium】[334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/) 数组题、贪心
- 🌟【medium】[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/) 贪心
- 🌟【medium】[452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/) 贪心
- 🌟【medium】[665. 非递减数列](https://leetcode.cn/problems/non-decreasing-array/) 贪心
- 🌟【medium】[646. 最长数对链](https://leetcode.cn/problems/maximum-length-of-pair-chain/) 贪心、区间问题
- 🌟【medium】[781. 森林中的兔子](https://leetcode.cn/problems/rabbits-in-forest/) 贪心
- ? 🌟【medium】[991. 坏了的计算器](https://leetcode.cn/problems/broken-calculator/) 贪心
- ??🌟【medium】[881. 救生艇](https://leetcode.cn/problems/boats-to-save-people/) 贪心
- ?🌟【meidum】[1014. 最佳观光组合](https://leetcode.cn/problems/best-sightseeing-pair/) 数组题、规律、脑筋急转弯、贪心

## 回溯思想

回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

- 【medium】 [46 全排列](https://leetcode.cn/problems/permutations/)
- 【medium】 [47 全排列 II](https://leetcode.cn/problems/permutations-ii/)
- 【medium】 [78 子集](https://leetcode.cn/problems/subsets/)
- 【medium】 [22 括号生成](https://leetcode.cn/problems/generate-parentheses/)
- 🌟【medium】 [93 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)
- 【medium】 [17 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
- 🌟【hard】 [51 N 皇后](https://leetcode.cn/problems/n-queens/)
- 🌟【hard】 [37 解数独](https://leetcode.cn/problems/sudoku-solver/)
- 🌟【medium】 [79 单词搜索](https://leetcode.cn/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/)
- 🌟【medium】[494 目标和](https://leetcode.cn/problems/target-sum/)
- 🌟【hard】[212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/) 字典树、回溯
- 🌟【hard】[980. 不同路径 III](https://leetcode.cn/problems/unique-paths-iii/) 回溯法
- 🌟【medium】[216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/) 回溯
- ? 🌟【medium】[784. 字母大小写全排列](https://leetcode.cn/problems/letter-case-permutation/) 排列组合、回溯
- 🌟【medium】[1087. 花括号展开](https://leetcode.cn/problems/brace-expansion/) 回溯、排列
- 🌟【medium】[77. 组合](https://leetcode.cn/problems/combinations/) 回溯法、排列组合
- ? 🌟【medium】[39. 组合总和](https://leetcode.cn/problems/combination-sum/) 回溯法、排列组合
- ? 🌟【easy】[401. 二进制手表](https://leetcode.cn/problems/binary-watch/) 回溯法、枚举
- ? 🌟【medium】[254. 因子的组合](https://leetcode.cn/problems/factor-combinations/) 回溯法、排列组合
- 🌟【medium】[267. 回文排列 II](https://leetcode.cn/problems/palindrome-permutation-ii/) 字符串、回文、回溯法
- ? 🌟【hard】[60. 排列序列](https://leetcode.cn/problems/permutation-sequence/) 回溯法、排列组合、规律题
- ? 🌟【medium】[526. 优美的排列](https://leetcode.cn/problems/beautiful-arrangement/) 回溯法、排列组合

## 二分查找、二分搜索

- 【easy】 [704 二分查找](https://leetcode.cn/problems/binary-search/)
- 🌟【hard】 [4 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)
- 🌟【easy】 [278 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)
- 🌟【medium】[33 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
- 🌟【medium】[34 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
- 🌟【medium】[475 供暖器](https://leetcode.cn/problems/heaters/)
- 🌟【medium】[540 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)
- 🌟【medium】[153 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
- 🌟【hard】[154 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)
- 🌟【medium】[162 寻找峰值](https://leetcode.cn/problems/find-peak-element/)
- 🌟【easy】[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/) 二分搜索
- 🌟【medium】[剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/) 二分搜索
- 🌟【medium】[378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) 分治法、归并排序、优先队列、小顶堆、二分搜索
- 🌟【medium】[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) 动态规划、二分搜索
- 🌟【hard】[354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/) 递增子序列问题、二分搜索
- 🌟【medium】[253. 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/) 二分搜索、排序、单调栈、上下车问题、重叠区间问题
- 🌟【easy】[1450. 在既定时间做作业的学生人数](https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/) 区间、区间权重累加、差分、二分搜索
- 🌟【medium】[852. 山脉数组的峰顶索引](https://leetcode.cn/problems/count-primes/) 二分搜索
- 🌟【medium】[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) 循环链表，二分搜索
- 🌟【medium】[633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/) 二分搜索、规律
- 【easy】[367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/) 规律、数学、平方
- 🌟【medium】[658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/) 二分搜索
- ??? 🌟【hard】[793. 阶乘函数后 K 个零](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/) 阶乘、二分搜索
- ? 🌟【medium】[334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/) 贪心、动态规划、二分搜索
- 🌟【easy】[1150. 检查一个数是否在数组中占绝大多数](https://leetcode.cn/problems/check-if-a-number-is-majority-element-in-a-sorted-array/) 二分搜索
- 🌟【medium】[1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/) 二分搜索
- ? 🌟【medium】[875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/) 二分搜索
- 🌟【hard】[1231. 分享巧克力](https://leetcode.cn/problems/divide-chocolate/) 二分搜索
- 🌟【medium】[面试题 10.03. 搜索旋转数组](https://leetcode.cn/problems/search-rotate-array-lcci/) 二分搜索
- 🌟【medium】[面试题 16.06. 最小差](https://leetcode.cn/problems/smallest-difference-lcci/) 二分搜索
- ?🌟【medium】[面试题 17.08. 马戏团人塔](https://leetcode.cn/problems/circus-tower-lcci/) 二分搜索、俄罗斯套娃问题
- ?🌟【easy】[面试题 10.05. 稀疏数组搜索](https://leetcode.cn/problems/sparse-array-search-lcci/) 二分搜索、稀疏数组
- ??🌟【medium】[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/) 二叉树、二分搜索
- ??🌟【medium】[611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/) 二分搜索、排序
- ?? 🌟【medium】[792. 匹配子序列的单词数](https://leetcode.cn/problems/number-of-matching-subsequences/) 二分搜索、哈希表
- 🌟【easy】[441. 排列硬币](https://leetcode.cn/problems/arranging-coins/) 二分搜索

## 排序算法的应用

### 冒泡

- ?[🌟【medium】969. 煎饼排序](https://leetcode.cn/problems/pancake-sorting/) 模拟、排序


### 归并

逆序对、链表排序

- 🌟【medium】[48 排序链表](https://leetcode.cn/problems/sort-list/)
- 🌟【hard】[315 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)
- 🌟【hard】[剑指 Offer 51 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

### 堆排序

前 K 大、前 K 小、单调队列

- 🌟【medium】[347 前 K 个高频元素【medium】](https://leetcode.cn/problems/top-k-frequent-elements/)

### 快排

前k个问题、快速选择

- ? 🌟【medium】[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/) 快排、快速排序、快速选择、快排相关算法
- ? 🌟【medium】[面试题 17.14. 最小K个数](https://leetcode.cn/problems/smallest-k-lcci/) 堆、优先队列、快速选择、前k个问题
- ? 🌟【medium】[973. 最接近原点的 K 个点](https://leetcode.cn/problems/k-closest-points-to-origin/) 优先队列、快速选择、分治法、堆、前K个问题
- 🌟【easy】[905. 按奇偶排序数组](https://leetcode.cn/problems/sort-array-by-parity/) 排序、数组题

### 桶排序、计数排序

- ? 🌟【medium】[451. 根据字符出现频率排序](https://leetcode.cn/problems/sort-characters-by-frequency/) 桶排序、桶排序衍生算法
- ? 🌟【medium】[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/) 堆排序、排序、桶排序
- 🌟【easy】[1608. 特殊数组的特征值](https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/) 桶排序、计数排序、排序
- ??? 🌟【medium】[剑指 Offer II 057. 值和下标之差都在给定的范围内](https://leetcode.cn/problems/7WqeDu/) 桶排序、滑动窗口
- 🌟【easy】[1122. 数组的相对排序](https://leetcode.cn/problems/relative-sort-array/) 计数排序

### 插入排序

- 🌟【medium】[147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/) 链表、插入排序、排序
- ? 🌟【easy】[剑指 Offer II 075. 数组相对排序](https://leetcode.cn/problems/0H97ZC/) 排序


# 二进制

## 与或非异或

与 `&`，或 `|`，非 `~`, 异或 `^`

`8(1000) & 7(0111) => 0`

`8(1000) | 7(0111) => 15(1111)`

`~8(1000) => -9(-1001)` 符号位也被取反了

`9(1001) ^ 10(1010) => 3(0011)`

相关位运算题目：[二进制相关](#二进制相关)

# 时间复杂度和空间复杂度

递归时间复杂度就是看它 每次递归进行了什么操作和递归了多少次

递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度

或者说递归算法的空间复杂度是任一时刻，占用的空间是多少

## 递归算法的时间与空间复杂度分析

- [递归算法的时间与空间复杂度分析！](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md)
- [程序员算法面试中，递归算法的空间复杂度你知道怎么求么？](https://blog.csdn.net/youngyangyang04/article/details/106313759)

# 😻✔ 基础算法 

常见复杂度曲线：

![](https://qiniu1.lxfriday.xyz/feoffer/1652356442444_09edc6aa-6dfe-41aa-bd02-b9f3097b3717.png)

排序算法排序流程图解：

[https://visualgo.net/zh/sorting](https://visualgo.net/zh/sorting)

## 😻✔ 排序算法 

ref

- [丰富图例讲解十大经典排序算法](https://juejin.im/post/5d9033fa5188257f6f1ba46b)
- [排序算法](https://github.com/lxfriday/give-me-job/tree/7c193c8279/algorithm/%E6%8E%92%E5%BA%8F)

![排序算法一览](https://qiniu1.lxfriday.xyz/feoffer/sort.png)

### 😻✔ 冒泡排序 

![](https://qiniu1.lxfriday.xyz/feoffer/bubbleSort.png)

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function bubbleSort(arr) {
  const length = arr.length
  if (length <= 1) return arr
  for (let i = 0; i < length; i++) {
    let changed = false // 没有数据交换则表示已经有序了
    for (let j = 0; j < length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
        changed = true
      }
    }
    if (!changed) break
  }
  return arr
}
```

### 😻✔ 选择排序 

![](https://qiniu1.lxfriday.xyz/feoffer/ec43f415-5224-bd9b-ad33-0ee480cd19e7.png)

![](https://qiniu1.lxfriday.xyz/feoffer/selectionSort.gif)

核心思想：进行 n 轮，每轮找出最小的放在这一轮的初始位置

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function selectionSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  for (let i = 0; i < len; i++) {
    let min = i
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[min]) min = j
    }
    swap(arr, i, min)
  }

  return arr
}
```

### 😻✔ 插入排序 

![](https://qiniu1.lxfriday.xyz/feoffer/6e79c1d5-2896-68bc-ebc0-280ee2881035.png)

![](https://qiniu1.lxfriday.xyz/feoffer/insertionSort.gif)

```javascript
function insertionSort(arr) {
  const len = arr.length
  if (len <= 1) return arr

  for (let i = 1; i < len; i++) {
    const cur = arr[i]
    let j = i - 1
    for (; j >= 0; j--) {
      if (arr[j] > cur) {
        arr[j + 1] = arr[j]
      } else {
        break
      }
    }
    arr[j + 1] = cur
  }

  return arr
}
```

### 😻✔ 快速排序 

![](https://qiniu1.lxfriday.xyz/feoffer/008ba6a2-d847-8894-a3b4-70b09a1b44b8.png)

![](https://qiniu1.lxfriday.xyz/feoffer/quicksort.gif)

复杂度分析：

- [快速排序的时间复杂度](https://www.cnblogs.com/tuyang1129/p/12857821.html#22-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)

快排的最好时间复杂度是O(logn)、最差会退化到 O(n^2)。




单路快排

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
function partition(arr, left, right) {
  let pivot = left
  let index = pivot + 1
  for (let i = index; i <= right; i++) {
    if (arr[i] < arr[pivot]) {
      swap(arr, i, index)
      index++
    }
  }
  swap(arr, pivot, index - 1)
  return index - 1
}

function quickSort(arr, l, r) {
  const len = arr.length
  const left = typeof l === 'number' ? l : 0
  const right = typeof r === 'number' ? r : len - 1
  let partitionIndex = 0
  if (left < right) {
    partitionIndex = partition(arr, left, right)
    quickSort(arr, left, partitionIndex - 1)
    quickSort(arr, partitionIndex + 1, right)
  }

  return arr
}
```

更好理解的快排

```js
function partition2(arr) {
  if (arr.length <= 1) return arr
  const target = arr[0]
  const leftArr = []
  const rightArr = []
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < target) {
      leftArr.push(arr[i])
    } else {
      rightArr.push(arr[i])
    }
  }
  return [...partition2(leftArr), target, ...partition2(rightArr)]
}

function quickSort2(arr) {
  return partition2(arr)
}
```

### 😻✔ 归并排序 

![](https://qiniu1.lxfriday.xyz/feoffer/3ccf988e-b992-84f0-a622-dd03c51123c9.png)

![](https://qiniu1.lxfriday.xyz/feoffer/d3de0b1f-7827-e3b9-eeb7-1993e03e0372.png)

![](https://qiniu1.lxfriday.xyz/feoffer/16d7b507ece11c9d.gif)

归并排序（英语：Merge sort，或 mergesort），是创建在归并操作上的一种有效的排序算法，效率为 O(nlogn)。1945 年由约翰·冯·诺伊曼首次提出。该算法是采用 分治法（Divide and Conquer） 的一个非常典型的应用，且各层分治递归可以同时进行。

采用分治法:

1. 分割：递归地把当前序列平均分割成两半。
1. 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。

归并排序时间复杂度分析

- [快速排序和归并排序的时间复杂度分析——通俗易懂](https://www.cnblogs.com/tuyang1129/p/12857821.html)

时间复杂度计算方式：递归层数 * 每层的时间复杂度(logn * n)，每层的时间复杂度都是n，都会把 n 个元素全部遍历一遍，而递归的层数取决于拆分的次数，n个元素需要拆分 logn 次。

空间复杂度计算方式：任一时刻占用的空间，


比较容易理解的版本

```javascript
function merge(arr1, arr2) {
  const res = []
  while (arr1.length && arr2.length) {
    if (arr1[0] < arr2[0]) {
      res.push(arr1.shift())
    } else {
      res.push(arr2.shift())
    }
  }
  while (arr1.length) {
    res.push(arr1.shift())
  }
  while (arr2.length) {
    res.push(arr2.shift())
  }

  return res
}

function mergeSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  const m = Math.floor(len / 2)
  const arr1 = arr.slice(0, m)
  const arr2 = arr.slice(m)
  return merge(mergeSort(arr1), mergeSort(arr2))
}
```

执行效率更高的版本

```js
function mergeSort1(arr, l, r) {
  l = typeof l === 'number' ? l : 0
  r = typeof r === 'number' ? r : arr.length - 1
  if (r === l) return [arr[l]]
  const mid = Math.floor((l + r) / 2)
  return merge1(mergeSort1(arr, l, mid), mergeSort1(arr, mid + 1, r))
}
function merge1(arr1, arr2) {
  const res = []
  const len1 = arr1.length
  const len2 = arr2.length
  let l1 = 0
  let l2 = 0
  while (l1 < len1 && l2 < len2) {
    if (arr1[l1] <= arr2[l2]) {
      res.push(arr1[l1++])
    } else {
      res.push(arr2[l2++])
    }
  }
  while (l1 < len1) {
    res.push(arr1[l1++])
  }
  while (l2 < len2) {
    res.push(arr2[l2++])
  }
  return res
}
```

上面两个的归并排序在排序大数据量时将会有非常大的差距，原因在于前一个易于理解的版本大量使用了数组操作的函数(slice、shift)，而后者并没有这种操作。

```js
// 比较时间
const data = new Array(500000).fill(Math.random() * 1000000)
const data1 = data.slice(0)
console.time('mergeSort1')
mergeSort1(data)
console.timeLog('mergeSort1')
console.time('mergeSort2')
mergeSort2(data1)
console.timeLog('mergeSort2')

// mergeSort1: 44.905s
// mergeSort2: 81.709ms
```

迭代法实现

```js
// 迭代法实现归并排序
// 对 [i, j] 范围内的数字进行排序
// [i, j] 范围内的数字分为两半之后，两个部分都是已经排好序数组
function sort(arr, i, j) {
  const len = arr.length
  let firstL = i
  const firstR = Math.floor((i + j) / 2) // midIndex
  let secondL = firstR + 1
  const secondR = j
  // 需要一个数字暂存排序结果
  const tmp = []
  while (firstL <= firstR && secondL <= secondR && secondL < len) {
    if (arr[firstL] < arr[secondL]) {
      tmp.push(arr[firstL++])
    } else {
      tmp.push(arr[secondL++])
    }
  }
  while (firstL <= firstR) {
    tmp.push(arr[firstL++])
  }
  while (secondL <= secondR && secondL < len) {
    tmp.push(arr[secondL++])
  }
  let k = i
  while (k <= j && k < len) {
    arr[k] = tmp[k - i]
    k++
  }
}

function mergeSort(arr) {
  const len = arr.length
  // 拆分 logn 次
  // 每次拆分之后，总和来看进行的是对 n 个数字排序，空间复杂度是 O(n)，所有的数子都会被放到 tmp 数组中一次
  for (let i = 2; i < 2 * len; i *= 2) {
    // 对拆分的所有子序列进行排序，复杂度是 n
    for (let j = 0; i * j < len; j++) {
      const startIndex = i * j
      const endIndex = startIndex + i - 1
      const midIndex = Math.floor((startIndex + endIndex) / 2)
      // 结尾可能存在小于i个数的情况，这时候要判断要不要排序
      // 如果结尾有k个数，且 k > i / 2，则是需要排序的
      if (midIndex < len - 1) {
        sort(arr, startIndex, endIndex)
      }
    }
  }
  return arr
}
```

### 😻✔ 希尔排序 

![](https://qiniu1.lxfriday.xyz/feoffer/907976b2-e3b0-91fc-0b6d-3ead3ee08c1c.png)

![](https://qiniu1.lxfriday.xyz/feoffer/16d7b4ce200763d6.gif)

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

```javascript
function shellSort(arr) {
  const len = arr.length
  if (len <= 1) return arr
  // gap 不断缩小，最后变成 1
  for (let gap = len >> 1; gap > 0; gap >>= 1) {
    // gap 确定之后，从 gap 位置开始向后循环
    for (let i = gap; i < len; i++) {
      const temp = arr[i]
      let j = i - gap
      // i 每轮循环中需要从左往右做插排
      for (; j >= 0 && arr[j] > temp; j -= gap) {
        arr[j + gap] = arr[j]
      }
      arr[j + gap] = temp
    }
  }

  return arr
}
```

### 😻✔ 堆排序(heap-sort) 

![堆排序](https://qiniu1.lxfriday.xyz/feoffer/heapSort2.png)
![堆排序](https://qiniu1.lxfriday.xyz/feoffer/heapSort.gif)

堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。其中每个节点最多存在两个子节点，对以 0 开始的堆数组，有如下规则：

1. 父节点 `i` 的**左**子节点在位置 `2 * i + 1`
1. 父节点 `i` 的**右**子节点在位置 `2 * i + 2`
1. 子节点 `i` 的父节点在位置 `Math.floor((i - 1) / 2)`

大顶堆：所有节点 `i` 的值比其左右子节点都大的堆

小顶堆：所有节点 `i` 的值比其左右子节点都小的堆

堆排序的重要过程（以大顶堆实现从小到大为例）：

1. 构建大顶堆
1. 把 0 和最后一位交换（无序数组的最后一位）
1. 从 0 位重新构建大顶堆
1. 重复步骤 2、3

```javascript
const swap = (arr, a, b) => ([arr[a], arr[b]] = [arr[b], arr[a]])
// 构建大顶堆的核心递归算法
function heapifyMax(arr, i, len) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let max = i
  if (left < len && arr[left] > arr[max]) {
    max = left
  }
  if (right < len && arr[right] > arr[max]) {
    max = right
  }
  if (i != max) {
    swap(arr, max, i)
    heapifyMax(arr, max, len)
  }
}
// 构建小顶堆的核心递归算法
function heapifyMin(arr, i, len) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let min = i
  if (left < len && arr[left] < arr[min]) {
    min = left
  }
  if (right < len && arr[right] < arr[min]) {
    min = right
  }
  if (i != min) {
    swap(arr, min, i)
    heapifyMin(arr, min, len)
  }
}

function buildMaxHeap(arr) {
  const len = arr.length
  for (let i = Math.floor(len / 2); i >= 0; i--) {
    heapifyMax(arr, i, len)
  }
}

function buildMinHeap(arr) {
  const len = arr.length
  for (let i = Math.floor(len / 2); i >= 0; i--) {
    heapifyMin(arr, i, len)
  }
}

// asc 为 true 表示从小到大，false 为从大到小
function heapSort(arr, asc = false) {
  if (asc) {
    // 使用大顶堆实现从小到大排序
    buildMaxHeap(arr)
    const len = arr.length
    for (let i = len - 1; i > 0; i--) {
      swap(arr, 0, i)
      heapifyMax(arr, 0, i)
    }
  } else {
    // 使用小顶堆实现从大到小排序
    buildMinHeap(arr)
    const len = arr.length
    for (let i = len - 1; i > 0; i--) {
      swap(arr, 0, i)
      heapifyMin(arr, 0, i)
    }
  }
  return arr
}
```

### 😻✔ 计数排序(counting-sort) 

![计数排序](https://qiniu1.lxfriday.xyz/feoffer/countingSort.png)

**限定为非负数**

计数排序是一种稳定的线性时间排序算法。计数排序使用一个额外的数组 `C` ，其中第 `i` 个元素是待排序数组 `A` 中值等于 `i` 的元素的个数。然后根据数组 `C` 来将 `A` 中的元素排到正确的位置。

当输入的元素是 `n` 个 `0` 到 `k` 之间的整数时，它的运行时间是 `t(n+k)`。**计数排序不是比较排序，排序的速度快于任何比较排序算法。**

由于用来计数的数组 `C` 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

```javascript
function countingSort(arr) {
  const len = arr.length
  if (len < 2) return arr
  const bucket = []
  let sortIndex = 0

  for (let i = 0; i < len; i++) {
    if (bucket[arr[i]]) {
      bucket[arr[i]] += 1
    } else {
      bucket[arr[i]] = 1
    }
  }

  for (let i = 0; i < bucket.length; i++) {
    for (let j = bucket[i]; j > 0; j--) {
      arr[sortIndex++] = i
    }
  }
  return arr
}
```

### 😻✔ 基数排序(radix-sort) 

![基数排序](https://qiniu1.lxfriday.xyz/feoffer/radixSort.png)

**限定为非负数**

基数排序原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。

它是这样实现的：将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

基数排序的方式可以采用 **LSD（Least significant digital）** 或 **MSD（Most significant digital）**，LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。

基数排序的时间复杂度是 `O(k*n)`，其中 `n` 是排序元素个数，`k` 是数字位数。这不是说这个时间复杂度一定优于 `O(nlogn)`，`k` 的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；`k` 决定了进行多少轮处理，而 `n` 是每轮处理的操作数目。

LSD 实现

```javascript
function radixSort(arr) {
  const len = arr.length
  // 得到最大值
  const max = Math.max(...arr)
  let bucket = []
  // 获取最大值的位数
  let digit = `${max}`.length
  let start = 1
  // 待操作的新数组
  let res = arr.slice()

  while (digit > 0) {
    // 每轮向左移动一位
    start *= 10
    for (let i = 0; i < len; i++) {
      const j = res[i] % start
      // 和计数排序类似
      if (!bucket[j]) {
        bucket[j] = []
      }
      // bucket 是一个二维数组
      bucket[j].push(res[i])
    }

    // 拼接前 res 设为空数组
    res = []
    for (let i = 0; i < bucket.length; i++) {
      if (bucket[i] !== undefined) {
        // res 拼接 bucket[i] 数组
        res = res.concat(bucket[i])
      }
    }
    // 结束之后 bucket 重置
    bucket = []
    digit--
  }

  return res
}
```

### 😻✔ 桶排序、箱排序(bucket-sort) 

![桶排序](https://qiniu1.lxfriday.xyz/feoffer/bucketSort.png)

桶排序工作原理是将数组分到有限数量的桶里，每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。

桶排序以下列步骤进行：

1. 设置桶个数 `size`，计算每个桶的存储范围；
1. 遍历数组，把数字放到对应的桶中；
1. 对步骤 2 放新数字的桶数组排序；
1. 数组遍历完之后，把桶中的数字依次取出放到最终的数组中；

```javascript
function swap(arr, i, j) {
  ;[arr[i], arr[j]] = [arr[j], arr[i]]
}

/**
 * @param {array} arr 待排序的数组
 * @param {number} size 桶的个数
 */
function bucketSort(arr, size = 5) {
  const len = arr.length
  // 取到最小值
  const min = Math.min(...arr)
  // 取得最大值
  const max = Math.max(...arr)
  // 每个桶的范围
  const bucketSize = Math.floor((max - min) / size) + 1
  const res = []
  // 总共的桶容器
  const bucket = []

  for (let i = 0; i < len; i++) {
    // arr[i] 分布在桶 j
    const j = Math.floor((arr[i] - min) / bucketSize)

    // 桶不存在则创建
    if (bucket[j] === undefined) {
      bucket[j] = []
    }
    // 将 arr[i] 推入桶中
    bucket[j].push(arr[i])
    let l = bucket[j].length - 1
    while (l > 0) {
      // 对个别桶使用冒泡
      // 若 arr[i] 在桶内不是最小，则向前移动
      bucket[j][l] < bucket[j][l - 1] && swap(bucket[j], l, l - 1)
      l--
    }
  }

  // 把 bucket 二维数组中的数据全部拿出来
  for (let i = 0; i < bucket.length; i++) {
    if (bucket[i] !== undefined) {
      for (let j = 0; j < bucket[i].length; j++) {
        res.push(bucket[i][j])
      }
    }
  }
  return res
}
```

## ✔ 搜索算法

### 😻✔ 二分搜索算法 

二分搜索算法的前提是目标数组已经排好序了。

```js
// 时间复杂度：O(1 * logn)  => O(logn)
// 空间复杂度：O(1* logn) => O(logn)
function binarySearch(arr, target) {
  let l = 0
  let r = arr.length - 1
  while (l <= r) {
    const med = Math.floor((l + r) / 2)
    if (target < arr[med]) {
      r = med - 1
    } else if (target > arr[med]) {
      l = med + 1
    } else {
      return med
    }
  }
  return -1
}
```

复杂度分析：

- [二分法（递归实现）的性能分析](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md#%E4%BA%8C%E5%88%86%E6%B3%95%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90)

二分法的拆分次数是 logn 次

时间复杂度 = 拆分次数 * 每次拆分的时间复杂度，则结果是 logn * 1 = O(logn)

空间复杂度= 递归深度 * 每次递归的空间复杂度，则结果是 logn * 1 = O(logn)

## 😻✔ LRU 缓存算法 

ref

- [https://juejin.im/post/5d77b68951882520d46abd18](https://juejin.im/post/5d77b68951882520d46abd18)

> 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：**先进先出策略** FIFO（First In，First Out）、**最少使用策略** LFU（Least Frequently Used）、**最近最少使用策略** LRU（Least Recently Used）。

最近最少，越是最近使用就越是不会被清除，而最远使用的将会逐渐被推到丢弃端，如果一直不被使用，数据不断存入时将会丢弃它们。

使用 ES6 Map 实现

```javascript
var LRUCache = function(capacity) {
  this.cache = new Map()
  this.capacity = capacity
};

LRUCache.prototype.get = function(key) {
  if(!this.cache.has(key)) return -1
  const ret = this.cache.get(key)
  this.put(key, ret)
  return ret
};

LRUCache.prototype.put = function(key, value) {
  if(this.cache.has(key)) {
    this.cache.delete(key)
  } else if(this.cache.size === this.capacity) {
    this.cache.delete(this.cache.keys().next().value)
  }
  this.cache.set(key, value)
};
```

双向链表实现

```javascript
var LRUCache = function(capacity) {
  this.capacity = capacity
  this.head = new ListNode()
  this.tail = new ListNode()
  this.maps = {}
  this.cnt = 0
};

LRUCache.prototype.get = function(key) {
  if(this.maps[key] === undefined) return -1
  const ret = this.maps[key].value
  this.delete(this.maps[key])
  this.add(new ListNode(key, ret))
  return ret
};

LRUCache.prototype.delete = function(node) {
  delete this.maps[node.key]
  this.cnt--
  if(this.cnt === 0) {
    this.head.next = null
    this.tail.next = null
  } else {
    if(node === this.head.next) {
      this.head.next = node.next
      node.next.prev = null
    } else if(node === this.tail.next) {
      this.tail.next = node.prev
      node.prev.next = null
    } else {
      node.prev.next = node.next
      node.next.prev = node.prev
    }
  }
};

LRUCache.prototype.add = function(node) {
  this.maps[node.key] = node
  this.cnt++
  if(this.cnt === 1) {
    this.head.next = node
    this.tail.next = node
  } else {
    node.prev = this.tail.next
    this.tail.next.next = node
    this.tail.next = node
  }
};

LRUCache.prototype.put = function(key, value) {
  if(this.maps[key]) {
    this.delete(this.maps[key])
  } else if(this.cnt === this.capacity) {
    this.delete(this.head.next)
  }
  this.add(new ListNode(key, value))
};

class ListNode {
  constructor(key, value) {
    this.key = key
    this.value = value
    this.prev = null
    this.next = null
  }
}

```

## LFU 缓存(最不经常使用 LFU)

- [460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)

```js
var LFUCache = function(capacity) {
  this.capacity = capacity
  this.kvs = new Map()
  this.min = -1
  // key-times
  this.timesMap = new Map()
  // time-keys(set)
  this.timeKeysMap = new Map()
};
LFUCache.prototype.get = function(key) {
  if(this.kvs.has(key)) {
    const ret = this.kvs.get(key)
    this.updateTimes(key, ret)
    return ret
  }
  return -1
};

LFUCache.prototype.updateTimes = function(key, value) {
  const times = this.timesMap.get(key)
  this.timesMap.set(key, times + 1)
  this.timeKeysMap.get(times).delete(key)
  if(this.timeKeysMap.get(times).size === 0 && times === 1) {
    this.min = 2
  }
  const set = this.timeKeysMap.get(times + 1) || new Set()
  set.add(key)
  this.timeKeysMap.set(times + 1, set)
};

LFUCache.prototype.delete = function() {
  const keysSet = this.timeKeysMap.get(this.min)
  const key = keysSet.keys().next().value
  this.kvs.delete(key)
  this.timesMap.delete(key)
  keysSet.delete(key)
};

LFUCache.prototype.put = function(key, value) {
  if(this.capacity === 0) return
  if(this.kvs.has(key)) {
    this.kvs.set(key, value)
    this.updateTimes(key, value)
  } else {
    if(this.kvs.size === this.capacity) {
      this.delete()
    }
    this.kvs.set(key, value)
    this.min = 1
    this.timesMap.set(key, 1)
    const set = this.timeKeysMap.get(1) || new Set()
    set.add(key)
    this.timeKeysMap.set(1, set)
  }
};
```

## 😻✔ 斐波拉契数列 

```
1 1 2 3 5 8 13 21 34 55 89
```

**尾递归**

现在浏览器和 NodeJS 已经禁用了尾递归优化，所以仅仅是尾递归，并不会起到优化的作用。

```javascript
// 时间复杂度：O(n)
// 空间复杂度：O(n)
function Fibonacci(n, prev1 = 1, prev2 = 0) {
  if (n === 1) return prev1
  return Fibonacci(n - 1, prev1 + prev2, prev1)
}
```

**迭代**

```javascript
// 时间复杂度：O(n)
// 空间复杂度：O(1)
function Fibonacci(n) {
  const init = [1, 0]
  for (let i = 1; i < n; i++) {
    ;[init[0], init[1]] = [init[0] + init[1], init[0]]
  }
  return init[0]
}
```

递归版本，极其低效，其实际进行了大量的重复计算

```js
// 时间复杂度：O(2 ^ n)
// 空间复杂度：O(n)
function Fibonacci(n) {
  if(n === 1) return 1
  if(n <= 0) return 0
  return Fibonacci(n - 1) + Fibonacci(n - 2)
}
```

## ✔ 斐波拉契数列的时间复杂度和空间复杂度

依据实现存在较大的差异。

[ref](https://blog.csdn.net/youngyangyang04/article/details/106313759)
[递归算法的时间与空间复杂度分析！](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md)


## 😻✔ 因式分解 

实现一个 `calc` 方法，可以将输入的数拆解为尽可能多的乘数，所有数相乘等于输入数。

```javascript
calc(2) // [2]
calc(8) // [2, 2, 2]
calc(24) // [2, 2, 2, 3]
calc(30) // [2, 3, 5]
```

```javascript
function calc(n) {
  const res = []
  let prev = n
  let i = 2

  while (i <= prev) {
    if (prev % i === 0) {
      res.push(i)
      prev /= i
      i = 2
    } else if (i < prev) {
      i++
    } else if (i === prev) {
      res.push(i)
    }
  }
  console.log(res)

  return res
}
```

# from - 其他

## ✔ 从数组中找出和为某个值的两数下标

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]。

初始代码：

```javascript
const twoSum = (nums, target) => {}
```

---

解法 1 - `Map`：

```javascript
const twoSum = (nums, target) => {
  const map = new Map()
  for (let i = 0, len = nums.length; i < len; i++) {
    if (map.get(nums[i])) {
      return [map.get(nums[i]), i]
    }
    map.set(target - nums[i], i)
  }
}
```

解法 2 - 两次循环：

```javascript
const twoSum = (nums, target) => {
  for (let i = 0, len = nums.length; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      if (nums[i] + nums[j] === target) return [i, j]
    }
  }
}
```

# leetcode 刷题记录

## 😻✔ 1 两数之和【easy】

[ref](https://leetcode.cn/problems/two-sum/)

Map、字典

```js
var twoSum = function (nums, target) {
  // for (var i = 0; i < nums.length; i++) {
  //   for (var j = i + 1; j < nums.length; j++) {
  //     if (nums[i] + nums[j] === target) return [i, j]
  //   }
  // }
  const m = new Map()
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i]
    const other = target - num
    if (m.has(other)) {
      return [m.get(other), i]
    } else {
      m.set(num, i)
    }
  }
}
```

## 😻✔ 2 两数相加【medium】

[ref](https://leetcode.cn/problems/add-two-numbers/)

链表

```js
var addTwoNumbers = function (l1, l2) {
  const head = new ListNode()
  let curr = head
  let add = 0
  let sum = 0
  while (l1 || l2) {
    sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + add
    add = Math.floor(sum / 10)
    curr.next = new ListNode(sum - 10 * add)
    l1 = l1 && l1.next
    l2 = l2 && l2.next
    curr = curr.next
  }
  if (add > 0) {
    curr.next = new ListNode(1)
  }

  return head.next
}

function ListNode(val, next) {
  this.val = val === undefined ? 0 : val
  this.next = next === undefined ? null : next
}
```

## 😻✔ 3 无重复字符的最长子串【medium】

[ref](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

滑动窗口、字典

```js
var lengthOfLongestSubstring = function(s) {
  let max = 0
  const set = new Set()
  let i=0
  for(let j=0;j<s.length;j++) {
    while(set.has(s[j])) {
      set.delete(s[i])
      i++
    }
    set.add(s[j])
    max = Math.max(max, set.size)
  }
  return max
};
```

```js
var lengthOfLongestSubstring = function (s) {
  let maxLen = 0
  let currStr = ''
  for (let i = 0; i < s.length; i++) {
    const indInCurrStr = currStr.indexOf(s[i])
    let len
    if (indInCurrStr === -1) {
      currStr += s[i]
      len = currStr.length
    } else {
      len = currStr.length
      currStr = currStr.slice(indInCurrStr + 1) + s[i]
    }
    maxLen = len > maxLen ? len : maxLen
  }
  return maxLen
}
```

or

```js
var lengthOfLongestSubstring = function (s) {
  let l = 0
  let max = 0
  const m = new Map()
  for (let r = 0; r < s.length; r++) {
    if (m.has(s[r]) && m.get(s[r]) >= l) {
      l = m.get(s[r]) + 1
    }
    m.set(s[r], r)
    max = Math.max(max, r - l + 1)
  }
  return max
}
```

## 🌟😻✔ 4 寻找两个正序数组的中位数【hard】

[ref](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

二分查找

```js

// 时间复杂度：O(log(m + n))
// 空间复杂度：O(1)
var findMedianSortedArrays = function(nums1, nums2) {
  // 利用中位数的特殊属性
  const m = nums1.length
  const n = nums2.length
  const totalLength = m + n
  if(totalLength % 2 === 1) {
    // 中位数就在数组中
    const mid = (totalLength - 1) / 2
    return getTarget(mid + 1, nums1, nums2)
  } else {
    // 中位数是最中间两个数的均值
    const mid = totalLength / 2
    return (getTarget(mid, nums1, nums2) + getTarget(mid + 1, nums1, nums2)) / 2
  }
};

// 转化为获取 nums1 和 nums2 数组中的第 k 大的数
// 两个数组是排好序的数组
function getTarget(k, nums1, nums2) {
  // 对于两个数组中下标为 k / 2 - 1(即第 k / 2 个) 的数字A(k / 2 - 1)和 B(k / 2 - 1)
  // ----------------------------------------------------------------------
  // 如果 A(k / 2 - 1) < B(k / 2 - 1) ，则有这样一个规则存在
  // 在 A、B 两个数组的前 k / 2 个数字中（即 A+B 的前K个数字中），A(k / 2 - 1)最多只能是第 k - 1 个数字，不可能是第 K 个数字
  // 由于 A(k / 2 - 1)  前面的数字比它还小，则其前面的数字只能排在A + B 数组的 k - 1 之前，则可以断定，第 K 个数字肯定不在 A[0]~A[k / 2 - 1] 内
  // 就可以把 A 中下标在 k / 2 之前的全部排除
  // 排除之后，新的 newK = k - (k / 2)
  // ----------------------------------------------------------------------
  // 如果 A(k / 2 - 1) > B(k / 2 - 1) 则对 B 进行上面的操作
  // ----------------------------------------------------------------------
  // 如果 A(k / 2 - 1) === B(k / 2 - 1) ，则 A 中 k / 2 - 1 前面的数字和 B 中 k / 2 - 1 前面的数字合并起来，也最多只能排在 k - 2 位
  // 则实际上 A(k / 2 - 1) 和 B(k / 2 - 1) 前面的数字都可以【排除掉】
  // 因为 A(k / 2 - 1) 和 B(k / 2 - 1) 是相等的，则 A(k / 2 - 1) 这一项也可以排除掉，极端情况下，刚好 B(k / 2 - 1) 就是想要的值
  // 综合之后就是，两者相等的时候，选择同 A(k / 2 - 1) < B(k / 2 - 1) 一样的操作，把 A 中前 k / 2 个数字全部排除掉
  // ----------------------------------------------------------------------
  // 由于 k 表示的是在 剩下的 nums1 和 nums2 合并后的有序数组中，第 k 个数字
  // 则当 k = 1 的时候 ，直接比较剩下的 nums1 和 nums2 两数组中靠在最前面且未被排除的下标，即可得出结果。
  // ----------------------------------------------------------------------
  // 这里 k 可能是奇数也可能是偶数，是偶数就完全符合上面的推断，是奇数的时候， k / 2 向下取整
  // 这样 Math.floor(k / 2) * 2 < k，所以从两个数组上取的数之和小于 k
  // 当 A(Math.floor(k / 2) - 1) < B(Math.floor(k / 2) - 1) 成立的时候，A(Math.floor(k / 2) - 1) 最多只能排在第 Math.floor(k / 2) * 2 - 1 的位置上
  // Math.floor(k / 2) * 2 - 1 < k - 1，故 A(Math.floor(k / 2) - 1) 对应的数字及其前面的数字都能排除掉，这和 k 是偶数的时候完全一样
  // 当 A(Math.floor(k / 2) - 1) === B(Math.floor(k / 2) - 1) 成立的时候
  // A(Math.floor(k / 2) - 1) 最多排在第 Math.floor(k / 2) * 2 的位置，而 Math.floor(k / 2) * 2 < k，故结果 k 是偶数的时候也是一致的
  // ----------------------------------------------------------------------
  // 上述思路对应的是两个数组中存在数字大于中位数，则一直执行上述操作直到获取到第k个数数字的时候，两个数组中都还有数字
  // 还有另外一种情况，某个数组中的数字全部排在中位数前面
  // 则肯定会出现一个数组中的所有数字全部是不需要的数字
  // 当上述操作执行到某个数组的下标超过边界的时候，只需要在另一个数组中找到第 k（去掉被排除的数字） 个数字即是结果

  let nums1Target
  let nums2Target
  let halfK
  let showDropCount
  let ind1 = 0
  let ind2 = 0

  while(true) {
    if(ind1 >= nums1.length) {
      return nums2[ind2 + k - 1]
    }
    if(ind2 >= nums2.length) {
      return nums1[ind1 + k - 1]
    }
    if(k === 1) {
      return Math.min(nums1[ind1], nums2[ind2])
    }
    halfK = Math.floor(k / 2)
    // showDropCount 表示应该丢弃的数字个数，由于可能存在下标越界的问题，当下标越界出现的时候
    // 默认使用数组的最后一个数字来做比较，而这个时候要排除的数字个数就可能不是 halfK 个了
    showDropCount = halfK
    // 超出了数组长度，则使用最后一个，也就是数组中最大的一个数
    if(ind1 + halfK - 1 >= nums1.length) {
      nums1Target = nums1[nums1.length - 1]
      showDropCount = nums1.length  - ind1
    } else {
      nums1Target = nums1[ind1 + halfK - 1]
    }
    if(ind2 + halfK - 1 >= nums2.length) {
      nums2Target = nums2[nums2.length - 1]
      showDropCount = nums2.length - ind2
    } else {
      nums2Target = nums2[ind2 + halfK - 1]
    }

    if(nums1Target <= nums2Target) {
      ind1 = ind1 + showDropCount
    } else {
      ind2 = ind2 + showDropCount
    }

    k = k - showDropCount
  }
}
```

## 😻✔ 5 最长回文子串【medium】

[ref](https://leetcode.cn/problems/longest-palindromic-substring/submissions/)

动态规划

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var longestPalindrome = function(s) {
  const len = s.length
  let maxStr = s[0]
  const dp = new Array(len).fill(false).map(_ => new Array(len).fill(false))

  for(let i=0;i<len;i++) {
    dp[i][i] = true
  }

  for(let L=2;L<=len;L++) {
    for(let i=0;i + L - 1 <len;i++) {
      if(s[i] === s[i + L - 1]) {
        dp[i][i + L - 1] = i + L - 2 >= i + 1 ? dp[i + 1][i + L - 2] : true
        if(dp[i][i + L - 1] && L > maxStr.length) {
          maxStr = s.slice(i, i + L)
        }
      }
    }
  }
  return maxStr
};
```

常规中心往两侧扩散

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var longestPalindrome = function(s) {
  let maxStr = ''
  for(let i=0;i<s.length;i++) {
    // 扫描两次
    // 单中心扫描
    let l=r=i
    while(r + 1 < s.length && l - 1 >= 0 && s[r + 1] === s[l - 1]) {
      l--
      r++
    }
    if(maxStr.length < r - l + 1) {
      maxStr = s.slice(l, r + 1)
    }
    // 双中心扫描
    if(i + 1 < s.length && s[i] === s[i + 1]) {
      l = i
      r = i + 1
      while(r + 1 < s.length && l - 1 >= 0 && s[r + 1] === s[l - 1]) {
        l--
        r++
      }
      if(maxStr.length < r - l + 1) {
        maxStr = s.slice(l, r + 1)
      }
    }

  }
  return maxStr
};
```

贪心算法

核心就是尝试以每个字符为中心，往两侧扩散

```js
// 时间复杂度：O(0^2)
// 空间复杂度：O(1)
var longestPalindrome = function(s) {
  let res = ''
  for(let i = 0; i < s.length; i++) {
    let end = findDuplicate(s, i)
    let l, r
    l = i - 1
    if(end === i + 1) {
      // 中心不是重复值
      r = i + 1
    } else {
      // 中心是重复值
      r = end
      // 因为都是重复值，所以直接把所有重复的值都跳过
      i = end - 1
    }
    while(l >= 0 && r < s.length && s[l] === s[r]) {
      l--
      r++
    }
    if(r - l - 1 > res.length) {
      res = s.slice(l + 1, r)
    }
  }
  return res
};


function findDuplicate(s, i) {
  let r = i
  while(s[i] === s[r]) {
    r++
  }
  return r
}
```

## 🌟😻✔ 6 Z 字形变换【medium】

[ref](https://leetcode.cn/problems/zigzag-conversion/)


```js
// 时间复杂度：O(n)
// 空间复杂度：O(k) k=numRows
var convert = function(s, numRows) {
  // 行数为 1 则直接返回 s
  if(numRows === 1) return s
  // 建一个 长度为 numRows 的数组，数组中每个元素为空字符串
  // 一个空字符串对应结果中的一行
  const resArr = new Array(numRows).fill('')
  // 对每个字符，计算出其所处的行
  for(let i = 0; i < s.length; i++) {
    // 2 * numRows - 2 最小的一个排列来回
    const m = i % (2 * numRows - 2)
    if(m <= numRows - 1) {
      // 从上往下
      resArr[m] += s[i]
    } else {
      // 从下往上
      const n = m - (numRows - 1)
      resArr[numRows - 1 - n] += s[i]
    }
  }
  return resArr.join('')
};
```


## 😻✔ 7 整数反转【medium】

[ref](https://leetcode.cn/problems/reverse-integer/)

```js
var reverse = function(x) {
  if(x === 0) return 0
  let isNegative = x < 0 ? true : false
  x = isNegative ? -x : x
  let result = 0
  while(x > 0) {
    const n = x % 10
    if(result > (2 ** 31 - 1 - n) / 10) return 0
    x = Math.floor(x / 10)
    result = 10 * result + n
  }
  return isNegative? -result : result
};
```

## ?? 🌟😻✔ 8 字符串转换整数 (atoi)【medium】

[ref](https://leetcode.cn/problems/string-to-integer-atoi/)

```js
// 时间复杂度：O(N)
// 时间复杂度：O(1)
var myAtoi = function(s) {
  while(s[0] === ' ') {
    s = s.slice(1)
  }
  let isNegative = false
  if(s[0] === '-') {
    isNegative = true
    s = s.slice(1)
  }else if(s[0] === '+') {
    s = s.slice(1)
  }
  let num = 0
  let i = 0
  while(i < s.length && s[i] >= '0' && s[i] <= '9') {
    if(!isNegative && (10 * num + Number(s[i]) > 2 ** 31 - 1)) {
      return 2 ** 31 - 1
    }else if(isNegative && (10 * num + Number(s[i]) > 2 ** 31 )) {
      return - (2 ** 31)
    }
    num = 10 * num + Number(s[i])
    i++
  }
  return !isNegative ? num : -num
};
```


## 🌟😻✔ 9 回文数【easy】

[ref](https://leetcode.cn/problems/palindrome-number/)

对回文数比较好的解决办法是，把从数字中取到的余数全部存进数组中，这样就算是0也可以表示，如果是直接计算成数字则可能出现 00123 这种情况，而前导0会被省略，导致出错。

```js
var isPalindrome = function(x) {
  if(x < 0) return false
  if(x === 0) return true
  let nums = []
  while(x > 0) {
    nums.push(x % 10)
    x = Math.floor(x / 10)
  }
  for(let i=0;i<nums.length / 2;i++) {
    if(nums[i] !== nums[nums.length - 1 - i]) {
      return false
    }
  }
  return true
};
```

## ?🌟😻✔ 10 正则表达式匹配【hard】

[ref](https://leetcode.cn/problems/regular-expression-matching/)

动态规划

```js
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var isMatch = function(s, p) {
  const m = s.length
  const n = p.length
  const dp = new Array(m + 1).fill(false).map(_ => new Array(n + 1).fill(false))
  dp[0][0] = true
  for(let j=2;j<=n;j+=2) {
    if(p[j - 1] === '*') {
      dp[0][j] = dp[0][j - 2]
    }
  }
  for(let i=1;i<=m;i++) {
    for(let j=1;j<=n;j++) {
      if(s[i - 1] === p[j - 1] || p[j - 1] === '.') {
        dp[i][j] = dp[i - 1][j - 1]
      } else if (p[j - 1] === '*') {
        dp[i][j] = dp[i][j-2] || false
        if(p[j - 2] === s[i - 1] || p[j - 2] === '.') {
          dp[i][j] = dp[i][j] || dp[i-1][j]
        }
      }
    }
  }
  return dp[m][n]
};

```

## ??🌟😻✔ 11 盛最多水的容器【medium】

[ref](https://leetcode.cn/problems/container-with-most-water/)

双指针

[我的题解](https://leetcode.cn/problems/container-with-most-water/solution/by-lxfriday-udsc/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxArea = function(height) {
  let l = 0
  let r = height.length - 1
  let max = 0
  while(l < r) {
    max = Math.max(Math.min(height[l], height[r]) * (r - l), max)
    if(height[l] <= height[r]) {
      l++
    } else {
      r--
    }
  }
  return max
}; 
```

## ✔ 13 罗马数字转整数【easy】

[ref](https://leetcode.cn/problems/roman-to-integer/)

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var romanToInt = function(s) {
  const map = {
    'I': 1,
    'V': 5,
    'X': 10,
    'L': 50,
    'C': 100,
    'D': 500,
    'M': 1000,
  }
  let sum = 0
  for(let i = 0; i < s.length; i++) {
    if(
      (s[i] === 'I' && (s[i + 1] === 'V' || s[i + 1] === 'X')) || 
      (s[i] === 'X' && (s[i + 1] === 'L' || s[i + 1] === 'C')) || 
      (s[i] === 'C' && (s[i + 1] === 'D' || s[i + 1] === 'M'))
    ) {
      sum -= map[s[i]]
    } else {
      sum += map[s[i]]
    }
  }
  return sum
};
```

## ✔ 14 最长公共前缀【easy】

[ref](https://leetcode.cn/problems/longest-common-prefix/)

```js
// 时间复杂度：O(n*k) k 公共前缀的长度
// 空间复杂度：O(1) 
var longestCommonPrefix = function(strs) {
  for(let i = 0;i <= strs[0].length; i++) {
    const target = strs[0].slice(0, i)
    for(let j = 1; j < strs.length; j++) {
      if(strs[j].indexOf(target) !== 0) {
        return strs[0].slice(0, i - 1)
      }
    }
  }
  return strs[0]
};
```

## 🌟😻✔ 15 三数之和 【medium】

[ref](https://leetcode.cn/problems/3sum/)

双指针

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(logN) 排序的空间复杂度
var threeSum = function(nums) {
  if(nums.length < 3) return []
  const res = []
  nums.sort((a, b) => a - b)
  const len = nums.length
  for(let i = 0; i < len - 2; i++) {
    if(nums[i] === nums[i - 1]) continue
    let l = i + 1
    let r = len - 1
    while(l < r) {
      if(l > i + 1 && nums[l] === nums[l - 1]) {
        l++
        continue
      }
      if(r < len - 1 && nums[r] === nums[r + 1]) {
        r--
        continue
      }
      const sum = nums[i] + nums[l] + nums[r]
      if(sum === 0) {
        res.push([nums[i], nums[l], nums[r]])
        l++
        r--
      } else if(sum > 0) {
        // 在每一个轮次中 nums[i] 固定不变，且知道 nums[l] <= nums[r]
        // sum > 0 则三个数中最大的数 nums[r] 一定大了， 要往左移
        // sum < 0 则 sum[l] 小了，要变大
        r--
      } else {
        l++
      }
    }
  }
  return res
};
```

## 🌟😻✔ 16 最接近的三数之和【medium】

[ref](https://leetcode.cn/problems/3sum-closest/)

双指针

```js
// 时间复杂度：O(n^2)
// 空间复杂度：O(logn) 排序
var threeSumClosest = function(nums, target) {
  nums.sort((a, b) => a - b)
  let finalSum
  let minGap = Infinity
  const len = nums.length
  for(let i=0;i<len;i++) {
    let l = i + 1
    let r = len - 1
    while(l < r) {
      const sum = nums[i] + nums[l] + nums[r]
      const gap = Math.abs(sum - target)
      if(gap < minGap) {
        finalSum = sum
        minGap = gap
      }
      (sum < target) ? (l++) : (r--)
    }
  }
  return finalSum
};
```

## 🌟😻✔ 17. 电话号码的字母组合【medium】

[ref](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

回溯、递归、排列组合

```js
// 回溯
// 时间复杂度：O(3^M*4^N)
// 空间复杂度：O(M+N)
var letterCombinations = function(digits) {
  if(!digits.length) return []
  const numMap = {
    2: ['a', 'b', 'c'],
    3: ['d', 'e', 'f'],
    4: ['g', 'h', 'i'],
    5: ['j', 'k', 'l'],
    6: ['m', 'n', 'o'],
    7: ['p', 'q', 'r', 's'],
    8: ['t', 'u', 'v'],
    9: ['w', 'x', 'y', 'z'],
  }
  const words = []
  for(let i=0;i<digits.length;i++) {
    words.push(numMap[digits[i]])
  }
  const len = words.length
  const res = []
  function dfs(path, startIndex) {
    if(path.length === len) {
      res.push(path)
      return
    } else {
      for(let word of words[startIndex]) {
        dfs(path + word, startIndex + 1)
      }
    }
  }
  dfs('', 0)
  return res
};

// [['a', 'b', 'c'], ['g', 'h', 'i'], ]
// [['a', 'b', 'c'], ['g', 'h', 'i'], ['g', 'h', 'i']]
```

## 🌟😻✔ 18 四数之和【medium】

[ref](https://leetcode.cn/problems/4sum/)

```js
// 时间复杂度：O(N^3)
// 空间复杂度：O(logN)
var fourSum = function(nums, target) {
  if(nums.length < 4) return []
  nums.sort((a, b) => a - b)
  const n = nums.length
  const res = []
  for(let i = 0;i<n - 3;i++) {
    if(i - 1 >= 0 && nums[i] === nums[i - 1]) continue
    const a = nums[i]
    const atarget = target - a
    for(let ii = i + 1;ii<n - 2;ii++) {
      if(ii - 1 >= i + 1 && nums[ii] === nums[ii - 1]) continue
      let b = nums[ii]
      let l = ii + 1, r = n - 1
      while(l < r) {
        const s = b + nums[l] + nums[r]
        if(s === atarget) {
          res.push([a, b, nums[l], nums[r]])
          while(nums[l] === nums[l + 1] && l < r) {
            l++
          }
          while(nums[r] === nums[r - 1] && l < r) {
            r--
          }
          l++
          r--
        } else {
          if(s > atarget) {
            r--
          } else {
            l++
          }
        }
      }
    }
  }
  return res
};
```

## 🌟😻✔ 20 有效的括号【easy】

[ref](https://leetcode.cn/problems/valid-parentheses/)

关键词：栈

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
  const leftValues = '({['
  const map = {
    '(': ')',
    '{': '}',
    '[': ']',
  }
  const stack = []
  for (let i = 0; i < s.length; i++) {
    if (leftValues.includes(s[i])) {
      stack.push(s[i])
    } else {
      const lastValue = stack.pop()
      if (map[lastValue] !== s[i]) return false
    }
  }
  return !stack.length
}
```

## 😻✔ 21 合并两个有序链表【easy】

[ref](https://leetcode.cn/problems/merge-two-sorted-lists/)

链表

```js
// 时间复杂度：O(n) n=list1.length + list2.length
// 空间复杂度：O(1)
var mergeTwoLists = function(list1, list2) {
  const head = new ListNode()
  let th = head
  while(list1 && list2) {
    if(list1.val < list2.val) {
      th.next = list1
      list1 = list1.next
    } else {
      th.next = list2
      list2 = list2.next
    }
    th = th.next
  }
  if(list1) {
    th.next = list1
  }
  if(list2) {
    th.next = list2
  }
  return head.next
};
```

## 😻✔ 22 括号生成【medium】

[ref](https://leetcode.cn/problems/generate-parentheses/)

回溯、递归

```js
var generateParenthesis = function(n) {
  const res = []
  let leftCount = 0
  let rightCount = 0
  function calc(str) {
    if(leftCount < rightCount || leftCount > n || rightCount > n) return
    if(leftCount === n && rightCount === n) {
      res.push(str)
      return
    }
    leftCount++
    calc(str + '(')
    leftCount--
    rightCount++
    calc(str + ')')
    rightCount--
  }
  calc('')
  return res
};
```

## ?😻✔ 23 合并K个升序链表【hard】

[ref](https://leetcode.cn/problems/merge-k-sorted-lists/)

链表、堆、分治法、归并

```js
// 时间复杂度：O(kn*logk)
// 空间复杂度：O(logk)
var mergeKLists = function(lists, l, r) {
  l = typeof l === 'number' ? l : 0
  r = typeof r === 'number' ? r: lists.length - 1
  if(l === r) return lists[l]
  if(l > r) return null
  const mid = Math.floor((l + r) / 2)
  return merge(mergeKLists(lists, l, mid), mergeKLists(lists, mid + 1, r))
};

function merge(list1, list2) {
  const head = new ListNode()
  let tHead = head
  while(list1 && list2) {
    if(list1.val < list2.val) {
      tHead.next = list1
      list1 = list1.next
    } else {
      tHead.next = list2
      list2 = list2.next
    }
    tHead = tHead.next
  }
  if(list1) {
    tHead.next = list1
  }
  if(list2) {
    tHead.next = list2
  }
  return head.next
}
```

```js
// 时间复杂度：O(kn*logk)
// 空间复杂度：O(k)
// k 是 list.lenght
// n 是所有链表节点的个数
var mergeKLists = function(lists) {
  const head = new ListNode()
  let th = head
  const h = new MinHeap()
  for(let list of lists) {
    list && h.insert(list)
  }

  while(h.size()) {
    let hPop = h.pop()
    th.next = hPop
    th = th.next
    if(hPop.next) h.insert(hPop.next)
  }

  return head.next
};
class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    let p = this.heap.pop()
    this.shiftDown(0)
    return p
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i].val > this.heap[left].val) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i].val > this.heap[right].val) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex].val > this.heap[i].val) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

常规顺序合并

```js
// 时间复杂度：O(n*k^2)
// 空间复杂度：O(1)
var mergeKLists = function(lists) {
  if(!lists.length) return null
  const len = lists.length
  const head = new ListNode()
  head.next = lists[0]
  for(let i=1;i<len;i++) {
    head.next = merge(head.next, lists[i])
  }
  return head.next
};

function merge(list1, list2) {
  const head = new ListNode()
  let tHead = head
  while(list1 && list2) {
    if(list1.val < list2.val) {
      tHead.next = list1
      list1 = list1.next
    } else {
      tHead.next = list2
      list2 = list2.next
    }
    tHead = tHead.next
  }
  if(list1) {
    tHead.next = list1
  }
  if(list2) {
    tHead.next = list2
  }
  return head.next
}
```

## 😻✔ 24 两两交换链表中的节点【medium】

[ref](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```js
var swapPairs = function(head) {
  let tHead = new ListNode()
  tHead.next = head
  let slow = tHead
  let fast = tHead
  while(fast.next && fast.next.next) {
    const tPrevSlow = slow
    slow = slow.next
    fast = fast.next.next
    const tFastNext = fast.next
    tPrevSlow.next = fast
    fast.next = slow
    slow.next = tFastNext
    fast = slow
  }
  return tHead.next
};
```

## 🌟😻✔ 25 K 个一组翻转链表【hard】

[ref](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

```js
// 比较优秀的版本
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var reverseKGroup = function(head, k) {
  let count = 0
  const myHead = new ListNode()
  myHead.next = head
  let start = myHead
  let end = start

  while(end.next) {
    end = end.next
    count++
    if(count % k === 0) {
      start = reverse(start, end)
      end = start
    }
  }
  return myHead.next
};

// start 的下一个节点才是起点
// 返回反转后的 end 节点
function reverse(start, end) {
  const myHead = new ListNode()
  const reversePrev = start
  const reverseNext = end.next
  start = start.next
  const prevStart = start
  while(myHead.next !== end) {
    const prev = myHead.next
    myHead.next = start
    start = start.next
    myHead.next.next = prev
  }
  reversePrev.next = myHead.next
  prevStart.next = reverseNext
  return prevStart
}
```

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var reverseKGroup = function(head, k) {
  let count = 0
  const myHead = new ListNode()
  let t = myHead
  const gapHead = new ListNode()
  let tGapHead
  while(head) {
    gapHead.next = head
    tGapHead = gapHead // *
    while(tGapHead.next) {
      tGapHead = tGapHead.next
      count++
      head = head.next
      if(count % k === 0) {
        tGapHead.next = null
        while(t.next) t = t.next
        t.next = reverse(gapHead.next) // *
        break // *
      }
    }
    if(count % k !== 0) {
      while(t.next) t = t.next
      t.next = gapHead.next
    }
  }
  return myHead.next
};

function reverse(head) {
  const myHead = new ListNode()
  while(head) {
    const prev = myHead.next
    myHead.next = head
    head = head.next
    myHead.next.next = prev
  }
  return myHead.next
}
```

## ✔ 26 删除有序数组中的重复项【easy】

[ref](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```js
var removeDuplicates = function(nums) {
  if(!nums.length) return 0
  let count = 1
  for(let i = 1; i < nums.length; i++) {
    if(nums[i] !== nums[i - 1]) {
      nums[count] = nums[i]
      count++
    }
  }
  return count 
};
```

## ✔ 27 移除元素【easy】

[ref](https://leetcode.cn/problems/remove-element/)

```js
var removeElement = function(nums, val) {
  const len = nums.length
  let index = 0
  for(let i=0;i<len;i++) {
    if(nums[i] !== val) {
      nums[index++] = nums[i]
    }
  }
  return index
};
```

## ✔ 28 实现 strStr()【easy】

[ref](https://leetcode.cn/problems/implement-strstr/)

```js
// M=haystack.length N=needle.length
// 时间复杂度：O(M*N)
// 空间复杂度：O(1)
var strStr = function(haystack, needle) {
  if(!needle.length) return 0
  for(let i=0;i<haystack.length;i++) {
    if(haystack[i] === needle[0]) {
      let j=1
      for(;j<needle.length;j++) {
        if(i + j >= haystack.length || needle[j] !== haystack[i + j]) break
      }
      if(j === needle.length) return i
    }
  }
  return -1
};
```

## 🌟😻✔ 31 下一个排列【medium】

[ref](https://leetcode.cn/problems/next-permutation/)

```js
var nextPermutation = function(nums) {
  const len = nums.length
  let i = len - 1
  for(;i>0;i--) {
    if(nums[i] > nums[i - 1]) {
      break
    }
  }
  for(let j = len - 1;j >= i ;j--) {
    if(nums[j] > nums[i - 1]) {
      swap(nums, i - 1, j)
      break
    }
  }
  reverse(nums, i, len - 1)
  return nums
};

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}

function reverse(arr, l, r) {
  const mid = Math.floor((l + r) / 2)
  for(let i=l;i<=mid;i++) {
    const t = arr[i]
    arr[i] = arr[r + l - i]
    arr[r + l - i] = t
  }
}
```

## ?🌟😻✔ 32 最长有效括号【hard】

[ref](https://leetcode.cn/problems/longest-valid-parentheses/)

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var longestValidParentheses = function(s) {
  const len = s.length
  const dp = new Array(len).fill(0)
  dp[0] = 0
  for(let i=1;i<len;i++) {
    if(s[i] === ')') {
      if(s[i - 1] === '(') {
        dp[i] = (i - 2 >= 0?dp[i - 2] : 0) + 2
      } else if(i - 1 - dp[i - 1] >=0 && s[i - 1 - dp[i - 1]] === '(') {
        dp[i] = 2 + dp[i - 1] + (i - 2 - dp[i - 1] >=0 ? dp[i - 2 - dp[i - 1]] : 0) 
      }
    }
  }
  return Math.max(...dp)
};
```

## ?🌟😻✔ 33 搜索旋转排序数组【medium】

[ref](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

![](https://qiniu1.lxfriday.xyz/feoffer/1653007574423_685e61d8-c663-4699-8719-3b7d78a01427.png)

```js
// 时间复杂度：O(logn)
// 空间复杂度：O(n)
var search = function(nums, target) {
  const len = nums.length
  if(!len) return -1
  if(len === 1) return target === nums[0] ? 0 : -1
  let l = 0
  let r = len - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(target === nums[mid]) {
      return mid
    }
    if(nums[0] <= nums[mid]) {
      if(nums[0] <= target && target < nums[mid]) {
        r= mid - 1
      } else {
        l = mid + 1
      }
    } else {
      if(nums[mid] < target && target <= nums[r]) {
        l = mid + 1
      } else {
        r = mid - 1
      }
    }
  }
  return  -1
};

```

## ?🌟😻✔ 34 在排序数组中查找元素的第一个和最后一个位置【medium】

[ref](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

二分搜索

```js
// 时间复杂度：O(logn)
// 空复杂度：O(1)
var searchRange = function(nums, target) {
  const leftIndex = binarySearch(nums, target, true)
  const rightIndex = binarySearch(nums, target, false) - 1
  if(
    leftIndex >= 0 &&
    rightIndex < nums.length &&
    nums[leftIndex] === target &&
    nums[rightIndex] === target
  ) {
    return [leftIndex, rightIndex]
  }
  
  return [-1, -1]
};

function binarySearch(nums, target, lower) {
  const len = nums.length
  let l = 0
  let r = len - 1
  let resIndex = len
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(target < nums[mid] || (lower && target <= nums[mid])) {
      r = mid - 1
      resIndex = mid
    } else {
      l = mid + 1
    }
  }
  return resIndex
}
```

## ?🌟😻✔ 37 解数独【hard】

[ref](https://leetcode.cn/problems/sudoku-solver/)

同[#51 N皇后](https://leetcode.cn/problems/n-queens/)问题比较类似

回溯、枚举

```js
// 基本上只要是涉及到枚举的，都可以用下面的这种方式，解法同样适用于 N 皇后问题
// 先扫描矩阵，把矩阵中的数字填充到其对应的行、列、3x3 宫格中，用于后续填充数字时的冲突检测
// 后面用 dfs 枚举每个空格处能填充的数字，且 dfs 会返回一个布尔值
// 表示当前位置填充对应数字之后后续 dfs 能否成功把九宫格填满，返回 true 就表示填满了，那就直接也返回 true
// 这题需要用原地修改的处理方式，所以直接 return 用来阻断后续的枚举
// 另外我使用了 matrixIndex 来表示九宫格格中对应的位置，这样可以避免 i 或者 j 到头之后难以找到下一个 i j 的问题
// matrixIndex 能直接推断出 i j，而 matrixIndex 最大为 n ** 2 - 1 = 80
var solveSudoku = function(board) {
  const rows = new Array(9).fill(0).map(_ => new Set())
  const cols = new Array(9).fill(0).map(_ => new Set())
  const blocks = new Array(9).fill(0).map(_ => new Set())

  for(let i=0;i<9;i++) {
    for(let j=0;j<9;j++) {
      if(board[i][j] !== '.') {
        rows[i].add(board[i][j])
        cols[j].add(board[i][j])
        blocks[Math.floor(i / 3) * 3 + Math.floor(j / 3)].add(board[i][j])
      }
    }
  }

  function dfs(matrixIndex) {
    let i = Math.floor(matrixIndex / 9)
    let j = matrixIndex - i * 9
    while(matrixIndex < 81 && board[i][j] !== '.') {
      matrixIndex ++
      i = Math.floor(matrixIndex / 9)
      j = matrixIndex - i * 9
    }

    if(matrixIndex === 81) {
      return true
    } else {
      for(let num = 1;num<=9;num++) {
        const numStr = String(num)
        const blockIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3)
        if(
          !rows[i].has(numStr) &&
          !cols[j].has(numStr) &&
          !blocks[blockIndex].has(numStr)
        ) {
          board[i][j] = numStr
          rows[i].add(numStr)
          cols[j].add(numStr)
          blocks[blockIndex].add(numStr)

          if(dfs(matrixIndex + 1)) {
            return true
          } else {
            board[i][j] = '.'
            rows[i].delete(numStr)
            cols[j].delete(numStr)
            blocks[blockIndex].delete(numStr)
          }
        }
      }
      return false
    }
  }

  dfs(0)
};
```

## 🌟😻✔ 38. 外观数列【medium】

[ref](https://leetcode.cn/problems/count-and-say/)

字符串、模拟

```js
// 时间复杂度：O(N*M) M 为生成字符串的最大长度
// 空间复杂度：O(1)
var countAndSay = function(n) {
  let numStr = '1'
  n--
  while(n > 0) {
    let tStr = ''
    let l=0
    while(l < numStr.length) {
      let r = l + 1
      while(r < numStr.length && numStr[r] === numStr[l]) {
        r++
      }
      tStr += (r-l) + numStr[l]
      l=r
    }
    numStr = tStr
    n--
  }
  return numStr
};
```

## ?🌟😻✔ 39. 组合总和【medium】

[ref](https://leetcode.cn/problems/combination-sum/)

回溯法、排列组合

```js
var combinationSum = function(candidates, target) {
  const res = []
  function walk(path, sum, startIndex) {
    if(sum === target) {
      res.push([...path])
    }
    for(let i=startIndex;i<candidates.length;i++) {
      if(sum + candidates[i] <= target) {
        path.push(candidates[i])
        walk(path, sum + candidates[i], i)
        path.pop()
      }
    }
  }
  walk([], 0, 0)
  return res
};
```

## ?🌟😻✔ 40. 组合总和 II【medium】

[ref](https://leetcode.cn/problems/combination-sum-ii/)

回溯法、排列组合

```js
var combinationSum2 = function(candidates, target) {
  const res = []
  candidates.sort((a, b) => a - b)
  const used = new Array(candidates.length).fill(false)
  function walk(path, sum, startIndex) {
    if(sum === target) {
      res.push([...path])
      return
    }
    for(let i=startIndex;i<candidates.length;i++) {
      if(i - 1 >= startIndex && !used[i - 1] && candidates[i] === candidates[i - 1]) continue
      if(sum + candidates[i] <= target) {
        path.push(candidates[i])
        used[i] = true
        walk(path, sum + candidates[i], i + 1)
        path.pop()
        used[i] = false
      }
    }
  }
  walk([], 0, 0)
  return res
};

```

## ?🌟😻✔ 41 缺失的第一个正数【hard】

[ref](https://leetcode.cn/problems/first-missing-positive/)

数组、哈希

```js
// 原地哈希就相当于，让每个数字n都回到下标为n-1的家里。
// 而那些没有回到家里的就成了孤魂野鬼流浪在外，他们要么是根本就没有自己的家（数字小于等于0或者大于nums.size()），要么是自己的家被别人占领了（出现了重复）。
// 这些流浪汉被临时安置在下标为i的空房子里，之所以有空房子是因为房子i的主人i+1失踪了（数字i+1缺失）。
// 因此通过原地构建哈希让各个数字回家，我们就可以找到原始数组中重复的数字还有消失的数字。
// 时间复杂度：O(N)
// 时间复杂度：O(1)
var firstMissingPositive = function(nums) {
 const len = nums.length
 for(let i=0;i<len;i++) {
   while(nums[i] - 1 >= 0 && nums[i] - 1 < len && nums[nums[i] - 1] !== nums[i]) {
     swap(nums, i, nums[i] - 1)
   }
 }
 for(let i=0;i<len;i++) {
   if(i + 1 !== nums[i]) {
     return i + 1
   }
 }
 return len + 1
};

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```


```js
// 常规思路
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var firstMissingPositive = function(nums) {
  const s = new Set(nums)
  let i=1
  while(true) {
    if(!s.has(i)) return i
    i++
  }
};
```

## 🌟😻✔ 42 接雨水【hard】

[ref](https://leetcode.cn/problems/trapping-rain-water/)

动态规划

双指针版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var trap = function(height) {
  let lMax = 0
  let rMax = 0
  let l = 0
  let r = height.length - 1
  let total = 0
  while(l < r) {
    if(height[l] < height[r]) {
      lMax = Math.max(lMax, height[l])
      total += lMax - height[l]
      l ++
    } else {
      rMax = Math.max(rMax, height[r])
      total += rMax - height[r]
      r--
    }
  }
  return total
};
```

动态规划版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var trap = function(height) {
  const len = height.length
  const leftMax = [0]
  const rightMax = []
  rightMax[len - 1] = [0]
  let total = 0
  for(let i = 1; i < len; i++) {
    leftMax[i] = Math.max(height[i - 1], leftMax[i - 1])
  }
  for(let i = len - 2; i >= 0; i--) {
    rightMax[i] = Math.max(height[i + 1], rightMax[i + 1])
  }
  for(let i = 0; i < len; i++) {
    total += Math.max(Math.min(leftMax[i], rightMax[i]) - height[i], 0)
  }

  return total
};
```

常规思路版

```js
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
var trap = function(height) {
  const len = height.length
  let total = 0
  for(let i = 1; i < len - 1; i++) {
    let l = i - 1
    let r = i + 1
    let lMax = height[i]
    let rMax = height[i]

    while(l >= 0) {
      if(height[l] > lMax) {
        lMax = height[l]
      } 
      l--
    }
    while(r <= len - 1) {
      if(height[r] > rMax) {
        rMax = height[r]
      } 
      r++
    }
    const receive = Math.min(lMax, rMax) - height[i]
    total += receive
  }
  return total
};
```

## 🌟😻✔ 43 字符串相乘【medium】

[ref](https://leetcode.cn/problems/multiply-strings/)

字符串相加、字符串相乘

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(M+N)
var multiply = function(num1, num2) {
  if(num1 === '0' || num2 === '0') return '0'
  const dp = new Array(num1.length + num2.length).fill(0)
  for(let i=num1.length - 1; i >= 0; i--) {
    for(let j=num2.length - 1; j >= 0; j--) {
      let k = i + j + 1
      dp[k] += num1[i] * num2[j]
      while(dp[k] > 9) {
        dp[k-1] += Math.floor(dp[k] / 10)
        dp[k] = dp[k] % 10
        k--
      }
    }
  }
  while(dp[0] === 0) dp.shift()
  return dp.join('')
};
```

```js
// 时间复杂度：O(mn)
// 空间复杂度：O(m + n)
var multiply = function(num1, num2) {
  if(num1 === '0' || num2 === '0') return '0'
  const m = num1.length
  const n = num2.length
  const numArr = new Array(m + n).fill(0)
  for(let i=m - 1;i>=0;i--) {
    for(let j=n - 1;j>=0;j--) {
      let addIndex = i + j + 1
      const sum = Number(num1[i]) * Number(num2[j]) + numArr[addIndex]
      numArr[addIndex] = sum % 10
      k = Math.floor(sum / 10)
      while(k > 0) {
        addIndex--
        const s = k + numArr[addIndex]
        numArr[addIndex] = s % 10
        k = Math.floor(s / 10)
      }
    }
  }
  while(numArr[0] === 0) numArr.shift()
  return numArr.join('')
};
```

or

```js
// 时间复杂度：O(mn + n^2)
// 空间复杂度：O(m + n) 空间复杂度取决于 sum 这个存储中间状态的字符串长度，实际上也可以认为是 O(1)
var multiply = function(num1, num2) {
  if(num1 === '0' || num2 === '0') return "0"
  const len1 = num1.length
  let sum = '0'
  for(let i=len1 -1;i>=0;i--) {
    const target = num1[i]
    sum = stringAdd(smallMulti(target, num2, len1 - i - 1), sum)
  }
  return sum
};

// 字符串相乘，x只有一位
// zeroCount 是后置0的个数
function smallMulti(x, y, zeroCount) {
  if(x === '0') return '0'
  const yLen = y.length
  let add = 0
  let res = ''
  
  for(let i=yLen - 1;i>=0;i--) {
    const n = Number(x) * Number(y[i]) + add
    add = Math.floor(n / 10)
    res = (n - add * 10) + res
  }
  if(add > 0) {
    res = add + res
  }
  let zeros = ''
  for(let i=0;i<zeroCount;i++) {
    zeros +='0'
  }
  return res + zeros
}

// 任意数字字符串相加
function stringAdd(x, y) {
  const xLen = x.length
  const yLen = y.length
  if(xLen >= yLen) {
    for(let i=0;i<xLen - yLen;i++) {
      y = '0' + y
    }
  } else {
    for(let i=0;i<yLen - xLen;i++) {
      x = '0' + x
    }
  }
  let res = ''
  let add = 0
  for(let i=x.length - 1;i>=0;i--) {
    const sum = Number(x[i]) + Number(y[i]) + add
    add = Math.floor(sum / 10)
    res = (sum - add * 10) + res
  }
  if(add > 0) {
    res = add + res
  }
  return res
}
```

## 😻✔ 45 跳跃游戏 II【medium】

[ref](https://leetcode.cn/problems/jump-game-ii/)

贪心算法

```js
// 从后往前分析，贪心的找到能到达最后一个数字的最远数字
// 可能会担心到不了这个下标，实际上，如果到不了这个下标，则一定到不了最后一个下标，故这个下标是一定能到的
// 用相同的办法，不断地把下标以每次最远的距离往前靠近，直到到达第一个数字
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var jump = function(nums) {
  let r = nums.length - 1
  let min = 0
  while(r > 0) {
    for(let i = 0; i < r; i++) {
      if(i + nums[i] >= r) {
        r = i
        min++
        break
      }
    }
  }
  return min
};
```

更优版本

不太好理解，可以参照这张图，黑色的蹦跶线代表每次跳的时候能跳的最远距离，红色线从终点反过来推，在每个黑色起跳区间内找一个值，最终推到起跳点位于0。

![](https://qiniu1.lxfriday.xyz/feoffer/1652678598702_5db9138d-58b3-4bbf-81ae-44b6795bacc5.png)

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var jump = function(nums) {
  // 每移动一次下标都计算一次能走到的最远距离
  let maxIndex1 = 0
  // 当走到上一轮能走到的最远下标的时候，更新当前轮次能走的最远下标
  let maxIndex2 = 0
  let count = 0
  for(let i = 0; i < nums.length - 1; i++) {
    maxIndex1 = Math.max(maxIndex1, i + nums[i])
    if(i === maxIndex2) {
      count++
      maxIndex2 = maxIndex1
    }
  }
  return count
};
```

## 😻✔ 46 全排列【medium】

[ref](https://leetcode.cn/problems/permutations/)

排列组合、回溯法、递归

```js
var permute = function(nums) {
  const numsLen = nums.length
  const res = []
  const used = {}
  function dfs(path) {
    if(path.length === numsLen) {
      res.push([...path])
      return
    }
    for(let i = 0; i < numsLen; i++){
      const num = nums[i]
      if(used[i]) continue
      used[i] = true
      dfs([...path, num])
      used[i] = false
    }
  }

  dfs([])
  return res
};
```
or

```js
// 时间复杂度：O(n!)
// 空间复杂度：O(n) 递归的层数
var permute = function(nums) {
  const res = []

  function calc(path) {
    if(path.length === nums.length) {
      res.push(path)
      return
    }
    nums.forEach(n => {
      if(!path.includes(n)) {
        calc([...path, n])
      }
    })
  }
  calc([])
  return res
};
```

or

```js
// 时间复杂度：O(n!)
// 空间复杂度：O(n)
var permute = function(nums) {
  if(nums.length === 1) return [nums]
  const res = []
  for(let i = 0;i < nums.length; i++) {
    permute(nums.slice(0, i).concat(nums.slice(i + 1))).forEach(_ => {
      res.push([nums[i], ..._])
    })
  }
  return res
};
```

## 😻✔ 47 全排列 II【medium】

[ref](https://leetcode.cn/problems/permutations-ii/)

排列组合、回溯法、递归

无排序

```js
var permuteUnique = function(nums) {
  const n = nums.length
  const res = []
  const used = new Array(n).fill(false)
  function walk(path) {
    if(path.length === n) {
      res.push([...path])
      return
    }
    const levelUsed = new Set()
    for(let i=0;i<n;i++) {
      if(levelUsed.has(nums[i]) || used[i]) continue
      levelUsed.add(nums[i])
      used[i] = true
      path.push(nums[i])
      walk(path)
      used[i] = false
      path.pop()
    }
  }
  walk([])
  return res
};
```

排序
```js
// 时间复杂度：O(n*n!)
// 空间复杂度：O(n)
var permuteUnique = function(nums) {
  // 把无序数组排成有序的，方便后面相同数字的处理
  nums.sort((a, b) => a - b)
  const numsLen = nums.length
  const res = []
  // 对某个值是否使用过做一个记录
  const used = {}
  function dfs(path) {
    if(path.length === numsLen) {
      res.push([...path])
      return
    }
    for(let i = 0; i < numsLen; i++){
      const num = nums[i]
      // 在相同层级的情况下，如果后续还有很多相同的数字，则都会直接跳过
      // 而这里 num === nums[i - 1] 就是表示相同的数字
      // !used[i - 1] 表示的是相同层级，即数组中装填的数字个数相同就表示是同一层级
      if(used[i] || (i >= 1 && num === nums[i - 1] && !used[i - 1])) continue
      used[i] = true
      path.push(num)
      // 这个地方在 dfs 前后会把 used[i] 的值更改两次
      // 原因是：执行 dfs 前，置为 true，然后进行 dfs 内的递归调用时，该调用栈内都会得到 used[i] 为 true
      dfs(path)
      path.pop()
      used[i] = false
    }
  }

  dfs([])
  return res
};
```

## 🌟😻✔ 48. 旋转图像【medium】

[ref](https://leetcode.cn/problems/rotate-image/)

数组、旋转数组、矩阵

```js
// 原地置换
// 时间复杂度：O(N^2)
// 时间复杂度：O(1)
var rotate = function(matrix) {
  const n = matrix.length;
  for (let i = 0; i < Math.floor(n / 2); ++i) {
    for (let j = 0; j < Math.floor((n + 1) / 2); ++j) {
      const temp = matrix[i][j];
      matrix[i][j] = matrix[n - j - 1][i];
      matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
      matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
      matrix[j][n - i - 1] = temp;
    }
  }
};
```

```js
// 常规解法
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var rotate = function(matrix) {
  const n = matrix.length
  const tmpArr = new Array(n).fill([]).map(_ => [])
  for(let i = 0;i < n;i++) {
    for(let j = 0;j< n;j++) {
      tmpArr[j][n - 1 - i] = matrix[i][j]
    }
  }
  for(let i = 0;i < n;i++) {
    for(let j = 0;j< n;j++) {
      matrix[i][j] = tmpArr[i][j]
    }
  }
};
// 0 3 => 3 3
// 0 2 => 2 3
// 1 1 => 1 2
// 2 1 => 1 1
// 3 0 => 0 0
```

## ✔ 49 字母异位词分组【medium】

[ref](https://leetcode.cn/problems/group-anagrams/)

```js
// 时间复杂度：O(NKlogK)
// 空间复杂度：O(NK)
var groupAnagrams = function(strs) {
  const map = new Map()
  for(let i=0;i<strs.length;i++) {
    const hash = strs[i].split('').sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).join('')
    map.set(hash,map.has(hash) ? [...map.get(hash), strs[i]]: [strs[i]])
  }
  return Array.from(map.values())
};
```

## ?🌟😻✔ 51 N 皇后【hard】

[ref](https://leetcode.cn/problems/n-queens/)

回溯、枚举

```js
var solveNQueens = function(n) {
  const rows = new Set()
  const cols = new Set()
  // 对称轴左上
  const leftTop = new Set()
  // 对称轴右上
  const rightTop = new Set()
  const preRes = []

  function dfs(matrixIndex, path, k) {
    if(k === 0) {
      preRes.push([...path])
      return
    }
    if(matrixIndex >= n ** 2) {
      return
    }

    let i = Math.floor(matrixIndex / n)
    let j = matrixIndex - i * n
    if(
      !rows.has(i) &&
      !cols.has(j) &&
      !leftTop.has(i + j) &&
      !rightTop.has(j - i)
    ) {
      path.push(matrixIndex)
      rows.add(i)
      cols.add(j)
      leftTop.add(i + j)
      rightTop.add(j - i)

      dfs(matrixIndex + 1, path, k - 1)

      path.pop()
      rows.delete(i)
      cols.delete(j)
      leftTop.delete(i + j)
      rightTop.delete(j - i)
    }
    dfs(matrixIndex + 1, path, k)
  }

  dfs(0, [],  n)
  const res = []
  preRes.forEach(_ => {
    const tplArr = new Array(n).fill(0).map(_ => new Array(n).fill('.'))
    for(let ind of _) {
      let i = Math.floor(ind / n)
      let j = ind - i * n
      tplArr[i][j] = 'Q'
    }
    res.push(tplArr.map(__ => __.join('')))
  })
  return res
};
```

## 🌟😻✔ 53 最大子数组和【medium】

[ref](https://leetcode.cn/problems/maximum-subarray/)

动态规划

数组版

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxSubArray = function(nums) {
 const dp = []
 // dp[i] 定义的是以 i 作为结束的连续子数组的 最大值
 // 则整个数组的最大连续子数组必然会命中 dp 中的一项，且为值最大的那一项
 dp[0] = nums[0]
 for(let i = 1;i<nums.length;i++) {
   if(dp[i - 1] < 0) {
     dp[i] = nums[i]
   } else {
     dp[i] = dp[i - 1] + nums[i]
   }
 }
 return Math.max(...dp)
};
```

精简版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
// 这个解法相比数组解法更难理解
var maxSubArray = function(nums) {
 // 前 i 个数字中连续子数组的最大和
 let max = nums[0]
 // 以 i 为结尾的连续子数组的最大和
 let sum = 0
 for(let i = 0; i < nums.length; i++) {
   if(sum < 0) {
     sum = nums[i]
   } else {
     sum = sum + nums[i]
   }
   max = Math.max(max, sum)
 }
 return max
};
```

## 🌟😻✔ 54 螺旋矩阵【medium】

[ref](https://leetcode.cn/problems/spiral-matrix/)

```js
// 直接递归硬找，好理解
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var spiralOrder = function(matrix) {
  const m = matrix.length
  const n = matrix[0].length
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  const res = []

  function walk(i, j, direction) {
    used[i][j] = true
    res.push(matrix[i][j])

    if(direction === 'right') {
      if((j + 1 < n) && !used[i][j + 1]) {
        walk(i, j + 1, 'right')
      } else {
        (i + 1 < m) && !used[i + 1][j] && walk(i + 1, j, 'bottom')
      }
    }

    if(direction === 'bottom') {
      if((i + 1 < m) && !used[i + 1][j]) {
        walk(i + 1, j, 'bottom')
      } else {
        (j - 1 >= 0) && !used[i][j - 1] && walk(i, j - 1, 'left')
      }
    }

    if(direction === 'left') {
      if((j - 1 >= 0) && !used[i][j - 1]) {
        walk(i, j - 1, 'left')
      } else {
        (i - 1 >= 0) && !used[i-1][j] && walk(i-1, j, 'top')
      }
    }

    if(direction === 'top') {
      if((i - 1 >= 0) && !used[i - 1][j]) {
        walk(i - 1, j, 'top')
      } else {
        (j + 1 < n) && !used[i][j + 1] && walk(i, j + 1, 'right')
      }
    }
  }

  walk(0, 0, 'right')

  return res
};
```


## 😻✔ 55 跳跃游戏【medium】

[ref](https://leetcode.cn/problems/jump-game/)

```js
// 从左往右扫描 i 位置往后最多能跳到哪
// maxIndex 用来记录 i 前面最多能跳到哪个下标，每到一个位置都刷新 maxIndex
// 如果出现 maxIndex < i，则说明i前面的位置无法跳到 i
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var canJump = function(nums) {
  let maxIndex = 0
  for(let i = 0; i < nums.length; i++) {
    if(i > maxIndex) return false
    maxIndex = Math.max(i + nums[i], maxIndex)
  }
  return true
};
```

## 😻✔ 56 合并区间【medium】

[ref](https://leetcode.cn/problems/merge-intervals/)

```js
// 时间复杂度：O(NlogN) 排序
// 空间复杂度：O(logN) 排序
var merge = function(intervals) {
  intervals.sort((a, b) => a[0] - b[0])
  const res = []
  while(intervals.length > 1) {
    let first = intervals.shift()
    let second = intervals.shift()
    // 区间有交集
    if(first[1] >= second[1]) {
      second = first
    } else if(first[1] >= second[0]) {
      second = [first[0], second[1]]
    } else {
      res.push(first)
    }
    intervals.unshift(second)
  }
  res.push(intervals.shift())
  return res
};
```

## ?😻✔ 60. 排列序列【hard】

[ref](https://leetcode.cn/problems/permutation-sequence/)

回溯法、排列组合、规律题

题解

- [【云影同学】回溯剪枝，直达目标数字](https://leetcode.cn/problems/permutation-sequence/solution/by-lxfriday-msh9/)

```js
// 最简单的解法
var getPermutation = function(n, k) {
  let res
  const used = new Array(10).fill(false)
  function walk(path) {
    if(path.length === n) {
      res = path
      return
    }
    let cnt = 0
    const len = n - path.length
    for(let i=1;i<=n;i++) {
      if(used[i]) continue
      cnt++
      const sumCount = cnt * steps(len - 1)
      if(sumCount >= k) {
        k -= (cnt - 1) * steps(len - 1)
        used[i] = true
        walk(path + i)
        used[i] = false
        break
      }
    }
  }
  walk('')
  return res
};
function steps(n) {
  if(n === 0) return 1
  if(n === 1) return 1
  return n * steps(n - 1)
}
```

## 😻✔ 62 不同路径【medium】

[ref](https://leetcode.cn/problems/unique-paths/)

动态规划

```js
// 时间复杂度：O(mn)
// 空间复杂度：O(mn)
var uniquePaths = function(m, n) {
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  dp[0][0] = 1
  for(let i=1;i<m;i++) {
    dp[i][0] = dp[i - 1][0]
  }
  for(let j=1;j<n;j++) {
    dp[0][j] = dp[0][j - 1]
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    } 
  }
  return dp[m - 1][n - 1]
};
```

## 🌟😻✔ 63. 不同路径 II【medium】

[ref](https://leetcode.cn/problems/unique-paths-ii/)

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var uniquePathsWithObstacles = function(grid) {
  if(grid[0][0] === 1) return 0
  const m = grid.length
  const n = grid[0].length
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  dp[0][0] = 1
  for(let i=1;i<m;i++) {
    dp[i][0] = (grid[i][0] === 0 && dp[i - 1][0] !== 0) ? 1 : 0
  }
  for(let j=1;j<n;j++) {
    dp[0][j] = (grid[0][j] === 0 && dp[0][j - 1] !== 0) ? 1 : 0
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      if(grid[i][j] === 1) {
        dp[i][j] = 0
      } else {
        dp[i][j] = dp[i-1][j] + dp[i][j - 1]
      }
    }
  }
  return dp[m-1][n-1]
};
```

## 😻✔ 64. 最小路径和【hard】

[ref](https://leetcode.cn/problems/minimum-path-sum/)

动态规划

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(N)
var minPathSum = function(grid) {
  const m = grid.length, n = grid[0].length
  let dp = new Array(n).fill(Number.MAX_SAFE_INTEGER)
  dp[0] = grid[0][0]
  for(let j=1;j<n;j++) {
    dp[j] = grid[0][j] + dp[j-1]
  }
  for(let i=1;i<m;i++) {
    const tdp = []
    for(let j=0;j<n;j++) {
      if(j === 0) {
        tdp.push(dp[0] + grid[i][j])
      } else {
        tdp.push(grid[i][j] + Math.min(dp[j], tdp[j-1]))
      }
    }
    dp = tdp
  }
  return dp[n-1]
};
```

## 😻✔ 65 有效的数字【hard】

[ref](https://leetcode.cn/problems/valid-number/)

```js
var isNumber = function(s) {
  // if(s === 'Infinity' || s === '+Infinity' || s === '-Infinity') return false
  // const num = Number(s)
  // if(isNaN(num)) return false
  // return true
  // 模拟法
  let numLeft = ''
  let numRight = ''
  s = s.trim().toLowerCase()
 if(s.includes('e')) {
    const sSplit = s.split('e')
    if(sSplit.length > 2) { return false }
    [numLeft, numRight] = sSplit
    if(validateNumLeft(numLeft) && validateNumRight(numRight)) return true
  } else {
    numLeft = s
    if(validateNumLeft(numLeft)) return true
  }
  return false
};

function validateNumLeft(numLeft) {
  if('-+'.includes(numLeft[0])) {
    numLeft = numLeft.slice(1)
    if(numLeft.includes('-') || numLeft.includes('+')) return false
  }
  if(!numLeft.length) return false
  let numLeftSplit
  if(numLeft.includes('.')) {
    numLeftSplit = numLeft.split('.')
    if(numLeftSplit.length > 2 ) return false
    if(!numLeftSplit[0].length && isNumStr(numLeftSplit[1])) return true
    if(!numLeftSplit[1].length && isNumStr(numLeftSplit[0])) return true
    if(isNumStr(numLeftSplit[0]) && isNumStr(numLeftSplit[1])) return true
    return false
  } else {
    return isNumStr(numLeft)
  }
}

function validateNumRight(numRight) {
  if(numRight[0] === '-' || numRight[0] === '+') {
    numRight = numRight.slice(1)
  }
  return isNumStr(numRight)
}

function isNumStr(numStr) {
  if(!numStr.length) return false
  for(let c of numStr) {
    if(!(c >= '0' && c <= '9')) return false
  }
  return true
}
```

## 😻✔ 70 爬楼梯【easy】

[ref](https://leetcode.cn/problems/climbing-stairs/)

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var climbStairs = function(n) {
  if(n === 1) return 1
  if(n === 2) return 2
  d1 = 1
  d2 = 2
  for(let i = 3; i <= n; i++) {
    const tmpD2 = d2
    d2 = d1 + d2
    d1 = tmpD2
  }
  return d2
};
```

数组解

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var climbStairs = function(n) {
  const d = []
  d[1] = 1
  d[2] = 2
  for(let i = 3; i <= n; i++) {
    d[i] = d[i - 1] + d[i - 2]
  }
  return d[n]
};
```

## 🌟😻✔ 72 编辑距离【hard】

[ref](https://leetcode.cn/problems/edit-distance/)

定义 `dp[i][j]` 是 word1 长度为 i 的字符串转换成 word2 长度为 j 字符串的最少操作次数。则 `dp[i][j]` 可由下面三种情况得到：

- `dp[i - 1][j - 1]` 替换掉 word1 中第 i 个字符
- `dp[i - 1][j]`  删除 word1 中第 i 个字符
- `dp[i][j - 1]`  在 word1 中第 i 个字符后面新增一个字符

上面三种情况的最小值 + 1，就是 `dp[i][j]`。

所以状态转移方程为：

```js
dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
```

然后设置初始值， i 为 0 则最短操作次数就是 j，j 为 0 则最短操作次数就是 i。


动态规划

```js
// m=word1.length n=word2.length
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var minDistance = function(word1, word2) {
  const len1 = word1.length
  const len2 = word2.length
  const dp = new Array(len1 + 1).fill(0).map(_ => new Array(len2 + 1).fill(0))
  for(let i = 0; i <= len1; i++) {
    dp[i][0] = i
  }
  for(let j = 0; j <= len2; j++) {
    dp[0][j] = j
  }
  for(let i = 1; i <= len1; i++) {
    for(let j = 1; j <= len2; j++) {
      if(word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1]
      } else {
        dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
      }
    }
  }
  return dp[len1][len2]
};
```

## ?🌟😻✔ 75. 颜色分类【medium】

[ref](https://leetcode.cn/problems/sort-colors/)

双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var sortColors = function(nums) {
  let l = 0, r = nums.length - 1, i = 0
  while(i <= r) {
    if(nums[i] === 0) {
      swap(nums, i, l)
      i++
      l++
    } else if(nums[i] === 2) {
      swap(nums, i, r)
      r--
    } else {
      i++
    }
  }
  return nums
};

function swap(nums, i, j) {
  const t = nums[i]
  nums[i] = nums[j]
  nums[j] = t
}
```

## 😻✔ 76 最小覆盖子串【hard】

[ref](https://leetcode.cn/problems/minimum-window-substring/)

双指针、滑动窗口

```js
var minWindow = function(s, t) {
  const need = new Map()
  let needType = 0
  for(let c of t) {
    if(need.has(c)) {
      need.set(c, need.get(c) + 1)
    } else {
      need.set(c, 1)
      needType += 1
    }
  }

  let l = 0
  let minStr = ''
  for(let r = 0;r < s.length; r++) {
    const c = s[r]
    if(need.has(c)) {
      need.set(c, need.get(c) - 1)
      if(need.get(c) === 0) needType -= 1 
    }
    while(needType === 0) {
      if(!minStr.length || s.slice(l, r + 1).length < minStr.length) minStr = s.slice(l, r + 1)
      if(need.has(s[l])) {
        need.set(s[l], need.get(s[l]) + 1)
        if(need.get(s[l]) === 1) {
          needType += 1
        }
      }
      l++
    }
  }
  return minStr
};
```

## 🌟😻✔ 77 组合【medium】

[ref](https://leetcode.cn/problems/combinations/)

```js
// 时间复杂度：O(C(n, k)) 组合数
// 空间复杂度：O(k)
var combine = function(n, k) {
  const res = []

  function run(path, start) {
    if(path.length === k) {
      res.push([...path])
      return
    }

    for(let i=start;i<=n;i++) {
      path.push(i)
      run(path, i + 1)
      path.pop()
    }
  }

  run([], 1)

  return res
};
```

## 🌟😻✔ 78 子集【medium】

回溯、递归

```js
// 时间复杂度：O(N*2^N)
// 时间复杂度：O(N)
var subsets = function(nums) {
  const res = []

  function calc(path, start = 0) {
    res.push(path)
    for(let i = start; i < nums.length; i++) {
      calc([...path, nums[i]], i + 1)
    }
  }

  calc([])
  return res
};
```

## ?🌟😻✔ 79 单词搜索【medium】

[ref](https://leetcode.cn/problems/word-search/)

```js
var exist = function(board, word) {
  const m = board.length
  const n = board[0].length
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  const words = word.split('')
  let has = false

  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      find(i, j, words)
    }
  }

  function find(i, j) {
    if(used[i][j]) return
    if(board[i][j] === words[0]) {
      const w = words.shift()
      used[i][j] = true

      if(!words.length) {
        has = true
        return
      }

      j + 1 < n && find(i, j + 1)
      j - 1 >= 0 && find(i, j - 1)
      i - 1 >=0 && find(i - 1, j)
      i + 1 < m && find(i + 1, j)
      words.unshift(w)
      used[i][j] = false
    }
  }

  return has
};
```

## ?🌟😻✔ 80. 删除有序数组中的重复项 II【medium】

[ref](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

数组原地操作

```typescript
// 时间复杂度：O(N)
// 空间复杂度：O(1)
function removeDuplicates(nums: number[]): number {
  if(nums.length < 3) return nums.length
  const n = nums.length
  let k = 2
  for(let i=2;i<n;i++) {
    if(nums[i] !== nums[k - 2]) {
      nums[k++] = nums[i]
    }
  }
  return k
};
```

```typescript
// 比较好理解的版本，原地标记，然后再次扫描
// 时间复杂度：O(N)
// 空间复杂度：O(1)
function removeDuplicates(nums: number[]): number {
  if(nums.length < 3) return nums.length
  let p1 = 0
  let p2 = 1
  const n = nums.length
  for(let i=2;i<n;i++) {
    if(nums[i] === nums[p1] && nums[i] === nums[p2]) {
      nums[i] = Number.MAX_SAFE_INTEGER
    } else {
      p1 = p2
      p2 = i
    }
  }
  let k = 2
  for(let i=2;i<n;i++) {
    if(nums[i] !== Number.MAX_SAFE_INTEGER) {
      nums[k++] = nums[i]
    }
  }
  return k
};
```

## ?🌟😻✔ 82 删除排序链表中的重复元素 II【medium】

[ref](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var deleteDuplicates = function(head) {
  let myHead = new ListNode()
  myHead.next = head
  let fast = myHead
  let slow = myHead
  while(fast.next && fast.next.next) {
    if(fast.next.val === fast.next.next.val) {
      fast = fast.next
    } else {
      if(fast === slow) {
        slow = slow.next
        fast = fast.next
      } else {
        slow.next = fast.next.next
        fast = slow
      }
    }
  }
  if(slow !== fast) {
    slow.next = null
  }
  return myHead.next
};
```

## ✔ 83 删除排序链表中的重复元素【easy】

[ref](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

链表

```js
var deleteDuplicates = function (head) {
  let t = head
  while (t && t.next) {
    const tNext = t.next
    if (t.val !== tNext.val) {
      t = t.next
    } else {
      t.next = tNext.next
    }
  }
  return head
}
```

## ?🌟😻✔ 84 柱状图中最大的矩形【hard】

[ref](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var largestRectangleArea = function(heights) {
  heights = [0, ...heights, 0]
  let max = 0
  const q = [0]
  for(let i=1;i<heights.length;i++) {
    while(heights[i] < heights[q[q.length - 1]]) {
      const h = heights[q.pop()]
      const w = i - q[q.length - 1] - 1
      max = Math.max(max, w * h)
    }
    if(heights[i] >= heights[q[q.length - 1]]) {
      q.push(i)
    }
  }
  return max
};
```

## ?🌟😻✔ 85 最大矩形【hard】

[ref](https://leetcode.cn/problems/maximal-rectangle/)

单调栈

相关请看 84 题

```js
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var maximalRectangle = function(matrix) {
  if(!matrix.length || !matrix[0].length) return 0
  const m = matrix.length
  const n = matrix[0].length
  const left = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(matrix[i][j] === '1') {
        left[i][j] = (j - 1 >= 0 ? left[i][j - 1] : 0) + 1
      }
    }
  }
  // 给每列加前导0和后置0，具体原因请看
  // #84 https://leetcode.cn/problems/largest-rectangle-in-histogram/
  // 前导0可以用于 w 宽度计算时的左边界
  // 后置0可以用于清空q栈，q是必须要清空的，如果不加后置0，则对于递增的高度需要做额外的后置处理
  left.unshift(new Array(n).fill(0))
  left.push(new Array(n).fill(0))
  let max = 0
  for(let j=0;j< n;j++) {
    const q = []
    for(let i=0;i<m + 2;i++) {
      while(q.length - 1 >= 0 && left[q[q.length - 1]][j] > left[i][j]) {
        const h = left[q.pop()][j]
        const w = i - q[q.length - 1] - 1
        max = Math.max(max, w * h)
      }
      q.push(i)
    }
  }
  return max
};
```

## 🌟😻✔ 86. 分隔链表【medium】

[ref](https://leetcode.cn/problems/partition-list/)

```js
var partition = function(head, x) {
  const head1 = new ListNode(), head2 = new ListNode()
  let tHead1 = head1, tHead2 = head2
  while(head) {
    const next = head.next
    if(head.val < x) {
      tHead1.next = head
      tHead1 = tHead1.next
    } else {
      tHead2.next = head
      tHead2 = tHead2.next
    }
    head = next
  }
  tHead1.next = head2.next
  tHead2.next = null
  return head1.next
};
```

## ✔ 88 合并两个有序数组【easy】

[ref](https://leetcode.cn/problems/merge-sorted-array/)

```js
// 时间复杂度：O(m+n)
// 空间复杂度：O(1)
var merge = function(nums1, m, nums2, n) {
  let mn = m + n - 1
  let mIndex = m - 1
  let nIndex = n - 1
  while(mIndex >= 0 && nIndex >= 0) {
    if(nums1[mIndex] > nums2[nIndex]) {
      nums1[mn] = nums1[mIndex]
      mIndex--
    } else {
      nums1[mn] = nums2[nIndex]
      nIndex--
    }
    mn--
  }
  // 有可能 nums1 中的数字都复制完了，nums2 中还存在数字
  // 则把 nums2 中的数字都复制过来
  // 如果是 nums2 没有需要复制的，而 nums1 有需要复制的，则可以直接跳过
  while(nIndex >= 0) {
    nums1[nIndex] = nums2[nIndex]
    nIndex--
    mn--
  }
};
```

## ?? 🌟😻✔ 89 格雷编码【medium】

[ref](https://leetcode.cn/problems/gray-code/)

规律题

```js
// 规律题
// 时间复杂度：O(2^N)
// 时间复杂度：O(2^N)
// 注意条件：
// 结果数组中有 2^N 个数，且刚好是 [0, 2^N -1] 内的数
// 1. 对于 N-1 的格雷编码，N 中的数字是N-1中数字的一倍
// 2. N-1 中已形成格雷编码的情况下，对这 N-1 个数字的二进制前面加一个1，然后翻转就是另外 2^(N-1) 个数字
// 0 01 => 0 01 0 01 => 0 01 10 11 => 0 01 11 10
// 0 01 11 10 => 0 01 11 10 0 01 11 10 => 0 01 11 10 100 101 111 110 => 0 01 11 10 110 111 101 100
var grayCode = function(n) {
  const res = [0];
  for (let i = 1; i <= n; i++) {
    const len = res.length;
    for (let j = len - 1; j >= 0; j--) {
      res.push(res[j] + len)
    }
  }
  return res;
};

// 0 1 11 10
// 0 1 3 2

// 0  0
// 1  1
// 2  10
// 3  11 
// 4  100
// 5  101
// 6  110
// 7  111
// 8  1000
// 9  1001
// 10 1010
// 11 1011
// 12 1100
// 13 1101
// 14 1110
// 15 1111

```

## 🌟😻✔ 90 子集 II【medium】

[ref](https://leetcode.cn/problems/subsets-ii/)

回溯、深度优先遍历

```js
// 时间复杂度：O(n×2^n)
// 空间复杂度：O(n)
var subsetsWithDup = function(nums) {
  nums.sort((a, b) => a - b)
  const res = []
  const len = nums.length
  const used = []
  function dfs(path, index) {
    res.push(path)
    for(let i=index;i<len;i++) {
      if(i - 1 >= index && !used[i - 1] && nums[i] === nums[i - 1]) continue
      used[i] = true
      dfs([...path, nums[i]], i + 1)
      used[i] = false
    }
  }
  dfs([], 0)
  return res
};
```

## ?? 🌟😻✔ 91. 解码方法【medium】

[ref](https://leetcode.cn/problems/decode-ways/)

动态规划、模拟、字符串题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numDecodings = function(s) {
  if(s[0] === '0') return 0
  const n = s.length
  let v1 = 0, v2 = 1
  for(let i = 1; i < n; i++) {
    if(s[i] === '0' && s[i - 1] !== '1' && s[i - 1] !== '2') return 0
    const pv1 = v1, pv2 = v2
    let nextV2 = 0
    if(s[i] !== '0') {
      nextV2 += pv2
    }
    if(s[i - 1] !== '0' && (s[i-1] * 10 + s[i] * 1 <= 26)) {
      nextV2 += (i - 2 >= 0 ? pv1 : 1)
    }
    v1 = pv2
    v2 = nextV2
  }
  return v2
};

```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var numDecodings = function(s) {
  if(s[0] === '0') return 0
  const n = s.length
  const dp = new Array(n).fill(0)
  dp[0]=1
  for(let i = 1; i < n; i++) {
    if(s[i] === '0' && s[i - 1] !== '1' && s[i - 1] !== '2') return 0
    if(s[i] !== '0') {
      dp[i] += dp[i - 1]
    }
    if(s[i - 1] !== '0' && (s[i-1] * 10 + s[i] * 1 <= 26)) {
      dp[i] += (i - 2 >= 0 ? dp[i - 2] : 1)
    }
  }
  return dp[n - 1]
};
```

of

```js
var numDecodings = function(s) {
  if(s[0] === '0') return 0
  const n = s.length
  const dp = new Array(n).fill(0)
  dp[0]=1
  for(let i = 1; i < n; i++) {
    if(s[i] === '0') {
      if(s[i - 1] === '1' || s[i - 1] === '2') {
        dp[i] = (i - 2 >= 0 ? dp[i - 2] : 1)
      } else {
        return 0
      }
    }else if(s[i] > 6) {
      if(s[i-1] === '1') {
        dp[i] = dp[i - 1] + (i - 2 >= 0 ? dp[i - 2] : 1)
      } else {
        dp[i] = dp[i - 1]
      }
    } else {
      if(s[i-1] === '1' || s[i-1] === '2') {
        dp[i] = dp[i - 1] + (i - 2 >= 0 ? dp[i - 2] : 1)
      } else {
        dp[i] = dp[i - 1]
      }
    }
  }
  return dp[n - 1]
};
```

## 🌟😻✔ 93 复原 IP 地址【medium】

[ref](https://leetcode.cn/problems/restore-ip-addresses/)

回溯法

```js
// SEG_COUNT=4 表示 ip 的地址段数
// 时间复杂度：O(3*SEG_COUNT)
// 空间复杂度：O(SEG_COUNT)
var restoreIpAddresses = function(s) {
  if(s.length < 4) return []
  const res = []

  function calc(path, start, dotLeft) {
    if(dotLeft === 0) {
      const end = s.slice(start)
      if(isValidSub(end)) {
        res.push(path + end)
      }
      return
    }
    ;([1, 2, 3]).forEach(l => {
      const current = s.slice(start, start + l)
      if(isValidSub(current)) {
        calc(path + current + '.', start + l, dotLeft - 1)
      }
    })
  }

  calc('', 0, 3)
  return res
};

function isValidSub(str) {
  if(str === '0' || str.indexOf('0') !== 0 && Number(str) > 0 && Number(str) <= 255) {
    return true
  }
  return false
}
```

## 😻✔ 94 二叉树的中序遍历【easy】

[ref](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

二叉树、中序遍历、DFS、深度优先遍历

```js
var inorderTraversal = function (root) {
  const res = []
  const dfs = node => {
    if (!node) return
    dfs(node.left)
    res.push(node.val)
    dfs(node.right)
  }
  dfs(root)
  return res
}1
```

## ?🌟😻✔ 95. 不同的二叉搜索树 II【medium】

[ref](https://leetcode.cn/problems/unique-binary-search-trees-ii/)

二叉搜索树

```js
var generateTrees = function(n) {
  function createTrees(min, max) {
    const allTrees = []
    if(min > max) {
      allTrees.push(null)
      return allTrees
    }
    for(let i=min;i<=max;i++) {
      const leftTrees = createTrees(min, i - 1)
      const rightTrees = createTrees(i + 1, max)
      for(let left of leftTrees) {
        for(let right of rightTrees) {
          const node = new TreeNode(i)
          node.left = left
          node.right = right
          allTrees.push(node)
        }
      }
    }
    return allTrees
  }
  return createTrees(1, n)
};
```


## ?🌟😻✔ 96 不同的二叉搜索树【medium】

[ref](https://leetcode.cn/problems/unique-binary-search-trees/)

模拟、动态规划

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var numTrees = function(n) {
  const m = new Map([[0, 1], [1, 1]])
  function createTree(min, max) {
    if(m.has(max - min + 1)) return m.get(max - min + 1)
    let sum = 0
    for(let i=min;i<=max;i++) {
      const leftSum = createTree(min, i - 1)
      const rightSum = createTree(i + 1, max)
      sum += leftSum * rightSum
    }
    m.set(max - min + 1, sum)
    return sum
  }
  return createTree(1, n)
};
```

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var numTrees = function(n) {
  const dp = new Array(n + 1).fill(0)
  dp[0] = 1
  dp[1] = 1
  for(let i=2;i<=n;i++) {
    for(let j=0;j<i;j++) {
      dp[i] += dp[j] * dp[i - 1 - j]
    }
  }
  return dp[n]
};
```

## ??🌟😻✔ 97. 交错字符串【medium】

[ref](https://leetcode.cn/problems/interleaving-string/)

字符串、动态规划

比较好理解的题解

- [动态规划 逐行解释 python3](https://leetcode.cn/problems/interleaving-string/solution/dong-tai-gui-hua-zhu-xing-jie-shi-python3-by-zhu-3/)

```js
// 时间复杂度：O(MN) M=s1.length N=s2.length
// 空间复杂度：O(N)
var isInterleave = function(s1, s2, s3) {
  const s1Len = s1.length, s2Len = s2.length
  if(s1Len + s2Len !== s3.length) return false
  let dp = new Array(s2Len + 1).fill(false)
  for(let i=0;i<=s1Len;i++) {
    let ndp = []
    for(let j=0;j<=s2Len;j++) {
      if(i === 0) {
        ndp[j] = s2.slice(0, j) === s3.slice(0, j)
      } else if(j === 0) {
        ndp[j] = s1.slice(0, i) === s3.slice(0, i)
      } else {
        ndp[j] = (dp[j] && s1[i - 1] === s3[i + j - 1]) || (ndp[j - 1] && s2[j - 1] === s3[i + j - 1])
      }
    }
    dp = ndp
  }
  return dp[s2Len]
};
```

```js
// 时间复杂度：O(MN) M=s1.length N=s2.length
// 空间复杂度：O(MN)
var isInterleave = function(s1, s2, s3) {
  const s1Len = s1.length, s2Len = s2.length
  if(s1Len + s2Len !== s3.length) return false
  const dp = new Array(s1Len + 1).fill(0).map(_ => new Array(s2Len + 1).fill(false))
  dp[0][0] = true
  for(let i=1;i<=s1Len;i++) {
    if(s1[i - 1] === s3[i - 1] && dp[i-1][0]) dp[i][0] = true
    else break
  }
  for(let j=1;j<=s2Len;j++) {
    if(s2[j - 1] === s3[j - 1] && dp[0][j - 1]) dp[0][j] = true
    else break
  }
  for(let i=1;i<=s1Len;i++) {
    for(let j=1;j<=s2Len;j++) {
      dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1])
    }
  }

  return dp[s1Len][s2Len]
};

```

## ?🌟😻✔ 98. 验证二叉搜索树【medium】

[ref](https://leetcode.cn/problems/validate-binary-search-tree/submissions/)

二叉树、二叉搜索树

```js
// 自顶向下，碰到异常情况直接结束，效率更优，不需要扫描所有节点
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var isValidBST = function(root) {
  function dfs(node, max, min) {
    if(!node) return true
    if(!(node.val > min && node.val < max)) return false
    return dfs(node.left, node.val, min) && dfs(node.right, max, node.val)
  }
  return dfs(root, Infinity, -Infinity)
};
```

```js
// DFS
// 自底向上，必须扫描所有节点
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var isValidBST = function(root) {
  let is = true
  function dfs(node) {
    let min = node.val, max = node.val
    if(node.left) {
      const [lmin, lmax] = dfs(node.left)
      if(lmax >= node.val) is = false
      min = Math.min(lmin, lmax, min)
      max = Math.max(lmin, lmax, max)
    }
    if(node.right) {
      const [rmin, rmax] = dfs(node.right)
      if(rmin <= node.val) is = false
      min = Math.min(rmin, rmax, min)
      max = Math.max(rmin, rmax, max)
    }
    return [min, max]
  }
  dfs(root)
  return is
};

```

## ?🌟😻✔ 99. 恢复二叉搜索树【medium】

[ref](https://leetcode.cn/problems/recover-binary-search-tree/)

二叉搜索树、二叉树

题解
- [ref](https://leetcode.cn/problems/recover-binary-search-tree/solution/dai-ma-jian-ji-by-lxfriday-qsvi/)

```js
// 时间复杂度：O(N) 会走一遍所有节点
// 空间复杂度：O(N) 递归消耗
var recoverTree = function(root) {
  let errNode1, errNode2
  let prevNode
  function dfs(node) {
    node.left && dfs(node.left)
    if(prevNode) {
      if(prevNode.val > node.val) {
        if(!errNode1) {
          errNode1 = prevNode
          errNode2 = node
        } else {
          errNode2 = node
        }
      }
    }
    prevNode = node
    node.right && dfs(node.right)
  }
  dfs(root)
  // 两个错误节点交换值
  const t = errNode1.val
  errNode1.val = errNode2.val
  errNode2.val = t
  return root
};
```


## 😻✔ 100 相同的树【easy】

[ref](https://leetcode.cn/problems/same-tree/)

二叉树、树

```js
// 时间复杂度：O(n)
// 空间复杂度：O(logn)~O(n)
var isSameTree = function(p, q) {
  if(!p && !q) return true
  if(p && q && p.val === q.val) {
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
  }
  return false
};
```

## 😻✔ 101 对称二叉树【easy】

[ref](https://leetcode.cn/problems/symmetric-tree/)

二叉树

```js
// 时间复杂度：O(n)
// 空间复杂度：O(logn)~O(n)
var isSymmetric = function(root) {
  if(!root) return true
  const isMirror = (l, r) => {
    if(!l && !r) return true
    if(l && r && l.val === r.val) {
      return isMirror(l.left, r.right) && isMirror(l.right, r.left)
    }
    return false
  }
  return isMirror(root.left, root.right)
};
```

## 😻✔ 102 二叉树的层序遍历【medium】

[ref](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

二叉树、BFS、广度优先遍历、层序遍历

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var levelOrder = function(root) {
  if(!root) return []
  const res = []
  let q = [root]
  let tmpQ = []
  let depthArr = []
  while(q.length) {
    const node = q.shift()
    depthArr.push(node.val)
    node.left && tmpQ.push(node.left)
    node.right && tmpQ.push(node.right)
    if(!q.length && tmpQ.length) {
      q = tmpQ
      tmpQ = []
      res.push(depthArr)
      depthArr = []
    } else if(!q.length && !tmpQ.length) {
      res.push(depthArr)
    }
  }
  return res
};
```

```js
var levelOrder = function (root) {
  if (!root) return []
  const q = [[root, 0]]
  const res = []
  while (q.length) {
    const [node, depth] = q.shift()
    res[depth] ? res[depth].push(node.val) : (res[depth] = [node.val])
    node.left && q.push([node.left, depth + 1])
    node.right && q.push([node.right, depth + 1])
  }

  return res
}
```

## ?😻✔ 103. 二叉树的锯齿形层序遍历【medium】

[ref](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

二叉树、广度优先搜索

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var zigzagLevelOrder = function(root) {
  if(!root) return []
  const res = [[root.val]]
  let q = [root]
  let tmp = []
  let isLeft = false
  while(q.length) {
    const node = q.shift()
    node.left && tmp.push(node.left)
    node.right && tmp.push(node.right)
    if(!q.length) {
      const tRes = []
      q = [...tmp]
      while(tmp.length) {
        tRes.push(tmp.shift().val)
      }
      tRes.length && res.push(isLeft ? tRes : tRes.reverse())
      isLeft = !isLeft
    }
  }
  return res
};
```

## 😻✔ 104 二叉树的最大深度【easy】

[ref](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

二叉树、深度优先遍历、DFS

```js
var maxDepth = function (root) {
  let maxLen = 0
  const dfs = (node, l) => {
    if (!node) return
    maxLen = Math.max(maxLen, l)
    dfs(node.left, l + 1)
    dfs(node.right, l + 1)
  }
  dfs(root, 1)
  return maxLen
}
```

## ?🌟😻✔ 105 从前序与中序遍历序列构造二叉树【medium】

[ref](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

二叉树、二叉树的构造

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var buildTree = function(preorder, inorder) {
  const root = new TreeNode(preorder.shift())
  let i= inorder.indexOf(root.val)
  const leftOrders = inorder.slice(0, i)
  const rightOrders = inorder.slice(i + 1)
  if(leftOrders.length) {
    root.left = buildTree(preorder, leftOrders)
  }
  if(rightOrders.length) {
    root.right = buildTree(preorder, rightOrders)
  }
  return root
};

```

## ?🌟😻✔ 106. 从中序与后序遍历序列构造二叉树【medium】

[ref](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

二叉树构建、二叉树

```js
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var buildTree = function(inorder, postorder) {
  function build(l, r) {
    if(l > r) return null
    const node = new TreeNode(postorder.pop())
    const ind = inorder.indexOf(node.val)
    node.right = build(ind + 1, r)
    node.left = build(l, ind - 1)
    return node
  }
  return build(0, inorder.length - 1)
};
```

```js
var buildTree = function(inorder, postorder) {
  if(!inorder.length) return null
  const node = new TreeNode(postorder.pop())
  const ind = inorder.indexOf(node.val)
  node.right = buildTree(inorder.slice(ind + 1), postorder)
  node.left = buildTree(inorder.slice(0, ind), postorder)
  return node
};
```


## 🌟😻✔ 107. 二叉树的层序遍历 II【medium】

[ref](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

二叉树、层序遍历、广度优先搜索、BFS

```typescript
function levelOrderBottom(root: TreeNode | null): number[][] {
  if(!root) return []
  let q:TreeNode[] = [root]
  const res: number[][] = []
  while(q.length) {
    const len = q.length
    const newQ:TreeNode[] = []
    const levelRes: number[] = []
    for(let i=0;i<len;i++) {
      const node = q[i]
      levelRes.push(node.val)
      node.left && newQ.push(node.left)
      node.right && newQ.push(node.right)
    }
    q = newQ
    res.unshift(levelRes)
  }
  return res
};
```

## 🌟😻✔ 108. 将有序数组转换为二叉搜索树【easy】

[ref](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

二叉搜索树、平衡二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
// 时间复杂度：O(N)
// 空间复杂度：O(logN)
var sortedArrayToBST = function(nums) {
  function toBST(l, r) {
    if(l > r) return null
    const mid = (l + r) >> 1
    const node = new TreeNode(nums[mid])
    node.left = toBST(l, mid - 1)
    node.right = toBST(mid + 1, r)
    return node
  }
  return toBST(0, nums.length - 1)
};
```

## 🌟😻✔ 109. 有序链表转换二叉搜索树【medium】

[ref](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)

二叉搜索树

```js
// 利用二叉搜索树的中序遍历特性和二叉搜索树特性
// 二叉搜索树的中序遍历结果对应的就是链表的数字
// 时间复杂度：O(N)
// 空间复杂度：O(logN)
var sortedListToBST = function(head) {
  let len = 0
  let thead = head
  while(thead) {
    len++
    thead = thead.next
  }
  function buildBST(l, r) {
    if(l > r) return null
    const mid = Math.floor((l + r) / 2)
    const leftNode = buildBST(l, mid - 1)
    const node = new TreeNode(head.val)
    head = head.next
    const rightNode = buildBST(mid + 1, r)
    node.left = leftNode
    node.right = rightNode
    return node
  }
  return buildBST(0, len - 1)
};
```

```js
// 快慢指针
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var sortedListToBST = function(head) {
  if(!head) return null
  const myHead = new TreeNode()
  myHead.next = head
  let slow = myHead, fast = myHead
  while(fast.next && fast.next.next) {
    slow = slow.next
    fast = fast.next.next
  }
  if(slow === fast) {
    return new TreeNode(slow.next.val)
  } else {
    const root = new TreeNode(slow.next.val)
    const head2 = slow.next.next
    slow.next = null
    root.left = sortedListToBST(head)
    root.right = sortedListToBST(head2)
    return root
  }
};
```


## 😻✔ 110. 平衡二叉树【easy】

[ref](https://leetcode.cn/problems/balanced-binary-tree/)

二叉树、平衡二叉树

```js
var isBalanced = function(root) {
  let is = true
  function dfs(node) {
    if(!node) return 0
    const left = dfs(node.left)
    const right = dfs(node.right)
    if(Math.abs(left - right) > 1) is = false
    return Math.max(left, right) + 1
  }
  dfs(root)
  return is
};
```

## 😻✔ 111 二叉树的最小深度【easy】

[ref](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

二叉树、广度优先遍历、BFS

```js
var minDepth = function (root) {
  if (!root) return 0
  const q = [[root, 1]]
  while (q.length) {
    const [node, depth] = q.shift()
    if (!node.left && !node.right) return depth
    node.left && q.push([node.left, depth + 1])
    node.right && q.push([node.right, depth + 1])
  }
}
```

## 😻✔ 112 路径总和【easy】

[ref](https://leetcode.cn/problems/path-sum/)

二叉树、二叉树的路径总和、DFS、深度优先遍历

```js
var hasPathSum = function (root, targetSum) {
  if (!root) return false
  let has = false
  const dfs = (node, sum) => {
    if (!node.left && !node.right) {
      if (node.val + sum === targetSum) {
        has = true
      }
    }
    node.left && dfs(node.left, node.val + sum)
    node.right && dfs(node.right, node.val + sum)
  }

  dfs(root, 0)
  return has
}
```

## 😻✔ 113 路径总和 II【medium】

[ref](https://leetcode.cn/problems/path-sum-ii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var pathSum = function(root, targetSum) {
  if(!root) return []
  const res = []

  function dfs(node, path, sum) {
    if(!node.left && !node.right) {
      if(sum + node.val === targetSum) {
        res.push([...path, node.val])
      }
      return
    }
    path.push(node.val)
    node.left && dfs(node.left, path, sum + node.val)
    node.right && dfs(node.right, path, sum + node.val)
    path.pop()
  }

  dfs(root, [], 0)

  return res
};
````

## ?🌟😻✔ 114 二叉树展开为链表【medium】

[ref](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

二叉树、链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var flatten = function(root) {
  if(!root) return root
  let left = flatten(root.left)
  let right = flatten(root.right)
  root.left = null
  if(left) {
    root.right = left
    while(left.right) {
      left = left.right
    }
    left.right = right
  } else {
    root.right = right
  }
  return root
};
```

## ???🌟😻✔ 115. 不同的子序列【hard】

[ref](https://leetcode.cn/problems/distinct-subsequences/)

动态规划

```js
var numDistinct = function(s, t) {
  const m = s.length, n = t.length, dp = new Array(m + 1).fill(0).map(_ => new Array(n + 1).fill(0))
  dp[0][0] = 1
  for(let i=1;i<=m;i++) dp[i][0] = 1
  for(let i=1; i <= m; i++) {
    for(let j=1; j <= Math.min(i, n); j++) {
      dp[i][j] = dp[i-1][j]
      if(s[i-1] === t[j - 1]) {
        dp[i][j] += dp[i-1][j-1]
      }
    }
  }
  return dp[m][n]
};
```

## ?🌟😻✔ 116. 填充每个节点的下一个右侧节点指针【medium】

[ref](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

二叉树、规律题

充分利用已经构建出来的 next 指针

```js
// 与 117 题同解
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var connect = function(root) {
  let node = root
  // 记录当前层的前一个节点
  let prev = null
  // 记录下一层的首个节点
  let nextLevelFirstNode = null
  while(node) {
    if(node.left) {
      if(prev) prev.next = node.left
      if(!nextLevelFirstNode) nextLevelFirstNode = node.left
      prev = node.left
    }
    if(node.right) {
      if(prev) prev.next = node.right
      if(!nextLevelFirstNode) nextLevelFirstNode = node.right
      prev = node.right
    }
    // 当前层右边还有节点，则继续往右走，否则往下一层走
    if(node.next) {
      node = node.next
    } else {
      // 当前层已经没有节点了，切换到下一层，重置 prev 和 nextLevelFirstNode
      node = nextLevelFirstNode
      nextLevelFirstNode = null
      prev = null
    }
  }
  return root
};

```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var connect = function(root) {
  let left1 = root
  while(left1) {
    let head = left1
    while(head && head.left) {
      head.left.next = head.right
      if(head.next) head.right.next = head.next.left
      head = head.next
    }
    left1 = left1.left
  }
  return root
};
```

```js
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

// 时间复杂度：O(N) N 节点个数
// 时间复杂度：O(logN)
var connect = function(root) {
  function dfs(node1) {
    if(!node1) return
    if(node1.left) {
      node1.left.next = node1.right
      dfs(node1.left)
    }
    if(node1.right) {
      node1.right.next = node1.next? node1.next.left : null
      dfs(node1.right)
    }
  }
  dfs(root)
  return root
};
```

## ??🌟😻✔ 117. 填充每个节点的下一个右侧节点指针 II【medium】

[ref](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

二叉树

题解：
- [【云影同学】通用解法，不管是不是完美二叉树](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/solution/by-lxfriday-qt73/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var connect = function(root) {
  let node = root
  // 记录当前层的前一个节点
  let prev = null
  // 记录下一层的首个节点
  let nextLevelFirstNode = null
  while(node) {
    if(node.left) {
      if(prev) prev.next = node.left
      if(!nextLevelFirstNode) nextLevelFirstNode = node.left
      prev = node.left
    }
    if(node.right) {
      if(prev) prev.next = node.right
      if(!nextLevelFirstNode) nextLevelFirstNode = node.right
      prev = node.right
    }
    // 当前层右边还有节点，则继续往右走，否则往下一层走
    if(node.next) {
      node = node.next
    } else {
      // 当前层已经没有节点了，切换到下一层，重置 prev 和 nextLevelFirstNode
      node = nextLevelFirstNode
      nextLevelFirstNode = null
      prev = null
    }
  }
  return root
};
```

## 🌟✔ 118 杨辉三角【easy】

[ref](https://leetcode.cn/problems/pascals-triangle/)

```js
// N=numRows
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var generate = function(numRows) {
  const res = []
  for(let i=0;i<numRows;i++) {
    const cur = []
    for(let j=0;j<=i;j++) {
      if(j === 0 || j === i) {
        cur.push(1)
      } else {
        cur.push(res[i - 1][j - 1] + res[i - 1][j])
      }
    }
    res.push(cur)
  }
  return res
};
```

## 🌟😻✔ 119. 杨辉三角 II【easy】

[ref](https://leetcode.cn/problems/pascals-triangle-ii/)

动态规划、滚动数组

```js
var getRow = function(rowIndex) {
  let dp = [1]
  for(let i=1;i<=rowIndex;i++) {
    const tdp = []
    for(let j=0;j<=i;j++) {
      if(j === 0) {
        tdp.push(dp[0])
      } else if(j === i) {
        tdp.push(dp[dp.length - 1])
      } else {
        tdp.push(dp[j - 1] + dp[j])
      }
    }
    dp = tdp
  }
  return dp
};
```

## 🌟😻✔ 120. 三角形最小路径和【medium】

[ref](https://leetcode.cn/problems/triangle/)

动态规划

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var minimumTotal = function(triangle) {
  for(let i=1;i<triangle.length;i++) {
    for(let j=0;j<=i;j++) {
      let sum = triangle[i][j]
      if(j === 0) {
        sum += triangle[i-1][j]
      } else if (j === i) {
        sum += triangle[i-1][j - 1]
      } else {
        sum += Math.min(triangle[i-1][j], triangle[i-1][j - 1])
      }
      triangle[i][j] = sum
    }
  }
  return Math.min(...triangle[triangle.length - 1])
};
```

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var minimumTotal = function(triangle) {
  const n = triangle.length
  let dp = [triangle[0][0]]
  for(let i=1;i<n;i++) {
    let dpp = []
    for(let j=0;j<=i;j++) {
      let sum = triangle[i][j]
      if(j === 0) {
        sum += dp[j]
      } else if (j === i) {
        sum += dp[j - 1]
      } else {
        sum += Math.min(dp[j], dp[j - 1])
      }
      dpp.push(sum)
    }
    dp = dpp
  }
  return Math.min(...dp)
};
```


```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var minimumTotal = function(triangle) {
  if(triangle.length === 1) return triangle[0][0]
  const n = triangle.length
  const dp = new Array(n).fill(0).map(_ => [])
  dp[0][0] = triangle[0][0]
  let min = Number.MAX_SAFE_INTEGER
  for(let i=1;i<n;i++) {
    for(let j=0;j<=i;j++) {
      dp[i][j] = triangle[i][j]
      if(j === 0) {
        dp[i][j] += dp[i-1][j]
      } else if (j === i) {
        dp[i][j] += dp[i-1][j - 1]
      } else {
        dp[i][j] += Math.min(dp[i-1][j], dp[i-1][j - 1])
      }
      if(i === n - 1) {
        min = Math.min(min, dp[i][j])
      }
    }
  }
  return min
};
```

## 😻✔ 121 买卖股票的最佳时机【easy】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

动态规划

```js
// 抓住一个点：从后往前看，到某一天的时候，能获得的最大利润是：Math.max(至前一天能获得的最大利润, 至当天能获得的最大利润)
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  let maxProfit = 0
  let everMin = prices[0]
  for(let i = 1 ;i < prices.length; i++) {
    everMin = Math.min(everMin, prices[i])
    maxProfit = Math.max(maxProfit, prices[i] - everMin)
  }
  return maxProfit
};
```

数组版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProfit = function(prices) {
  let dp = []
  let everMin = prices[0]
  dp[0] = 0
  for(let i = 1 ;i < prices.length; i++) {
    everMin = Math.min(everMin, prices[i])
    dp[i] = Math.max(dp[i - 1], prices[i] - everMin)
  }
  return dp[prices.length - 1]
};
```

## 😻✔ 122 买卖股票的最佳时机 II【medium】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

动态规划

```js
var maxProfit = function(prices) {
  let maxProfit = 0
  for(let i = 1; i < prices.length; i++) {
    maxProfit = Math.max(maxProfit, maxProfit + prices[i] - prices[i - 1])
  }
  return maxProfit
};
```

数组版本

```js
var maxProfit = function(prices) {
  const dp = []
  dp[0] = 0
  for(let i = 1; i < prices.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 1] + prices[i] - prices[i - 1])
  }
  return dp[prices.length - 1]
};
```

or

```js
// 时间复杂度：O(n)
// 时间复杂度：O(1)
// 赚钱的宗旨：只要后一天比前一天价格高，我就会赚，所以我每天都买，但是我知道第二天会跌
// 会涨：则默认为我昨天就买了，今天的涨幅算进利润里
// 会跌：那我前一天买了又卖了
var maxProfit = function(prices) {
  let maxProfit = 0
  let buyPrice = prices[0]
  for(let i = 1;i < prices.length; i++) {
    if(prices[i] >= buyPrice) {
      maxProfit += prices[i] - buyPrice
    }
    buyPrice = prices[i]
  }
  return maxProfit
};
```



## 😻✔ 123 买卖股票的最佳时机 III【hard】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

动态规划


容易理解的版本

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxProfit = function(prices) {
  const n = prices.length
  const lDp = new Array(n).fill(0)
  const rDp = new Array(n).fill(0)

  // 从左往右扫描，记录 0~i 范围内操作一次的最大收益
  let lMin = prices[0]
  let lProMax = 0
  for(let i=1;i<n;i++) {
    if(prices[i] > lMin) {
      lProMax = Math.max(prices[i] - lMin, lProMax)
    } else {
      lMin = prices[i]
    }
    lDp[i] = lProMax
  }

  // 从右往左扫描，记录 i~n-1 范围内操作一次的最大收益
  let rMax = prices[n-1]
  let rProMax = 0
  for(let i=n-2;i>=0;i--) {
    if(prices[i] < rMax) {
      rProMax = Math.max(rMax - prices[i], rProMax)
    } else {
      rMax = prices[i]
    }
    rDp[i] = rProMax
  }

  let maxPro = 0
  // 最多操作两次，而且两次不能重叠，所以上面 lDp 和 rDp 刚好互补
  // 从0~n做一次扫描，记录左右操作的和，取最大值即为结果
  for(let i = 0; i < n; i++) {
    maxPro = Math.max(lDp[i] + rDp[i], maxPro)
  }
  return maxPro
};
```

超高效版本

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  const n = prices.length;
  let buy1 = -prices[0], buy2 = -prices[0];
  let sell1 = 0, sell2 = 0;
  for (let i = 1; i < n; i++) {
      sell2 = Math.max(sell2, buy2 + prices[i]);
      buy2 = Math.max(buy2, sell1 - prices[i]);
      sell1 = Math.max(sell1, buy1 + prices[i]);
      buy1 = Math.max(buy1, -prices[i]);
  }
  return sell2;
};
```

普通版本

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
// ref https://blog.csdn.net/qq_35027690/article/details/118557921
var maxProfit = function(prices) {
  // 最多操作两次时
  // 第i天的收益，总共包含5中情况（i 对应数组下标）
  // 0：没操作，收益为0，可以直接排除，对应 d[i][0] = 0 一直是 0
  // 1：只买了一次，流动资金相比初始状态是负值
  // 2：买了一次，卖了一次，流动资金相比初始状态是正值（只赚不赔）
  // 3：买了一次，卖了一次，又买了一次，流动资金相比初始状态是未知的
  // 4：买了一次，卖了一次，又买了一次，又卖了一次，流动资金相比初始状态是正值（只赚不赔）
  const dp = new Array(prices.length).fill('').map(_ =>[])
  // 把初始值定出来
  dp[0][0] = 0
  dp[0][1] = -prices[0]
  dp[0][2] = 0
  dp[0][3] = -prices[0]
  dp[0][4] = 0
  for(let i = 1; i < prices.length; i++) {
    // 构建状态转移方程
    // --------------------------
    // i 天内只买了一次的最大收益
    // dp[i][1] = max(dp[i - 1][1] , dp[i - 1][0] - prices[i])
    // dp[i - 1][1]： 第i天没操作，顺延到 i - 1 天内只买了一次，没卖
    // dp[i - 1][0] - prices[i]： i - 1 天内没操作，在 i 天买了,  - prices[i]
    // 实际就是：dp[i][1] = max(dp[i - 1][1] , - prices[i])
    dp[i][1] = Math.max(dp[i-1][1], -prices[i])
    // --------------------------
    // i 天内只买了一次又卖了一次的最大收益
    // dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i])
    // dp[i-1][2]：第 i 天没操作，顺延到 i - 1 天内进行了买卖各一次
    // dp[i-1][1] + prices[i]：第 i 天卖了，在第 i - 1 天内进行了一次买入操作
    dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i])
    // --------------------------
    // i 天内进行了买一次，卖一次，又买一次的最大收益
    // dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i])
    // dp[i-1][3]：第 i 天没有操作，顺延到 i - 1 天内进行买卖买操作后的结果
    // dp[i-1][2] - prices[i]：第 i 天买了，在 i - 1 天内进行了一次买卖操作
    dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i])
    // --------------------------
    // i 天内进行了买一次，卖一次，又买一次，又卖一次的最大收益
    // dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i])
    // dp[i-1][4]：第 i 天没操作，顺延到 i - 1 天内进行了买卖各两次
    // dp[i-1][3] + prices[i]：第 i 天卖了一次，并且在 i - 1 天内进行了买卖买操作
    dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i])
    // --------------------------
  }
  return dp[prices.length - 1][4]
};
```

## 🌟😻✔ 124 二叉树中的最大路径和【hard】

[ref](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

一般涉及到路径的问题，都可以从路径根节点下手，任一一条路径必然会有一个根节点，二叉树中以任意一个节点为根节点的最大路径节点总和的**最大值**即为答案。

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n) 空间复杂度取决于递归调用的层数，最差情况下为 O(n)
var maxPathSum = function(root) {
  let max = root.val
  function dfs(node) {
    let leftMax = 0
    let rightMax = 0
    if(node.left) {
      leftMax = dfs(node.left)
    }
    if(node.right) {
      rightMax = dfs(node.right)
    }
    const ret = Math.max(leftMax + node.val, rightMax + node.val, node.val)
    max = Math.max(ret, leftMax + rightMax + node.val, max)
    return ret
  }

  dfs(root)
  return max
};

```

## ✔ 125. 验证回文串【easy】

[ref](https://leetcode.cn/problems/valid-palindrome/)

回文串

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var isPalindrome = function(s) {
  s = s.toLowerCase()
  let l = 0
  let r = s.length - 1
  while(l < r) {
    while(l < r && !isValid(s[l])) {
      l++
    }
    while(l < r && !isValid(s[r])) {
      r--
    }
    if(s[l] !== s[r]) return false
    l++
    r--
  }
  return true
};

function isValid(c) {
  return c !== ' ' && (c >= '0' && c <= '9' || c >= 'a' && c <= 'z')
}
```

## ???🌟😻✔ 126. 单词接龙 II【hard】

[ref](https://leetcode.cn/problems/word-ladder-ii/)

BFS、广度优先搜索、图

这道题要获取路径，相比 127 题麻烦了很多。

```js
var findLadders = function(beginWord, endWord, wordList) {
  const wordListSet = new Set(wordList)
  wordListSet.delete(beginWord)
  let q = [beginWord]
  const connectionMap = new Map()
  let level = 0
  const visited = new Set()
  const levelMap = new Map()
  levelMap.set(beginWord, 0)
  let nextIsEnd = false
  while(q.length) {
    level++
    const prevQLen = q.length
    for(let i=0;i<prevQLen;i++) {
      const target = q.shift()
      for(let j=0;j<target.length;j++) {
        for(let k=97;k<=122;k++) {
          const s = target.slice(0, j) + String.fromCharCode(k) + target.slice(j + 1)
          if(wordListSet.has(s)) {
            if(connectionMap.has(s)) {
              connectionMap.get(s).push(target)
            } else {
              connectionMap.set(s, [target])
            }
            if(s === endWord) nextIsEnd = true
            if(!visited.has(s)) {
              levelMap.set(s, level)
              q.push(s)
              visited.add(s)
            }
          }
        }
      }
    }
  }

  if(!nextIsEnd) return []

  const res = []
  function dfs(path, word) {
    if(word === beginWord) {
      res.push([beginWord, ...path])
      return
    }
    path.unshift(word)
    const words = connectionMap.get(word)
    if(words) {
      for(let parent of words) {
        if(levelMap.get(parent) + 1 === levelMap.get(word)) {
          dfs(path, parent)
        }
      }
    }
    path.shift()
  }

  dfs([],endWord)
  return res
};

```

## ??🌟😻✔ 127. 单词接龙【hard】

[ref](https://leetcode.cn/problems/word-ladder/)

图、BFS、广度优先搜索

关联：
- [815 公交路线【hard】](https://leetcode.cn/problems/bus-routes/)

```js
// 时间复杂度：O(N*C*Z) Z=26 C=beginWord.length N=wordList.length
// 空间复杂度：O(N*C)
var ladderLength = function(beginWord, endWord, wordList) {
  const wordListSet = new Set(wordList)
  let q = [[beginWord, 1]]
  while(q.length) {
    const [target, level] = q.shift()
    if(target === endWord) return level
    for(let i=0;i<target.length;i++) {
      for(let j=97;j<=122;j++) {
        const nTarget = target.slice(0, i) + String.fromCharCode(j) + target.slice(i + 1)
        if(wordListSet.has(nTarget)) {
          q.push([nTarget, level + 1])
          wordListSet.delete(nTarget)
        }
      }
    }
  }
  return 0
};
```

```js
// 时间复杂度：O(C*N^2)
// 空间复杂度：O(C*N^2)
var ladderLength = function(beginWord, endWord, wordList) {
  const map = new Map()
  const n = wordList.length
  map.set(beginWord, [])
  for(let i=0;i<n;i++) {
    const a = wordList[i]
    if(isValid(beginWord, a)) {
      map.get(beginWord).push(a)
    }
    for(let j=0;j<n;j++) {
      const b = wordList[j]
      if(i !== j && isValid(a, b)) {
        if(map.has(a)) {
          map.get(a).push(b)
        } else {
          map.set(a, [b])
        }
      }
    }
  }
  let q = [beginWord]
  let count = 1
  let tq = []
  const used = {}
  while(q.length) {
    const target = q.shift()
    if(target === endWord) return count
    if(!used[target]) {
      if(map.has(target)) {
        tq = [...tq, ...map.get(target)]
      }
      used[target] = true
    }
    if(!q.length) {
      q = [...new Set(tq)]
      tq = []
      count++
    }
  }
  return 0
};

function isValid(s1, s2) {
  let l1 = 0, l2 = 0
  let hasDif = false
  while(l1 < s1.length) {
    if(s1[l1++] !== s2[l2++]) {
      if(hasDif) return false
      hasDif = true
    }
  }
  return true
}
```

## ?🌟😻✔ 128 最长连续序列【medium】

数组题

[ref](https://leetcode.cn/problems/longest-consecutive-sequence/)

![](https://qiniu1.lxfriday.xyz/feoffer/1653261522967_db2092bf-f1fd-4013-b0e6-67a1cfd5909f.png)

```js
// 别一看到 for 里面套着 while 就认为大于 O(n)
// 并不是所有的 value 都会进入 while 循环，只有作为区间左值的 value 才会进入 while
// for+while 的组合刚好可以把所有的数字统计一遍
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var longestConsecutive = function(nums) {
  const set = new Set(nums)
  let max = 0
  for(let num of set.values()) {
    if(!set.has(num - 1)) {
      let count = 1
      while(set.has(count + num)) {
        count++
      }
      max = Math.max(count, max)
    }
  }
  return max
};
```

## 🌟😻✔ 129. 求根节点到叶节点数字之和【medium】

[ref](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var sumNumbers = function(root) {
  let sum = 0
  function dfs(node, num) {
    num = 10 * num + node.val
    if(!node.left &&!node.right) {
      sum += num
      return
    }
    node.left && dfs(node.left, num)
    node.right && dfs(node.right, num)
  }
  dfs(root, 0)
  return sum
};
```

## 🌟😻✔ 130. 被围绕的区域【medium】

[ref](https://leetcode.cn/problems/surrounded-regions/)

矩阵、深度优先搜索

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var solve = function(board) {
  const m = board.length, n = board[0].length
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(i === 0 || i === m - 1 || j === 0 || j === n - 1) {
        find(i, j)
      }
    }
  }
  function find(i, j) {
    if(i >= 0 && i < m && j >= 0 && j < n && !used[i][j] && board[i][j] === "O") {
      used[i][j] = true
      find(i - 1, j)
      find(i + 1, j)
      find(i, j - 1)
      find(i, j + 1)
    }
  }
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(!used[i][j] && board[i][j] === "O") {
        board[i][j] = 'X'
      }
    }
  }
};
```

## ?🌟😻✔ 131 分割回文串【medium】

[ref](https://leetcode.cn/problems/palindrome-partitioning/)

回溯、动态规划

```js
// 时间复杂度：O(N*2^N)
// 空间复杂度：O(N^2)
var partition = function(s) {
  const n = s.length
  const f = new Array(n).fill(true).map(_ => new Array(n).fill(true))

  for(let i=n-1;i>=0;i--) {
    for(let j=i+1;j<n;j++) {
      f[i][j] = s[i] === s[j] && f[i + 1][j - 1]
    }
  }

  const res = []

  function run(si, path) {
    if(si >= n) {
      res.push([...path])
    }
    for(let i=si;i<n;i++) {
      if(f[si][i]) {
        path.push(s.slice(si, i + 1))
        run(i + 1, path)
        path.pop()
      }
    }
  }

  run(0, [])

  return res
};
```

回溯

```js
var partition = function(s) {
  let result = []
  const map = new Map()
  function walk(target) {
    const len = target.length
    const res = []
    for(let i=1;i<=len;i++) {
      const first = target.slice(0, i)
      if(!map.has(first)) {
        map.set(first, isPalindrome(first))
      }
      if(map.get(first)) {
        const subPartition = walk(target.slice(i))
        if(!subPartition.length) {
          res.push([first])
        } else {
          for(let p of subPartition) {
            res.push([first, ...p])
          }
        }
      }
    }
    return res
  }

  result = walk(s)
  return result
};

function isPalindrome(str) {
  const len = str.length
  if(len === 0) return false
  for(let i=0;i<Math.floor(len + 1 / 2);i++) {
    if(str[i] !== str[len - i - 1]) return false
  }
  return true
}
```

## ?🌟😻✔ 132 分割回文串 II【hard】

[ref](https://leetcode.cn/problems/palindrome-partitioning-ii/)

动态规划

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var minCut = function(s) {
  const n = s.length
  const f = new Array(n).fill(true).map(_ => new Array(n).fill(true))
  for(let i=n - 1;i>=0;i--) {
    for(let j=i + 1;j < n;j++) {
      f[i][j] = s[i] === s[j] && f[i + 1][j - 1]
    }
  }
  const dp = new Array(n).fill(0)
  dp[0] = 1
  for(let j=1;j<n;j++) {
    let min = j + 1
    for(let i = j;i>=0;i--) {
      if(f[i][j]) {
        min = Math.min(min, (i - 1 >=0 ? dp[i - 1] : 0) + 1)
      }
    }
    dp[j] = min
  }
  return dp[n - 1] - 1
};
```

## 😻✔ 133 克隆图【medium】

[ref](https://leetcode.cn/problems/clone-graph/)

图、深度优先遍历、广度优先遍历、DFS、BFS

```js
// DFS
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function(node) {
  if(!node) return 
  const visited = new Map()
  function dfs (targetNode) {
    const newNode = new Node(targetNode.val)
    visited.set(targetNode, newNode);
    (targetNode.neighbors || []).forEach(neighborNode => {
      if(!visited.has(neighborNode)) {
        dfs(neighborNode)
      }
      newNode.neighbors.push(visited.get(neighborNode))
    })
  }
  dfs(node)
  return visited.get(node)
};

// BFS
var cloneGraph = function(node) {
  if(!node) return 
  const visited = new Map()
  const q = [node]
  visited.set(node, new Node(node.val));
  while(q.length) {
    const targetNode = q.shift();
    (targetNode.neighbors || []).forEach(neighborNode => {
      if(!visited.has(neighborNode)) {
        q.push(neighborNode)
        visited.set(neighborNode, new Node(neighborNode.val))
      }
      visited.get(targetNode).neighbors.push(visited.get(neighborNode))
    })
  }
  return visited.get(node)
};
```

## ?🌟😻✔ 135 分发糖果【hard】

[ref](https://leetcode.cn/problems/candy/)

贪心

![](https://qiniu1.lxfriday.xyz/feoffer/1653173511115_0db6c0f3-47bc-4bf7-8a84-ed7366d2f8ca.png)

给任何一个人发糖果都要考虑这个人和他左右两边人的发糖果数量。

- -> 从左往右看，如果右边人的评分大于左边，则右边人糖果的数量一定是大于左边人的，如果左边人糖果数最少为 l1，右边人糖果最少数则为 l1 + 1
  - 如果右边人的评分小于等于左边人，则右边人糖果数可以设为 1
- <- 从右往左看，如果左边人的评分大于右边，则左边人糖果的数量一定是大于右边人的，如果右边人糖果数最少为 r1，则左边人糖果数最少则为 r1 + 1
  - 如果左边人的评分小于等于右边人，则左边人糖果数可以设为 1


对于任意挨着的两个人，如果其评分分别为 `rate1 < rate2`，且 rate1 在 rate2 左边，则存在下面的关系：

- 第1个人糖果数：从左往右为 `l1`，从右往左为 `1`，其中 `l1 >= 1`
- 第2个人糖果数：从左往右为 `l1 + 1`，从右往左为 `r2`，其中 `l2 >= 1`

则必然会有这个关系存在 `max(l1, 1) < max(l1 + 1, l2)`

因为 `l1 >= 1`，则推出 `max(l1, 1) = l1`，而 `max(l1 + 1, l2) >= l1 + 1`，故 `max(l1 + 1, l2) > l1 = max(l1, 1)`

综合上述的推论就可以知道，只需要从左往右和从右往左扫描评分数组两次，然后综合每个位置上两个方向所需要的最小糖果数，就可以得到总的最少糖果数。

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var candy = function(ratings) {
  const len = ratings.length
  const leftDp = []
  const rightDp = []
  let sum = 0
  for(let i=0;i<len;i++) {
    if(i - 1 >= 0 && ratings[i] > ratings[i - 1]) {
      leftDp[i] = leftDp[i - 1] + 1
    } else {
      leftDp[i] = 1
    }
  }
  for(let i=len-1;i>=0;i--) {
    if(i + 1 < len && ratings[i] > ratings[i + 1]) {
      rightDp[i] = rightDp[i + 1] + 1
    }else {
      rightDp[i] = 1
    }
    sum += Math.max(leftDp[i], rightDp[i])
  }
  return sum
};
```

## ✔ 136 只出现一次的数字【easy】

[ref](https://leetcode.cn/problems/single-number/)

```js
// 要求时间空间复杂度是：O(n) O(1)
var singleNumber = function(nums) {
  let res = 0
  for(let i = 0; i < nums.length; i++) {
    res ^= nums[i]
  }
  return res
};
```

## ??🌟😻✔ 137. 只出现一次的数字 II【medium】

[ref](https://leetcode.cn/problems/single-number-ii/)

位运算

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var singleNumber = function(nums) {
  let res = 0
  for(let i=0;i<32;i++) {
    let sum = 0
    for(let num of nums) {
      sum += ((num >> i) & 1)
    }
    if(sum % 3) {
      res |= (1 << i)
    }
  }
  return res
};
```

## 🌟😻✔ 138. 复制带随机指针的链表【medium】

[ref](https://leetcode.cn/problems/copy-list-with-random-pointer/)

链表、复制链表

```js
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

// 时间复杂度：O(N)
// 空间复杂度：O(1)
var copyRandomList = function(head) {
  let tHead = head
  while(tHead) {
    const node = new Node(tHead.val)
    const next = tHead.next
    tHead.next = node
    node.next = next
    tHead = next
  }
  tHead = head
  while(tHead) {
    const copyNode = tHead.next
    const next = tHead.next.next
    copyNode.random = tHead.random? tHead.random.next : null
    tHead = next
  }
  tHead = head
  const myHead = new Node()
  let tMyHead = myHead
  while(tHead) {
    const copyNode = tHead.next
    const next = tHead.next.next
    tMyHead.next = copyNode
    tMyHead = tMyHead.next
    tHead.next = next
    tHead = tHead.next
  }
  return myHead.next
};
```

or

```js
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

// 时间复杂度：O(N)
// 空间复杂度：O(N)
var copyRandomList = function(head) {
  if(!head) return null
  const map = new Map()
  function copy(node1) {
    if(map.has(node1)) return map.get(node1)
    const node = new Node(node1.val)
    map.set(node1, node)
    if(node1.next) {
      node.next = copy(node1.next)
    }
    if(node1.random) {
      node.random = copy(node1.random)
    }
    return node
  }
  return copy(head)
};
```

## 😻✔ 139 单词拆分【medium】

[ref](https://leetcode.cn/problems/word-break/)

动态规划

```js
// 动态规划
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var wordBreak = function(s, wordDict) {
  const wordSet = new Set(wordDict)
  const sLen = s.length
  const dp = new Array(sLen).fill(false)
  
  for(let i=0;i<sLen;i++) {
    for(let j=i; j>=0; j--) {
      if(wordSet.has(s.slice(j, i + 1))) {
        dp[i] = dp[i] || (j - 1 >= 0 ? dp[j - 1] : true)
      }
    }
  }

  return dp[sLen - 1]
};
```

## 🌟😻✔ 140. 单词拆分 II【hard】

[ref](https://leetcode.cn/problems/word-break-ii/)

回溯法

```js
var wordBreak = function(s, wordDict) {
  wordDict = new Set(wordDict)
  const n = s.length
  const res = []
  function walk(i, path) {
    if(i === n) {
      res.push(path.trim())
      return
    }
    for(let j = i; j < n; j++) {
      const target = s.slice(i, j + 1)
      if(wordDict.has(target)) {
        walk(j + 1, path + ' ' + target)
      }
    }
  }
  walk(0, '')
  return res
};

```

## 😻✔ 141 环形链表【easy】

[ref](https://leetcode.cn/problems/linked-list-cycle/)

环形链表，双指针，快慢指针

```js
var hasCycle = function (head) {
  let p1 = head
  let p2 = head
  while (p2 && p2.next) {
    p1 = p1.next
    p2 = p2.next.next
    if (p1 === p2) return true
  }

  return false
}
```

## ??🌟😻✔ 142 环形链表 II【medium】

[ref](https://leetcode.cn/problems/linked-list-cycle-ii/)

链表、快慢指针、双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var detectCycle = function(head) {
  const myHead = new ListNode()
  myHead.next = head
  let slow = myHead, fast = myHead
  while(fast.next && fast.next.next) {
    slow = slow.next
    fast = fast.next.next
    if(slow === fast) {
      slow = slow.next
      let t = head
      while(t !== slow) {
        t = t.next
        slow = slow.next
      }
      return t
    }
  }
  return null
};
```

集合解法

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var detectCycle = function(head) {
  const s = new Set()
  while(head) {
    if(s.has(head)) return head
    s.add(head)
    head = head.next
  }
  return null
};
```

## ?🌟😻✔ 143 重排链表【medium】

[ref](https://leetcode.cn/problems/reorder-list/)

```js
// 快慢指针+链表反转
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var reorderList = function(head) {
  const beginNode = new ListNode()
  let tHead = beginNode
  let fast = beginNode
  let slow = beginNode
  beginNode.next = head
  while(fast.next && fast.next.next && slow.next) {
    slow = slow.next
    fast = fast.next.next
  }
  let left = head
  let right = slow.next
  slow.next = null
  right = reverse(right)
  while(left) {
    const lNode = left
    const rNode = right
    left = left.next
    right = right.next

    tHead.next = lNode
    lNode.next = rNode
    tHead = tHead.next.next
  }
  if(right) {
    tHead.next = right
    tHead = tHead.next
  }
  tHead.next = null
};

function reverse(head) {
  const myHead = new ListNode()
  while(head) {
    const prev = myHead.next
    const target = head
    head = head.next
    target.next = prev
    myHead.next = target
  }
  return myHead.next
}
```

```js
// 用数组存储节点，然后操作
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var reorderList = function(head) {
  let tHead = head
  let myHead = new ListNode()
  const leftNodes = []
  const rightNodes = []
  let count = 0
  while(tHead) {
    leftNodes.push(tHead)
    rightNodes.unshift(tHead)
    tHead = tHead.next
    count++
  }
  let showUseLeftNodes = true
  let leftIndex = 0
  let rightIndex = 0
  while(count > 0) {
    if(showUseLeftNodes) {
      myHead.next = leftNodes[leftIndex++]
      showUseLeftNodes = false
    } else {
      myHead.next = rightNodes[rightIndex++]
      showUseLeftNodes = true
    }
    myHead = myHead.next
    count--
  }
  myHead.next = null
};
```

```js
// 提取数字，然后进行重新赋值，不符合题目要求
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var reorderList = function(head) {
  const nums = []
  const reverseNums = []
  const resNums = []
  let tHead = head
  
  while(tHead) {
    nums.push(tHead.val)
    reverseNums.unshift(tHead.val)
    tHead = tHead.next
  }
  const len = nums.length
  let showAddReverse = false
  while(resNums.length < len) {
    if(!showAddReverse) {
      resNums.push(nums.shift())
      showAddReverse = true
    } else {
      resNums.push(reverseNums.shift())
      showAddReverse = false
    }
  }
  tHead = head
  let i = 0
  while(tHead) {
    tHead.val = resNums[i++]
    tHead = tHead.next
  }
};
```

## 😻✔ 144. 二叉树的前序遍历【easy】

[ref](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

二叉树、先序遍历、前序遍历

```js
var preorderTraversal = function(root) {
  const res = []
  function dfs(node) {
    if(!node) return
    res.push(node.val)
    dfs(node.left)
    dfs(node.right)
  }
  dfs(root)
  return res
};
```

## 😻✔ 145. 二叉树的后序遍历【easy】

[ref](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

二叉树、后序遍历

```js
var postorderTraversal = function(root) {
  const res = []
  function dfs(node) {
    if(!node) return
    dfs(node.left)
    dfs(node.right)
    res.push(node.val)
  }
  dfs(root)
  return res
};
```
## 😻✔ 146 LRU 缓存【medium】

[ref](https://leetcode.cn/problems/lru-cache/)

```js
var LRUCache = function(capacity) {
  this.capacity = capacity
  this.head = new ListNode()
  this.tail = new ListNode()
  this.maps = {}
  this.cnt = 0
};

LRUCache.prototype.get = function(key) {
  if(this.maps[key] === undefined) return -1
  const ret = this.maps[key].value
  this.delete(this.maps[key])
  this.add(new ListNode(key, ret))
  return ret
};

LRUCache.prototype.delete = function(node) {
  delete this.maps[node.key]
  this.cnt--
  if(this.cnt === 0) {
    this.head.next = null
    this.tail.next = null
  } else {
    if(node === this.head.next) {
      this.head.next = node.next
      node.next.prev = null
    } else if(node === this.tail.next) {
      this.tail.next = node.prev
      node.prev.next = null
    } else {
      node.prev.next = node.next
      node.next.prev = node.prev
    }
  }
};

LRUCache.prototype.add = function(node) {
  this.maps[node.key] = node
  node.prev = null
  node.next = null
  this.cnt++
  if(this.cnt === 1) {
    this.head.next = node
    this.tail.next = node
  } else {
    node.prev = this.tail.next
    this.tail.next.next = node
    this.tail.next = node
  }
};

LRUCache.prototype.put = function(key, value) {
  if(this.maps[key]) {
    this.maps[key].val = value
    this.delete(this.maps[key])
  } else if(this.cnt === this.capacity) {
    this.delete(this.head.next)
  }
  this.add(new ListNode(key, value))
};

class ListNode {
  constructor(key, value) {
    this.key = key
    this.value = value
    this.prev = null
    this.next = null
  }
}
```

```js
var LRUCache = function(capacity) {
  this.cache = new Map()
  this.capacity = capacity
};

LRUCache.prototype.get = function(key) {
  if(!this.cache.has(key)) return -1
  const ret = this.cache.get(key)
  this.put(key, ret)
  return ret
};

LRUCache.prototype.put = function(key, value) {
  if(this.cache.has(key)) {
    this.cache.delete(key)
  } else if(this.cache.size === this.capacity) {
    this.cache.delete(this.cache.keys().next().value)
  }
  this.cache.set(key, value)
};
```

```js
var LRUCache = function(capacity) {
  this.capacity = capacity
  this.cache = new Map()
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
  if(!this.cache.has(key)) {
    return -1
  }
  const value = this.cache.get(key)
  this.moveToEnd(key, value)
  return value
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
  if(this.cache.has(key)) {
    this.cache.delete(key)
  } else if(this.cache.size === this.capacity) {
    this.cache.delete(this.cache.keys().next().value)
  }
  this.cache.set(key, value)
};

LRUCache.prototype.moveToEnd = function(key, value) {
  this.cache.delete(key)
  this.cache.set(key, value)
};
```

## ?🌟😻✔ 147. 对链表进行插入排序【medium】

[ref](https://leetcode.cn/problems/insertion-sort-list/submissions/)

链表

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var insertionSortList = function(head) {
  const myHead = new ListNode()
  while(head) {
    const node = head
    head = head.next
    let tHead = myHead
    while(tHead.next && tHead.next.val <= node.val) tHead = tHead.next
    node.next = tHead.next
    tHead.next = node
  }
  return myHead.next
};
```

## ?🌟😻✔ 148 排序链表【medium】

[ref](https://leetcode.cn/problems/sort-list/)

链表归并排序

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var sortList = function(head) {
  const tHead = new ListNode()
  tHead.next = head
  let slow = tHead
  let fast = tHead
  while(fast.next && fast.next.next) {
    slow = slow.next
    fast = fast.next.next
  }
  if(slow === fast) return head
  const next = slow.next
  slow.next = null
  return merge(sortList(tHead.next), sortList(next))
};

function merge(list1, list2) {
  const myHead = new ListNode()
  let tHead = myHead
  while(list1 && list2) {
    if(list1.val < list2.val) {
      tHead.next = list1
      list1 = list1.next
    } else {
      tHead.next = list2
      list2 = list2.next
    }
    tHead = tHead.next
  }
  if(list1) {
    tHead.next = list1
  }
  if(list2) {
    tHead.next = list2
  }
  return myHead.next
}
```

## ??🌟😻✔ 149. 直线上最多的点数【hard】

[ref](https://leetcode.cn/problems/max-points-on-a-line/)

数学题、模拟

```js
// 时间复杂度：O(N^2*logM) 坐标值差值最大为M
// 空间复杂度：O(N)
var maxPoints = function(points) {
  const n = points.length
  let max = 1
  for(let i=0;i<n;i++) {
    const [x1, y1] = points[i]
    const m = new Map()
    for(let j=i + 1;j<n;j++) {
      const [x2, y2] = points[j]
      const a = x1 - x2, b = y1 - y2
      const w = gcd(a, b)
      const target = `${b/w}|${a/w}`
      m.set(target, (m.get(target) || 1) + 1)
      max = Math.max(m.get(target), max)
    }
  }
  return max
};

const gcd = (a, b) => b === 0? a : gcd(b, a % b)
```

```js
// 时间复杂度：O(N^3)
// 空间复杂度：O(1)
var maxPoints = function(points) {
  if(points.length <= 2) return points.length
  let max = 0
  for(let i=0;i<points.length;i++) {
    for(let j=i+1;j < points.length;j++) {
      const [x1, y1] = points[i]
      const [x2, y2] = points[j]
      let count = 2
      for(let k=j+1;k < points.length;k++) {
        const [x3, y3] = points[k]
        if(x1===x2) {
          if(x2 === x3) count++
        } else if(y1===y2) {
          if(y2 === y3) count++
        } else {
          if((y3-y2) / (x3-x2) === (y2-y1) / (x2-x1)) {
            count++
          }
        }
      }
      max = Math.max(max, count)
    }
  }
  return max
};
```

## ??🌟😻✔ 150. 逆波兰表达式求值【medium】

[ref](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

栈、数组题、字符串、逆波兰表达式、逆波兰

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var evalRPN = function(tokens) {
  const stack = []
  for(let i=0;i<tokens.length;i++) {
    const c = tokens[i]
    if(c === '+' || c === '-' || c === '*' || c === '/') {
      const n1 = stack.pop()
      const n2 = stack.pop()
      let res = 0
      if(c === '+') res = n2 + n1
      if(c === '-') res = n2 - n1
      if(c === '*') res = n2 * n1
      if(c === '/') res = parseInt(n2 / n1)
      stack.push(res)
    } else {
      stack.push(+c)
    }
  }
  return stack[0]
};
```

## 🌟😻✔ 151. 颠倒字符串中的单词【medium】

[ref](https://leetcode.cn/problems/reverse-words-in-a-string/)

```js
var reverseWords = function(s) {
    return s.trim().split(/\s+/).reverse().join(' ');
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var reverseWords = function(s) {
  const arr = s.split(' ').reverse()
  let res = ''
  for(let i=0;i<arr.length;i++) {
    if(arr[i] !== '') {
      if(!res.length) {
        res = arr[i]
      } else {
        res += (' ' + arr[i])
      }
    }
  }
  return res
};
```

## ??🌟😻✔ 152 乘积最大子数组【medium】

[ref](https://leetcode.cn/problems/maximum-product-subarray/)


动态规划

```js
// 数组版
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProduct = function(nums) {
  const len = nums.length
  const dpMax = [nums[0]]
  const dpMin = [nums[0]]
  for(let i=1;i<len;i++) {
    // 以 i 为结尾的非空连续子数组
    dpMax[i] = Math.max(nums[i], nums[i] * dpMax[i-1], nums[i] * dpMin[i-1])
    dpMin[i] = Math.min(nums[i], nums[i] * dpMax[i-1], nums[i] * dpMin[i-1])
  }
  return Math.max(...dpMax)
};
```

```js
// 空间复杂度优化版
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProduct = function(nums) {
  const len = nums.length
  let prevMax = nums[0]
  let prevMin = nums[0]
  let res = prevMax
  for(let i=1;i<len;i++) {
    // 以 i 为结尾的非空连续子数组
    const tmpPrevMax = prevMax
    const tmpPrevMin = prevMin

    prevMax = Math.max(nums[i], nums[i] * tmpPrevMax, nums[i] * tmpPrevMin)
    prevMin = Math.min(nums[i], nums[i] * tmpPrevMax, nums[i] * tmpPrevMin)
    res = Math.max(res, prevMax)
  }
  return res
};
```

## 🌟😻✔ 153 寻找旋转排序数组中的最小值【medium】

[ref](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

二分搜索

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var findMin = function(nums) {
  let l = 0,r = nums.length - 1
  const max = nums[nums.length - 1]
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] < max) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return nums[l]
};
```

## ?🌟😻✔ 154 寻找旋转排序数组中的最小值 II【hard】

[ref](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

二分搜索

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findMin = function(nums) {
  const len = nums.length
  let l = 0,r = len - 1
  let rMax = nums[r]
  while(nums[l] === nums[r]) {
    l++
  }
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] <= rMax) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return nums[r]
};
```

## ?🌟😻✔ 160 相交链表【easy】

[ref](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

```js
// 时间复杂度：O(M + N)
// 空间复杂度：O(1)
var getIntersectionNode = function(headA, headB) {
  let pA = headA
  let pB = headB
  while(pA !== pB) {
    pA = pA !== null ? pA.next : headB
    pB = pB !== null ? pB.next : headA
  }
  return pA
};
```

## ?🌟😻✔ 161. 相隔为 1 的编辑距离【medium】

[ref](https://leetcode.cn/problems/one-edit-distance/)

双指针、动态规划

题解

- [【云影同学】双指针或者动态规划](https://leetcode.cn/problems/one-edit-distance/solution/shuang-zhi-zhen-huo-zhe-dong-tai-gui-hua-ttv8/)

```js
// 双指针
// 时间复杂度：O(min(M, N))
// 空间复杂度：O(1)
var isOneEditDistance = function(s, t) {
  const m = s.length, n = t.length
  let si = 0, ti = 0
  let op = 0
  if(m === n) {
    op = 0
  } else if(m > n) {
    op = 1
  } else {
    op = 2
  }
  let errCnt = 0
  while(si < m && ti < n) {
    if(s[si] === t[ti]) {
      si++
      ti++
    } else {
      if(errCnt > 0) return false
      errCnt ++
      if(op === 0) {
        si++
        ti++
      } else if(op === 1) {
        si++
      } else {
        ti++
      }
    }
  }
  if(
    si === m && ti === n && errCnt === 1
    || si === m - 1 && ti === n && errCnt === 0
    || si === m && ti === n - 1 && errCnt === 0
    ) return true
  return false
};
```

```js
// 滚动数组版动态规划
// 时间复杂度：O(MN)
// 空间复杂度：O(N)
var isOneEditDistance = function(s, t) {
  if(!s.length && !t.length) return false
  if(Math.abs(s.length - t.length) > 1) return false
  if(t.length === 0) return s.length === 1
  if(s.length === 0) return t.length === 1
  const m = s.length, n = t.length
  let dp = new Array(n + 1).fill(0)
  for(let j=1;j<=n;j++) {
    dp[j] = j
  }
  for(let i=1;i<=m;i++) {
    const tdp = []
    for(let j=0;j<=n;j++) {
      if(j === 0) {
        tdp[j] = i
      } else if(s[i - 1] === t[j - 1]) {
        tdp[j] = dp[j - 1]
      } else {
        tdp[j] = Math.min(tdp[j - 1], dp[j], dp[j - 1]) + 1
      }
    }
    dp = tdp
  }
  return dp[n] === 1
};
```

## ?🌟😻✔ 162 寻找峰值【medium】

[ref](https://leetcode.cn/problems/find-peak-element/)

二分法

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var findPeakElement = function(nums) {
  let l = 0
  let r = nums.length - 1
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] < nums[mid + 1]) {
      l = mid + 1
    } else {
      r = mid
    }
  }
  return l
};
```

## 🌟😻✔ 163. 缺失的区间【easy】

[ref](https://leetcode.cn/problems/missing-ranges/)

区间

```js
// 添加哨兵
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findMissingRanges = function(nums, lower, upper) {
  nums.unshift(lower - 1)
  nums.push(upper + 1)
  const res = []
  for(let i=1;i<nums.length;i++) {
    if(nums[i] - nums[i - 1] === 2) {
      res.push(`${nums[i] - 1}`)
    }
    if(nums[i] - nums[i - 1] > 2) {
      res.push(`${nums[i-1] + 1}->${nums[i] - 1}`)
    }
  }
  return res
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findMissingRanges = function(nums, lower, upper) {
  if(!nums.length) return [gen(lower, upper)]
  const n = nums.length
  const res = []
  if(nums[0] > lower) {
    res.push(gen(lower, nums[0] - 1))
  }
  let i = 1
  while(i < n) {
    while(i < n && nums[i] === nums[i - 1] + 1) i++
    if(i < n) {
      res.push(gen(nums[i - 1] + 1, nums[i] - 1))
    }
    i++
  }
  if(upper > nums[n - 1]) {
    res.push(gen(nums[n - 1] + 1, upper))
  }
  return res
};

function gen(x, y) {
  if(x === y) return `${x}`
  return `${x}->${y}`
}
```


## ✔ 165 比较版本号【medium】

[ref](https://leetcode.cn/problems/compare-version-numbers/)

```js
var compareVersion = function(version1, version2) {
  // 去除前导零
  let v1Arr = version1.split('.').map(_ => parseInt(_, 10))
  let v2Arr = version2.split('.').map(_ => parseInt(_, 10))
  // 补齐数组长度
  if(v1Arr.length > v2Arr.length) {
    v2Arr = v2Arr.concat(new Array(v1Arr.length - v2Arr.length).fill(0))
  } else {
    v1Arr = v1Arr.concat(new Array(v2Arr.length - v1Arr.length).fill(0))
  }
  for(let i=0;i<v1Arr.length;i++) {
    if(v1Arr[i] < v2Arr[i]) return -1
    else if(v1Arr[i] > v2Arr[i]) return 1
  }
  return 0
};

```


## ??🌟😻✔ 166. 分数到小数【medium】

[ref](https://leetcode.cn/problems/fraction-to-recurring-decimal/)

哈希表、模拟运算

```js
// 时间复杂度：O(l) l 是答案字符串的长度
// 空间复杂度：O(l)
var fractionToDecimal = function(numerator, denominator) {
  if(numerator % denominator === 0) return String(numerator / denominator)
  let pres = []
  if(numerator * denominator < 0) pres.push('-')
  numerator = Math.abs(numerator)
  denominator = Math.abs(denominator)

  pres.push(Math.floor(numerator / denominator))
  numerator = numerator % denominator
  pres.push('.')
  const map = new Map()

  while(numerator !== 0) {
    numerator *= 10
    if(map.has(numerator)) {
      pres.splice(map.get(numerator), 0, '(')
      pres.push(')')
      break
    } else {
      map.set(numerator, pres.length)
      if(numerator >= denominator) {
        pres.push(Math.floor(numerator / denominator))
        numerator = numerator % denominator
      } else {
        pres.push('0')
      }
    }
  }
  return pres.join('')
};
```

## ✔ 167 两数之和 II - 输入有序数组【medium】

[ref](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var twoSum = function(numbers, target) {
  let l = 0, r = numbers.length - 1
  while(l<r) {
    let s = numbers[l] + numbers[r]
    if(s === target) {
      return [l + 1, r + 1]
    } else if(s > target) {
      r--
    } else {
      l++
    }
  }
};
```

## ??🌟😻✔ 168. Excel表列名称【easy】

[ref](https://leetcode.cn/problems/excel-sheet-column-title/)

模拟

```js
var convertToTitle = function(columnNumber) {
  const abase = 'A'.charCodeAt(0)
  let res = ''
  while(columnNumber) {
    columnNumber--
    res = String.fromCharCode(columnNumber % 26 + abase) +res
    columnNumber = Math.floor(columnNumber / 26)
  } 
  return res
};
```

## ?🌟😻✔ 169 多数元素【easy】

[ref](https://leetcode.cn/problems/majority-element/)

摩尔投票法

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var majorityElement = function(nums) {
  let count = 1
  let ret = nums[0]
  for(let i=1;i<nums.length;i++) {
    if(count === 0) {
      ret = nums[i]
      count++
    } else {
      if(nums[i] === ret) {
        count++
      } else {
        count--
      }
    }
  }
  return ret
};
```

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var majorityElement = function(nums) {
  const map = new Map()
  const len = nums.length
  for(let i=0;i<len;i++) {
    map.set(nums[i], map.has(nums[i])? map.get(nums[i]) + 1: 1)
    if(map.get(nums[i]) > len / 2) return nums[i] 
  }
};
```


## ?🌟😻✔ 171. Excel 表列序号【easy】

[ref](https://leetcode.cn/problems/excel-sheet-column-number/submissions/)

进制转换、类进制转换

```js
// 时间复杂度：O(N) N=columnTitle.length
// 空间复杂度：O(1)
var titleToNumber = function(columnTitle) {
  let res = 0
  for(let i=0;i<columnTitle.length;i++) {
    const num = columnTitle[i].charCodeAt(0) - 'A'.charCodeAt(0) + 1
    res = 26 * res + num 
  }
  return res
};
```


常规思路
```js
var titleToNumber = function(columnTitle) {
  const m = {A:1,B:2,C:3,D:4,E:5,F:6,G:7,H:8,I:9,J:10,K:11,L:12,M:13,N:14,O:15,P:16,Q:17,R:18,S:19,T:20,U:21,V:22,W:23,X:24,Y:25,Z:26}
  const len = columnTitle.length
  let count = 0
  let k = 1
  while(k<len) {
    count += 26 ** k
    k++
  }
  for(let i=0;i<columnTitle.length;i++) {
    const a = m[columnTitle[i]]
    const l = len - i - 1
    count += (a - 1) * (26 ** l)
  }
  return count + 1
};
```

## ?🌟😻✔ 173. 二叉搜索树迭代器【medium】

[ref](https://leetcode.cn/problems/binary-search-tree-iterator/)

二叉搜索树、二叉树、迭代器

```js
// 利用中序遍历特性
var BSTIterator = function(root) {
  this.curr = root
  this.stack = []
};

BSTIterator.prototype.next = function() {
  while(this.curr) {
    this.stack.push(this.curr)
    this.curr = this.curr.left
  }
  this.curr = this.stack.pop()
  const ret = this.curr.val
  this.curr = this.curr.right
  return ret
};

BSTIterator.prototype.hasNext = function() {
  return !!this.curr || !!this.stack.length
};
```

```js
var BSTIterator = function(root) {
  this.values = []
  function dfs(node, arr) {
    node.left && dfs(node.left, arr)
    arr.push(node.val)
    node.right && dfs(node.right, arr)
  }
  dfs(root, this.values)
  this.i = 0
};

BSTIterator.prototype.next = function() {
  return this.values[this.i++]
};

BSTIterator.prototype.hasNext = function() {
  return this.i < this.values.length
};
```


## ?🌟😻✔ 172. 阶乘后的零【medium】

[ref](https://leetcode.cn/problems/factorial-trailing-zeroes/)

规律题

```js
// 问题转换为寻找 1-n 中每个数的因数中5的个数
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var trailingZeroes = function(n) {
  let res = 0
  while(n!==0) {
    n = Math.floor(n / 5)
    res += n
  }
  return res
};
```

常规思路

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var trailingZeroes = function(n) {
  let res = 0
  for(let i=1;i<=n;i++) {
    let j = i
    while(j % 5 === 0) {
      j /= 5
      res++
    }
  }
  return res
};
```

## ?🌟😻✔ 179 最大数【medium】

[ref](https://leetcode.cn/problems/largest-number/)

数学理论

```js
var largestNumber = function(nums) {
  nums.sort((x, y) => (String(y) + String(x)) - (String(x) + String(y)))
  if (nums[0] === 0) return '0'
  return nums.join('');
};
```

## 🌟😻✔ 186. 翻转字符串里的单词 II【medium】

[ref](https://leetcode.cn/problems/reverse-words-in-a-string-ii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var reverseWords = function(s) {
  function reverse(i, j) {
    while(i < j) {
      const t = s[i]
      s[i] = s[j]
      s[j] = t
      i++
      j--
    }
  }

  reverse(0, s.length - 1)

  let l = 0

  for(let i=0;i<s.length;i++) {
    if(s[i] === ' ') {
      reverse(l, i - 1)
      l = i + 1
    }
    if(i === s.length - 1) {
      reverse(l, i)
    }
  }

  return s
};
```

## 🌟😻✔ 187. 重复的DNA序列【medium】

[ref](https://leetcode.cn/problems/repeated-dna-sequences/)

```js
// 时间复杂度：O(N*C) C=10
// 空间复杂度：O(N)
var findRepeatedDnaSequences = function(s) {
  const res = new Set()
  const set = new Set()
  for(let i=9;i<s.length;i++) {
    const str = s.slice(i - 9,i + 1)
    if(set.has(str)) {
      res.add(str)
    } else {
      set.add(str)
    }
  }
  return [...res]
};

```

## ??🌟😻✔ 188 买卖股票的最佳时机 IV【hard】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

动态规划

```js
// 时间复杂度：O(KN)
// 空间复杂度：O(KN)
var maxProfit = function(k, prices) {
  if(prices.length < 2) return 0
  const n = prices.length
  const buyDp = new Array(n).fill(0).map(_ => new Array(k + 1).fill(0))
  const sellDp = new Array(n).fill(0).map(_ => new Array(k + 1).fill(0))
  for(let j=0;j<=k;j++) {
    buyDp[0][j] = -prices[0]
  }
  for(let i=1;i<n;i++) {
    buyDp[i][0] = Math.max(-prices[i], buyDp[i-1][0])
  }

  for(let i = 1; i < n; i++) {
    for(let j = 1; j <= k; j++) {
      buyDp[i][j] = Math.max(buyDp[i-1][j], -prices[i] + sellDp[i-1][j])
      sellDp[i][j] = Math.max(sellDp[i-1][j], prices[i] + buyDp[i-1][j-1])
    }
  }

  return Math.max(...sellDp[n-1])
};
```

```js
// 时间复杂度：O(n*k)
// 空间复杂度：O(n*k)
var maxProfit = function(k, prices) {
  if(prices.length < 1) return 0
  const dp = new Array(prices.length).fill('').map(_ => new Array(2 * k + 1).fill(0))
  for(let j = 1;j <= k; j++) {
    dp[0][2 * j - 1] = -prices[0]
  }
  for(let i = 1; i < prices.length; i++) {
    for(let j = 1;j <= 2 * k; j++) {
      const isOdd = j % 2 === 1
      dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - 1] + (isOdd? - prices[i] : prices[i]))
    }
  }
  return Math.max(...dp[prices.length - 1])
};
```

## ?🌟😻✔ 189 轮转数组【medium】

[ref](https://leetcode.cn/problems/rotate-array/)

数组轮转、数组原地操作、规律题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var rotate = function(nums, k) {
  const n = nums.length
  k = k % n
  reverse(nums, 0, n - 1)
  reverse(nums, 0, k - 1)
  reverse(nums, k, n - 1)
};

function reverse(arr, i, j) {
  while(i < j) {
    const t = arr[i]
    arr[i] = arr[j]
    arr[j] = t
    i++
    j--
  }
}

// n = 8, k = 5
// [1,2,3,4,5,6,7,8] 
// [6,2,3,4,5,1,7,8] 
// [3,2,6,4,5,1,7,8] 
// [8,2,6,4,5,1,7,3] 
// [5,2,6,4,8,1,7,3] 
// [2,5,6,4,8,1,7,3] 
// [7,5,6,4,8,1,2,3] 
// [4,5,6,7,8,1,2,3] 

// n = 7, k = 3
// [1,2,3,4,5,6,7] 
// [4,2,3,1,5,6,7] 
// [7,2,3,1,5,6,4] 
// [3,2,7,1,5,6,4] 
// [6,2,7,1,5,3,4] 
// [2,6,7,1,5,3,4] 
// [5,6,7,1,2,3,4] 
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var rotate = function(nums, k) {
  const len = nums.length
  k = k % len
  let count = 0
  for(let i=0;i<len;i++) {
    let prevI = (i + k) % len
    let prevV = nums[prevI]
    nums[prevI] = nums[i]
    count++
    while(prevI !== i) {
      const targetI = (prevI + k) % len
      const targetV = nums[targetI]
      nums[targetI] = prevV
      prevI = targetI
      prevV = targetV
      count++
      if(count === len) return
    }
  }
};
```

## ?? 🌟😻✔ 190. 颠倒二进制位【easy】

[ref](https://leetcode.cn/problems/reverse-bits/)

位运算

```js
var reverseBits = function(n) {
  let arr = []
  for(let i=0;i<32;i++) {
    if((n & (1 << i)) !== 0) {
      arr.push(1)
    } else {
      arr.push(0)
    }
  }
  let res = 0
  for(let i=0;i<32;i++) {
    res += arr[i] * 2 ** (31 - i)
  }
  return res
};

```

## ?? 🌟😻✔ 191. 位1的个数【easy】

[ref](https://leetcode.cn/problems/number-of-1-bits/)

位运算

```js
var hammingWeight = function(n) {
  let count = 0
  for(let i=0;i<32;i++) {
    if((n & (1 << i)) !== 0) count++
  }
  return count
};
```

## 😻✔ 198 打家劫舍【medium】

[ref](https://leetcode.cn/problems/house-robber/)

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var rob = function(nums) {
  if(nums.length === 1) return nums[0]
  if(nums.length === 2) return Math.max(nums[0], nums[1])
  let d0 = nums[0]
  let d1 = Math.max(nums[0], nums[1])
  for(let i = 2;i < nums.length; i++) {
    const t = d1
    d1 = Math.max(d0 + nums[i], d1)
    d0 = t
  }
  return d1
};
```
or
```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var rob = function(nums) {
  const dp = []
  dp[0] = nums[0]
  dp[1] = Math.max(nums[0], nums[1])
  for(let i = 2;i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1])
  }
  return dp[nums.length - 1]
};
```

## 😻✔ 199 二叉树的右视图【medium】

[ref](https://leetcode.cn/problems/binary-tree-right-side-view/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var rightSideView = function(root) {
  if(!root) return []
  const res = []
  let q = [root]
  let tmpQ = []

  while(q.length) {
    const node = q.pop()
    node.left && tmpQ.unshift(node.left)
    node.right && tmpQ.unshift(node.right)
    if(!q.length) {
      res.push(node.val)
      q = [...tmpQ]
      tmpQ = []
    }
  }

  return res
};
```

## 😻✔ 200 岛屿数量【medium】

[ref](https://leetcode.cn/problems/number-of-islands/)

深度优先搜索

```js
// 贪心标记法，DFS
// 时间复杂度：O(M*N)
// 空间复杂度：O(M*N)
var numIslands = function(grid) {
  const m = grid.length
  const n = grid[0].length
  let count = 0
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(used[i][j]) continue
      if(grid[i][j] === "1") {
        count++
        walk(i, j)
      }
    }
  }

  function walk(i, j) {
    if(used[i][j]) return
    if(grid[i][j] === "1") {
      used[i][j] = true
    } else {
      return  
    }
    (i - 1 >= 0) && walk(i - 1, j);
    (i + 1 <  m) && walk(i + 1, j);
    (j - 1 >= 0) && walk(i, j - 1);
    (j + 1 < n) && walk(i, j + 1);
  }

  return count
};
```

## ✔ 202 快乐数【easy】

[ref](https://leetcode.cn/problems/happy-number/)

```js
var isHappy = function(n) {
  const set = new Set()
  while(true) {
    let newN = 0
    n.toString().split('').forEach(v => {
      newN += Number(v) ** 2
    })
    if(newN === 1) {
      return true
    } else if(set.has(newN)) {
      return false
    } else {
      set.add(newN)
      n = newN
    }
  }
};

```

## ✔ 203. 移除链表元素【easy】

[ref](https://leetcode.cn/problems/remove-linked-list-elements/)

链表

```js
var removeElements = function(head, val) {
  const myHead = new ListNode(0, head)
  let tHead = myHead
  while(tHead.next) {
    if(tHead.next.val === val) {
      tHead.next = tHead.next.next
    } else {
      tHead = tHead.next
    }
  }
  return myHead.next
};
```

## ?🌟😻✔ 204 计数质数【medium】

[ref](https://leetcode.cn/problems/count-primes/)

埃氏筛法、质数统计

```js
var countPrimes = function(n) {
  let count = 0
  const p = new Array(n).fill(true)
  for(let i=2;i<n;i++) {
    if(p[i]) {
      count++
      for(let j = i * i;j<n;j += i) {
        p[j] = false
      }
    }
  }
  return count
};
 
```

## 🌟😻✔ 205. 同构字符串【easy】

[ref](https://leetcode.cn/problems/isomorphic-strings/)

字符串、哈希表

```js
var isIsomorphic = function(s, t) {
  const sMap = new Map(), tMap = new Map()
  for(let i=0;i<s.length;i++) {
    if(sMap.has(s[i]) || tMap.has(t[i])) {
      if(sMap.get(s[i]) !== t[i] || tMap.get(t[i]) !== s[i]) return false
    } else {
      sMap.set(s[i], t[i])
      tMap.set(t[i], s[i])
    }
  }
  return true
};
```

## 🌟😻✔ 206 反转链表【easy】

[ref](https://leetcode.cn/problems/reverse-linked-list/)

链表

```js
var reverseList = function (head) {
  const t = new ListNode()
  while(head) {
    const prev = t.next
    t.next = head
    head = head.next
    t.next.next = prev
  }
  return t.next
```

## ?🌟😻✔ 207. 课程表【medium】

[ref](https://leetcode.cn/problems/course-schedule/)

图、拓扑

```js
var canFinish = function(numCourses, prerequisites) {
  const indegree = new Array(numCourses).fill(0)
  const nextMap = new Map()
  for(const prerequisite of prerequisites) {
    indegree[prerequisite[0]]++
    if(nextMap.has(prerequisite[1])) {
      nextMap.get(prerequisite[1]).push(prerequisite[0])
    } else {
      nextMap.set(prerequisite[1], [prerequisite[0]])
    }
  }
  let q = []
  let cnt = 0
  for(let i=0;i<numCourses;i++) {
    if(indegree[i] === 0) {
      q.push(i)
      cnt++
    }
  }

  while(q.length) {
    const len = q.length
    const tq = []
    for(let i=0;i<len;i++) {
      if(nextMap.has(q[i])) {
        const next = nextMap.get(q[i])
        for(let j = 0; j < next.length; j++) {
          indegree[next[j]]--
          if(indegree[next[j]] === 0) {
            tq.push(next[j])
            cnt++
          }
        }
      }
    }
    q = tq
  }

  return cnt === numCourses
};
```

## ??🌟😻✔ 208 实现 Trie (前缀树)【medium】

[ref](https://leetcode.cn/problems/implement-trie-prefix-tree/)

前缀树、字典树、trie

```js
var Trie = function() {
  this.tree = new TrieNode()
};

/** 
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function(word) {
  let curr = this.tree
  for(let i=0;i<word.length;i++) {
    const c = word[i]
    if(!curr[c]) {
      curr[c] = new TrieNode(c)
    }
    if(i === word.length - 1) {
      curr[c].isEnd = true
    }
    curr = curr[c]
  }
};

/** 
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function(word) {
  let curr = this.tree
  for(let i=0;i<word.length;i++) {
    const c = word[i]
    if(!curr[c]) return false
    curr = curr[c]
    if(i === word.length - 1) {
      return !!curr.isEnd
    }
  }
};

/** 
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function(prefix) {
  let curr = this.tree
  for(let i=0;i<prefix.length;i++) {
    const c = prefix[i]
    if(!curr[c]) return false
    curr = curr[c]
  }
  return true
};

class TrieNode {
  constructor(val, isEnd = false) {
    this.val = val
    this.isEnd = isEnd
  }
}
```

## 😻✔ 209 长度最小的子数组【medium】

[ref](https://leetcode.cn/problems/minimum-size-subarray-sum/)

滑动窗口


```js
// 双指针滑动窗口
// 时间复杂度：O(N) start end 最多移动 N 次
// 空间复杂度：O(1)
var minSubArrayLen = function(target, nums) {
  const len = nums.length
  let sum = 0
  let min = Number.MAX_SAFE_INTEGER
  for(let start=0,end=0;end<len;end++) {
    sum+=nums[end]
    while(sum>=target) {
      min = Math.min(end - start + 1, min)
      sum-=nums[start]
      start++
    }
  }
  return min === Number.MAX_SAFE_INTEGER ? 0 : min
};
```

```js
// 暴力解法
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var minSubArrayLen = function(target, nums) {
  let min = Number.MAX_SAFE_INTEGER
  for(let i=0;i<nums.length;i++) {
    let sum = 0
    for(let j=i;j>=0;j--) {
      sum += nums[j]
      if(sum >= target) {
        min = Math.min(min, i - j + 1)
        break
      }
    }
  }
  return min === Number.MAX_SAFE_INTEGER ? 0 : min
};
```

## ??🌟😻✔ 210 课程表 II【medium】

[ref](https://leetcode.cn/problems/course-schedule-ii/)

拓扑排序、图

```js
var findOrder = function(numCourses, prerequisites) {
  const pre = new Array(numCourses).fill(0)
  const aft = new Map()
  for(let i=0;i<prerequisites.length;i++) {
    const target = prerequisites[i]
    pre[target[0]]++
    if(aft.has(target[1])) {
      aft.get(target[1]).push(target[0])
    } else {
      aft.set(target[1], [target[0]])
    }
  }
  const q = []
  for(let i=0;i<pre.length;i++) {
    if(pre[i] === 0) q.push(i)
  }
  let count = 0
  const res = []
  while(q.length) {
    const target = q.shift()
    count++
    res.push(target)
    const next = aft.get(target)
    if(next && next.length) {
      for(let i=0;i<next.length;i++) {
        pre[next[i]]--
        if(pre[next[i]] === 0) {
          q.push(next[i])
        }
      }
    }
  }
  return count === numCourses ? res : []
};
```

## ?? 🌟😻✔ 211 添加与搜索单词 - 数据结构设计【medium】

[ref](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)

字典树

![时空复杂度](http://qiniu1.lxfriday.xyz/feoffer/1659318737209_acbeaa0b-3502-4808-92de-623f0224d55a.png)

```js
var WordDictionary = function() {
  this.tree = new TreeNode()
};
WordDictionary.prototype.addWord = function(word) {
  let node = this.tree
  for(let i=0;i<word.length;i++) {
    if(!node.children[word[i]]) {
      node.children[word[i]] = new TreeNode()
    }
    node = node.children[word[i]]
    if(i === word.length - 1) node.isEnd = true
  }
};
WordDictionary.prototype.search = function(word) {
  return search(this.tree, word, 0)
};
function search(node, word, i) {
  if(i >= word.length) return node.isEnd
  if(word[i] === '.') {
    const keys = Object.keys(node.children)
    if(!keys.length) return false
    for(let j=0;j<keys.length;j++) {
      if(search(node.children[keys[j]], word, i + 1)) return true
    }
    return false
  } else {
    if(node.children[word[i]]) {
      return search(node.children[word[i]], word, i + 1)
    } else {
      return false
    }
  }
}

class TreeNode {
  constructor() {
    this.isEnd = false
    this.children = {}
  }
}
```

```js
var WordDictionary = function() {
  this.tree = new TrieNode()
};

/** 
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function(word) {
  let curr = this.tree
  for(let i=0;i<word.length;i++) {
    const c = word[i]
    if(!curr[c]) {
      curr[c] = new TrieNode(c)
    }
    if(i === word.length - 1) {
      curr[c].end = true
    }
    curr = curr[c]
  }
};

/** 
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function(word) {
  function searchFrom(curr, startIndex) {
    if(startIndex >= word.length) return curr.end
    const c = word[startIndex]
    if(c === '.') {
      // 只搜有的 key 不泛化的搜索 a-z
      for(let key of Object.keys(curr)) {
        if(key === 'val' || key === 'end') continue
        if(searchFrom(curr[key], startIndex + 1)) {
          return true
        }
      }
      return false
    } else if(curr[c] && curr[c].val === c) {
      return searchFrom(curr[c], startIndex + 1)
    }
    return false
  }
  return searchFrom(this.tree, 0)
};



/**
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */

class TrieNode {
  constructor(val) {
    this.val = val
    this.end = false
  }
}
```

## ?? 🌟😻✔ 212. 单词搜索 II【hard】

[ref](https://leetcode.cn/problems/word-search-ii/)

字典树、回溯

```js
// 时间复杂度：O(MN*4^L)
// 空间复杂度：O(KL) K 是单词个数、L是最长单词长度
var findWords = function(board, words) {
  const tree = createTree(words)
  const m = board.length
  const n = board[0].length
  const res = []
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      find(i, j, tree, '')
    }
  }

  function find(i, j, node, path) {
    if(i < 0 || j < 0 || i >= m || j >= n) return
    if(used[i][j]) return
    const key = board[i][j]
    if(node[key]) {
      path += key
      if(node[key].end) {
        res.push(path)
        node[key].end = false
      }
      used[i][j] = true
      find(i + 1, j, node[key], path)
      find(i - 1, j, node[key], path)
      find(i, j + 1, node[key], path)
      find(i, j - 1, node[key], path)
      used[i][j] = false
    }
  }

  return res
};

function createTree(words) {
  const tree = new Node()
  for(let i=0;i<words.length;i++) {
    let curr = tree
    const word = words[i]
    for(let j=0;j<word.length;j++) {
      const c = word[j]
      if(!curr[c]) {
        curr[c] = new Node(c)
      }
      if(j === word.length - 1) {
        curr[c].end = true
      }
      curr = curr[c]
    }
  }
  return tree
}

class Node {
  constructor(val, end) {
    this.val = val
    this.end = end || false
  }
}
```

## 🌟😻✔ 213 打家劫舍 II【medium】

[ref](https://leetcode.cn/problems/house-robber-ii/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var rob = function(nums) {
  const len = nums.length
  if(len === 1) return nums[0]
  const dp1 = new Array(len).fill(0)
  const dp2 = new Array(len - 1).fill(0)
  dp1[0] = nums[0]
  dp1[1] = Math.max(nums[0], nums[1])
  dp2[0] = nums[1]
  for(let i=2;i<len;i++) {
    dp1[i] = Math.max(dp1[i - 1], (i - 2 >=0 ? dp1[i - 2] : 0) + nums[i])
    dp2[i-1] = Math.max(dp2[i - 2], (i - 3 >=0 ? dp2[i - 3] : 0) + nums[i])
  }
  return Math.max(dp1[len - 2], dp2[len - 2])
};
```

## ???🌟😻✔ 215 数组中的第K个最大元素【medium】

[ref](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

堆、小顶堆、第K大、大顶堆、快排、快速选择、快速排序

```js
// 期望时间复杂度：O(N)
// 空间复杂度：O(1)
var findKthLargest = function(nums, k) {
  function partition(l, r) {
    if(l === r) return l
    const randomIdx = Math.floor(Math.random() * (r - l)) + l
    swap(nums, l, randomIdx)
    const pivot = nums[l]
    let k = l + 1
    for(let i=l + 1;i <= r; i++) {
      if(nums[i] > pivot) {
        swap(nums, i, k)
        k++
      }
    }
    swap(nums, k-1, l)
    return k-1
  }
  let l = 0, r = nums.length - 1
  while(true) {
    const partitionIndex = partition(l, r)
    if(partitionIndex === k - 1) {
      return nums[partitionIndex]
    } else if(partitionIndex > k - 1) {
      r = partitionIndex - 1
    } else {
      l = partitionIndex + 1
    }
  }
};

function swap(nums, i, j) {
  const t = nums[i]
  nums[i] = nums[j]
  nums[j] = t
}
```

```js
 // 小顶堆解法
 // 时间复杂度：O(nlogn)
 // 空间复杂度：O(logn)
var findKthLargest = function(nums, k) {
  const heap = new MinHeap()

  nums.forEach(n => {
      heap.insert(n)
    if(heap.size() > k) {
      heap.pop()
    }
  })
  return heap.peek()
};

class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    this.heap.pop()
    this.shiftDown(0)
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i] > this.heap[left]) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i] > this.heap[right]) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex] > this.heap[i]) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

```js
// 大顶堆解法
// 时间复杂度：O(nlogn)
// 空间复杂度：O(logn)
var findKthLargest = function(nums, k) {
  const maxHeap = new MaxHeap(k)
  for(let n of nums) {
    maxHeap.insert(n)
  }
  while (k > 1) {
    maxHeap.pop()
    k--
  }
  return maxHeap.peek()
};
// 大顶堆法，从大顶堆执行 pop() k - 1 次，则数组首个就是第 k 大
class MaxHeap{
  constructor() {
    this.heap = []
  }
  insert(n) {
    this.heap.push(n)
    this.up(this.heap.length - 1)
  }
  pop() {
    const target = this.heap[0]
    swap(this.heap, 0, this.heap.length - 1)
    this.heap.pop()
    this.down(0)
    return target
  }
  peek() {
    return this.heap[0]
  }
  get size () {
    return this.heap.length
  }
  up(index) {
    const parentIndex = Math.floor((index - 1) / 2)
    if(this.heap[index] > this.heap[parentIndex]) {
      swap(this.heap, index, parentIndex)
      this.up(parentIndex)
    }
  }
  down(index) {
    const lIndex = 2 * index + 1
    const rIndex = 2 * index + 2
    if(this.heap[index] < this.heap[lIndex]) {
      swap(this.heap, lIndex, index)
      this.down(lIndex)
    }
    if(this.heap[index] < this.heap[rIndex]) {
      swap(this.heap, rIndex, index)
      this.down(rIndex)
    }
  }
}
function swap(arr, i, j) {
  let t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

更优解、也是用大顶堆，但是没有创建新数组

```js
// 时间复杂度：O(nlogn)
// 空间复杂度：O(logn)
var findKthLargest = function(nums, k) {
  const len = nums.length
  buildMaxHeap(nums)
  for(let i = 0;i < k - 1; i++) {
    swap(nums, 0, len - 1 - i)
    maxHeapify(nums, 0, len - 2 - i)
  }
  return nums[0]
};

function buildMaxHeap(nums) {
  const len = nums.length
  for(let i = Math.floor(len / 2); i >= 0 ; i--) {
    maxHeapify(nums, i, len - 1)
  }
}

function maxHeapify(nums, i, endIndex) {
  const lIndex =  2 * i + 1
  const rIndex =  2 * i + 2
  if(lIndex <= endIndex && nums[i] < nums[lIndex]) {
    swap(nums, i, lIndex)
    maxHeapify(nums, lIndex, endIndex)
  }
  if(rIndex <= endIndex && nums[i] < nums[rIndex]) {
    swap(nums, i, rIndex)
    maxHeapify(nums, rIndex, endIndex)
  }
}

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

## 🌟😻✔ 216. 组合总和 III【medium】

[ref](https://leetcode.cn/problems/combination-sum-iii/)

回溯

```js
var combinationSum3 = function(k, n) {
  const res = []
  function walk(path, sum, startIndex) {
    if(path.length === k) {
      if(sum === n) {
        res.push([...path])
      }
      return
    }
    
    for(let i = startIndex;i<=9;i++) {
      if(sum + i <= n) {
        path.push(i)
        walk(path, sum + i, i + 1)
        path.pop()
      }
    }
  }
  walk([], 0, 1)
  return res
};
```

## ✔ 217 存在重复元素【easy】

[ref](https://leetcode.cn/problems/contains-duplicate/)

```js
var containsDuplicate = function(nums) {
  return [...new Set(nums)].length !== nums.length
};
```

## ???🌟😻✔ 218. 天际线问题【hard】

[ref](https://leetcode.cn/problems/the-skyline-problem/solution/)

排序、优先队列、大顶堆

题解

- [比较高效的解决方案，思路清晰，操作稳健（大顶堆+排序+前值维护）](https://leetcode.cn/problems/the-skyline-problem/solution/by-lxfriday-zjit/)

```js
// 扫描线问题，所有涉及到的X轴都是一条扫描线，在每一条扫描线上都要取得最大高度
// 如果没有高度存在(当前扫描线上只有[right, h])，则高度为0
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var getSkyline = function(buildings) {
  const xArr = []
  // 大顶堆维护经过的最高高度
  const maxHeap = new MaxHeap()
  // 记录所有的 X 值及其高度，【扫描线】
  // 右端点记录为负值，左端点记录为正值，方便做高度对应和区分
  // 正负区分左右端点，也正好对应一对左右端点
  for(let i=0;i<buildings.length;i++) {
    const curr = buildings[i]
    xArr.push([curr[0], curr[2]])
    xArr.push([curr[1], -curr[2]])
  }
  const res = []
  let prev = 0
  maxHeap.insert(0)
  // 按照X轴排序，X轴相同的按从大到小排序
  // 注意x轴相同时，必须是按从大到小排，即一定要拿到当前扫描线上的最高点
  xArr.sort((a, b) => (a[0] - b[0] || b[1] - a[1]))
  for(let i=0;i<xArr.length;i++) {
    const [x, y] = xArr[i]
    if(y < 0) {
      // 如果高度为负值，则删除堆中对应的起始高度
      maxHeap.remove(-y)
    } else {
      // 如果为正值，表示扫描到一个新的起始点
      maxHeap.insert(y)
    }
    // 获取最大高度（大顶堆顶部值）
    const curr = maxHeap.peek() 
    // 比较前面加入的高度和当前要加入的高度是否相等，不等则不在一条水平线上，可以加入
    if(prev !== curr) {
      res.push([x, curr])
      prev = curr
    }
  }
  return res
};

// 大顶堆
class MaxHeap {
  constructor(){
    this.heap = []
  }
  insert(h){
    this.heap.push(h)
    this.shiftUp(this.heap.length - 1)
  }
  // 删除指定高度，这里查找时间是 O(N) 
  remove(h) {
    let i = 0
    while(i < this.heap.length) {
      if(this.heap[i] === h) {
        break
      }
      i++
    }
    this.swap(i, this.heap.length - 1)
    this.heap.pop()
    this.shiftDown(i)
  }
  shiftUp(i) {
    const parentI = Math.floor((i - 1) / 2)
    if(parentI >= 0 && this.heap[i] > this.heap[parentI]) {
      this.swap(i, parentI)
      this.shiftUp(parentI)
    }
  }
  shiftDown(i) {
    const lIndex = 2 * i + 1
    const rIndex = 2 * i + 2
    let maxI = i
    if(lIndex < this.heap.length && this.heap[maxI] < this.heap[lIndex]) {
      maxI = lIndex
    }
    if(rIndex < this.heap.length && this.heap[maxI] < this.heap[rIndex]) {
      maxI = rIndex
    }
    if(maxI !== i) {
      this.swap(maxI, i)
      this.shiftDown(maxI)
    }
  }
  peek() {
    return this.heap[0]
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
}
```

## 🌟😻✔ 219. 存在重复元素 II【easy】

[ref](https://leetcode.cn/problems/contains-duplicate-ii/)

数组题

```js
 // 时间复杂度：O(N)
 // 空间复杂度：O(N)
var containsNearbyDuplicate = function(nums, k) {
  const map = new Map(), n = nums.length
  for(let i=0;i<n;i++) {
    if(map.has(nums[i])) {
      if(i - map.get(nums[i]) <= k) return true
    }
    map.set(nums[i], i)
  }
  return false
};
```

## ?🌟😻✔ 221 最大正方形【medium】

[ref](https://leetcode.cn/problems/maximal-square/)

动态规划

```js
// 时间复杂度：O(M*N)
// 空间复杂度：O(M*N)
var maximalSquare = function(matrix) {
  const m = matrix.length
  const n = matrix[0].length
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  let max = 0

  for(let i = 1;i<m;i++) {
    dp[i][0] = parseInt(matrix[i][0], 10)
    max = Math.max(max, dp[i][0])
  }

  for(let j = 0;j<n;j++) {
    dp[0][j] = parseInt(matrix[0][j], 10)
    max = Math.max(max, dp[0][j])
  }

  for(let i = 1;i<m;i++) {
    for(let j = 1;j<n;j++) {
      if(matrix[i][j] === '1') {
        dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1
        max = Math.max(dp[i][j], max)
      }
    }
  }
  return max * max
};
````

## ??🌟😻✔ 222. 完全二叉树的节点个数【medium】

[ref](https://leetcode.cn/problems/count-complete-tree-nodes/)

二叉树、二分搜索

```js
var countNodes = function(root) {
  if(!root) return 0
  let h = 0, node0 = root
  while(node0) {
    h++
    node0 = node0.left
  }
  let l = 2 ** (h - 1), r = 2 ** h - 1
  while(l < r) {
    const mid = Math.ceil((l + r) / 2)
    if(exist(mid)) {
      l = mid
    } else {
      r = mid - 1
    }
  }
  return l

  function exist(target) {
    if(target === 1) return !!root
    let node = root, k = h
    while(k >= 2) {
      const bits = 1 << (k - 2)
      const w = target & bits
      if(w > 0) node = node.right
      else node = node.left
      k--
    }
    return !!node
  }
};

  //           1                                            1
  //     2          3                           10                     11
  //  4    5     6     7                   100        101        110         111
  // 8 9 10 11 12 13 14 15              1000 1001 1010  1011  1100 1101   1110  1111 
```

## ?🌟😻✔ 223. 矩形面积【medium】

[ref](https://leetcode.cn/problems/rectangle-area/)

扫描线

```js
var computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const xArr = []
  const rects = [
    [ax1, ay1, ax2, ay2],
    [bx1, by1, bx2, by2]
  ]
  for(let i=0;i<rects.length;i++) {
    xArr.push(rects[i][0])
    xArr.push(rects[i][2])
  }
  xArr.sort((a, b) => a - b)
  let s = 0
  for(let i=1;i<xArr.length;i++) {
    const a = xArr[i - 1], b = xArr[i], xLen = b - a
    if(xLen === 0) continue
    const lines = []
    for(let rect of rects) {
      if(rect[0] <= a && rect[2] >= b) lines.push([rect[1], rect[3]])
    }
    lines.sort((a, b) => a[0] - b[0] || a[1] - b[1])
    let max = Number.MIN_SAFE_INTEGER
    let hSum = 0
    for(let i=0;i<lines.length;i++) {
      if(lines[i][0] >= max) {
        hSum += lines[i][1] - lines[i][0]
        max = lines[i][1]
      } else if(lines[i][1] > max) {
        hSum += lines[i][1] - max
        max = lines[i][1]
      }
    }
    s += hSum * xLen
  }
  return s
};
```

## ?🌟😻✔ 224 基本计算器【hard】

[ref](https://leetcode.cn/problems/basic-calculator/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var calculate = function(s) {
  const len = s.length
  const signs = [1]
  let sign = 1
  let i=0
  let ret = 0
  while(i<len) {
    if(s[i] === ' ') {
      i++
    } else if(s[i] === '(') {
      signs.push(sign)
      i++
    } else if(s[i] === ')') {
      signs.pop()
      i++
    } else if(s[i] === '+') {
      sign = signs[signs.length - 1]
      i++
    } else if(s[i] === '-') {
      sign = -signs[signs.length - 1]
      i++
    } else {
      let num = 0
      while(i < len && !isNaN(Number(s[i])) && s[i] !== ' ') {
        num = 10 * num + Number(s[i])
        i++
      }
      ret += sign * num
    }
  }
  return ret
};
```

## ?🌟😻✔ 225 用队列实现栈【easy】

[ref](https://leetcode.cn/problems/implement-stack-using-queues/)

相关

- [232 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

```js
var MyStack = function() {
  this.q = []
  this.preq = []
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
  this.preq.push(x)
  while(this.q.length){
    this.preq.push(this.q.shift())
  }
  while(this.preq.length){
    this.q.push(this.preq.shift())
  }
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
  return this.q.shift()
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
  return this.q[0]
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
  return !this.q.length && !this.preq.length
};
```

## 😻✔ 226 翻转二叉树【easy】

[ref](https://leetcode.cn/problems/invert-binary-tree/)

翻转二叉树实际就是把每个节点的子树全部翻转一次

二叉树、二叉树翻转、翻转二叉树、堆

```js
// 时间复杂度：O(n) 每个节点都访问到了
// 空间复杂度：O(h) h 是树的高度，h 最坏的情况是 n
var invertTree = function(root) {
  if(!root) return root
  return {
    val: root.val,
    left: invertTree(root.right),
    right: invertTree(root.left),
  }
};
``` 

解法2

```js
var invertTree = function(root) {
  if(!root) return root
  const head = new TreeNode(root.val)

  const dfs = (node, parent, isLeft) => {
    if(!node) return
    if(isLeft) {
      parent.right = new TreeNode(node.val)
      dfs(node.left, parent.right, true)
      dfs(node.right, parent.right, false)
    } else {
      parent.left = new TreeNode(node.val)
      dfs(node.left, parent.left, true)
      dfs(node.right, parent.left, false)
    }
  }

  dfs(root.left, head, true)
  dfs(root.right, head, false)

  return head
};
```

## ?🌟😻✔ 227. 基本计算器 II【medium】

[ref](https://leetcode.cn/problems/basic-calculator-ii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var calculate = function(s) {
  const len = s.length
  let sign = '+'
  let ret = 0
  let i = 0
  let tmp = 0
  while(i<len) {
    if(s[i] === ' ') {
      i++
    } else if (s[i] === '+') {
      sign = '+'
      ret += tmp
      tmp = 0
      i++
    } else if (s[i] === '-') {
      sign = '-'
      ret += tmp
      tmp = 0
      i++
    } else if (s[i] === '*') {
      sign = '*'
      i++
    } else if (s[i] === '/') {
      sign = '/'
      i++
    } else {
      let num = 0
      while(i < len && s[i] !== ' ' && !isNaN(Number(s[i]))) {
        num = num * 10 + Number(s[i])
        i++
      }
      if(sign === '+') {
        tmp = num
      } else if(sign === '-') {
        tmp = -num
      }else if(sign === '*') {
        tmp = tmp * num
      } else if(sign === '/') {
        tmp = tmp < 0 ?Math.ceil(tmp / num) : Math.floor(tmp / num)
      }
    }
  }
  ret += tmp
  return ret
};
```

## ?🌟😻✔ 229. 多数元素 II【medium】

[ref](https://leetcode.cn/problems/majority-element-ii/)

数组

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var majorityElement = function(nums) {
  const n = nums.length
  let team1 = 0, count1 = 0
  let team2 = 0,  count2 = 0
  for(let i = 0; i < n; i++) {
    const num = nums[i]
    if(count1 > 0 && num === team1) {
      count1++
    } else if(count2 > 0 && num === team2) {
      count2++
    } else if(count1 > 0 && count2 > 0 && num !== team1 && num !== team2) {
      count1--
      count2--
    } else if(count1 === 0) {
      team1 = nums[i]
      count1++
    } else {
      team2 = nums[i]
      count2++
    }
  }
  const res = []
  let c1 = 0, c2 = 0
  for(let i = 0; i < n; i++) {
    if(nums[i] === team1) c1++
    else if(nums[i] === team2) c2++
  }
  if(count1 > 0 && c1 > n / 3) res.push(team1)
  if(count2 > 0 && c2 > n / 3) res.push(team2)
  return res
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var majorityElement = function(nums) {
  const n = nums.length
  const targetCount = Math.floor(n / 3) + 1
  const m = new Map()
  const res = new Set()
  for(let i = 0; i < n; i++) {
    m.set(nums[i], (m.get(nums[i]) || 0) + 1)
    if(m.get(nums[i]) >= targetCount) {
      res.add(nums[i])
    }
  }
  return [...res]
};
```

## ?🌟😻✔ 230 二叉搜索树中第K小的元素【medium】

[ref](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

二叉搜索树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var kthSmallest = function(root, k) {
  let target
  function dfs(node, extraCount) {
    if(!node) return 0
    const leftCount = dfs(node.left, extraCount)
    const allCount = extraCount + leftCount + 1
    if(allCount === k) {
      target = node.val
    }
    const rightCount = dfs(node.right, allCount)
    return leftCount + 1 + rightCount
  }

  dfs(root, 0)
  return target
};
```

## ✔ 231 2 的幂【easy】

[ref](https://leetcode.cn/problems/power-of-two/)

```js
var isPowerOfTwo = function(n) {
  return n > 0 && (n & (n - 1)) === 0
};
```

## ✔ 232 用栈实现队列【easy】

[ref](https://leetcode.cn/problems/implement-queue-using-stacks/)

相关

- [225 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)


```js
var MyQueue = function() {
  this.stack = []
  this.prestack = []
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
  this.prestack.push(x)
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
  if(!this.stack.length) {
    while(this.prestack.length) {
      this.stack.push(this.prestack.pop())
    }
  }
  return this.stack.pop()
};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
  if(!this.stack.length) {
    while(this.prestack.length) {
      this.stack.push(this.prestack.pop())
    }
  }
  return this.stack[this.stack.length - 1]
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
  return !this.stack.length && !this.prestack.length
};
```


## 🌟😻✔ 235 二叉搜索树的最近公共祖先【easy】

[ref](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

二叉搜索树

```js
// 迭代
// 时间复杂度：O(N)
// 时间复杂度：O(1)
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
  while(true) {
    if(root.val < p.val && root.val < q.val) {
      root = root.right
    } else if(root.val > p.val && root.val > q.val) {
      root = root.left
    } else {
      return root
    }
  }
};
```

```js
// 递归
var lowestCommonAncestor = function(root, p, q) {
  let min = Math.min(p.val, q.val)
  let max = Math.max(p.val, q.val)
  if(root.val < min) {
    return lowestCommonAncestor(root.right, p, q)
  } else if(root.val > max) {
    return lowestCommonAncestor(root.left, p, q)
  } else {
    return root
  }
};
```

## 🌟😻✔ 236 二叉树的最近公共祖先【medium】

[ref](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

二叉树

```js
// 时间复杂度:O(N)
// 空间复杂度:O(N)
var lowestCommonAncestor = function(root, p, q) {
  let target = root
  let targetDepth = 1
  function dfs(node, depth) {
    let count = 0
    if(node === p || node === q) {
      count ++
    }
    if(node.left) {
      count += dfs(node.left, depth + 1)
    }
    if(node.right) {
      count += dfs(node.right, depth + 1)
    }
    if(count === 2 && depth > targetDepth) {
      targetDepth = depth
      target = node
    }
    return count
  }
  dfs(root, 1)
  return target
};
```

## 🌟😻✔ 238 除自身以外数组的乘积【medium】

[ref](https://leetcode.cn/problems/product-of-array-except-self/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)  输出数组不计算在内
var productExceptSelf = function(nums) {
  const n = nums.length 
  let lm = 1
  let rm = 1
  const res = []
  for(let i=0;i<n;i++) {
    res[i] = lm
    lm *= nums[i]
  }
  for(let i=n-1;i>=0;i--) {
    res[i] = rm * res[i]
    rm *= nums[i]
  }
  return res
};

```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var productExceptSelf = function(nums) {
  const n = nums.length 
  const lp = []
  const rp = []
  let lm = 1
  let rm = 1
  const res = []
  for(let i=0;i<n;i++) {
    lp[i] = lm
    lm *= nums[i]
  }
  for(let i=n-1;i>=0;i--) {
    rp[i] = rm
    rm *= nums[i]
  }
  for(let i=0;i<n;i++) {
    res[i] = lp[i]*rp[i]
  }
  return res
};
```

## 🌟😻✔ 239 滑动窗口最大值【hard】

[ref](https://leetcode.cn/problems/sliding-window-maximum/)

优先队列、大顶堆、单调队列

```js
// 时间复杂度：O(nlogn)
// 空间复杂度：O(n)
var maxSlidingWindow = function(nums, k) {
  const len = nums.length
  const res = []
  const maxHeap = new MaxHeap()
  for(let i=0;i<k - 1;i++) {
    maxHeap.insert({
      index: i,
      val: nums[i]
    })
  }
  for(let i=k - 1;i<len;i++) {
    maxHeap.insert({
      index: i,
      val: nums[i]
    })
    while(maxHeap.peek().index < i + 1 - k) maxHeap.pop()
    res.push(maxHeap.peek().val)
  }
  return res
};

class MaxHeap {
  constructor() {
    this.heap = []
  }
  insert(target) {
    this.heap.push(target)
    this.shiftUp(this.size - 1)
  }
  pop() {
    this.swap(0, this.size - 1)
    this.heap.pop()
    this.shiftDown(0)
  }
  get size() {
    return this.heap.length
  }
  peek() {
    return this.heap[0]
  }
  shiftUp(i) {
    const parentIndex =  Math.floor((i - 1) / 2)
    if(parentIndex >= 0 && this.heap[parentIndex].val < this.heap[i].val) {
      this.swap(i, parentIndex)
      this.shiftUp(parentIndex)
    }
  }
  shiftDown(i) {
    const l = 2 * i + 1
    const r = 2 * i + 2
    let maxIndex = i
    if(l < this.size && this.heap[maxIndex].val < this.heap[l].val) {
      maxIndex = l
    }
    if(r < this.size && this.heap[maxIndex].val < this.heap[r].val) {
      maxIndex = r
    }
    if(maxIndex !== i) {
      this.swap(i, maxIndex)
      this.shiftDown(maxIndex)
    }
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
}
```

单调队列解法，比较难理解

```js
// 时间复杂度：O(n) 每个下标被放进队列1次，且出队列1次
// 空间复杂度：O(k) 
var maxSlidingWindow = function(nums, k) {
  const len = nums.length
  const q = []
  const res = []
  for(let i=0;i<k - 1;i++) {
    while(q.length && nums[q[q.length - 1]] <= nums[i]) {
      q.pop()
    }
    q.push(i)
  }
  for(let i=k - 1;i<len;i++) {
    while(q.length && nums[q[q.length - 1]] <= nums[i]) {
      q.pop()
    }
    q.push(i)
    while(q[0] < i - k + 1) {
      q.shift()
    }
    res.push(nums[q[0]])
  }
  return res
};
```

## 🌟😻✔ 240 搜索二维矩阵 II【medium】

[ref](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

```js
// 时间复杂度：O(m+n)
// 空间复杂度：O(1)
var searchMatrix = function(matrix, target) {
  const m = matrix.length, n = matrix[0].length
  let i = 0,j = n - 1
  while(i < m && j >=0) {
    if(matrix[i][j] === target) return true
    else if(target < matrix[i][j]) {
      j--
    } else {
      i++
    }
  }
  return false
};
```

## ?🌟😻✔ 241. 为运算表达式设计优先级【medium】

[ref](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

递归、字符串

```js
var diffWaysToCompute = function(expression) {
  const n = expression.length
  const res = []
  for(let i=0;i<n;i++) {
    if(expression[i] >= '0' && expression[i] <= '9') continue
    const leftValues = diffWaysToCompute(expression.slice(0, i))
    const rightValues = diffWaysToCompute(expression.slice(i + 1))
    for(let lv of leftValues) {
      for(let rv of rightValues) {
        if(expression[i] === '+') {
          res.push(lv + rv)
        } else if(expression[i] === '-') {
          res.push(lv - rv)
        } else {
          res.push(lv * rv)
        }
      }
    }
  }
  if(!res.length) {
    res.push(Number(expression))
  }
  return res
};
```

## ✔ 252 会议室【easy】

[ref](https://leetcode.cn/problems/meeting-rooms/)

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var canAttendMeetings = function(intervals) {
  intervals.sort((a, b) => a[0] - b[0])
  for(let i=0;i<intervals.length - 1;i++) {
    if(intervals[i][1] > intervals[i+1][0]) return false
  }
  return true
};
```

## ✔ 242. 有效的字母异位词【easy】

[ref](https://leetcode.cn/problems/valid-anagram/)

哈希表

```js
// 时间复杂度：O(M+N)
// 空间复杂度：O(S) S 是字符集 S=26
var isAnagram = function(s, t) {
  const map = new Map()
  for(let i=0;i<s.length;i++) {
    map.set(s[i], map.has(s[i])? map.get(s[i]) + 1 : 1)
  }
  for(let i=0;i<t.length;i++) {
    if(!map.has(t[i]) || map.get(t[i]) === 0) return false
    map.set(t[i], map.get(t[i]) - 1)
  }
  return true
};
```


## 🌟😻✔ 251. 展开二维向量【medium】

[ref](https://leetcode.cn/problems/flatten-2d-vector/)

```js
var Vector2D = function(vec) {
  this.vec = vec
  this.i = 0
  this.j = 0
};

Vector2D.prototype.next = function() {
  while(this.j >= this.vec[this.i].length) {
    this.i++
    this.j = 0
  }
  return this.vec[this.i][this.j++]
};

Vector2D.prototype.hasNext = function() {
  while(this.i < this.vec.length && this.j >= this.vec[this.i].length) {
    this.i++
    this.j = 0
  }
  if(this.i < this.vec.length) {
    return true
  }
  return false
};
 
```

## ?🌟😻✔ 253 会议室 II【medium】

[ref](https://leetcode.cn/problems/meeting-rooms-ii/)

二分搜索、排序、单调栈、上下车问题、重叠区间问题

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var minMeetingRooms = function(intervals) {
  let s = new Set()
  for(let i=0;i<intervals.length;i++) {
    s.add(intervals[i][0])
    s.add(intervals[i][1])
  }
  s = [...s].sort((a, b) => a - b)
  intervals.sort((a, b) => a[0] - b[0])
  let max = 0
  const stack = []
  let k = 0
  for(let i of s) {
    while(k < intervals.length && intervals[k][0] === i) {
      const target = intervals[k++][1]
      let l = 0, r = stack.length - 1
      while(l <= r) {
        const mid = Math.floor((l + r) / 2)
        if(stack[mid] < target) {
          l = mid + 1
        } else {
          r = mid - 1
        }
      }
      stack.splice(l, 0, target)
    }
    while(stack.length && stack[0] <= i) {
      stack.shift()
    }
    max = Math.max(max, stack.length)
  }
  return max
};
```

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var minMeetingRooms = function(intervals) {
  const start = []  
  const end = []
  for(let i=0;i<intervals.length;i++) {
    start.push(intervals[i][0])
    end.push(intervals[i][1])
  }
  start.sort((a, b) => a - b)
  end.sort((a, b) => a - b)
  let max = 0
  let curr = 0

  while(start.length && end.length) {
    if(start[0] < end[0]) {
      curr++
      max = Math.max(max, curr)
      start.shift()
    } else {
      curr--
      end.shift()
    }
  }

  return max
};
```

## ?🌟😻✔ 254. 因子的组合【medium】

[ref](https://leetcode.cn/problems/factor-combinations/)

回溯法

```js
var getFactors = function(n) {
  const res = []

  function walk(path, k, start) {
    if(path.length > 0) {
      res.push([...path, k])
    }
    for(let i=2;i * i<=k;i++) {
      if(k % i === 0) {
        path.push(i)
        walk(path, k / i, i)
        path.pop()
      }
    }
  }
  walk([], n, 2)

  return res
};

```

## 🌟😻✔ 256 粉刷房子【medium】

[ref](https://leetcode.cn/problems/paint-house/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var minCost = function(costs) {
  let a = costs[0][0]
  let b = costs[0][1]
  let c = costs[0][2]
  for(let i=1;i<costs.length;i++) {
    const pa = a, pb = b, pc = c
    a = costs[i][0] + Math.min(pb, pc)
    b = costs[i][1] + Math.min(pa, pc)
    c = costs[i][2] + Math.min(pa, pb)
  }
  return Math.min(a, b, c)
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var minCost = function(costs) {
  const dp = new Array(costs.length).fill(0).map(_ => new Array(3).fill(0))
  dp[0][0] = costs[0][0]
  dp[0][1] = costs[0][1]
  dp[0][2] = costs[0][2]
  for(let i=1;i<costs.length;i++) {
    dp[i][0] = costs[i][0] + Math.min(dp[i-1][1], dp[i-1][2])
    dp[i][1] = costs[i][1] + Math.min(dp[i-1][0], dp[i-1][2])
    dp[i][2] = costs[i][2] + Math.min(dp[i-1][0], dp[i-1][1])
  }
  return Math.min(...dp[costs.length - 1])
};
```

## ✔ 257. 二叉树的所有路径【easy】

[ref](https://leetcode.cn/problems/binary-tree-paths/)

二叉树

```js
var binaryTreePaths = function(root) {
  const res = []
  function dfs(node, path) {
    if(!node.left && !node.right) {
      path.push(node.val)
      res.push(path.join('->'))
      path.pop()
    }
    path.push(node.val)
    node.left && dfs(node.left, path)
    node.right && dfs(node.right, path)
    path.pop()
  }
  dfs(root, [])
  return res
};
```

## 🌟😻✔ 258. 各位相加【easy】

[ref](https://leetcode.cn/problems/add-digits/)

模拟、数学问题、数论

```js
var addDigits = function(num) {
  return num < 10 ? num : addDigits(num.toString().split('').reduce((prev, next) => prev + Number(next), 0))
};
```

```js


```

## 🌟😻✔ 259 较小的三数之和【medium】

[ref](https://leetcode.cn/problems/3sum-smaller/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(logN)
var threeSumSmaller = function(nums, target) {
  const n = nums.length
  if(n < 3) return 0
  nums.sort((a, b) => a - b)
  let res = 0
  for(let i=0; i < n - 2; i++) {
    let l = i + 1, r = n - 1
    while(l < r) {
      const s = nums[i] + nums[l] + nums[r]
      if(s < target) {
        let tl = l
        while(tl < r && nums[i] + nums[tl] + nums[r] < target) {
          tl++
          res++
        }
        r--
      } else {
        r--
      }
    }
  }
  return res
};
```

## ?🌟😻✔ 260. 只出现一次的数字 III【medium】

[ref](https://leetcode.cn/problems/single-number-iii/)

位运算

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var singleNumber = function(nums) {
  let s = 0
  for(let i=0;i<nums.length;i++) {
    s ^= nums[i]
  }
  let k = 1
  while((k & s) === 0) {
    k <<= 1
  }
  let a = 0, b = 0
  for(let i=0;i<nums.length;i++) {
    if((k & nums[i]) === 0) {
      a ^= nums[i]
    } else {
      b ^= nums[i]
    }
  }
  return [a, b]
};
```

## ?🌟😻✔ 261. 以图判树【medium】

[ref](https://leetcode.cn/problems/graph-valid-tree/)

并查集、广度优先搜索

题解

- [【云影同学】并查集、广度优先搜索BFS 双解](https://leetcode.cn/problems/graph-valid-tree/solution/by-lxfriday-h59q/)

```js
// 并查集
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var validTree = function(n, edges) {
  const parent = new Array(n).fill(0).map((v, i) => i)
  for(let i=0;i<edges.length;i++) {
    const edge = edges[i]
    if(find(parent, edge[0]) !== find(parent, edge[1])) {
      union(parent, edge[0], edge[1])
    } else {
      return false
    }
  }
  let targetSet = new Set()
  const used = new Set()
  for(let i=0;i<n;i++) {
    if(used.has(i)) continue
    let j = i
    while(parent[j] !== j) {
      used.add(j)
      j = parent[j]
    }
    used.add(j)
    targetSet.add(j)
  }
  return targetSet.size === 1
};

function find(parent, index) {
  if(parent[index] !== index) {
    parent[index] = find(parent, parent[index])
  }
  return parent[index]
}

function union(parent, index1, index2) {
  parent[find(parent, index1)] = find(parent, index2)
}
```


```js
// BFS
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var validTree = function(n, edges) {
  const connectionMap = new Map()
  for(let i=0;i<edges.length;i++) {
    const edge = edges[i]
    if(connectionMap.has(edge[0])) {
      connectionMap.get(edge[0]).add(edge[1])
    } else {
      connectionMap.set(edge[0], new Set([edge[1]]))
    }
    if(connectionMap.has(edge[1])) {
      connectionMap.get(edge[1]).add(edge[0])
    } else {
      connectionMap.set(edge[1], new Set([edge[0]]))
    }
  }
  let q = new Set([0])
  const used = new Set([0])
  let lenEdges = edges.length
  while(q.size) {
    const tq = new Set()
    for(let qi of q) {
      const nexts = connectionMap.get(qi)
      if(nexts) {
        for(let next of nexts) {
          if(used.has(next)) continue
          used.add(next)
          tq.add(next)
          lenEdges--
        }
      }
    }
    q = tq
  }
  return lenEdges === 0 && used.size === n
};
````


## ✔ 263 丑数【easy】

[ref](https://leetcode.cn/problems/ugly-number/)

```js
var isUgly = function(n) {
  if(n === 0) return false
  if(n === 1) return true
  if(n % 2 === 0) return isUgly(n / 2)
  if(n % 3 === 0) return isUgly(n / 3)
  if(n % 5 === 0) return isUgly(n / 5)
  return false
};
```

## ?🌟😻✔ 264 丑数 II【medium】

[ref](https://leetcode.cn/problems/ugly-number-ii/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var nthUglyNumber = function(n) {
  const dp = new Array(n + 1).fill(1)
  let j2 = 1,j3 = 1,j5 = 1
  for(let i=2;i<=n;i++) {
    const v2 = dp[j2] * 2
    const v3 = dp[j3] * 3
    const v5 = dp[j5] * 5
    const min = Math.min(v2, v3, v5)

    if(min === v2) j2++
    if(min === v3) j3++
    if(min === v5) j5++
    dp[i] = min
  }

  return dp[n]
};
```

or 优先队列、小顶堆


```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var nthUglyNumber = function(n) {
  let c = 1
  n--
  const s = new Set()
  const minHeap = new MinHeap()
  while(n > 0) {
    if(!s.has(2 * c)) {
      s.add(2 * c)
      minHeap.insert(2 * c)
    }
    if(!s.has(3 * c)) {
      s.add(3 * c)
      minHeap.insert(3 * c)
    }
    if(!s.has(5 * c)) {
      s.add(5 * c)
      minHeap.insert(5 * c)
    }
    c = minHeap.pop()
    n--
  }
  return c
};

class MinHeap {
  constructor() {
    this.heap = []
  }
  insert(v){
    this.heap.push(v)
    this.shiftUp(this.heap.length - 1)
  }
  pop(){
    this.swap(0, this.heap.length - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  shiftUp(i){
    const parentIndex = Math.floor((i - 1) / 2)
    if(this.heap[i] < this.heap[parentIndex]) {
      this.swap(i, parentIndex)
      this.shiftUp(parentIndex)
    }
  }
  shiftDown(i){
    const leftIndex= 2 * i + 1
    const rightIndex= 2 * i + 2
    let minIndex = i
    if(this.heap[minIndex] > this.heap[leftIndex]) {
      minIndex = leftIndex
    }
    if(this.heap[minIndex] > this.heap[rightIndex]) {
      minIndex = rightIndex
    }
    if(minIndex !== i) {
      this.swap(i, minIndex)
      this.shiftDown(minIndex)
    }
  }
  swap(i,j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
}

```

## 🌟😻✔ 265 粉刷房子 II【hard】

[ref](https://leetcode.cn/problems/paint-house-ii/)

动态规划

极致优化方案

```js
// 时间复杂度：O(N*K)
// 空间复杂度：O(1)
var minCostII = function(costs) {
  const n = costs.length
  const k = costs[0].length
  let min1 = Number.MAX_SAFE_INTEGER, min1j = 0
  let min2 = Number.MAX_SAFE_INTEGER
  for(let j=0;j<k;j++) {
    if(costs[0][j] < min1) {
      min2 = min1
      min1 = costs[0][j]
      min1j = j
    } else if(costs[0][j] < min2) {
      min2 = costs[0][j]
    }
  }
  for(let i=1;i<n;i++) {
    let tmin1 = Number.MAX_SAFE_INTEGER, tmin1j = 0
    let tmin2 = Number.MAX_SAFE_INTEGER
    for(let j=0;j<k;j++) {
      let s
      if(j !== min1j) {
        s = costs[i][j] + min1
      } else {
        s = costs[i][j] + min2
      }
      if(s < tmin1) {
        tmin2 = tmin1
        tmin1 = s
        tmin1j = j
      } else if(s < tmin2) {
        tmin2 = s
      }
    }
    min1 = tmin1
    min1j = tmin1j
    min2 = tmin2
  }
  return min1
};

```

常规 dp

```js
// 时间复杂度：O(N*K^2)
// 空间复杂度：O(N*K)
var minCostII = function(costs) {
  const n = costs.length
  const k = costs[0].length
  const dp = new Array(n).fill(0).map(_ => new Array(k).fill(0))
  for(let j=0;j<k;j++) {
    dp[0][j] = costs[0][j]
  }
  for(let i=1;i<n;i++) {
    for(let j=0;j<k;j++) {
      let min = Number.MAX_SAFE_INTEGER
      for(let jj=0;jj<k;jj++) {
        if(jj !== j) {
          min = Math.min(min, dp[i-1][jj])
        }
      }
      dp[i][j] = costs[i][j] + min
    }
  }
  return Math.min(...dp[n-1])
};

```

## 🌟😻✔ 266. 回文排列【easy】

[ref](https://leetcode.cn/problems/palindrome-permutation/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var canPermutePalindrome = function(s) {
  const map = new Map()
  for(let i=0;i<s.length;i++) {
    map.set(s[i], (map.get(s[i]) || 0) + 1)
  }
  let singleCount = 0
  for(const count of map.values()) {
    if(count % 2 === 1) {
      singleCount ++
    }
  }
  return singleCount <= 1
};
```

## 🌟😻✔ 267. 回文排列 II【medium】

[ref](https://leetcode.cn/problems/palindrome-permutation-ii/)

回溯法

题解

- [ref](https://leetcode.cn/problems/palindrome-permutation-ii/solution/by-lxfriday-6w11/)

```js
var generatePalindromes = function(s) {
  const map = new Map()
  for(let i=0;i<s.length;i++) {
    map.set(s[i], (map.get(s[i]) || 0) + 1)
  }
  let singleChar = ''
  for(const [c, count] of map.entries()) {
    if(count % 2 === 1) {
      if(singleChar !== '') return []
      singleChar = c
    }
  }
  if(singleChar !== '') {
    map.set(singleChar, map.get(singleChar) - 1)
  }
  // 回溯法拼接回文串
  const res = []
  function walk(path) {
    if(path.length === s.length) {
      res.push(path)
      return
    }
    for(const [c, count] of map.entries()) {
      if(count < 2) continue
      map.set(c, map.get(c) - 2)
      walk(`${c}${path}${c}`)
      map.set(c, map.get(c) + 2)
    }
  }
  walk(singleChar)
  return res
};

```

## 🌟😻✔ 268 丢失的数字【easy】

[ref](https://leetcode.cn/problems/3sum-smaller/submissions/)

常规

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(logN)
var threeSumSmaller = function(nums, target) {
  const n = nums.length
  if(n < 3) return 0
  nums.sort((a, b) => a - b)
  let res = 0
  for(let i=0; i < n - 2; i++) {
    let l = i + 1, r = n - 1
    while(l < r) {
      const s = nums[i] + nums[l] + nums[r]
      if(s < target) {
        let tl = l
        while(tl < r && nums[i] + nums[tl] + nums[r] < target) {
          tl++
          res++
        }
        r--
      } else {
        r--
      }
    }
  }

  return res
};
```

二分

```js
// 时间复杂度：O(N^2*logN)
// 空间复杂度：O(logN)
var threeSumSmaller = function(nums, target) {
  const n = nums.length
  if(n < 3) return 0
  nums.sort((a, b) => a - b)
  let res = 0
  for(let i=0; i < n - 2; i++) {
    for(let j = i + 1;j<n-1;j++) {
      const t = target - nums[i] - nums[j]
      const ind = binarySearch(t, nums, j + 1, n - 1)
      res += ind - j
    }
  }

  return res
};

function binarySearch(t, nums, l, r) {
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] >= t) {
      r = mid - 1
    } else {
      l = mid + 1
    }
  }
  return l - 1
}

```

## ???🌟😻✔ 269. 火星词典【hard】

[ref](https://leetcode.cn/problems/alien-dictionary/)

拓扑排序、深度优先搜索

```js
var alienOrder = function(words) {
  const map = new Map()
  let invalid = false
  const degree = new Map()
  // 所包含的所有字符
  const chars = new Set()
  for(let i=0;i<words.length;i++) {
    for(let j=0;j<words[i].length;j++) {
      chars.add(words[i][j])
    }
  }
  function getOrder(start, end, k) {
    if(start ===  end) return
    let l = start, i = start
    while(i <= end) {
      while(i + 1 <= end && k < words[i].length && words[i][k] === words[i + 1][k]) {
        i++
      }
      if(i + 1 <= end && k < words[i].length) {
        const a = words[i][k], b = words[i + 1][k]
        if(b === undefined) {
          invalid = true
          return
        }
        if(map.has(a)) {
          map.get(a).add(b)
        } else {
          map.set(a, new Set([b]))
        }
      }
      getOrder(l, i, k + 1)
      l = i + 1
      i++
    }
  }
  getOrder(0, words.length - 1, 0)
  if(invalid) return ''
  const used = new Set()
  function dfs(k) {
    if(used.has(k)) {
      invalid = true
      return 0
    }
    if(degree[k]) return degree[k]
    if(!map.has(k)) {
      degree.set(k, 1)
      return 1
    }
    let sum = 1
    used.add(k)
    for(let nextKey of map.get(k)) {
      sum += dfs(nextKey)
    }
    used.delete(k)
    degree.set(k, sum)
    return sum
  }
  for(let k of chars) {
    dfs(k)
  }
  const sorted = [...degree].sort((a, b) => b[1] - a[1])
  let res = ''
  for(let c of sorted) {
    res += c[0]
  }
  return invalid? '' : res
};
```

## ?🌟😻✔ 276. 栅栏涂色【medium】

[ref](https://leetcode.cn/problems/encode-and-decode-strings/)

字符串、数组

```js
var encode = function(strs) {
  if(!strs.length) return ''
  let res = ''
  for(let i=0;i<strs.length;i++) {
    res += strs[i] + '饕'
  }
  return res
};
var decode = function(s) {
  if(!s.length) return []
  let i=0
  const res = []
  while(i < s.length) {
    let j = i
    while(j < s.length && s[j] !== '饕') {
      j++
    }
    res.push(s.slice(i, j))
    i = j + 1
  }
  return res
};
```

## 🌟😻✔ 276. 栅栏涂色【medium】

[ref](https://leetcode.cn/problems/paint-fence/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numWays = function(n, k) {
  let s = 0, nos = k
  for(let i=1;i<n;i++) {
    const ts = s, tnos = nos
    s = tnos
    nos = (ts + tnos) * (k - 1)
  }
  return s + nos
};
```

or

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var numWays = function(n, k) {
  const dp = new Array(n).fill(0).map(_ => new Array(2).fill(0))
  dp[0][0] = 0
  dp[0][1] = k
  for(let i=1;i<n;i++) {
    dp[i][0] = dp[i-1][1]
    dp[i][1] = (dp[i-1][0] + dp[i-1][1]) * (k - 1)
  }
  return dp[n-1][0] + dp[n-1][1]
};
```

## 🌟😻✔ 278 第一个错误的版本【easy】

[ref](https://leetcode.cn/problems/first-bad-version/)

二分查找

```js
var solution = function(isBadVersion) {
  /**
   * @param {integer} n Total versions
   * @return {integer} The first bad version
   */
  return function(n) {
      let r = n
      let l = 1
      while(l < r) {
        const mid = Math.floor((l + r) / 2)
        if(!isBadVersion(mid)) {
          l = mid + 1
        } else {
          r = mid
        }
      }
      return r
  };
};
```


## 🌟😻✔ 279 完全平方数【medium】

[ref](https://leetcode.cn/problems/perfect-squares/)

```js
var numSquares = function(n) {
  const dp = new Array(n + 1).fill(0)
  for(let i=0;i<=n;i++) {
    let min = i
    for(let j = 1;j * j <= i; j++) {
      min = Math.min(dp[i - j * j] + 1, min)
    }
    dp[i] = min
  }
  return dp[n]
};
```

## ?🌟😻✔ 280. 摆动排序【medium】

[ref](https://leetcode.cn/problems/wiggle-sort/)

摆动排序

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var wiggleSort = function(nums) {
  let less = true
  for(let i=0;i<nums.length;i++) {
    if(less) {
      if(nums[i] > nums[i + 1]) {
        swap(nums, i, i + 1)
      }
    } else {
      if(nums[i] < nums[i + 1]) {
        swap(nums, i, i + 1)
      }
    }
    less = !less
  }
};

function swap(nums, i, j) {
  const t = nums[i]
  nums[i] = nums[j]
  nums[j] = t
}
```

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var wiggleSort = function(nums) {
  nums.sort((a, b) => a - b)
  let l = 1
  while(l + 1 < nums.length) {
    const t = nums[l]
    nums[l] = nums[l + 1]
    nums[l + 1] = t
    l += 2
  }
};
```

```js
var wiggleSort = function(nums) {
  const cpy = [...nums].sort((a, b) => a - b)
  let l = 0, r = nums.length - 1
  const res = [cpy[l++]]
  while(l <= r) {
    res.push(cpy[r--])
    if(l <= r) {
      res.push(cpy[l++])
    }
  }
  for(let i=0;i<nums.length;i++) {
    nums[i] = res[i]
  }
};
```


## ?🌟😻✔ 281. 锯齿迭代器【medium】

[ref](https://leetcode.cn/problems/zigzag-iterator/)

迭代器

题解

- [ref](https://leetcode.cn/problems/zigzag-iterator/solution/by-lxfriday-z65p/)

```js
var ZigzagIterator = function ZigzagIterator(v1, v2) {
  this.vec = [v1, v2]
  this.i = 0
};
ZigzagIterator.prototype.hasNext = function hasNext() {
  if(this.vec[this.i].length) {
    return true
  } else {
    while(this.vec.length && !this.vec[this.i].length) {
      this.vec.splice(this.i, 1)
      if(this.vec.length === 0) return false
      this.i = this.i % this.vec.length
    }
    if(!this.vec.length) return false
    return true
  }
};
ZigzagIterator.prototype.next = function next() {
  const ret = this.vec[this.i].shift()
  this.i = (this.i + 1) % this.vec.length
  return ret
};
```

拓展版本

```js
// const karr = [
//   [1, 2, 3, 4, 5, 6, 7, 8],
//   [10, 20, 30, 40, 50, 60, 70],
//   [100, 200, 300, 400, 500],
//   [1000, 2000, 3000, 4000, 5000, 6000],
//   [10000, 20000, 30000],
// ]

var ZigzagIterator = function ZigzagIterator(v1, v2) {
  this.vec = [v1, v2]
  this.i = 0
};
ZigzagIterator.prototype.hasNext = function hasNext() {
  if(this.vec[this.i].length) {
    return true
  } else {
    while(this.vec.length && !this.vec[this.i].length) {
      this.vec.splice(this.i, 1)
      if(this.vec.length === 0) return false
      this.i = this.i % this.vec.length
    }
    return true
  }
};
ZigzagIterator.prototype.next = function next() {
  const ret = this.vec[this.i].shift()
  this.i = (this.i + 1) % this.vec.length
  return ret
};

```

## ✔ 283 移动零【easy】

[ref](https://leetcode.cn/problems/move-zeroes/)

数组

```js
var moveZeroes = function(nums) {
  let realIndex = 0
  for(let i=0;i<nums.length;i++) {
    if(nums[i] !== 0) {
      nums[realIndex++] = nums[i]
    }
  }
  while(realIndex<nums.length) {
    nums[realIndex++] = 0
  }
};
```

## 🌟😻✔ 284. 顶端迭代器【medium】

[ref](https://leetcode.cn/problems/peeking-iterator/)

迭代器

```js
var PeekingIterator = function(iterator) {
   this.iterator = iterator
   this.tmp = undefined
};
PeekingIterator.prototype.peek = function() {
  if(this.tmp !== undefined) return this.tmp
  this.tmp = this.iterator.next()
  return this.tmp
};
PeekingIterator.prototype.next = function() {
  if(this.tmp !== undefined) {
    const ret = this.tmp
    this.tmp = undefined
    return ret
  } else {
    return this.iterator.next()
  }
};
PeekingIterator.prototype.hasNext = function() {
  return this.tmp !== undefined || this.iterator.hasNext()
};

```

## ?🌟😻✔ 285. 二叉搜索树中的中序后继【medium】

[ref](https://leetcode.cn/problems/inorder-successor-in-bst/)

二叉搜索树

```js
// 通用解法，不利用二叉搜索树的性质
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var inorderSuccessor = function(root, p) {
  let res = null
  let prev = null
  function dfs(node) {
    node.left && dfs(node.left)
    if(prev === p) {
      res = node
    }
    prev = node
    node.right && dfs(node.right)
  }
  dfs(root)
  return res
};
```

```js
// 利用二叉搜索树的性质，p 无右节点，则中序后继必然比p大且为p的祖先节点
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var inorderSuccessor = function(root, p) {
  if(p.right) {
    let node = p.right
    while(node.left) {
      node = node.left
    }
    return node
  }
  let node = root
  let next = null
  while(node) {
    if(node.val > p.val) {
      next = node
      node = node.left
    } else {
      node = node.right
    }
  }
  return next
};
```

## ?🌟😻✔ 286. 墙与门【medium】

[ref](https://leetcode.cn/problems/walls-and-gates/)

广度优先搜索、多源广度优先搜索

```ts
function wallsAndGates(rooms: number[][]): void {
  const INF = 2147483647
  const m = rooms.length
  const n = rooms[0].length
  let q: Array<[number, number, number]> = []
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(rooms[i][j] === 0) q.push([i, j, 0])
    }
  }
  const dots = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  while(q.length) {
    const len = q.length
    const newQ : Array<[number, number, number]> = []
    for(let k=0;k<len;k++) {
      const [i, j, depth] = q[k]
      for(let kk=0;kk<dots.length;kk++) {
        const ii = i + dots[kk][0], jj = j + dots[kk][1]
        if(ii < 0 || jj < 0 || ii >= m || jj >= n || rooms[ii][jj] !== INF) continue
        rooms[ii][jj] = depth + 1
        newQ.push([ii, jj, depth + 1])
      }
    }
    q = newQ
  }
};
```


## ??🌟😻✔ 287 寻找重复数【medium】

[ref](https://leetcode.cn/problems/find-the-duplicate-number/)

双指针、快慢指针、环链表、二分搜索

参考
- [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(1)
var findDuplicate = function(nums) {
  let l = 1, r = nums.length - 1
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    let count = 0
    for(let num of nums) {
      count += (num <= mid ? 1 : 0)
    }
    if(mid < count) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return r
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findDuplicate = function(nums) {
  let slow = 0, fast = 0
  do {
    slow = nums[slow]
    fast = nums[nums[fast]]
  } while(slow !== fast)

  slow = 0
  while(slow !== fast) {
    slow = nums[slow]
    fast = nums[fast]
  }
  return slow
};
```

## 🌟😻✔ 290. 单词规律【easy】

[ref](https://leetcode.cn/problems/word-pattern/)

哈希表

```js
var wordPattern = function(pattern, s) {
  const pattern2StrMap = new Map(), str2PatternMap = new Map(), arr = s.split(' ')
  if(arr.length !== pattern.length) return false
  for(let i=0;i<arr.length;i++) {
    if(pattern2StrMap.has(pattern[i]) || str2PatternMap.has(arr[i])) {
      if(pattern2StrMap.get(pattern[i]) !== arr[i] || str2PatternMap.get(arr[i]) !== pattern[i]) return false
    } else {
      pattern2StrMap.set(pattern[i], arr[i])
      str2PatternMap.set(arr[i], pattern[i])
    }
  }
  return true
};
```

## ✔ 292 Nim 游戏【easy】

[ref](https://leetcode.cn/problems/nim-game/)

```js
var canWinNim = function(n) {
  return n % 4 === 0 ? false : true
};
```

## 🌟😻✔ 289. 生命游戏【medium】

[ref](https://leetcode.cn/problems/game-of-life/)

矩阵、原地算法

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(1)
var gameOfLife = function(board) {
  const m = board.length
  const n = board[0].length
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      calc(i, j)
    }
  }
  function calc(i, j) {
    const places = [
      [-1, -1], 
      [-1, 0], 
      [-1, 1], 
      [0, -1], 
      [0, 1], 
      [1, -1], 
      [1, 0], 
      [1, 1], 
    ]
    let alive = 0
    for(let k=0;k<8;k++) {
      const ii = i + places[k][0]
      const jj = j + places[k][1]
      if(ii < 0 || jj < 0 || ii >= m || jj >= n) continue
      let status = board[ii][jj]
      if(status === 1 || status === 4 || status === 5) {
        alive++
      }
    }
    if(board[i][j] === 0) {
      if(alive === 3) {
        // `0|1`
        board[i][j] = 3
      } else {
        // `0|0`
        board[i][j] = 2
      }
    } else {
      if(alive < 2 || alive > 3) {
        // `1|0`
        board[i][j] = 4
      } else {
        // `1|1`
        board[i][j] = 5
      }
    }
  }
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      board[i][j] = (board[i][j] === 3 || board[i][j] === 5) ? 1: 0
    }
  }
  return board
};
```

## ?🌟😻✔ 295 数据流的中位数【hard】

[ref](https://leetcode.cn/problems/find-median-from-data-stream/)

优先队列、大顶堆、小顶堆

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(N)
var MedianFinder = function() {
  this.maxHeap = new MaxHeap() // 小的部分
  this.minHeap = new MinHeap() // 大的部分
};

MedianFinder.prototype.addNum = function(num) {
  if(
    this.maxHeap.size() === 0
    || num < this.maxHeap.peek()) {
      this.maxHeap.insert(num)
      if(this.maxHeap.size() > this.minHeap.size() + 1) {
        this.minHeap.insert(this.maxHeap.pop())
      }
  } else {
    this.minHeap.insert(num)
    if(this.minHeap.size() > this.maxHeap.size()) {
      this.maxHeap.insert(this.minHeap.pop())
    }
  }
};

MedianFinder.prototype.findMedian = function() {
  if(this.minHeap.size() === this.maxHeap.size()) {
    return (this.minHeap.peek() + this.maxHeap.peek()) / 2
  } else {
    return this.maxHeap.peek()
  }
};

// 小顶堆
class MinHeap {
  constructor(isMin) {
    this.heap = []
  }
  insert(v) {
    this.heap.push(v)
    this.shiftUp(this.heap.length - 1)
  }
  pop() {
    this.swap(0, this.heap.length - 1)
    const target = this.heap.pop()
    this.shiftDown(0)
    return target
  }
  shiftUp(i) {
    const parentIndex = Math.floor((i - 1) / 2)
    if(this.heap[i] < this.heap[parentIndex]) {
      this.swap(i, parentIndex)
      this.shiftUp(parentIndex)
    }
  }
  shiftDown(i) {
    const lIndex = 2 * i + 1
    const rIndex = 2 * i + 2
    let minIndex = i
    if(this.heap[lIndex] < this.heap[minIndex]) {
      minIndex = lIndex
    }
    if(this.heap[rIndex] < this.heap[minIndex]) {
      minIndex = rIndex
    }
    if(minIndex !== i) {
      this.swap(minIndex, i)
      this.shiftDown(minIndex)
    }
  }
  peek() {
    return this.heap[0]
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  size() {
    return this.heap.length
  }
}

// 大顶堆
class MaxHeap {
  constructor() {
    this.heap = []
  }
  insert(v) {
    this.heap.push(v)
    this.shiftUp(this.heap.length - 1)
  }
  pop() {
    this.swap(0, this.heap.length - 1)
    const target = this.heap.pop()
    this.shiftDown(0)
    return target
  }
  shiftUp(i) {
    const parentIndex = Math.floor((i - 1) / 2)
    if(this.heap[i] > this.heap[parentIndex]) {
      this.swap(i, parentIndex)
      this.shiftUp(parentIndex)
    }
  }
  shiftDown(i) {
    const lIndex = 2 * i + 1
    const rIndex = 2 * i + 2
    let maxIndex = i
    if(this.heap[lIndex] > this.heap[maxIndex]) {
      maxIndex = lIndex
    }
    if(this.heap[rIndex] > this.heap[maxIndex]) {
      maxIndex = rIndex
    }
    if(maxIndex !== i) {
      this.swap(maxIndex, i)
      this.shiftDown(maxIndex)
    }
  }
  peek() {
    return this.heap[0]
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  size() {
    return this.heap.length
  }
}
```

## ?🌟😻✔ 297 二叉树的序列化与反序列化【hard】

[ref](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

```js
var serialize = function(root) {
  if(!root) return ''
  let str = ''
  function serializer(node) {
    if(!node) {
      str += '[]'
      return
    }
    str += `[${node.val}`
    serializer(node.left)
    serializer(node.right)
    str += `]`
  }
  serializer(root)
  return str
};
var deserialize = function(data) {
  if(data === '') return null
  let i = 1
  function deserializer() {
    const sign = data[i] === '-'? (i++, -1):1
    let num = 0
    while(data[i] < 10) num = 10 * num + Number(data[i++])
    const node = new TreeNode(sign * num)
    if(data[i] === '[') {
      i++
      if(data[i] !== ']') {
        node.left = deserializer()
      } else {
        i++
      }
    }
    if(data[i] === '[') {
      i++
      if(data[i] !== ']') {
        node.right = deserializer()
      } else {
        i++
      }
    }
    i++
    return node
  }
  return deserializer()
};
```

```js
var serialize = function(root) {
  let str = ''
  function serializer(node) {
    if(!node) {
      str += 'null#'
      return
    }
    str += `${node.val}#`
    serializer(node.left)
    serializer(node.right)
  }
  serializer(root)
  return str
};
var deserialize = function(data) {
  let i = 0
  const dataArr = data.split('#')
  function deserializer() {
    if(dataArr[i] === 'null') {
      i++
      return null
    }
    const node = new TreeNode(+dataArr[i++])
    node.left = deserializer()
    node.right = deserializer()
    return node
  }
  return deserializer()
};
```

## 😻✔ 298 二叉树最长连续序列【medium】

[ref](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/)

二叉树、深度优先遍历

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var longestConsecutive = function(root) {
  let max = 1

  function dfs(node, parentValue, len) {
    if(node.val === parentValue + 1) {
      len++
      max = Math.max(max, len)
    } else {
      len = 1
    }
    node.left && dfs(node.left, node.val, len)
    node.right && dfs(node.right, node.val, len)
  }

  dfs(root, undefined, 0)
  return max
};
```

## ?🌟😻✔ 299. 猜数字游戏【medium】

[ref](https://leetcode.cn/problems/bulls-and-cows/)

哈希表、数字、字符串

```js
// 时间复杂度：O(N)
// 时间复杂度：O(M) M= 10
var getHint = function(secret, guess) {
  let A = 0, B = 0
  const nums = new Array(10).fill(0)
  for(let i=0;i<secret.length;i++) {
    if(secret[i] === guess[i]) {
      A++
    } else {
      if(nums[guess[i]] > 0) {
        B++
      }
      nums[guess[i]]--
      if(nums[secret[i]] < 0) {
        B++
      }
      nums[secret[i]]++
    }
  }
  return `${A}A${B}B`
};
```

```js
// 两次扫描，常规解法
// 时间复杂度：O(N)
// 时间复杂度：O(M) M= secret有多少个不同数字
var getHint = function(secret, guess) {
  let A = 0, B = 0
  const m = new Map()
  for(let i=0;i<secret.length;i++) {
    if(secret[i] === guess[i]) {
      A++
    } else {
      m.set(secret[i], (m.get(secret[i]) || 0) + 1)
    }
  }
  for(let i=0;i<secret.length;i++) {
    if(secret[i] !== guess[i]) {
      if(m.get(guess[i]) > 0) {
        B++
        m.set(guess[i], m.get(guess[i]) - 1)
      }
    }
  }
  return `${A}A${B}B`
};

```

## ??🌟😻✔ 300 最长递增子序列【medium】

[ref](https://leetcode.cn/problems/longest-increasing-subsequence/)

动态规划

```js
// 时间复杂度：O(n^2)
// 空间复杂度：O(n)
var lengthOfLIS = function(nums) {
  let len = nums.length
  const dp = new Array(len).fill(1)
  for(let i=0;i<len;i++) {
    dp[i] = 1
    for(let j = i - 1; j>=0; j--) {
      if(nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1)
      }
    }
  }
  return Math.max(...dp)
};
```

更高效版

理论依据：在查找最长递增子序列的过程中，需要尽可能让长度为 x 的子序列的最大值最小，这样才能尽可能多的在后面补上新数字

dp[i] 代表长度为 i 的最长递增子序列的最后一个数的最小值

```js
// 时间复杂度：O(NlogN)
// 时间复杂度：O(N)
var lengthOfLIS = function(nums) {
  const n = nums.length
  const dp = []
  dp[0] = nums[0]
  let k = 0
  for(let i=1;i<n;i++) {
    if(nums[i] > dp[k]) {
      dp[++k] = nums[i]
    } else {
      let l = 0, r = k
      while(l <= r) {
        const mid = Math.floor((l + r) / 2)
        if(dp[mid] < nums[i]) {
          l = mid + 1
        } else {
          r = mid - 1
        }
      }
      dp[l] = nums[i]
    }
  }
  return dp.length
};
```

## ??🌟😻✔ 301 删除无效的括号【hard】

[ref](https://leetcode.cn/problems/remove-invalid-parentheses/)

BFS

```js
var removeInvalidParentheses = function(s) {
  let q = new Set([s])
  while(true) {
    const nextQ = new Set()
    const valids = [...q].filter(isValid)
    if(valids.length) {
      return valids
    }
    for(let targetStr of q) {
      for(let i=0;i<targetStr.length;i++) {
        if('()'.includes(targetStr[i])) {
          nextQ.add(targetStr.slice(0, i) + targetStr.slice(i + 1))
        }
      }
    }
    q = nextQ
  }
};

function isValid(s) {
  let count = 0
  for(let i=0;i<s.length;i++) {
    if(s[i] === '(') {
      count++
    } else if(s[i] === ')') {
      count--
      if(count < 0) return false
    }
  }
  return count === 0
}

```

## 🌟😻✔ 303. 区域和检索 - 数组不可变【easy】

[ref](https://leetcode.cn/problems/range-sum-query-immutable/)

前缀数组

```js
var NumArray = function(nums) {
  this.pfxArr = []
  let sum = 0
  for(let i=0;i<nums.length;i++) {
    sum += nums[i]
    this.pfxArr.push(sum)
  }
};

NumArray.prototype.sumRange = function(left, right) {
  return this.pfxArr[right] - (left - 1 >= 0 ? this.pfxArr[left - 1]: 0)
};
```

## ?🌟😻✔ 304. 二维区域和检索 - 矩阵不可变【medium】

[ref](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

前缀数组、二维前缀数组

```js
var NumMatrix = function(matrix) {
  const m = matrix.length, n = matrix[0].length
  this.pfxArr = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  for(let i=0;i<m;i++) {
    let sum = 0
    for(let j=0;j<n;j++) {
      sum += matrix[i][j]
      this.pfxArr[i][j] = sum + (i - 1 >= 0 ? this.pfxArr[i - 1][j] : 0)
    }
  }
};

NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {
  return this.pfxArr[row2][col2]
           - (row1 - 1 >= 0 ? this.pfxArr[row1 - 1][col2] : 0)
           - (col1 - 1 >= 0 ? this.pfxArr[row2][col1 - 1] : 0)
           + (row1 - 1 >= 0 && col1 - 1 >= 0 ? this.pfxArr[row1 - 1][col1 - 1] : 0)
};
```

## ??🌟😻✔ 309 最佳买卖股票时机含冷冻期【medium】

[ref](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

高效版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  const len = prices.length
  // 确定初始值
  let profitWithShare = -prices[0]
  let profitWithCooldown = 0
  let profitWithoutCooldown = 0

  for(let i = 1; i < len; i++) {
    const profitWithShareBefore = profitWithShare
    const profitWithCooldownBefore = profitWithCooldown
    const profitWithoutCooldownBefore = profitWithoutCooldown
    profitWithShare = Math.max(profitWithShareBefore, profitWithoutCooldownBefore - prices[i])
    profitWithCooldown = profitWithShareBefore + prices[i]
    profitWithoutCooldown = Math.max(profitWithoutCooldownBefore, profitWithCooldownBefore)
  }

  return Math.max(profitWithCooldown, profitWithoutCooldown)
};
```

数组版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProfit = function(prices) {
  // -------------------------------------
  // i 天结束之后会存在三种状态（注意，是 i 天结束）：
  // 0. 持有股票
  // 1. 不持有股票，且处于冷冻期
  // 2. 不持有股票，且不处于冷冻期
  // -------------------------------------
  // 三种状态的转移方程
  // -------------------------------------
  // 0. 持有股票：
  // i - 1 天结束的时候就持有股票
  // 或者 i 天买了股票（i - 1 天的时候不处于冷冻期）
  // dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2] - prices[i])
  // -------------------------------------
  // 1. 不持有股票，且处于冷冻期
  // i 天卖出了股票, i - 1 结束的时候持有股票
  // dp[i][1] = dp[i-1][0] + prices[i]
  // -------------------------------------
  // 2. 不持有股票，且不处于冷冻期
  // i - 1 天结束的时候就是不持有股票且不处于冷冻期
  // i - 1 天结束的时候处于冷冻期
  // dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1])
  // -------------------------------------
  // 综合下来 i 天结束之后，能获得的最大收益
  // Math.max(dp[i][0], d[i][1], dp[i][2])
  // 要注意一点，i 天结束之后，如果还持有股票，这肯定比 i 天结束之后不持有股票的收益低
  // 则最终结果 Math.max(d[i][1], dp[i][2])

  const len = prices.length
  // 确定初始值
  const dp = new Array(len).fill(1).map(_ => [])
  dp[0][0] = -prices[0]
  dp[0][1] = 0
  dp[0][2] = 0

  for(let i = 1; i < len; i++) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2] - prices[i])
    dp[i][1] = dp[i-1][0] + prices[i]
    dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1])
  }

  return Math.max(dp[len - 1][1], dp[len - 1][2])
};
```

## ??🌟😻✔ 312 戳气球【hard】

[ref](https://leetcode.cn/problems/burst-balloons/)

开区间动态规划

```js
// 时间复杂度：O(N^3)
// 空间复杂度：O(N^2)
var maxCoins = function(nums) {
  nums.unshift(1)
  nums.push(1)
  const n = nums.length
  const dp = new Array(n).fill(0).map(_ => new Array(n).fill(0))
  for(let i = n; i >=0 ; i--) {
    for(let j = i + 2; j < n; j++) {
      for(let k = i + 1; k < j; k++) {
        dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])
      }
    }
  }
  return dp[0][n-1]
};

```

## ?🌟😻✔ 313. 超级丑数【medium】

[ref](https://leetcode.cn/problems/super-ugly-number/)

```js
// 时间复杂度：O(n*m)
// 空间复杂度：O(n + m)
var nthSuperUglyNumber = function(n, primes) {
  const len = primes.length
  const baseCalc = new Array(len).fill(1)
  const dp = new Array(n + 1).fill(1)
  for(let i=2;i<=n;i++) {
    let min = Number.MAX_SAFE_INTEGER
    for(let j = 0;j<primes.length;j++) {
      min = Math.min(dp[baseCalc[j]] * primes[j], min)
    }
    for(let j = 0;j<primes.length;j++) {
      if(dp[baseCalc[j]] * primes[j] === min) {
        baseCalc[j]++
      }
    }

    dp[i] = min
  }
  return dp[n]
};
```

## ?🌟😻✔ 315 计算右侧小于当前元素的个数【hard】

[ref](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

逆序对、归并排序

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var countSmaller = function(nums) {
  for(let i=0;i<nums.length;i++) {
    nums[i] = {ind: i, val: nums[i]}
  }
  const ret = new Array(nums.length).fill(0)
  function mergeSort(nums, l, r) {
    l = typeof l === 'number' ? l : 0
    r = typeof r === 'number' ? r : nums.length - 1
    if(l === r) return [nums[l]]
    const mid = Math.floor((l + r) / 2)
    return merge(mergeSort(nums, l, mid), mergeSort(nums, mid + 1, r))
  }

  function merge(arr1, arr2) {
    const len1 = arr1.length
    const len2 = arr2.length
    let l1 = l2 = 0
    const res = []
    while(l1 < len1 && l2 < len2) {
      if(arr1[l1].val > arr2[l2].val) {
        ret[arr1[l1].ind] += len2 - l2
        res.push(arr1[l1++])
      } else {
        res.push(arr2[l2++])
      }
    }
    while(l1 < len1) {
      res.push(arr1[l1++])
    }
    while(l2 < len2) {
      res.push(arr2[l2++])
    }
    return res
  }

  mergeSort(nums)
  return ret
};
```

## ?🌟😻✔ 316. 去除重复字母【medium】

[ref](https://leetcode.cn/problems/remove-duplicate-letters/)

```js
// 时间复杂度：O(N)
var removeDuplicateLetters = function(s) {
  // 统计各字符出现的次数
  const map = new Map(), n = s.length
  for(let i = n - 1; i >= 0; i--) {
    map.set(s[i], (map.get(s[i]) || 0) + 1)
  }
  const stack = []
  // 使用了哪些字符，后面碰到前面使用过的字符则直接跳过，不参与构成结果
  const used = new Set()
  for(let i=0;i<n;i++) {
    // 如果该字符在前面已经使用过了，则直接跳过
    if(used.has(s[i])) {
      map.set(s[i], map.get(s[i]) - 1)
      continue
    }
    while(
      stack.length
      && stack[stack.length - 1] > s[i]
      && map.get(stack[stack.length - 1]) > 0
    ) {
      // stack[stack.length - 1] 有后续替代，当前位用字典序更小的字符
      used.delete(stack.pop())
    }
    stack.push(s[i])
    used.add(s[i])
    map.set(s[i], map.get(s[i]) - 1)
  }
  return stack.join('')
};

```

## ?🌟😻✔ 319. 灯泡开关【medium】

[ref](https://leetcode.cn/problems/bulb-switcher/)

规律、模拟

```js
var bulbSwitch = function(n) {
  return Math.floor(Math.sqrt(n))
};
```

## ?🌟😻✔ 322 零钱兑换【medium】

[ref](https://leetcode.cn/problems/coin-change/)

动态规划、01背包

```js
// 动态规划
// N=coins.length S=amount
// 时间复杂度：O(S*N)
// 空间复杂度：O(S)
var coinChange = function(coins, amount) {
  const len = coins.length
  const dp = new Array(amount + 1).fill(amount + 1)
  dp[0] = 0
  for(let i=1;i<=amount;i++) {
    for(let j=0;j<coins.length;j++) {
      if(i - coins[j] >= 0) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1)
      }
    }
  }
  return dp[amount] > amount? -1 : dp[amount]
};
```

## 🌟😻✔ 323. 无向图中连通分量的数目【medium】

[ref](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/comments/)

图、广度优先搜索、并查集

```js
var countComponents = function(n, edges) {
  const map = new Map()
  const edgeSet = new Set()
  for(let i=0;i<edges.length;i++) {
    const edge = edges[i]
    edgeSet.add(edge[0])
    edgeSet.add(edge[1])
    if(map.has(edge[0])) {
      map.get(edge[0]).push(edge[1])
    } else {
      map.set(edge[0], [edge[1]])
    }
    if(map.has(edge[1])) {
      map.get(edge[1]).push(edge[0])
    } else {
      map.set(edge[1], [edge[0]])
    }
  }
  let count = 0
  const used = new Set()
  for(let dot of edgeSet) {
    if(used.has(dot)) continue
    used.add(dot)
    count++
    let q = [dot]
    while(q.length) {
      const tq = []
      for(let i=0;i<q.length;i++) {
        const relas = map.get(q[i])
        for(let j=0;j<relas.length;j++) {
          if(!used.has(relas[j])) {
            used.add(relas[j])
            tq.push(relas[j])
          }
        }
      }
      q = tq
    }
  }
  return count + n - edgeSet.size
};
```

并查集实现

```js
var countComponents = function(n, edges) {
  const parent = new Array(n).fill(0).map((v, i) => i)
  for(let edge of edges) {
    union(parent, edge[0], edge[1])
  }
  let count = 0
  for(let i=0;i<n;i++) {
    if(parent[i] === i) count++
  }
  return count
};
function find(parent, i) {
  if(parent[i] !== i) {
    return find(parent, parent[i])
  }
  return parent[i]
}
function union(parent, i, j) {
  parent[find(parent, i)] = find(parent, j)
}
```

## ?🌟😻✔ 324. 摆动排序 II【medium】

[ref](https://leetcode.cn/problems/wiggle-sort-ii/)

摆动排序

```js
// 时间复杂度：O(NlogN)
// 时间复杂度：O(logN)
var wiggleSort = function(nums) {
  const cpy = [...nums].sort((a, b) => a - b)
  const n = nums.length
  const mid = Math.floor((n - 1) / 2)
  let i = mid
  let j = n - 1
  let isI = true
  for(let k=0;k<nums.length;k++) {
    nums[k] = isI ? cpy[i--] : cpy[j--]
    isI = !isI
  }
  return nums
};
```

## ✔ 325 和等于 k 的最长子数组长度【medium】

[ref](https://leetcode.cn/problems/maximum-size-subarray-sum-equals-k/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxSubArrayLen = function(nums, k) {
  const n = nums.length
  const m = new Map()
  let sum = 0
  let max = 0
  for(let i=0;i<n;i++) {
    sum += nums[i]
    if(sum === k) {
      max = Math.max(max, i + 1)
    }
    if(m.has(sum - k)) {
      max = Math.max(max, i - m.get(sum - k))
    }
    if(!m.has(sum)) {
      m.set(sum, i)
    }
  }
  return max
};
```

## 🌟😻✔ 326. 3 的幂【easy】

[ref](https://leetcode.cn/problems/power-of-three/)

进制转换

```js
// 时间复杂度：O(1)
// 时间复杂度：O(1)
var isPowerOfThree = function(n) {
  const nStr = n.toString(3)
  if(nStr[0] === '1') {
    if(nStr.lenghth === 1 || Number(nStr.slice(1)) === 0) return true
  }
  return false
};
```

## ?🌟😻✔ 327. 区间和的个数【hard】

[ref](https://leetcode.cn/problems/count-of-range-sum/)

归并排序、前缀树组、数组题

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var countRangeSum = function(nums, lower, upper) {
  const n = nums.length
  const sum = []
  let s = 0
  let count = 0

  for(let i = 0; i < n; i++) {
    s += nums[i]
    sum[i] = s
    if(s >= lower && s <= upper) count++
  }

  function mergeSort(l, r) {
    l = typeof l === 'number' ? l : 0
    r = typeof r === 'number' ? r : n - 1
    if(l === r) return [sum[l]]
    const mid = Math.floor((l + r) / 2)
    return merge(mergeSort(l, mid), mergeSort(mid + 1, r))
  }

  function merge(arr1, arr2) {
    const len1 = arr1.length, len2 = arr2.length

    let arr2l = 0, arr2r = 0
    for(let i = 0; i < len1; i++) {
      while(arr2l < len2 && arr2[arr2l] - arr1[i] < lower) {
        arr2l++
      }
      while(arr2r < len2 && arr2[arr2r] - arr1[i] <= upper) {
        arr2r++
      }
      count += arr2r - arr2l
    }

    const mergeRes = new Array(len1 + len2)
    let ind = 0
    let l1 = 0, l2 = 0
    while(l1 < len1 && l2 < len2) {
      if(arr1[l1] < arr2[l2]) {
        mergeRes[ind++] = arr1[l1++]
      } else {
        mergeRes[ind++] = arr2[l2++]
      }
    }
    while(l1 < len1) {
      mergeRes[ind++] = arr1[l1++]
    }
    while(l2 < len2) {
      mergeRes[ind++] = arr2[l2++]
    }
    return mergeRes
  }

  mergeSort()
  return count
};
```

## ?🌟😻✔ 328. 奇偶链表【medium】

[ref](https://leetcode.cn/problems/odd-even-linked-list/)

链表操作

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var oddEvenList = function(head) {
  const head1 = new ListNode()
  const head2 = new ListNode()
  let th1 = head1
  let th2 = head2
  while(head) {
    th1.next = head
    head = head.next
    th1 = th1.next
    if(head) {
      th2.next = head
      head = head.next
      th2 = th2.next
      th2.next = null
    }
  }
  th1.next = head2.next
  return head1.next
};

```

## ?🌟😻✔ 329 矩阵中的最长递增路径【hard】

[ref](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)

记忆化深度优先

```js
// 时间复杂度：O(M*N)
// 空间复杂度：O(M*N)
var longestIncreasingPath = function(matrix) {
  const m = matrix.length
  const n = matrix[0].length
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(-1))
  let max = 0

  for(let i = 0; i < m; i++) {
    for(let j = 0; j < n; j++) {
      max = Math.max(max, find(i, j, -1))
    }
  }

  function find(i, j, prevValue) {
    if(
        i < m
        && i >= 0
        && j < n
        && j >= 0
        && !used[i][j]
        && matrix[i][j] > prevValue
      ) {
      if(dp[i][j] >= 0) return dp[i][j]
      used[i][j] = true
      const maxLen = Math.max(
        find(i - 1, j, matrix[i][j]),
        find(i + 1, j, matrix[i][j]),
        find(i, j - 1, matrix[i][j]),
        find(i, j + 1, matrix[i][j])
      ) + 1
      used[i][j] = false
      dp[i][j] = maxLen
      return maxLen
    }
    return 0
  }
  return max
};

```

## 🌟😻✔ 334. 递增的三元子序列【medium】

[ref](https://leetcode.cn/problems/increasing-triplet-subsequence/)

数组题、贪心

```js
// 贪心，你真贪
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var increasingTriplet = function(nums) {
  if(nums.length < 3) return false
  let lmin = nums[0]
  let rmin = Number.MAX_SAFE_INTEGER
  for(let i=1;i<nums.length;i++) {
    if(nums[i] > rmin) return true
    if(nums[i] > lmin) {
      rmin = Math.min(rmin, nums[i])
    } else {
      lmin = Math.min(lmin, nums[i])
    }
  }
  return false
};
```

## ??🌟😻✔ 336 回文对【hard】

[ref](https://leetcode.cn/problems/palindrome-pairs/)

```js
var palindromePairs = function(words) {
  const res = []
  const m = new Map()
  for(let i=0;i<words.length;i++) {
    m.set(words[i].split('').reverse().join(''), i)
  }
  for(let i=0;i<words.length;i++) {
    const curStr = words[i]
    if(is(curStr) && curStr !== '' && m.has('')) {
      res.push([i, m.get('')])
      res.push([m.get(''), i])
    }
    for(let j = 0;j<curStr.length;j++) {
      const lStr = curStr.slice(0, j + 1)
      const rStr = curStr.slice(j + 1)
      if(is(lStr) && m.has(rStr) && m.get(rStr) !== i && rStr !== '') {
        res.push([m.get(rStr), i])
      }
      if(is(rStr) && m.has(lStr) && m.get(lStr) !== i) {
        res.push([i, m.get(lStr)])
      }
    }
  }
  return res
};

function is(s) {
  let l = 0, r = s.length - 1
  while(l <= r) {
    if(s[l++] !== s[r--]) return false
  }
  return true
}
```

## ?🌟😻✔ 337 打家劫舍 III【medium】

[ref](https://leetcode.cn/problems/house-robber-iii/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var rob = function(root) {
  const s = new Map()
  const notS = new Map()

  function dfs(node) {
    node.left && dfs(node.left)
    node.right && dfs(node.right)
    notS.set(node,(s.get(node.left) || 0) + (s.get(node.right) || 0))
    s.set(node, Math.max(
      node.val + ((notS.get(node.left) || 0) + (notS.get(node.right) || 0)),
      notS.get(node)
    ))
  }

  dfs(root)
  return s.get(root)
};
```

## ?😻✔ 338 比特位计数【easy】

[ref](https://leetcode.cn/problems/counting-bits/)

规律、模拟

```js
var countBits = function(n) {
  const res = [0]

  // 分奇数偶数讨论
  for(let i=1;i<=n;i++) {
    if(i % 2 === 0) {
      res[i] = res[i / 2]
    } else {
      res[i] = res[i - 1] + 1
    }
  }

  return res
};

```

## 🌟😻✔ 340. 至多包含 K 个不同字符的最长子串【medium】

[ref](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)

滑动窗口

```js
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var lengthOfLongestSubstringKDistinct = function(s, k) {
  if(k === 0) return 0
  const m = new Map()
  let l = 0, r = 0
  let max = 0
  let diffCount = 0
  while(r < s.length) {
    m.set(s[r], (m.get(s[r]) || 0) + 1)
    if(m.get(s[r]) === 1) {
      diffCount++
    }
    while(l<=r && diffCount > k) {
      m.set(s[l], m.get(s[l]) - 1)
      if(m.get(s[l]) === 0) diffCount--
      l++
    }
    max = Math.max(max, r - l + 1)
    r++
  }
  return max
};
```

## 🌟😻✔ 341. 扁平化嵌套列表迭代器【medium】

[ref](https://leetcode.cn/problems/flatten-nested-list-iterator/)

递归、数组扁平化

```js
var NestedIterator = function(nestedList) {
  function calc(list) {
    let res = []
    for(let i=0;i<list.length;i++) {
      if(list[i]._integer !== null) {
        res.push(list[i]._integer)
      } else {
        res = [...res, ...calc(list[i]._list)]
      }
    }
    return res
  }

  this.list = calc(nestedList)
  this.i = 0
};
NestedIterator.prototype.hasNext = function() {
  return this.i < this.list.length
};
NestedIterator.prototype.next = function() {
  return this.list[this.i++]
};
```

```js
var NestedIterator = function(nestedList) {
  this.list = nestedList
};
NestedIterator.prototype.hasNext = function() {
  while(this.list.length) {
    if(this.list[0].isInteger()) {
      return true
    } else {
      const h = this.list.shift() 
      this.list = [...h.getList(), ...this.list]
    }
  }
  return false
};
NestedIterator.prototype.next = function() {
  return this.list.shift().getInteger()
};
```

## 😻✔ 343 整数拆分【medium】

[ref](https://leetcode.cn/problems/integer-break/)

动态规划、整数拆分

关联 [剑指 Offer 14- I. 剪绳子](#🌟😻✔-剑指-offer-14-i-剪绳子【medium】)

```js
var cuttingRope = function(n) {
  if(n <= 3) return n - 1
  let res = 1
  while(n > 4) {
    res *= 3
    n -= 3
  }
  return res * n
};
```

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var integerBreak = function(n) {
  const dp = new Array(n + 1).fill(1)
  dp[0] = 1
  dp[1] = 1
  dp[2] = 1
  for(let i=3;i<=n;i++) {
    for(j = 1;j<i;j++) {
      dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j])
    }
  }
  return dp[n]
};
```

## 🌟😻✔ 345. 反转字符串中的元音字母【medium】

[ref](https://leetcode.cn/problems/reverse-vowels-of-a-string/)

字符串、双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var reverseVowels = function(s) {
  s = s.split('')
  const baseSet = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])
  let l = 0, r = s.length - 1
  while(l < r) {
    while(l < r && !baseSet.has(s[l])) l++
    while(l < r && !baseSet.has(s[r])) r--
    if(l < r) {
      swap(s, l, r)
      l++
      r--
    }
  }
  return s.join('')
};

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

## 😻✔ 347 前 K 个高频元素【medium】

[ref](https://leetcode.cn/problems/top-k-frequent-elements/)

堆、小顶堆、前K大、桶排序

```js
// 桶排序
// 时间复杂度：O(N+K)
// 空间复杂度：O(K)
var topKFrequent = function(nums, k) {
  const m = new Map()
  for(let i=0;i<nums.length;i++) {
    m.set(nums[i], (m.get(nums[i]) || 0) + 1)
  }
  const arr = []
  for(let [num, count] of m.entries()) {
    if(!arr[count]) {
      arr[count] = []
    }
    arr[count].push(num)
  }
  const res = []
  for(let i = arr.length - 1;i > 0;i--) {
    if(arr[i]) {
      for(let j=0;j<arr[i].length;j++) {
        res.push(arr[i][j])
        if(res.length === k) return res
      }
    }
  }
};
```

```js
// 时间复杂度：O(nlogk)
// 空间复杂度：O(n)
var topKFrequent = function(nums, k) {
  const map = new Map()
  const h = new MinHeap()
  for(let n of nums) {
    map.set(n, map.has(n) ? map.get(n) + 1 : 1)
  }

  map.forEach((frequence, num) => {
    h.insert({num, frequence})
    if(h.size() > k) {
      h.pop()
    }
  })

  return h.heap.map(_ => _.num)
};

class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(num) {
    this.heap.push(num)
    this.shiftUp(this.heap.length - 1)
  }

  pop() {
    this.swap(0, this.heap.length - 1)
    let p = this.heap.pop()
    this.shiftDown(0)
    return p
  }

  peek() {
    return this.heap[0]
  }

  size() {
    return this.heap.length
  }

  shiftDown(i) {
    const left = this.getLeftIndex(i)
    const right = this.getRightIndex(i)
    if (left < this.heap.length && this.heap[i].frequence > this.heap[left].frequence) {
      this.swap(i, left)
      this.shiftDown(left)
    }
    if (right < this.heap.length && this.heap[i].frequence > this.heap[right].frequence) {
      this.swap(i, right)
      this.shiftDown(right)
    }
  }

  shiftUp(i) {
    if (i === 0) return
    const parentIndex = this.getParentIndex(i)
    if (this.heap[parentIndex].frequence > this.heap[i].frequence) {
      this.swap(parentIndex, i)
      this.shiftUp(parentIndex)
    }
  }

  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2)
  }
  getLeftIndex(i) {
    return 2 * i + 1
  }
  getRightIndex(i) {
    return 2 * i + 2
  }
}
```

or

```js
// 单调数组
// 时间复杂度：O(n*k) => O(n^2)
// 空间复杂度：O(k)
var topKFrequent = function(nums, k) {
  const map = new Map()
  const q = []
  for(let num of nums) {
    map.set(num, map.has(num)? map.get(num) + 1:1)
  }
  for(let [num, count] of map.entries()) {
    let index = q.length - 1
    while(q[index] && q[index].count < count) {
      q[index + 1] = q[index]
      index--
    }
    q[++index] = {num, count}
    if(q.length > k) q.pop()
  }
  return q.map(_ => _.num)
};
```

or 直接对次数排序

```js
// 时间复杂度：O(nlogn) 快排
// 空间复杂度：O(n)
var topKFrequent = function(nums, k) {
  const map = new Map()
  for(let n of nums) {
    map.set(n, map.has(n) ? map.get(n) + 1 : 1)
  }
  const mapArr = Array.from(map)
  mapArr.sort((a, b) => b[1] - a[1])
  return mapArr.slice(0, k).map(_ => _[0]) 
};
```

## 😻✔ 349 两个数组的交集【easy】

[ref](https://leetcode.cn/problems/intersection-of-two-arrays/)

```js
// 时间复杂度：O(M+N)
// 空间复杂度：O(M+N)
var intersection = function(nums1, nums2) {
  const s1 =new Set(nums1)
  const s2 =new Set(nums2)
  const res = []
  for(let v of s1.values()) {
    if(s2.has(v)) {
      res.push(v)
    }
  }
  return res
};
```

## 🌟😻✔ 350. 两个数组的交集 II【easy】

[ref](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

哈希表、map

```js
// 时间复杂度：O(M+N)
// 空间复杂度：O(min(M, N))
var intersect = function(nums1, nums2) {
  if(nums1.length > nums2.length) return intersect(nums2, nums1)
  const m1 = new Map()
  for(let i=0;i<nums1.length;i++) {
    m1.set(nums1[i], m1.has(nums1[i])? m1.get(nums1[i]) + 1:1)
  }
  const res = []
  for(let i=0;i<nums2.length;i++) {
    if(m1.get(nums2[i])) {
      res.push(nums2[i])
      m1.set(nums2[i], m1.get(nums2[i]) - 1)
    }
  }
  return res
};
```

## ??🌟😻✔ 354 俄罗斯套娃信封问题【hard】

[ref](https://leetcode.cn/problems/russian-doll-envelopes/)

二分法、递增子序列

相关
- [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var maxEnvelopes = function(envelopes) {
  envelopes.sort((a, b) => {
    if(a[0] !== b[0]) {
      return a[0] - b[0]
    } else {
      return  b[1] - a[1]
    }
  })
  const len = envelopes.length
  const dp = []
  let count = 0
  dp[count] = envelopes[0]
  for(let i=1;i<len;i++) {
    if(envelopes[i][1] > dp[count][1]) {
      dp[++count] = envelopes[i]
    } else {
      let l = 0, r = count
      while(l < r) {
        const mid = Math.floor((l + r) / 2)
        if(envelopes[i][1] > dp[mid][1]) {
          l = mid + 1
        } else {
          r = mid
        }
      }
      dp[l] = envelopes[i]
    }
  }
  return count + 1
};

```

## ?🌟😻✔ 357. 统计各位数字都不同的数字个数【medium】

[ref](https://leetcode.cn/problems/count-numbers-with-unique-digits/)

排列组合、数学问题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var countNumbersWithUniqueDigits = function(n) {
  let res = 1
  let curr = 1
  for(let i=1;i<=n;i++) {
    res += 9 * curr
    curr *= 10 - i
  }
  return res
};
```

## ✔ 367. 有效的完全平方数【easy】

[ref](https://leetcode.cn/problems/valid-perfect-square/)

数学、规律、平方、二分搜索

```js
// 二分搜索
// 时间复杂度：O(log(num))
// 空间复杂度：O(1)
var isPerfectSquare = function(num) {
  let l = 1, r = num
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    const s = mid * mid
    if(s === num) {
      return true
    } else if(s > num){
      r = mid - 1
    } else {
      l = mid + 1
    }
  }
  return false
};
```

```js
// 时间复杂度：O(sqrt(num))
// 空间复杂度：O(1)
var isPerfectSquare = function(num) {
  for(let i=1;i*i<=num;i++) {
    if(i*i === num) return true
  }
  return false
};
```

## 🌟😻✔ 371. 两整数之和【medium】

[ref](https://leetcode.cn/problems/sum-of-two-integers/)

位运算

```js
// 时间复杂度：O(log(max(a, b)))
// 空间复杂度：O(1)
var getSum = function(a, b) {
  while(b!==0) {
    const d = (a&b) << 1
    a ^= b
    b = d
  }
  return a
};
```

## 😻✔ 374 猜数字大小【easy】

[ref](https://leetcode.cn/problems/guess-number-higher-or-lower/)

二分搜索

```js
var guessNumber = function(n) {
  let l = 0
  let r = n
  while(l <= r) {
    const med = Math.floor((l + r) / 2)
    if(guess(med) === -1) {
      r = med - 1
    } else if(guess(med) === 1) {
      l = med + 1
    } else {
      return med
    }
  }
};
```

## ?🌟😻✔ 376. 摆动序列【medium】

[ref](https://leetcode.cn/problems/wiggle-subsequence/)

贪心

能构成峰谷就不放过

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var wiggleMaxLength = function(nums) {
  if(nums.length < 2) return nums.length
  const n = nums.length
  let i = 1
  while(i < n && nums[i] === nums[0]) {
    i++
  }
  let isLess = nums[i] < nums[0]
  let count = 1
  while(i < n) {
    if(isLess && nums[i] < nums[i-1] || !isLess && nums[i] > nums[i-1]) {
      count++
      isLess = !isLess
    }
    i++
  }
  return count
};
```

## ??🌟😻✔ 377. 组合总和 Ⅳ【medium】

[ref](https://leetcode.cn/problems/combination-sum-iv/)

动态规划、排列组合、背包问题

```js
// 时间复杂度：O(NT)
// 空间复杂度：O(T)
var combinationSum4 = function (nums, target) {
  const n = nums.length, t = target
  const dp = new Array(t + 1).fill(0)
  dp[0] = 1
  for(let i=1;i<=t;i++) {
    for(let j=0;j<n;j++) {
      if(i >= nums[j]) {
        dp[i] += dp[i - nums[j]]
      }
    }
  }
  return dp[t]
};

```

## ?🌟😻✔ 378. 有序矩阵中第 K 小的元素【medium】

[ref](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

分治法、归并排序、优先队列、小顶堆、二分搜索

```js
// 二分搜索
// 时间复杂度：O(Nlog(r-l))
// 空间复杂度：O(1)
var kthSmallest = function(matrix, k) {
  const n = matrix.length
  function countAll(mid) {
    let i = n - 1, j = 0
    let count = 0
    while(i >= 0 && j < n) {
      if(mid >= matrix[i][j]) {
        count += i + 1
        j++
      } else {
        i--
      }
    }
    return count >= k
  }
  let l = matrix[0][0]
  let r = matrix[n - 1][n - 1]
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(countAll(mid)) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return l
};
```

```js
// 归并思路
// 时间复杂度：O(KN)
// 空间复杂度：O(1)
var kthSmallest = function(matrix, k) {
  let t
  while(k > 0) {
    let minIndex = 0
    let minVal = Number.MAX_SAFE_INTEGER
    for(let i=0;i<matrix.length;i++) {
      if(matrix[i].length && matrix[i][0] < minVal) {
        minIndex = i
        minVal = matrix[i][0]
      }
    }
    t = matrix[minIndex].shift()
    k--
  }
  return t
};
```

小顶堆

```js

// 小顶堆、优先队列
// 时间复杂度：O(KlogN + N)
// 空间复杂度：O(N)
var kthSmallest = function(matrix, k) {
  const minHeap = new MinHeap()
  for(let i=0;i<matrix.length;i++) {
    minHeap.insert(matrix[i])
  }
  for(let i=1;i<=k;i++) {
    const t = minHeap.pop()
    const ret = t.shift()
    if(t.length) minHeap.insert(t)
    if(i===k) return ret
  }
};

class MinHeap {
  constructor() {
    this.heap = []
  }
  insert(v){
    this.heap.push(v)
    this.shiftUp(this.heap.length - 1)
  }
  pop(){
    this.swap(0, this.heap.length - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  shiftUp(i){
    const parentIndex = Math.floor((i - 1) / 2)
    if(parentIndex >= 0 && this.heap[i][0] < this.heap[parentIndex][0]) {
      this.swap(i, parentIndex)
      this.shiftUp(parentIndex)
    }
  }
  shiftDown(i){
    const leftIndex= 2 * i + 1
    const rightIndex= 2 * i + 2
    let minIndex = i
    if(leftIndex < this.heap.length && this.heap[minIndex][0] > this.heap[leftIndex][0]) {
      minIndex = leftIndex
    }
    if(rightIndex < this.heap.length && this.heap[minIndex][0] > this.heap[rightIndex][0]) {
      minIndex = rightIndex
    }
    if(minIndex !== i) {
      this.swap(i, minIndex)
      this.shiftDown(minIndex)
    }
  }
  swap(i,j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
}
```

二分搜索

```js

```

## ?🌟😻✔ 380 O(1) 时间插入、删除和获取随机元素【medium】

[ref](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

```js
var RandomizedSet = function() {
  this.map = new Map()
  this.vals = []
};

/** 
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.insert = function(val) {
  if(this.map.has(val)) return false
  this.vals.push(val)
  this.map.set(val, this.vals.length - 1)
  return true
};

/** 
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.remove = function(val) {
  if(!this.map.has(val)) return false
  const ind = this.map.get(val)
  this.vals[ind] = this.vals[this.vals.length - 1]
  this.vals.pop()
  this.map.delete(val)
  this.map.set(this.vals[ind], ind)
  return true
};

/**
 * @return {number}
 */
RandomizedSet.prototype.getRandom = function() {
  const size = this.vals.length
  const randomIndex = Math.floor(Math.random() * size)
  return this.vals[randomIndex]
};
```

## ✔ 383 赎金信【easy】

[ref](https://leetcode.cn/problems/ransom-note/)

```js
// 时间复杂度：O(M+N)
// 空间复杂度：O(N)
var canConstruct = function(ransomNote, magazine) {
  const map = new Map()
  for(let i=0;i<magazine.length;i++) {
    map.set(magazine[i], map.has(magazine[i]) ? map.get(magazine[i]) + 1: 1)
  }

  for(let i=0;i<ransomNote.length;i++) {
    if(!map.has(ransomNote[i]) || map.get(ransomNote[i]) === 0) return false
    map.set(ransomNote[i], map.get(ransomNote[i]) - 1)
  }
  return true
};
```

## ?🌟😻✔ 386 字典序排数【medium】

[ref](https://leetcode.cn/problems/shuffle-an-array/)

洗牌算法

```js
var Solution = function(nums) {
  this.original = nums
  this.nums = [...nums]
};

Solution.prototype.reset = function() {
  this.nums = [...this.original]
  return this.nums
};

Solution.prototype.shuffle = function() {
  const len = this.nums.length
  for(let i=0;i<len;i++) {
    const rand = Math.floor(Math.random() * (len - i)) + i
    swap(this.nums, i, rand)
  }
  return this.nums
};

function swap(nums, i, j) {
  const t = nums[i]
  nums[i] = nums[j]
  nums[j] = t
}

```

## ?🌟😻✔ 386 字典序排数【medium】

[ref](https://leetcode.cn/problems/lexicographical-numbers/)

字典树、字典序

```js
// 时间复杂度：O(N)
// 时间复杂度：O(1)
var lexicalOrder = function(n) {
  let k = 1
  const res = []
  while(res.length < n) {
    res.push(k)
    const small = 10 * k
    if(n >= small) {
      k = small
    } else {
      while(k % 10 === 9 || k + 1 > n) {
        k = Math.floor(k / 10)
      }
      k++
    }
  }

  return res
};
```

## ✔ 387. 字符串中的第一个唯一字符【easy】

[ref](https://leetcode.cn/problems/first-unique-character-in-a-string/)

哈希表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var firstUniqChar = function(s) {
  const m = new Map()
  for(let i=0;i<s.length;i++) {
    m.set(s[i], (m.get(s[i]) || 0) + 1)
  }
  for(let i=0;i<s.length;i++) {
    if(m.get(s[i]) === 1) return i
  }
  return -1
};
```

## ✔ 389. 找不同【easy】

[ref](https://leetcode.cn/problems/find-the-difference/)

字符串、哈希表

```js
// 时间复杂度：O(M+N) M=s.length N=t.length
// 空间复杂度：O(M)
var findTheDifference = function(s, t) {
  const sMap = new Map()
  for(const c of s) sMap.set(c, (sMap.get(c) || 0) + 1)
  for(let i=0;i<t.length;i++) {
    if(!sMap.has(t[i]) || sMap.get(t[i]) === 0) return t[i]
    sMap.set(t[i], sMap.get(t[i]) - 1)
  }
};
```

## 🌟😻✔ 392. 判断子序列【easy】

[ref](https://leetcode.cn/problems/is-subsequence/)

双指针、字符串、子序列问题

```js
var isSubsequence = function(s, t) {
  if(s.length > t.length) return false
  if(s.length === t.length) return s === t
  let i=0, j = 0
  while(i < s.length && j < t.length) {
    if(s[i] === t[j]) {
      i++
    }
    j++
  }
  return i === s.length
};
```

## ?🌟😻✔ 394 字符串解码【medium】

[ref](https://leetcode.cn/problems/decode-string/)

字符串题、递归

```js
var decodeString = function(s) {
  const len = s.length
  let res = ''
  for(let i=0;i<len;i++) {
    if(s[i] >= 'a' && s[i] <= 'z') {
      res+=s[i]
    } else if(s[i] >= '1' && s[i] <= '9') {
      let count = parseInt(s.slice(i), 10)
      i += String(count).length
      const j = searchEnd(s, i)
      const temp = decodeString(s.slice(i + 1, j))
      res+=gen(count, temp)
      i=j
    }
  }
  return res
};

// 生成字符串
function gen(count, temp) {
  let res = ''
  for(let i=0;i<count;i++) {
    res+=temp
  }
  return res
}

// 从 i 开始，搜索 i 的结束括号 j
function searchEnd(s, i) {
  let leftCount = 0
  while(i<s.length) {
    if(s[i] === '[') {
      leftCount++
    } else if(s[i] === ']') {
      leftCount--
    }
    if(leftCount === 0) {
      return i
    }
    i++
  }
}
```

## ??🌟😻✔ 395. 至少有 K 个重复字符的最长子串【medium】

[ref](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)

分治法

```js
// 时间复杂度：O(N*W) W 是字符集
// 空间复杂度：O(W^2)
var longestSubstring = function(s, k) {
  if(!s.length) return 0
  const m = new Map()
  let kindCount = 0
  for(let i=0;i<s.length;i++) {
    m.set(s[i], m.has(s[i])? m.get(s[i]) + 1 : 1)
    if(m.get(s[i]) === 1) kindCount++
    if(m.get(s[i]) === k) kindCount--
  }
  if(!kindCount) return s.length
  let max = 0
  let l = 0
  for(let i=0;i<s.length;i++) {
    if(m.get(s[i]) < k) {
      max = Math.max(longestSubstring(s.slice(l, i), k), max)
      l = i + 1
    }
    if(i === s.length - 1) {
      max = Math.max(longestSubstring(s.slice(l, i + 1), k), max)
    }
  }
  return max
};

```

## ?🌟😻✔ 397. 整数替换【medium】

[ref](https://leetcode.cn/problems/integer-replacement/)

规律、模拟、位运算

```js
var integerReplacement = function(n) {
  if(n === 1) return 0
  if(n % 2 === 0) {
    return 1 + integerReplacement(n / 2)
  } else {
    return 1 + Math.min(integerReplacement(n + 1), integerReplacement(n - 1))
  }
};
```

## ??🌟😻✔ 399. 除法求值【medium】

[ref](https://leetcode.cn/problems/evaluate-division/)

Floyd 算法

```js
var calcEquation = function(equations, values, queries) {
  const gridMap = new Map()

  function gridMapSet(c1, c2, v) {
    if(gridMap.has(c1)) {
      gridMap.get(c1).set(c2, v)
    } else {
      gridMap.set(c1, new Map([[c2, v]]))
    }
  }
  const chars = new Set()
  for(let i=0;i<equations.length;i++) {
    const [c1, c2] = equations[i]
    chars.add(c1)
    chars.add(c2)
    gridMapSet(c1, c1, 1)
    gridMapSet(c2, c2, 1)
    gridMapSet(c1, c2, values[i])
    gridMapSet(c2, c1, 1 / values[i])
  }
  for(let c0 of chars) {
    for(let c1 of chars) {
      for(let c2 of chars) {
        if(c1 === c2 || gridMap.get(c1).has(c2)) continue
        if(gridMap.get(c1).has(c0) && gridMap.get(c0).has(c2)) {
          gridMap.get(c1).set(c2, gridMap.get(c1).get(c0) * gridMap.get(c0).get(c2))
        }
      }
    }
  }
  const res = []
  for(let i=0;i<queries.length;i++) {
    const [c1, c2] = queries[i]
    if(gridMap.has(c1) && gridMap.get(c1).has(c2)) {
      res.push(gridMap.get(c1).get(c2))
    } else {
      res.push(-1)
    }
  }
  return res
};

```

## ?🌟😻✔ 400 第 N 位数字【medium】

[ref](https://leetcode.cn/problems/nth-digit/)

模拟法

```js
// 时间复杂度：O(log10n)
// 空间复杂度：O(1)
var findNthDigit = function(n) {
  let k = 1
  let count = 0
  while(count + 9 * k * 10 ** (k - 1) < n) {
    count += 9 * k * 10 ** (k - 1)
    k++
  }
  n -= count
  const targetNum = 10 ** (k - 1) + Math.floor((n - 1) / k)
  const targetIndex = (n - 1) % k
  return Math.floor(targetNum / 10 ** (k - targetIndex - 1)) % 10
};
```

## ?🌟😻✔ 401. 二进制手表【easy】

[ref]()

回溯法、枚举

题解

- [【云影同学】回溯法，你猜我什么用回溯](https://leetcode.cn/problems/binary-watch/solution/yun-ying-tong-xue-hui-su-fa-by-lxfriday-dcc4/)


```js
var readBinaryWatch = function(turnedOn) {
  let res = []
  function walk(path, k, startIndex) {
    if(k === 0) {
      res.push(`${path[0]}:${String(path[1]).length === 1? '0' + path[1] : path[1]}`)
      return
    }
    for(let i = startIndex;i<=9;i++) {
      let h = 0, m = 0
      if(i <= 3) {
        h = 2 ** i
      } else {
        m = 2 ** (i - 4)
      }
      if(h + path[0] >= 12 || m + path[1] >= 60) continue
      path[0] += h
      path[1] += m
      walk(path, k - 1, i + 1)
      path[0] -= h
      path[1] -= m
    }
  }
  walk([0, 0], turnedOn, 0)
  return res
};
```

枚举

```js
// 枚举
var readBinaryWatch = function(turnedOn) {
const res = []
 for(let h=0;h<12;h++) {
   for(let m=0;m<60;m++) {
     const hCount = h.toString(2).replace(/0/g, '').length
     const mCount = m.toString(2).replace(/0/g, '').length
     if(hCount + mCount === turnedOn) {
       res.push(`${h}:${String(m).length === 1 ? `0` + m : m}`)
     }
   }
 }
 return res
};
```

## ?🌟😻✔ 402 移掉 K 位数字【medium】

[ref](https://leetcode.cn/problems/remove-k-digits/)

```js
var removeKdigits = function(num, k) {
  if(k === num.length) return '0'
  let i=0
  while(k > 0) {
    while(i + 1 < num.length && num[i] <= num[i + 1]) {
      i++
    }
    if(i === num.length - 1) {
      num = num.slice(0, i)
      i = num.length - 1
    } else {
      num = num.slice(0, i) + num.slice(i + 1)
      i = i - 1
      if(i < 0) i = 0
    }

    k--
  }
  while(num.length && num[0] === '0') {
    num = num.slice(1)
  }
  return num === ''? '0' : num
};
```

```js
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var removeKdigits = function(num, k) {
  const stack = []
  let l = 0
  while(l < num.length) {
    while(stack.length - 1 >= 0 && num[l] < stack[stack.length - 1] && k > 0) {
      stack.pop()
      k--
    }
    stack.push(num[l])
    l++
  }
  while(k > 0) {
    stack.pop()
    k--
  }
  while(stack[0] === '0') {
    stack.shift()
  }
  if(!stack.length) return '0'
  return stack.join('')
};
```

```js
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var removeKdigits = function(num, k) {
  let l = 0
  let stack = []
  while(l<num.length) {
    while(stack.length > 0 && k > 0 && stack[stack.length - 1] > num[l]) {
      stack.pop()
      k--
    }
    stack.push(num[l])
    l++
    while(stack[0] === '0') {
      stack.shift()
    }
  }
  // 或者 k=0
  // 或者 k>0&&stack 单调
  if(stack.length - k > 0) {
    stack = stack.slice(0, stack.length - k)
  } else {
    stack = []
  }
  return !stack.length ? '0': stack.join('')
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var removeKdigits = function(num, k) {
  let l = 0
  while(l<num.length && k > 0) {
    if(num[l] > num[l + 1]) {
      num = num.slice(0, l) + num.slice(l + 1)
      l--
      k--
    } else {
      l++
    }
    while(num[0]==='0') {
      num = num.slice(1)
    }
    if(k>=num.length) return '0'
  }
  num = num.slice(0, num.length - k)
  return num === ''? '0': num
};
```

## 🌟😻✔ 404. 左叶子之和【easy】

[ref](https://leetcode.cn/problems/sum-of-left-leaves/)

二叉树

```js
var sumOfLeftLeaves = function(root) {
  let sum = 0
  function dfs(node, isLeft) {
    if(isLeft && !node.left && !node.right) sum += node.val
    node.left && dfs(node.left, true)
    node.right && dfs(node.right, false)
  }
  dfs(root, false)
  return sum
};

```

## 🌟😻✔ 406 根据身高重建队列【medium】

[ref](https://leetcode.cn/problems/queue-reconstruction-by-height/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(logN)
var reconstructQueue = function(people) {
  people.sort((a, b) => {
    if(a[0] !== b[0]) {
      return b[0] - a[0]
    } else {
      return a[1] - b[1]
    }
  })
  let res = []
  for(let i=0;i<people.length;i++) {
    res.splice(people[i][1], 0, people[i])
  }
  return res
};

```

## ??🌟😻✔ 407 接雨水 II【hard】

[ref](https://leetcode.cn/problems/trapping-rain-water-ii/)

优先队列

```js
// 时间复杂度：O(MNlog(M+N))
// 空间复杂度：O(MN)
var trapRainWater = function(heightMap) {
  const m = heightMap.length
  const n = heightMap[0].length
  const used = new Array(m).fill(0).map(_ => new Array(n).fill(false))
  const heap = new MinHeap()
  let res = 0
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(!used[i][j] && (i === 0 || j === 0 || i === m - 1 || j === n - 1)) {
        used[i][j] = true
        heap.insert([heightMap[i][j], i, j])
      }
    }
  }

  const nexts = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  while(heap.size()) {
    const min = heap.pop()
    for(let i=0;i<nexts.length;i++) {
      const ni = min[1] + nexts[i][0]
      const nj = min[2] + nexts[i][1]
      if(ni >= 0 && ni < m && nj >=0 && nj < n && !used[ni][nj]) {
        used[ni][nj] = true
        res += Math.max(min[0] - heightMap[ni][nj], 0) 
        heap.insert([Math.max(heightMap[ni][nj], min[0]), ni, nj])
      }
    }
  }
  return res
};

class MinHeap {
  constructor() {
    this.heap = []
  }
  pop(){
    this.swap(0, this.heap.length - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  insert(t){
    this.heap.push(t)
    this.shiftUp(this.heap.length - 1)
  }
  swap(i, j){
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  shiftUp(i){
    const pi = Math.floor((i - 1) / 2)
    if(pi >= 0 && this.heap[i][0] < this.heap[pi][0]) {
      this.swap(i, pi)
      this.shiftUp(pi)
    }
  }
  shiftDown(i){
    const li = 2 * i + 1
    const ri = 2 * i + 2
    let mini = i
    if(li < this.size() && this.heap[li][0] < this.heap[mini][0]) {
      mini = li
    }
    if(ri < this.size() && this.heap[ri][0] < this.heap[mini][0]) {
      mini = ri
    }
    if(mini !== i) {
      this.swap(i, mini)
      this.shiftDown(mini)
    }
  }
  size(){
    return this.heap.length
  }
}
```

## 🌟😻✔ 409. 最长回文串【easy】

[ref](https://leetcode.cn/problems/longest-palindrome/)

字符串、回文串

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var longestPalindrome = function(s) {
  const m = new Map()
  for(let c of s) m.set(c, (m.get(c) || 0) + 1)
  let res = 0, canAdd = false
  for(const cnt of m.values()) {
    if(cnt % 2 === 0) {
      res += cnt
    } else {
      res += cnt - 1
      canAdd = true
    }
  }
  if(canAdd) res ++
  return res
};
```

## ✔ 412. Fizz Buzz【easy】

[ref](https://leetcode.cn/problems/fizz-buzz/)

```js
var fizzBuzz = function(n) {
  const res = []
  for(let i=1;i<=n;i++) {
    if(i % 3 === 0 && i % 5 === 0) res.push("FizzBuzz")
    else if(i % 3 === 0) res.push("Fizz")
    else if(i % 5 === 0) res.push("Buzz")
    else res.push(String(i))
  }
  return res
};
```

## 🌟😻✔ 414. 第三大的数【easy】

[ref](https://leetcode.cn/problems/third-maximum-number/)

数组题

```js
var thirdMax = function(nums) {
  let max1 = Number.MIN_SAFE_INTEGER, max2 = Number.MIN_SAFE_INTEGER,max3 = Number.MIN_SAFE_INTEGER
  max1 = Math.max(...nums)
  for(const num of nums) {
    if(num > max1) {
      max3 = max2
      max2 = max1
      max1 = num
    } else if(num < max1 && num > max2) {
      max3 = max2
      max2 = num
    } else if(num < max2 && num > max3) {
      max3 = num
    }
  }
  return max3 === Number.MIN_SAFE_INTEGER ? max1 : max3
};
```

```js
var thirdMax = function(nums) {
  let max1 = Number.MIN_SAFE_INTEGER, max2 = Number.MIN_SAFE_INTEGER,max3 = Number.MIN_SAFE_INTEGER
  max1 = Math.max(...nums)
  for(const num of nums) {
    if(num < max1) {
      max2 = Math.max(max2, num)
    }
  }
  for(const num of nums) {
    if(num < max2) {
      max3 = Math.max(max3, num)
    }
  }
  return max3 === Number.MIN_SAFE_INTEGER ? max1 : max3
};
```

## 🌟😻✔ 415 字符串相加【easy】

[ref](https://leetcode.cn/problems/arithmetic-slices/)

动态规划

```js
// 动态规划
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numberOfArithmeticSlices = function(nums) {
  if(nums.length < 3) return 0
  const n = nums.length
  let count = 0
  let prev = 0
  for(let i=2;i<n;i++) {
    if(nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]) {
      prev = 1 + prev
      count += prev
    } else {
      prev = 0
    }
  }
  return count
};

```

```js
// 动态规划
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var numberOfArithmeticSlices = function(nums) {
  if(nums.length < 3) return 0
  const n = nums.length
  const dp = new Array(n).fill(0)
  let count = 0
  for(let i=2;i<n;i++) {
    if(nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]) {
      dp[i] = 1 + dp[i - 1]
      count += dp[i]
    }
  }
  return count
};

```


## 🌟😻✔ 415 字符串相加【easy】

[ref](https://leetcode.cn/problems/add-strings/)

```js
// 双指针法，不需要补充前导 0
// 时间复杂度：O(max(len1,len2))
// 空间复杂度：O(1)
var addStrings = function(num1, num2) {
  let i1 = num1.length - 1
  let i2 = num2.length - 1
  let sum = ''
  let add = 0
  while(i1 >= 0 || i2 >= 0) {
    const tmpSum = (i1 >= 0 ? +num1[i1] : 0) + (i2 >= 0 ? +num2[i2] : 0) + add
    sum = tmpSum % 10 + sum
    add = Math.floor(tmpSum / 10)
    i1--
    i2--
  }
  if(add > 0) {
    sum = 1 + sum
  }
  return sum
};
````

```js
// 常规方法，补充前导 0
// 时间复杂度：O(max(len1,len2))
// 空间复杂度：O(1)
var addStrings = function(num1, num2) {
  if(num1.length > num2.length) {
    num2 = new Array(num1.length - num2.length).fill('0').join('') + num2
  } else if(num1.length < num2.length) {
    num1 = new Array(num2.length - num1.length).fill('0').join('') + num1
  }
  let sum = ''
  let add = 0
  for(let i=num1.length - 1; i>=0; i--) {
    const tmpSum = parseInt(num1[i], 10) + parseInt(num2[i], 10) + add
    sum = (tmpSum % 10) + sum
    add = Math.floor(tmpSum / 10)
  }
  if(add > 0) {
    sum = 1 + sum
  }
  return sum
};
```

## ?🌟😻✔ 416 分割等和子集【medium】

[ref](https://leetcode.cn/problems/partition-equal-subset-sum/)

背包问题、动态规划

```js
// 时间复杂度：O(n*target)
// 空间复杂度：O(n*target)
var canPartition = function(nums) {
  const len = nums.length
  let sum = 0, maxNum = nums[0]
  for(let num of nums) {
    sum+=num
    maxNum = Math.max(maxNum, num)
  }
  if(sum % 2 ===1) {
    return false
  }
  const target = sum / 2
  if(maxNum > target) {
    return false
  }
  const dp = new Array(nums.length).fill(0).map(_ => new Array(target + 1).fill(false))
  for(let i=0;i<len;i++) {
    dp[i][0] = true
  }
  dp[0][nums[0]] = true
  for(let i=1;i<len;i++) {
    for(let j=0;j<=target;j++) {
      if(j >= nums[i]) {
        dp[i][j] = dp[i - 1][j] | dp[i - 1][j - nums[i]]
      } else {
        dp[i][j] = dp[i - 1][j]
      }
    }
  }

  return dp[len-1][target]
};
```


## 🌟😻✔ 417 太平洋大西洋水流问题【medium】

[ref](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

深度优先遍历、DFS、图、逆流而上

```js
var pacificAtlantic = function(heights) {
  const m = heights.length
  const n = heights[0].length
  const leftTopFlow = new Array(m).fill(1).map(() => new Array(n).fill(false))
  const rightBottomFlow = new Array(m).fill(1).map(() => new Array(n).fill(false))
  const res = []

  function dfs(i, j, flow) {
    flow[i][j] = true;
    [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]].forEach(([ni, nj]) => {
      if(
        ni >= 0 && ni < m &&
        nj >= 0 && nj < n &&
        !flow[ni][nj] &&
        heights[ni][nj] >= heights[i][j]
      ) {
        dfs(ni, nj, flow)
      }
    })
  }

  for(let i = 0;i < m; i++) {
    dfs(i, 0, leftTopFlow)
    dfs(i, n - 1, rightBottomFlow)
  }
  for(let j = 0;j < n; j++) {
    dfs(0, j, leftTopFlow)
    dfs(m - 1, j, rightBottomFlow)
  }

  for(let i = 0;i < m; i++) {
    for(let j = 0;j < n; j++) {
      if(leftTopFlow[i][j] && rightBottomFlow[i][j]) res.push([i, j])
    }
  }

  return res
};
```

## ??🌟😻✔ 424 替换后的最长重复字符【medium】

[ref](https://leetcode.cn/problems/longest-repeating-character-replacement/)

双指针、滑动窗口

```js
// 时间复杂度：O(N)
// 空间复杂度：O(∣Σ∣)，其中 ∣Σ∣ 是字符集的大小
var characterReplacement = function(s, k) {
  const nums = new Map()
  let l = r = 0
  let maxn = 0
  while(r < s.length) {
    nums.set(s[r], nums.has(s[r]) ? nums.get(s[r]) + 1 : 1)
    maxn = Math.max(maxn, nums.get(s[r]))
    if(r - l + 1 - maxn > k) {
      nums.set(s[l], nums.get(s[l]) - 1)
      l++
    }
    r++
  }
  return r - l
};

```

## ?🌟😻✔ 428. 序列化和反序列化 N 叉树【hard】

[ref](https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/)

二叉树、序列化、N叉树

题解

- [【云影同学】看起来比较好懂的分隔方法+DFS](https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/solution/by-lxfriday-iatg/)

```js

class Codec {
  // 时间复杂度：O(N)
  // 空间复杂度：O(N)
  serialize = function(root) {
    if(!root) return ''
    let str = ''
    function serializer(node) {
      str += `[${node.val}`
      for(let child of node.children) {
        serializer(child)
      }
      str += ']'
    }
    serializer(root)
    return str
  };

  deserialize = function(data) {
    if(data === '') return null
    let i = 1
    function deserializer() {
      let num = 0
      while(data[i] < 10) num = 10 * num + Number(data[i++])
      const node = new Node(num, [])
      while(data[i] === '[') {
        i++
        node.children.push(deserializer())
      }
      i++
      return node
    }
    const root = deserializer()
    return root
  };
}
```

## 🌟😻✔ 429. N 叉树的层序遍历【medium】

[ref](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

树、N叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var levelOrder = function(root) {
  if(!root) return []
  let q = [root]
  const res = []
  while(q.length) {
    const tq = []
    const levelRes = []
    for(let i=0;i<q.length;i++) {
      const {val, children} = q[i]
      levelRes.push(val)
      if(children) {
        for(let j=0;j<children.length;j++) {
          tq.push(children[j])
        }
      }
    }
    q = tq
    res.push(levelRes)
  }
  return res
};
```

## ?🌟😻✔ 430. 扁平化多级双向链表【medium】

[ref](https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list/)

链表、双向链表、二叉树

```js
// 常规dfs 搜索，看成二叉树来处理
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var flatten = function(head) {
  if(!head) return head
  const myHead = new Node()
  let tHead = myHead
  function dfs(node) {
    const child = node.child, next = node.next
    tHead.next = node
    node.prev = tHead
    tHead = node
    node.child = null
    child && dfs(child)
    next && dfs(next)
  }
  dfs(head)
  myHead.next.prev = null
  return myHead.next
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var flatten = function(head) {
  if(!head) return head
  myFlatten(head)
  return head
};

function myFlatten(head) {
  while(head) {
    const rNext = head.next
    if(head.child) {
      const end = myFlatten(head.child)
      head.next = head.child
      head.child.prev = head
      head.child = null
      end.next = rNext
      rNext && (rNext.prev = end)
      if(!rNext) return end
    }
    if(!rNext) return head
    head = rNext
  }
}
```

## ✔ 434. 字符串中的单词数【easy】

[ref](https://leetcode.cn/problems/number-of-segments-in-a-string/)

字符串

```js
var countSegments = function(s) {
  let cnt = 0
  for(let i=0;i<s.length;i++) {
    if(s[i] !== ' ') {
      if(i === 0 || s[i-1] === ' ') cnt++
    }
  }
  return cnt
};
```

## ?🌟😻✔ 435. 无重叠区间【medium】

[ref](https://leetcode.cn/problems/non-overlapping-intervals/)

贪心

```js
// 贪心，尽量删除对后续更可能有影响的区间
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var eraseOverlapIntervals = function(intervals) {
  intervals.sort((a, b) => a[0] - b[0])
  const n = intervals.length
  let r = intervals[0][1]
  let count = 0
  for(let i=1;i<n;i++) {
    if(intervals[i][0] >= r) {
      r = intervals[i][1]
    } else {
      r = Math.min(r, intervals[i][1])
      count++
    }
  }
  return count
};
```

## ?🌟😻✔ 437. 路径总和 III【medium】

[ref](https://leetcode.cn/problems/path-sum-iii/)

前缀和

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var pathSum = function(root, targetSum) {
  if(!root) return 0
  const map = new Map()
  let count = 0
  function dfs(node, sum) {
    if(!node) return
    sum += node.val
    if(sum === targetSum) count++
    if(map.has(sum - targetSum)) {
      count += map.get(sum - targetSum)
    }
    map.set(sum, map.has(sum) ? map.get(sum) + 1: 1)
    dfs(node.left, sum)
    dfs(node.right, sum)
    map.set(sum, map.get(sum) - 1)
  }
  dfs(root, 0)
  return count
};
```

## 🌟😻✔ 438 找到字符串中所有字母异位词【medium】

[ref](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

滑动窗口、双指针

```js
// 时间复杂度：O(M+N) M=s.length N=p.length
// 空间复杂度：O(N)
var findAnagrams = function(s, p) {
  const pMap = new Map()
  let pCount = 0
  for(let i=0;i<p.length;i++) {
    pMap.set(p[i], pMap.has(p[i])?pMap.get(p[i]) + 1 : 1)
    if(pMap.get(p[i]) === 1) {
      pCount++
    }
  }
  let l = 0, r = 0
  const res = []
  let sCount = 0
  let sMap = new Map()
  while(r<s.length) {
    if(!pMap.has(s[r])) {
      r++
      l=r
      sCount = 0
      sMap = new Map()
    } else if(sMap.get(s[r]) === pMap.get(s[r])){
      while(l <= r&& s[l] !== s[r]) {
        sMap.set(s[l], sMap.get(s[l]) - 1)
        if(sMap.get(s[l]) + 1 === pMap.get(s[l])) sCount--
        l++
      }
      l++
      r++
    } else {
      sMap.set(s[r], sMap.has(s[r])?sMap.get(s[r]) + 1 : 1)
      if(sMap.get(s[r]) === pMap.get(s[r])) {
        sCount++
      }
      r++
    }
    if(sCount === pCount) {
      res.push(l)
    }
  }
  return res
};
```

## ?🌟😻✔ 440 字典序的第K小数字【hard】

[ref](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)

字典序、字典树

```js
// 字典序
// 时间复杂度：O()
// 空间复杂度：O()
var findKthNumber = function(n, k) {
  let s = 1
  k--
  while(k>0) {
    const count = getCount(s, n)
    if(count < k) {
      s++
      k-=count
    } else {
      s*=10
    }
    k--
  }
  return s
};

function getCount(s, n) {
  let min = 10 * s
  let max = 10 * s + 9
  let count = 0
  while(max <= n) {
    count += max - min + 1
    min = 10 * min
    max = 10 * max + 9
  }
  count += Math.max(0, n - min + 1)
  return count
}
```

## 🌟😻✔ 441. 排列硬币【easy】

[ref](https://leetcode.cn/problems/arranging-coins/)

二分搜索

```js
var arrangeCoins = function(n) {
  let l = 1, r = n
  while(l < r) {
    const mid = Math.ceil((l + r) / 2)
    const sum = (1 + mid) * mid / 2
    if(sum <= n) {
      l = mid
    } else {
      r = mid - 1
    }
  }
  return l
};
```

## 🌟😻✔ 442. 数组中重复的数据【medium】

[ref](https://leetcode.cn/problems/find-all-duplicates-in-an-array/)

数组

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findDuplicates = function(nums,k = 2) {
  const n = nums.length
  let l = 0
  const res = []
  const n1 = n + 1
  while(l < nums.length) {
    if(nums[l] < n + 1) {
     while(nums[l] < n + 1) {
       const nextIndex = nums[l] - 1
       if(nums[nextIndex] < n + 1) {
         nums[l] = nums[nextIndex]
         nums[nextIndex] = n1 + 1
       } else {
         nums[l] = n1
         nums[nextIndex] ++
       }
     }
    }
    l++
  }
  for(let i=0;i<nums.length;i++) {
    if(nums[i] - n1 === k) {
      res.push(i + 1)
    }
  }
  return res
};

```

## 🌟😻✔ 443. 压缩字符串【medium】

[ref](https://leetcode.cn/problems/string-compression/)

数组、字符串、数组原地操作

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var compress = function(chars) {
  let i = 0
  let idx = 0
  while(i < chars.length) {
    let j = i + 1
    while(j < chars.length && chars[j] === chars[i]) {
      j++
    }
    let cnt = j - i
    chars[idx++] = chars[i]
    if(cnt > 1) {
      const cntStr = cnt.toString()
      for(const num of cntStr) {
        chars[idx++] = num
      }
      i=j
    } else {
      i++
    }
  }
  return idx
};

```

## ?🌟😻✔ 445 两数相加 II【medium】

[ref](https://leetcode.cn/problems/add-two-numbers-ii/)

链表

```js
// 时间复杂度：O(max(M, N))
// 空间复杂度：O(M + N)
var addTwoNumbers = function(l1, l2) {
  const s1 = [], s2 = []
  while(l1) {
    s1.push(l1.val)
    l1 = l1.next
  }
  while(l2) {
    s2.push(l2.val)
    l2 = l2.next
  }
  let add = 0
  let head = new ListNode()
  while(s1.length || s2.length) {
    const tmpS = (s1.length ? s1.pop() : 0) + (s2.length ? s2.pop() : 0) + add
    const newH = new ListNode(tmpS % 10)
    newH.next = head.next
    head.next = newH
    add = Math.floor(tmpS / 10)
  }
  if(add > 0) {
    const newH = new ListNode(add)
    newH.next = head.next
    head.next = newH
  }
  return head.next
};
```

## ?🌟😻✔ 448 找到所有数组中消失的数字【easy】

[ref](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findDisappearedNumbers = function(nums) {
  const n = nums.length
  for(let i=0;i<n;i++) {
    const num = nums[i] % (n + 1)
    nums[num - 1] += n + 1
  }
  const res = []
  for(let i=0;i<n;i++) {
    if(nums[i] < n + 1) res.push(i + 1)
  }
  return res
};
```

## 🌟😻✔ 449. 序列化和反序列化二叉搜索树【medium】

[ref](https://leetcode.cn/problems/serialize-and-deserialize-bst/)

二叉树、序列化

```js
var serialize = function(root) {
  let str = ''
  function serializer(node) {
    if(!node) {
      str += 'null#'
      return
    }
    str += `${node.val}#`
    serializer(node.left)
    serializer(node.right)
  }
  serializer(root)
  return str
};
var deserialize = function(data) {
  let i = 0
  const dataArr = data.split('#')
  function deserializer() {
    if(dataArr[i] === 'null') {
      i++
      return null
    }
    const node = new TreeNode(+dataArr[i++])
    node.left = deserializer()
    node.right = deserializer()
    return node
  }
  return deserializer()
};
```

## ?🌟😻✔ 450. 删除二叉搜索树中的节点【medium】

[ref](https://leetcode.cn/problems/delete-node-in-a-bst/)

二叉搜索树

```js
/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var deleteNode = function(root, key) {
  if(!root) return null
  if(root.val === key) {
    let node = root.right
    if(!node) return root.left 
    if(!node.left) {
      node.left = root.left
      return node
    }
    let prev
    while(node.left) {
      prev = node
      node = node.left
    }
    prev.left = node.right
    node.left = root.left
    node.right = root.right
    return node
  } else if(root.val < key) {
    root.right = deleteNode(root.right, key)
  } else {
    root.left = deleteNode(root.left, key)
  }
  return root
};
```

## ?🌟😻✔ 451. 根据字符出现频率排序【medium】

[ref](https://leetcode.cn/problems/sort-characters-by-frequency/)

桶排序、桶排序衍生算法

```js
// 桶排序
// 时间复杂度：O(N+K) N=s.length K=不同字符的个数
// 空间复杂度：O(N+K)
var frequencySort = function(s) {
  const countMap = new Map()
  const bucketMap = new Map()
  let max = 0
  for(let c of s) {
    countMap.set(c, (countMap.get(c) || 0) + 1)
    max = Math.max(countMap.get(c), max)
  }

  for(let [c, count] of countMap.entries()) {
    if(bucketMap.has(count)) {
      bucketMap.get(count).push(c)
    } else {
      bucketMap.set(count, [c])
    }
  }

  const res = []
  for(let i=max;i>0;i--) {
    if(bucketMap.has(i)) {
      for(let c of bucketMap.get(i)) {
        for(let j=0;j<i;j++) res.push(c)
      }
    }
  }
  return res.join('')
};
```

```js
// 常规解法
// 时间复杂度：O(N+KlogK) N=s.length K=sorted.length
// 空间复杂度：O(N+K)
var frequencySort = function(s) {
  const m = new Map()
  for(let c of s) {
    m.set(c, (m.get(c) || 0) + 1)
  }
  const sorted = [...m].sort((a, b) => b[1] - a[1])
  const res = []
  for(let [c, count] of sorted) {
    for(let i=0;i<count;i++) {
      res.push(c)
    }
  }
  return res.join('')
};
```

## ?🌟😻✔ 452. 用最少数量的箭引爆气球【medium】

[ref](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

贪心

```js
// 时间复杂度：O(NlogN)
// 时间复杂度：O(logN)
var findMinArrowShots = function(points) {
  points.sort((a, b) => a[0] - b[0] || a[1] - b[1])
  const n = points.length
  let i = 1
  let count = 1
  let max = points[0][1]
  while(i < n) {
    if(points[i][0] <= max) {
      max = Math.min(points[i][1], max)
    } else {
      count++
      max = points[i][1]
    }
    i++
  }
  return count
};
```

## ?🌟😻✔ 453. 最小操作次数使数组元素相等【medium】

[ref](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var minMoves = function(nums) {
  const n = nums.length
  let sum = 0
  let min = Number.MAX_SAFE_INTEGER
  for(let num of nums) {
    sum += num
    min = Math.min(min, num) 
  }
  return sum - n * min
};

// 1 2 3 4
// 2 3 4 4
// 3 4 5 4
// 4 5 6 4
// 5 6 6 5
// 6 7 6 6
// 7 7 7 7

// 1 3 5 6
// 2 4 6 6
// 3 5 7 6
// 4 6 8 6
// 5 7 9 6
// 6 8 10 6
// 7 9 10 7
// 8 10 10 8
// 9 11 10 9
// 10 12 10 10
// 11 12 11 11
// 12 12 12 12



```

## ?🌟😻✔ 454 四数相加 II【medium】

[ref](https://leetcode.cn/problems/4sum-ii/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var fourSumCount = function(nums1, nums2, nums3, nums4) {
  let c = 0
  const m = new Map()
  for(let i=0;i<nums1.length;i++) {
    for(let j=0;j<nums2.length;j++) {
      const s = nums1[i] + nums2[j]
      m.set(s, m.has(s)?m.get(s)+1: 1)
    }
  }

  for(let i=0;i<nums3.length;i++) {
    for(let j=0;j<nums4.length;j++) {
      const s = nums3[i] + nums4[j]
      if(m.has(-s)) {
        c += m.get(-s)
      }
    }
  }

  return c
};
```

## 😻✔ 455 分发饼干【easy】

[ref](https://leetcode.cn/problems/assign-cookies/)

贪心算法

```js
// 时间复杂度：O(nlogn) 排序时间复杂度
// 时间复杂度：O(logn) 排序空间复杂度
var findContentChildren = function(g, s) {
  g.sort((a, b) => a - b)
  s.sort((a, b) => a - b)

  let i = 0
  s.forEach((n) => {
    if(n >= g[i]) {
      i++
    }
  })
  return i
};
```

## ???🌟😻✔ 459. 重复的子字符串【easy】

[ref](https://leetcode.cn/problems/repeated-substring-pattern/)

字符串、模拟

```js
var repeatedSubstringPattern = function(s) {
  const str = s + s
  return str.slice(1, str.length -1).includes(s)
};
```

```js
// 暴力，O(N^2)
var repeatedSubstringPattern = function(s) {
  const n = s.length
  if(n < 2) return false
  for(let i=0;i<n / 2;i++) {
    if(canRepeat(s.slice(0, i + 1), s)) return true
  }
  return false
};

function canRepeat(str, s) {
  const strLen = str.length
  let i = 0, j = 0
  while(j < s.length) {
    if(str[i] === s[j]) {
      i = (i + 1) % strLen
      j++
    } else return false
  }
  return i === 0
}
```

## ???🌟😻✔ 460. LFU 缓存【hard】

[ref](https://leetcode.cn/problems/lfu-cache/)

设计

```js
var LFUCache = function(capacity) {
  this.capacity = capacity
  this.kvs = new Map()
  this.min = -1
  // key-times
  this.timesMap = new Map()
  // time-keys(set)
  this.timeKeysMap = new Map()
};
LFUCache.prototype.get = function(key) {
  if(this.kvs.has(key)) {
    const ret = this.kvs.get(key)
    this.updateTimes(key, ret)
    return ret
  }
  return -1
};

LFUCache.prototype.updateTimes = function(key, value) {
  const times = this.timesMap.get(key)
  this.timesMap.set(key, times + 1)
  this.timeKeysMap.get(times).delete(key)
  if(this.timeKeysMap.get(times).size === 0 && times === 1) {
    this.min = 2
  }
  const set = this.timeKeysMap.get(times + 1) || new Set()
  set.add(key)
  this.timeKeysMap.set(times + 1, set)
};

LFUCache.prototype.delete = function() {
  const keysSet = this.timeKeysMap.get(this.min)
  const key = keysSet.keys().next().value
  this.kvs.delete(key)
  this.timesMap.delete(key)
  keysSet.delete(key)
};

LFUCache.prototype.put = function(key, value) {
  if(this.capacity === 0) return
  if(this.kvs.has(key)) {
    this.kvs.set(key, value)
    this.updateTimes(key, value)
  } else {
    if(this.kvs.size === this.capacity) {
      this.delete()
    }
    this.kvs.set(key, value)
    this.min = 1
    this.timesMap.set(key, 1)
    const set = this.timeKeysMap.get(1) || new Set()
    set.add(key)
    this.timeKeysMap.set(1, set)
  }
};
```

## ?🌟😻✔ 461 汉明距离【easy】

[ref](https://leetcode.cn/problems/hamming-distance/)

模拟、推断、规律

```js
var convertInteger = function(x, y) {
  let num = ((x ^ y) >>> 0).toString(2), cnt = 0
  for(let i=0;i<32;i++) {
    if(num[i] === '1') cnt++
  }
  return cnt
};
```

```js
var hammingDistance = function(x, y) {
  let res = 0
  while(x !== y) {
    if(x % 2 !== y % 2) res ++
    x = Math.floor(x / 2)
    y = Math.floor(y / 2)
  }
  return res
};

// 1   (0 0 0 1)
// 2   (0 0 1 0)
// 3   (0 0 1 1)
// 4   (0 1 0 0)
// 5   (0 1 0 1)
// 6   (0 1 1 0)

```

## ✔ 463. 岛屿的周长【easy】

[ref](https://leetcode.cn/problems/island-perimeter/)

矩阵

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(1)
var islandPerimeter = function(grid) {
  const m = grid.length, n = grid[0].length
  let c = 0
  function calc(i, j) {
    if(i === 0) c++
    if(j === 0) c++
    if(i === m - 1) c++
    if(j === n - 1) c++
    if(i - 1 >= 0 && grid[i-1][j] === 0) c++
    if(i + 1 < m && grid[i + 1][j] === 0) c++
    if(j - 1 >= 0 && grid[i][j - 1] === 0) c++
    if(j + 1 < n && grid[i][j + 1] === 0) c++
  }
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 1) calc(i, j)
    }
  }
  return c
};
```

## ?🌟😻✔ 468. 验证IP地址【medium】

[ref](https://leetcode.cn/problems/validate-ip-address/)

字符串题

```js
var validIPAddress = function(queryIP) {
  let v4 = false, v6 = false
  for(const c of queryIP) {
    if(c === '.') v4 = true
    else if(c === ':') v6 = true
  }
  if((v4 && v6) || (!v4 && !v6)) return 'Neither'
  if(v4) return validateIPv4(queryIP) ? 'IPv4' : 'Neither'
  return validateIPv6(queryIP) ? 'IPv6' : 'Neither'
};

function validateIPv4(queryIP) {
  const ipSplit = queryIP.split('.')
  if(ipSplit.length !== 4) return false
  for(let str of ipSplit) {
    if(
      str.length < 1 ||
      str.length > 1 && str[0] === '0'
    ) return false
    let num = 0
    for(let i=0;i<str.length;i++) {
      if(str[i] !== ' ' && str[i] >= '0' && str[i] <= '9') num = 10* num + Number(str[i])
      else return false
    }
    if(num > 255) return false
  }
  return true
}

const v6PartSet = new Set('0123456789abcdefABCDEF'.split(''))

function validateIPv6(queryIP) {
  const ipSplit = queryIP.split(':')
  if(ipSplit.length !== 8) return false
  for(let str of ipSplit) {
    if(str.length < 1 || str.length > 4) return false
    for(const c of str) {
      if(!v6PartSet.has(c)) return false
    }
  }
  return true
}
```

## ??🌟😻✔ 470. 用 Rand7() 实现 Rand10()【medium】

[ref](https://leetcode.cn/problems/implement-rand10-using-rand7/)

```js
var rand10 = function() {
  let res 
  while(true) {
    res = 7 * (rand7() - 1) + rand7()
    if(res <= 40) break
  }
  return res % 10 + 1
};
```

```js
var rand10 = function() {
  let a = rand7(), b = rand7()
  while(a === 7) {
    a = rand7()
  }
  while(b > 5) {
    b = rand7()
  }
  return (a & 1 ? 0 : 5) + b
};
```

## ??🌟😻✔ 474. 一和零【medium】

[ref](https://leetcode.cn/problems/ones-and-zeroes/)

动态规划、背包问题

```js
// 时间复杂度：O(MN) K=strs.length W=平均 str[i].length
// 空间复杂度：O(MN)
var findMaxForm = function(strs, m, n) {
  const dp = new Array(m + 1).fill(0).map(_ => new Array(n + 1).fill(0))
  for(let str of strs) {
    let c0 = 0, c1 = 0
    for(let c of str) {
      if(c === '0') c0++
      else c1++
    }
    for(let i=m;i>=c0;i--) {
      for(let j=n;j>=c1;j--) {
        dp[i][j] = Math.max(dp[i][j], 1 + dp[i - c0][j - c1])
      }
    }
  }
  return dp[m][n]
};
```

## ?🌟😻✔ 475 供暖器【medium】

[ref](https://leetcode.cn/problems/heaters/)

二分搜索

```js
// M = houses.length N = heaters.length
// 时间复杂度：O((M+N)*logN)
// 空间复杂度：O(logN)
var findRadius = function(houses, heaters) {
  heaters.sort((a, b) => a - b)
  let min = 0
  for(const house of houses) {
    const i = binarySearch(heaters, house)
    const j = i + 1
    const lDistance = i < 0 ? Number.MAX_SAFE_INTEGER :house - heaters[i]
    const rDistance = j >= heaters.length ? Number.MAX_SAFE_INTEGER :heaters[j] - house
    const curMin = Math.min(lDistance, rDistance)
    min = Math.max(min, curMin)
  }
  return min
};

function binarySearch(heaters, target) {
  if(target<heaters[0]) {
    return -1
  }
  let l = 0
  let r = heaters.length - 1
  while(l < r) {
    const mid = Math.floor((l + r + 1) / 2) 
    if(heaters[mid] > target) {
      r = mid - 1
    } else {
      l = mid
    }
  }
  return l
}
```

## 🌟😻✔ 476. 数字的补数【easy】

[ref](https://leetcode.cn/problems/number-complement/)

二进制、位运算

```js
var findComplement = function(num) {
  let ret = 0, i = 0
  while(num > 0) {
    ret |= (1 - (num & 1)) << i
    num >>= 1
    i++
  }
  return ret
};
```

## ✔ 485. 最大连续 1 的个数【easy】

[ref](https://leetcode.cn/problems/max-consecutive-ones/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findMaxConsecutiveOnes = function(nums) {
  let i = 0
  let max = 0
  while(i<nums.length) {
    let count = 0
    while(i<nums.length && nums[i] === 1) {
      count++
      i++
    }
    max = Math.max(max, count)
    i++
  }
  return max
};
```

## ?🌟😻✔ 487. 最大连续1的个数 II【medium】

[ref](https://leetcode.cn/problems/max-consecutive-ones-ii/)

双指针、滑动窗口

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findMaxConsecutiveOnes = function(nums) {
  let l = 0, r = 0
  let max = 0
  let k = 1
  while(r < nums.length) {
    if(nums[r] === 1) {
      max = Math.max(max, r - l + 1)
    } else {
      if(k === 1) {
        k--
        max = Math.max(max, r - l + 1)
      } else {
        while(l <= r && nums[l] !==0) l++
        l++
      }
    }
    r++
  }
  return max
};
```

## ?🌟😻✔ 491. 递增子序列【medium】

[ref](https://leetcode.cn/problems/increasing-subsequences/)

排列组合、数组题

```js
var findSubsequences = function(nums) {
  const n = nums.length
  const res = []
  function find(startIndex, path) {
    if(path.length >= 2) {
      res.push([...path])
    }
    const s = new Set()
    for(let i = startIndex; i < n; i++) {
      if(s.has(nums[i])) continue
      s.add(nums[i])
      if(!path.length || path[path.length - 1] <= nums[i]) {
        path.push(nums[i])
        find(i + 1, path)
        path.pop()
      }
    }
  }
  find(0, [])
  return res
};


```

## ?🌟😻✔ 493. 翻转对【hard】

[ref](https://leetcode.cn/problems/reverse-pairs/)

数组题，归并排序

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var reversePairs = function(nums) {
  let count = 0
  function mergeSort(l, r) {
    l = typeof l === 'number' ? l : 0
    r = typeof r === 'number' ? r : nums.length - 1
    if(l === r) return [nums[l]]
    const mid = Math.floor((l + r) / 2)
    return merge(mergeSort(l, mid), mergeSort(mid + 1, r))
  }
  function merge(arr1, arr2) {
    const r = new Array(arr1.length + arr2.length)
    let ind = 0
    let l1 = 0, l2 = 0
    // 这里时间复杂度是 O(M+N) M=arr1.length N=arr2.length
    while(l1<arr1.length) {
      while(l2 < arr2.length && arr1[l1] > 2* arr2[l2]) {
        l2++
      }
      count += l2
      l1++
    }
    l1=0, l2=0
    while(l1 < arr1.length && l2 < arr2.length) {
      if(arr1[l1] < arr2[l2]) {
        r[ind++] = arr1[l1++]
      } else {
        r[ind++] = arr2[l2++]
      }
    }
    while(l1 < arr1.length) {
      r[ind++] = arr1[l1++]
    }
    while(l2 < arr2.length) {
      r[ind++] = arr2[l2++]
    }
    return r
  }
  mergeSort()
  return count
};

```

## ?? 🌟😻✔ 494 目标和【medium】

[ref](https://leetcode.cn/problems/target-sum/)

动态规划、回溯、背包问题、01背包

```js
var findTargetSumWays = function(nums, target) {
  let sum = 0
  for(const num of nums) sum += num
  const neg = (sum - target) / 2
  if(neg !== Math.floor(neg) || neg < 0) return 0
  const dp = new Array(neg + 1).fill(0)
  dp[0] = 1
  for(const num of nums) {
    for(let j=neg;j>=num;j--) {
      dp[j] += dp[j-num]
    }
  }
  return dp[neg]
};

```

```js
// 时间复杂度：O(2**N)
// 空间复杂度：O(N)
var findTargetSumWays = function(nums, target) {
  let count = 0
  function search(i, sum) {
    if(i === nums.length) {
      if(sum === target) count++
      return
    }
    search(i + 1, sum + nums[i])
    search(i + 1, sum - nums[i])
  }
  search(0, 0)
  return count
};
```

## 🌟😻✔ 495. 提莫攻击【easy】

[ref](https://leetcode.cn/problems/teemo-attacking/)

数组、区间问题

```js
var findPoisonedDuration = function(timeSeries, duration) {
  let max = -1, res = 0
  for(const time of timeSeries) {
    if(time > max) {
      res += duration
    } else {
      res += Math.max(time + duration - 1 - max, 0)
    }
    max = Math.max(time + duration - 1, max)
  }
  return res
};
```

## ✔ 496. 下一个更大元素 I【easy】

[ref](https://leetcode.cn/problems/next-greater-element-i/)

```js
var nextGreaterElement = function(nums1, nums2) {
  const res = []
  for(let i=0;i<nums1.length;i++) {
    for(let j=nums2.indexOf(nums1[i]);j<nums2.length;j++) {
      if(nums2[j] > nums1[i]) {
        res.push(nums2[j])
        break
      }
    }
    if(res.length <= i) {
      res.push(-1)
    }
  }
  return res
};
```

## ?🌟😻✔ 498. 对角线遍历【medium】

[ref](https://leetcode.cn/problems/diagonal-traverse/)

规律

题解
- [【云影同学】递归或者迭代（双解），思路清晰，操作稳健](https://leetcode.cn/problems/diagonal-traverse/solution/by-lxfriday-85vq/)

```js
// 普通迭代
// 时间复杂度：O(MN)
// 空间复杂度：O(1)
var findDiagonalOrder = function(mat) {
  const m = mat.length, n = mat[0].length
  const res = []
  let i = 0, j = 0
  let isToRight = true
  while(true) {
    res.push(mat[i][j])
    if(res.length === m * n) return res
    if(isToRight) {
      if(j + 1 >= n) {
        i++
        isToRight = false
      } else if(i - 1 < 0) {
        j++
        isToRight = false
      } else {
        i--
        j++
      }
    } else {
      if(i + 1 >= m) {
        j++
        isToRight = true
      } else if(j - 1 < 0) {
        i++
        isToRight = true
      } else {
        i++
        j--
      }
    }
  }
};

```

```js
// 递归查找
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var findDiagonalOrder = function(mat) {
  const m = mat.length, n = mat[0].length
  const res = []
  function findRight(i, j) {
    res.push(mat[i][j])
    if(res.length === m * n) return
    const nextI = i - 1
    const nextJ = j + 1
    if(nextJ >= n) {
      findLeft(i + 1, j)
    } else if(nextI < 0) {
      findLeft(i, j + 1)
    } else {
      findRight(nextI, nextJ)
    }
  }

  function findLeft(i, j) {
    res.push(mat[i][j])
    if(res.length === m * n) return
    const nextI = i + 1
    const nextJ = j - 1
    if(nextI >= m) {
      findRight(i, j + 1)
    } else if(nextJ < 0) {
      findRight(i + 1, j)
    } else {
      findLeft(nextI, nextJ)
    }
  }

  findRight(0, 0)
  return res
};

```

## ?🌟😻✔ 503. 下一个更大元素 II【medium】

[ref](https://leetcode.cn/problems/next-greater-element-ii/)

单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var nextGreaterElements = function(nums) {
  const n = nums.length
  const res = new Array(n).fill(-1)
  const stack = []
  for(let j=0;j<2 * n - 1;j++) {
    const i = j % n
    while(stack.length && nums[stack[stack.length - 1]] < nums[i]) {
      res[stack.pop()] = nums[i]
    }
    stack.push(i)
  }
  return res
};
```

## 🌟😻✔ 513. 找树左下角的值【medium】

[ref](https://leetcode.cn/problems/find-bottom-left-tree-value/comments/)

层序遍历、广度优先搜索

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var findBottomLeftValue = function(root) {
  let q = [root]
  let prev
  while(q.length) {
    const len = q.length
    for(let i=0;i<len;i++) {
      const node = q.shift()
      prev = node
      if(node.right) q.push(node.right)
      if(node.left) q.push(node.left)
    }
  }
  return prev.val
};
```

## 🌟😻✔ 515. 在每个树行中找最大值【medium】

[ref](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

深度优先搜索、广度优先搜索

```js
 // 时间复杂度：O(N)
 // 空间复杂度：O(N)
var largestValues = function(root) {
  if(!root) return []
  const res = []
  function dfs(node, ind) {
    if(res[ind] === undefined) {
      res[ind] = node.val
    } else {
      res[ind] = Math.max(node.val, res[ind])
    }
    node.left && dfs(node.left, ind + 1)
    node.right && dfs(node.right, ind + 1)
  }
  dfs(root, 0)
  return res
};
```

```js
// BFS
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var largestValues = function(root) {
  if(!root) return []
  let q = [root]
  const res = []
  while(q.length) {
    const tq = []
    let max = Number.MIN_SAFE_INTEGER
    for(let i=0;i<q.length;i++) {
      max = Math.max(max, q[i].val)
      q[i].left && tq.push(q[i].left)
      q[i].right && tq.push(q[i].right)
    }
    q = tq
    res.push(max)
  }
  return res
};
```

## ?🌟😻✔ 516 最长回文子序列【medium】

[ref](https://leetcode.cn/problems/longest-palindromic-subsequence/)

```js
// 时间复杂度：O(N*2)
// 空间复杂度：O(N*2)
var longestPalindromeSubseq = function(s) {
  const len = s.length
  const dp = new Array(len).fill(0).map(_ => new Array(len).fill(0))
  for(let i=0;i<len;i++) {
    dp[i][i] = 1
  }
  for(let L = 2;L <= len;L++) {
    for(let i=0;i + L - 1<len;i++) {
      if(s[i] === s[i + L - 1]) {
        dp[i][i + L - 1] = (i + L - 2 >= i + 1 ? dp[i + 1][i + L - 2] : 0) + 2
      } else {
        dp[i][i + L - 1] = Math.max(dp[i][i + L - 2], dp[i + 1][i + L - 1])
      }
    }
  }
  return dp[0][len-1]
};
```

## ??🌟😻✔ 518. 零钱兑换 II【medium】

[ref](https://leetcode.cn/problems/coin-change-2/)

背包问题、动态规划

```js
// 时间复杂度：O(N*M)
// 空间复杂度：O(M)
var change = function(amount, coins) {
  const dp = new Array(amount + 1).fill(0)
  dp[0] = 1
  for(let j=0;j<coins.length;j++) {
    for(let i=1;i<=amount;i++) {
      if(i >= coins[j]) {
        dp[i] += dp[i - coins[j]]
      }
    }
  }
  return dp[amount]
};
```

## ✔ 520. 检测大写字母【easy】

[ref](https://leetcode.cn/problems/detect-capital/)

字符串

```js
var detectCapitalUse = function(word) {
  let cnt = 0
  for(const c of word) {
    if(c === c.toUpperCase()) cnt++
  }
  if(cnt === word.length || cnt === 0) return true
  return cnt === 1 && word[0] === word[0].toUpperCase()
};
```

## ?? 🌟😻✔ 523. 连续的子数组和【medium】

[ref](https://leetcode.cn/problems/continuous-subarray-sum/)

前缀和、同余定理

```js
// 同余：当前缀和 pfx[i] - pfx[j] 是 k 的倍数的时候，pfx[i] 和 pfx[j] 的余数必定相同
// 只需要存储扫描到的前缀和，判断当前前缀和对 k 的余数在 哈希表中是否存在就可以得出结果
// 哈希表初始化的时候带上 [0, -1] 是为了处理从下标0开始到某个下标刚好前缀和为 k 的情况
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var checkSubarraySum = function(nums, k) {
  if(nums.length < 2) return false
  let sum = 0
  const m  = new Map([[0, -1]])
  for(let i=0;i<nums.length;i++) {
    sum = (nums[i] + sum) % k
    if(m.has(sum)) {
      const prevIndex = m.get(sum)
      if(i - prevIndex >= 2) {
        return true
      }
    } else {
      m.set(sum, i)
    }
  }
  return false
};
```

## 🌟😻✔ 524. 通过删除字母匹配到字典里最长单词【medium】

[ref](https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/)

双指针、字符串

```js
// 时间复杂度：O(d*(M+N)) d=dictionary.length M=s.length N=平均 dictionary[i].length
// 空间复杂度：O(1)
var findLongestWord = function(s, dictionary) {
  const n = dictionary.length
  let res = ''
  for(let i=0;i<n;i++) {
    const word = dictionary[i]
    if(word.length > s.length) continue
    let lword = 0, ls = 0
    while(lword < word.length && ls < s.length) {
      if(s[ls] === word[lword]) {
        lword++
      }
      ls++
    }
    if(lword === word.length) {
      if(
        !res.length
        || word.length > res.length
        || (word.length ===  res.length && word < res)
      ) {
        res = word
      }
    } 
  }
  return res
};
```

## ?🌟😻✔ 526. 优美的排列【medium】

[ref](https://leetcode.cn/problems/beautiful-arrangement/)

回溯法

```js
var countArrangement = function(n) {
  const arr = new Array(n + 1).fill(0).map(_ => [])
  for(let i=1;i<=n;i++) {
    for(let j=1;j<=n;j++) {
      if(i % j === 0 || j % i === 0) {
        arr[i].push(j)
      }
    }
  }
  let cnt = 0
  const used = new Set()
  function walk(ind) {
    if(ind === n + 1) {
      cnt++
      return
    }
    const next = arr[ind]
    for(let j = 0; j < next.length; j++) {
      if(used.has(next[j])) continue
      used.add(next[j])
      walk(ind + 1)
      used.delete(next[j]) 
    }
  }
  walk(1)
  return cnt
};

// 1 2
// 2 1

// 1 2 3
// 3 2 1
// 2 1 3
```

## ?🌟😻✔ 532. 数组中的 k-diff 数对【medium】

[ref](https://leetcode.cn/problems/k-diff-pairs-in-an-array/)

哈希表

```js
var findPairs = function(nums, k) {
  const numsMap = new Map()
  let cnt = 0
  for(let num of nums) numsMap.set(num, (numsMap.get(num) || 0) + 1)
  for(const num of nums) {
    if(numsMap.get(num) <= 0) continue 
    if(k !== 0) {
      if(numsMap.get(k + num) > 0) cnt++
      if(numsMap.get(num - k) > 0) cnt++
    } else {
      if(numsMap.get(num) > 1) cnt++
    }
    numsMap.set(num, 0)
  }
  return cnt
};
```

## ?🌟😻✔ 536. 从字符串生成二叉树【medium】

[ref](https://leetcode.cn/problems/construct-binary-tree-from-string/)

二叉树

```js
var str2tree = function(s) {
  if(s === '') return null
  let i = 0
  function dfs() {
    const sign = s[i] === '-' ? -1 : 1
    if(sign < 0) i++
    let num = 0
    while(s[i] < 10) num = num * 10 + Number(s[i++])
    const node = new TreeNode(sign * num)
    if(s[i] === '(') {
      i++
      node.left = dfs()
    }
    if(s[i] === '(') {
      i++
      node.right = dfs()
    }
    i++
    return node
  }

  return dfs(s)
};
```

## ??🌟😻✔ 538 把二叉搜索树转换为累加树【medium】

[ref](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var convertBST = function(root) {
  convert(root, 0)
  return root
};

function convert(node, bigger) {
  if(!node) return 0
  const v = node.val
  const rightSum = convert(node.right, bigger)
  node.val = bigger + v + rightSum
  const leftSum = convert(node.left, node.val)
  return leftSum + v + rightSum
}
```

## 🌟😻✔ 540 有序数组中的单一元素【medium】

[ref](https://leetcode.cn/problems/single-element-in-a-sorted-array/)

二分搜索

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var singleNonDuplicate = function(nums) {
  const len = nums.length
  let l = 0,r=nums.length - 1
  while(l<r) {
    const mid = Math.floor((l + r) / 2)
    if(mid % 2 === 0) {
      if(mid + 1 < len && nums[mid] === nums[mid + 1]) {
        l = mid + 2
      } else {
        r = mid
      }
    } else {
      if(mid - 1 >= 0 && nums[mid] === nums[mid - 1]) {
        l = mid + 1
      } else {
        r = mid - 1
      }
    }
  }
  return nums[r]
};

```

## 🌟😻✔ 541. 反转字符串 II【easy】

[ref](https://leetcode.cn/problems/reverse-string-ii/)

字符串、模拟

```js
var reverseStr = function(s, k) {
  const n = s.length, arr = s.split('')
  let l = 0
  while(l < n) {
    reverse(arr, l, Math.min(l + k - 1, n - 1))
    l += 2 * k
  }
  return arr.join('')
};
function reverse(arr, l, r) {
  while(l < r) {
    const t = arr[l]
    arr[l] = arr[r]
    arr[r] = t
    l++
    r--
  }
}
```

## ? 🌟😻✔ 542. 01 矩阵【medium】

[ref](https://leetcode.cn/problems/01-matrix/)

广度优先搜索、多起点问题

题解

-[【云影同学】BFS 多源广度优先](https://leetcode.cn/problems/01-matrix/solution/by-lxfriday-syx9/)

```js
// 广度优先搜索，多起点问题（0）
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var updateMatrix = function(mat) {
  const m = mat.length, n = mat[0].length
  const res = new Array(m).fill(false).map(_ => new Array(n).fill(0))
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  let q = []
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(mat[i][j] === 0) {
        q.push([i, j, 0])
        used[i][j] = true
      }
    }
  }
  const sides = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  while(q.length) {
    const len = q.length
    const tq = []
    for(let i=0;i<len;i++) {
      const [targetI, targetJ, level] = q[i]
      for(let j=0;j<4;j++) {
        const ii = targetI + sides[j][0]
        const jj = targetJ + sides[j][1]
        if(ii >= 0 && ii < m && jj >= 0 && jj < n && !used[ii][jj]) {
          used[ii][jj] = true
          res[ii][jj] = level + 1
          tq.push([ii, jj, level + 1])
        }
      }
    }
    q = tq
  }
  return res
};


```

## 🌟😻✔ 543 二叉树的直径【easy】

[ref](https://leetcode.cn/problems/diameter-of-binary-tree/)

二叉树

一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

二叉树的任何一条路径都会以某个节点作为根，而最长路径则是 Max(左子树深度 + 右子树深度) 。

```js
// 时间复杂度：O(n) n 是二叉树的节点数
// 空间复杂度：O(H) H 是二叉树的高度
var diameterOfBinaryTree = function(root) {
  let maxRes = 0

  function depth(node) {
    if(!node) return 0
    let lDepth = depth(node.left)
    let rDepth = depth(node.right)
    maxRes = Math.max(maxRes, lDepth + rDepth)
    return Math.max(lDepth, rDepth) + 1
  }
  depth(root)
  return maxRes
};
```

## ?🌟😻✔ 547. 省份数量【medium】

[ref](https://leetcode.cn/problems/number-of-provinces/)

深度优先搜索、广度优先搜索、DFS、BFS

```js
// 深度优先搜索
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
function findCircleNum(isConnected) {
  const visited = new Set(), n = isConnected.length
  let count = 0
  for(let j=0;j<n;j++) {
    if(!visited.has(j)) {
      count++
      visited.add(j)
      dfs(j)
    }
  }
  function dfs(j) {
    for(let i=0;i<n;i++) {
      if(i !== j &&  isConnected[i][j] === 1) {
        if(!visited.has(i)) {
          visited.add(i)
          dfs(i)
        }
      }
    }
  }
  return count
};
````

```js
var findCircleNum = function(isConnected) {
  const n = isConnected.length
  const parent = new Array(n).fill(0).map((v, i) => [])
  for(let i=0;i<n;i++) {
    for(let j=0;j<n;j++) {
      if(i !== j && isConnected[i][j] === 1) {
        parent[i].push(j)
      }
    }
  }
  const used = new Set()
  let count = 0
  for(let i=0;i<n;i++) {
    if(used.has(i)) continue
    used.add(i)
    count++
    let q = [i]
    while(q.length) {
      const len = q.length
      const tq = []
      for(let j=0;j<len;j++) {
        const curr = q[j]
        for(let k=0;k<parent[curr].length;k++) {
          const next = parent[curr][k]
          if(!used.has(next)) {
            tq.push(next)
            used.add(next)
          }
        }
      }
      q = tq
    }
  }
  return count
};


```

```typescript
// 广度优先搜索
function findCircleNum(isConnected: number[][]): number {
  const cityMap = new Map()
  const n = isConnected.length
  for(let i=0;i<n;i++) {
    for(let j=0;j<n;j++) {
      if(isConnected[i][j] === 1 && i !== j) {
        if(cityMap.has(i)) {
          cityMap.get(i).push(j)
        } else {
          cityMap.set(i, [j])
        }
      }
    }
  }
  const used = new Array(n).fill(false)
  let count = 0
  for(let i=0;i<n;i++) {
    if(used[i]) continue
    used[i] = true
    count++
    if(!cityMap.has(i)) {
      continue
    }
    let q = [i]
    while(q.length) {
      const target = q.shift()
      if(cityMap.has(target)) {
        const relas = cityMap.get(target)
        for(let city of relas) {
          if(!used[city]) {
            q.push(city)
            used[city] = true
          }
        }
      }
    }
  }
  return count
};
```


## ?🌟😻✔ 557 反转字符串中的单词 III【easy】

[ref](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)

双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var reverseWords = function(s) {
  const n = s.length
  let l = 0, r = 0
  let res = ''

  while(r < n) {
    if(s[r] === ' ') {
      res += ' '
      r++
      l=r
    } else if(r + 1 < n && s[r + 1] === ' ') {
      res += reverse(s.slice(l, r + 1))
      r++
      l = r
    } else {
      r++
    }
  }
  if(l !== r) {
    res += reverse(s.slice(l, r))
  }

  return res
};

function reverse(s) {
  let res = ''
  let r = s.length - 1
  while(r >= 0) {
    res += s[r]
    r--
  }
  return res
}
```

## ?🌟😻✔ 560 和为 K 的子数组【medium】

[ref](https://leetcode.cn/problems/subarray-sum-equals-k/)

巧妙设计一个统计 `0~i` 位置总和数量的 map。

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var subarraySum = function(nums, k) {
  const len = nums.length
  let sum = 0
  const map = new Map()
  let count = 0
  for(let i = 0; i < len; i++) {
    sum += nums[i]
    if(sum === k) count++
    if(map.has(sum - k)) {
      count += map.get(sum - k)
    }
    map.set(sum, map.has(sum)? map.get(sum) + 1: 1)
  }
  return count
};
```

## 😻✔ 566. 重塑矩阵【easy】

[ref](https://leetcode.cn/problems/reshape-the-matrix/)

矩阵

```js
var matrixReshape = function(mat, r, c) {
  const m = mat.length, n = mat[0].length
  if(m * n !== r * c) return mat
  const res = new Array(r).fill(0).map(_ => new Array(c))
  for(let i=0;i<m*n;i++) {
    res[Math.floor(i / c)][i % c] = mat[Math.floor(i / n)][i % n]
  }
  return res
};

```

## 😻✔ 567 字符串的排列【medium】

[ref](https://leetcode.cn/problems/permutation-in-string/)

滑动窗口

```js
// m = s1.length, n = s2.length
// 时间复杂度：O(m + n)
// 时间复杂度：O(m)
var checkInclusion = function(s1, s2) {
  if(s2.length < s1.length) return false
  const len = s1.length
  const map = new Map()
  let typeCount = 0
  for(let i=0;i<len;i++) {
    if(map.has(s1[i])) {
      map.set(s1[i], map.get(s1[i]) + 1)
    } else {
      map.set(s1[i], 1)
      typeCount ++
    }
  }
  for(let i=0;i<len;i++) {
    if(map.has(s2[i])) {
      map.set(s2[i], map.get(s2[i]) - 1)
      if(map.get(s2[i]) === 0) {
        typeCount--
      }
    }
  }
  if(typeCount === 0) return true
  for(let i=len;i<s2.length;i++) {
    if(map.has(s2[i])) {
      map.set(s2[i], map.get(s2[i]) - 1)
      if(map.get(s2[i]) === 0) {
        typeCount--
      }
    }
    if(map.has(s2[i - len])) {
      map.set(s2[i - len], map.get(s2[i - len]) + 1)
      if(map.get(s2[i - len]) === 1) {
        typeCount++
      }
    }
    if(typeCount === 0) return true
  }
  return false
};
```

## ?🌟😻✔ 572. 另一棵树的子树【easy】

[ref](https://leetcode.cn/problems/subtree-of-another-tree/)

二叉树

```js
var isSubtree = function(root, subRoot) {
  if(!root) return false
  return is(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)
};
function is(node1, node2) {
  if(!node1 && !node2) return true
  if(!node1 || !node2) return false
  return node1.val === node2.val && is(node1.left, node2.left) && is(node1.right, node2.right)
}
```

## ✔ 575 分糖果【easy】

[ref](https://leetcode.cn/problems/distribute-candies/)

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var distributeCandies = function(candyType) {
  const set = new Set(candyType)
  return Math.min(candyType.length / 2, set.size)
};
```

## ?🌟😻✔ 581 最短无序连续子数组【medium】

[ref](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)

直接排序，双指针找到左右两侧首个不同的数字

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var findUnsortedSubarray = function(nums) {
  const numsSorted = [...nums].sort((a, b) => a - b)
  let l = 0, r = nums.length - 1
  while(l < nums.length || r >= 0) {
    if(nums[l] === numsSorted[l]) {
      l++
    }
    if(nums[r] === numsSorted[r]) {
      r--
    }
    if(nums[l] !== numsSorted[l] && nums[r] !== numsSorted[r]) return r - l + 1
  }
  return 0
};
```

确定无序子数组的上下边界

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findUnsortedSubarray = function(nums) {
  const n = nums.length
  let max = -Infinity, maxi = -1 
  let min = Infinity, mini = -1
  for(let i=0;i<n;i++) {
    if(nums[i] >= max) {
      max = nums[i]
    } else {
      maxi = i
    }

    const j = n - 1 - i
    if(nums[j] <= min) {
      min = nums[j]
    } else {
      mini = j
    }
  }
  return maxi !== -1 ? maxi - mini + 1 : 0
};
```

上面的解法比较难想到，下面的更容易理解

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var findUnsortedSubarray = function(nums) {
  const lArr = []
  for(let i=0;i<nums.length;i++) {
    while(lArr.length && nums[lArr[lArr.length - 1]] > nums[i]) {
      lArr.pop()
    }
    lArr.push(i)
  }
  const rArr = []
  for(let i=nums.length - 1;i>=0;i--) {
    while(rArr.length && nums[rArr[0]] < nums[i]) {
      rArr.shift()
    }
    rArr.unshift(i)
  }
  let l, r
  let has = false
  for(let i=0;i<nums.length;i++) {
    const t = lArr.shift()
    if(i !== t) {
      l = i
      has = true
      break
    }
  }
  for(let i=nums.length - 1;i>=0;i--) {
    const t = rArr.pop()
    if(i !== t) {
      r = i
      has = true
      break
    }
  }
  return has ? r - l + 1 : 0
};
```

## ? 🌟😻✔ 583. 两个字符串的删除操作【easy】

[ref](https://leetcode.cn/problems/delete-operation-for-two-strings/)

动态规划

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var minDistance = function(word1, word2) {
  const m = word1.length, n = word2.length
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  dp[0][0] = word1[0] === word2[0] ? 1 : 0
  for(let i=1;i<m;i++) {
    dp[i][0] = word1[i] === word2[0] ? 1 : dp[i - 1][0]
  }
  for(let j=1;j<n;j++) {
    dp[0][j] = word1[0] === word2[j] ? 1 : dp[0][j - 1]
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      if(word1[i] === word2[j]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
      }
    }
  }
  return m + n - 2 * dp[m - 1][n - 1]
};

// len1 + len2 = 2*maxCommon + deleted
```

## 🌟😻✔ 589. N 叉树的前序遍历【easy】

[ref](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

N叉树

```js
// 时间复杂度：O(M) M=N叉树节点个数
// 空间复杂度：O(M)
var preorder = function(root) {
  if(!root) return []
  const res = []
  const stack = [root]
  while(stack.length) {
    const node = stack.pop()
    const {val, children} = node
    res.push(val)
    for(let i=children.length - 1;i>=0;i--) {
      stack.push(children[i])
    }
  }
  return res
};
```

## ??🌟😻✔ 593. 有效的正方形【medium】

[ref](https://leetcode.cn/problems/valid-square/)

哈希表、模拟

存储所有点之间的距离，没有为0的距离而且只有两种距离，斜线和边线

```js
var validSquare = function(p1, p2, p3, p4) {
  const set = new Set()
  set.add((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)
  set.add((p2[0] - p3[0]) ** 2 + (p2[1] - p3[1]) ** 2)
  set.add((p3[0] - p4[0]) ** 2 + (p3[1] - p4[1]) ** 2)
  set.add((p1[0] - p3[0]) ** 2 + (p1[1] - p3[1]) ** 2)
  set.add((p1[0] - p4[0]) ** 2 + (p1[1] - p4[1]) ** 2)
  set.add((p2[0] - p4[0]) ** 2 + (p2[1] - p4[1]) ** 2)
  if(set.has(0)) return false
  if(set.size !== 2) return false
  const min = Math.min(...set), max = Math.max(...set)
  return max === 2 * min
};
```

## 🌟😻✔ 605. 种花问题【easy】

[ref](https://leetcode.cn/problems/can-place-flowers/)

数组题

```js
var canPlaceFlowers = function(flowerbed, n) {
  const len = flowerbed.length
  let cnt = 0
  for(let i=0;i<len;i++) {
    if(flowerbed[i] === 0) {
      if((i - 1 < 0 || flowerbed[i-1] === 0) && (i + 1 >= len || flowerbed[i+1] === 0)) {
        cnt++
        flowerbed[i] = 1
        i++
      }
    }
  }
  return cnt >= n
};
```

## 🌟😻✔ 606. 根据二叉树创建字符串【easy】

[ref](https://leetcode.cn/problems/construct-string-from-binary-tree/)

二叉树、二叉树序列化

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var tree2str = function(root) {
  if(!root) {
    return ''
  }
  let left = tree2str(root.left)
  let right = tree2str(root.right)
  let res = `${root.val}`
  if(left === '' && right !== '') {
    res += `()(${right})`
  } else if(left !== '' && right === '' ) {
    res += `(${left})`
  } else if(left !== '' && right !== '') {
    res += `(${left})(${right})`
  }
  return res
};
```

## ??🌟😻✔ 611. 有效三角形的个数【medium】

[ref](https://leetcode.cn/problems/valid-triangle-number/)

二分搜索、排序、双指针

```js
var triangleNumber = function(nums) {
  const n = nums.length
  nums.sort((a, b) => a - b)
  let cnt = 0
  for(let i=0; i < n - 2;i++) {
    let k = i + 1
    for(let j = i + 1;j<n-1;j++) {
      while(k + 1 < n && nums[k + 1] < nums[i] + nums[j]) {
        k++
      }
      cnt += Math.max(k-j, 0)
    }
  }
  return cnt
};
```

```js
var triangleNumber = function(nums) {
  nums.sort((a, b) => a - b)
  const n = nums.length
  let cnt = 0
  for(let i=0;i<n-2;i++) {
    const a = nums[i]
    for(let j=i + 1;j<n-1;j++) {
      const b = nums[j]
      let targetMax = a + b - 1
      if(targetMax < nums[j + 1]) continue
      const r = binarySearch(nums, j + 1, n - 1, targetMax)
      cnt += r - j
    }
  }
  return cnt
};

function binarySearch(nums, l, r, target) {
  while(l < r) {
    const mid = Math.ceil((l + r) / 2)
    if(nums[mid] <= target) {
      l = mid
    } else {
      r = mid - 1
    }
  }
  return l
}
// a, b, x
// a + b > x
// a + x > b => x > b - a
// b + x > a => x > a - b
```


## 🌟😻✔ 617 合并二叉树【easy】

[ref](https://leetcode.cn/problems/merge-two-binary-trees/)

```js
// 时间复杂度：O(min(M, N))
// 空间复杂度：O(min(M, N))
var mergeTrees = function(root1, root2) {
  function merge(node1, node2) {
    if(!node1) return node2
    if(!node2) return node1
    let sum = node1.val + node2.val
    const node = new TreeNode(sum)
    node.left = merge(node1.left, node2.left)
    node.right = merge(node1.right, node2.right)
    return node
  }
  return merge(root1, root2)
};
```

## ??🌟😻✔ 621 任务调度器【medium】

[ref](https://leetcode.cn/problems/task-scheduler/)

模拟

```js
// 模拟题，不要扯什么算法，就是直接模拟硬推
// 时间复杂度：O(N+K) K 是大写字母的种类
// 空间复杂度：O(K)
var leastInterval = function(tasks, n) {
  const taskCount = new Array(26).fill(0)
  for(let i=0;i<tasks.length;i++) {
    taskCount[tasks[i].charCodeAt(0) - 'A'.charCodeAt(0)]++
  }
  taskCount.sort((a, b) => b - a)
  let bucketCount = 1
  let i = 1
  while(i < taskCount.length && taskCount[0] === taskCount[i]) {
    bucketCount++
    i++
  }
  return Math.max(bucketCount + (n + 1) * (taskCount[0] - 1), tasks.length)
};

```

## ?🌟😻✔ 622. 设计循环队列【medium】

[ref](https://leetcode.cn/problems/design-circular-queue/)

队列、循环队列

```js
var MyCircularQueue = function(k) {
  this.capacity = k
  this.q = new Array(k)
  this.i = 0
  this.j = -1
  this.count = 0
};

/** 
 * @param {number} value
 * @return {boolean}
 */
MyCircularQueue.prototype.enQueue = function(value) {
  if(this.isFull()) return false
  this.j = (this.j + 1) % this.capacity
  this.q[this.j] = value
  this.count++
  return true
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.deQueue = function() {
  if(this.isEmpty()) return false
  this.i = (this.i + 1) % this.capacity
  this.count--
  return true
};

/**
 * @return {number}
 */
MyCircularQueue.prototype.Front = function() {
  if(this.isEmpty()) return -1
  return this.q[this.i]
};

/**
 * @return {number}
 */
MyCircularQueue.prototype.Rear = function() {
  if(this.isEmpty()) return -1
  return this.q[this.j]
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.isEmpty = function() {
  return this.count === 0
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.isFull = function() {
  return this.count === this.capacity
};

```

## ??🌟😻✔ 630 课程表 III【hard】

[ref](https://leetcode.cn/problems/course-schedule-iii/)

贪心、优先队列、堆

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var scheduleCourse = function(courses) {
  courses.sort((a, b) => a[1] - b[1])
  let sum = 0
  const heap = new MaxHeap()
  for(let i=0;i<courses.length;i++) {
    const target = courses[i]
    sum += target[0]
    heap.insert(target[0])
    if(sum > target[1]) {
      sum -= heap.pop()
    }
  }
  return heap.size()
};

class MaxHeap {
  constructor() {
    this.heap = []
  }
  size() {
    return this.heap.length
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  insert(v) {
    this.heap.push(v)
    this.shiftUp(this.heap.length - 1)
  }
  pop() {
    this.swap(0, this.heap.length - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  shiftUp(i) {
    const pi = Math.floor((i - 1) / 2)
    if(this.heap[i] > this.heap[pi]) {
      this.swap(i, pi)
      this.shiftUp(pi)
    }
  }
  shiftDown(i) {
    const li = 2 * i + 1
    const ri = 2 * i + 2
    let maxi = i
    if(this.heap[li] > this.heap[maxi]) {
      maxi = li
    }
    if(this.heap[ri] > this.heap[maxi]) {
      maxi = ri
    }
    if(maxi !== i) {
      this.swap(maxi, i)
      this.shiftDown(maxi)
    }
  }
}

```

## ?🌟😻✔ 633. 平方数之和【medium】

[ref](https://leetcode.cn/problems/sum-of-square-numbers/)

二分搜索、数学规律

```js
// 时间复杂度：O(sqrt(c))
// 空间复杂度：O(1)
var judgeSquareSum = function(c) {
  for(let i=0;i * i <= c;i++) {
    if(Math.floor(Math.sqrt(c - i * i)) ** 2 + i **2 === c) return true
  }
  return false
};
```

```js
// 时间复杂度：O(sqrt(c))
// 空间复杂度：O(1)
var judgeSquareSum = function(c) {
  let a = 0
  let b = Math.floor(Math.sqrt(c))
  while(a <= b) {
    if(a*a+b*b<c) {
      a++
    } else if(a*a+b*b > c) {
      b--
    } else {
      return true
    }
  }
  return false
};
```

```js
// 二分，效率低
var judgeSquareSum = function(c) {
  for(let i=0;i * i <= c;i++) {
    const target = c - i * i
    let l = 0, r = target
    while(l <= r) {
      const mid = Math.floor((l + r) / 2)
      const s = mid * mid
      if(s === target) {
        return true
      } else if(s > target) {
        r = mid - 1
      } else {
        l = mid + 1
      }
    }
  }
  return false
};
```

## ??🌟😻✔ 639. 解码方法 II【hard】

[ref](https://leetcode.cn/problems/decode-ways-ii/)

枚举、模拟

```js
// 动态规划
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var numDecodings = function(s) {
  // '0*'  '0'
  if(s[0] === '0') return 0
  const mod = 10**9 + 7
  const n = s.length
  const dp = new Array(n).fill(0)
  if(s[0] === '*') {
    dp[0] = 9
  } else {
    dp[0] = 1
  }
  for(let i = 1; i < n; i++) {
    // 当前位是 0 的时候检测字符串是否合法
    if(s[i] === '0' && s[i-1] !== '1' && s[i-1] !== '2' && s[i-1] !== '*') return 0
    if(s[i] === '*') {
      // * 不表示组合位的时候
      dp[i] = dp[i-1] * 9 % mod
      // * 和前面数字组合
      if(s[i-1] === '*') {
        dp[i] = (dp[i] + (i - 2 >= 0 ? dp[i - 2] : 1) * 15) % mod
      } else {
        if(s[i-1] === '1') {
          dp[i] = (dp[i] + (i-2>=0? dp[i - 2]:1) * 9) % mod
        } else if(s[i-1] === '2') {
          dp[i] = (dp[i] + (i-2>=0? dp[i - 2]:1) * 6) % mod
        }
      }
    } else {
      // 当前位不和前面数字组合的时候
      if(s[i] >= '1') {
        dp[i] = dp[i-1]
      }
      // 和前面的数字组合的情况
      if(s[i-1] === '*') {
        if(s[i] >= '0' && s[i] <= '6') {
          dp[i] = (dp[i] + (i-2 >= 0 ? dp[i-2] : 1) * 2) % mod
        } else {
          dp[i] = (dp[i] + (i-2 >= 0 ? dp[i-2] : 1) * 1) % mod
        }
      } else {
        // s[i] s[i-1] 都不是 *，两位数字组合起来在 [1,0] 内的时候
        if(s[i - 1] !== '0' && (s[i - 1] * 10 + s[i] * 1 <= 26)) {
          dp[i] = (dp[i] + (i-2 >= 0 ? dp[i-2] : 1) * 1) % mod
        }
      }
    }
  }
  return dp[n - 1]
};
```

## 🌟😻✔ 640. 求解方程【medium】

[ref](https://leetcode.cn/problems/solve-the-equation/)

模拟

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var solveEquation = function(equation) {
  const equationSplit = equation.split('=')
  const [lxCal, lnumCal] = exact(equationSplit[0])
  const [rxCal, rnumCal] = exact(equationSplit[1])
  if(lxCal === rxCal) {
    if(lnumCal === rnumCal) return 'Infinite solutions'
    // 无解情况
    if(lnumCal !== rnumCal) return 'No solution'
  }
  return 'x=' + (lnumCal - rnumCal) / (rxCal - lxCal)
};
function exact(str) {
  let i = 0
  // x 系数和
  let xCal = 0
  // 整数和
  let numCal = 0
  while(i < str.length) {
    if(str[i] === 'x') {
      if(i>0 && str[i-1] === '-') {
        xCal--
      } else {
        xCal++
      }
      i++
    } else if(str[i] >= 0 && str[i] <= 9) {
      let j=i+1
      while(j < str.length && str[j] >= 0 && str[j] <= 9) j++
      let num = +str.slice(i, j)
      if(i > 0 && str[i - 1] === '-') num = -num
      if(str[j] === 'x') {
        xCal += num
        i=j + 1
      } else {
        numCal += num
        i=j
      }
    } else {
      i++
    }
  }
  return [xCal, numCal]
}
```

## 🌟😻✔ 641. 设计循环双端队列【medium】

[ref](https://leetcode.cn/problems/design-circular-deque/)

队列、循环队列、双端队列、循环双端队列

```js
var MyCircularDeque = function(k) {
  this.capacity = k
  this.count = 0
  this.i = 0
  this.j = k-1
  this.q = []
};
MyCircularDeque.prototype.insertFront = function(value) {
  if(this.isFull()) return false
  this.i = (this.i - 1 + this.capacity) % this.capacity
  this.q[this.i] = value
  this.count++
  return true
};
MyCircularDeque.prototype.insertLast = function(value) {
  if(this.isFull()) return false
  this.j = (this.j + 1) % this.capacity
  this.q[this.j] = value
  this.count++
  return true
};
MyCircularDeque.prototype.deleteFront = function() {
  if(this.isEmpty()) return false
  this.i = (this.i + 1) % this.capacity
  this.count--
  return true
};
MyCircularDeque.prototype.deleteLast = function() {
  if(this.isEmpty()) return false
  this.j = (this.j - 1 + this.capacity) % this.capacity
  this.count--
  return true
};
MyCircularDeque.prototype.getFront = function() {
  if(this.isEmpty()) return -1
  return this.q[this.i]
};
MyCircularDeque.prototype.getRear = function() {
  if(this.isEmpty()) return -1
  return this.q[this.j]
};
MyCircularDeque.prototype.isEmpty = function() {
  return this.count === 0
};
MyCircularDeque.prototype.isFull = function() {
  return this.count === this.capacity
};

````

## 🌟😻✔ 646. 最长数对链【medium】

[ref](https://leetcode.cn/problems/maximum-length-of-pair-chain/)

贪心、区间问题

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var findLongestChain = function(pairs) {
  const sortedPairs = pairs.sort((a, b) => a[1] - b[1] || a[0] - b[0])
  let res = 1
  let maxR = sortedPairs[0][1]
  for(let i=1;i<sortedPairs.length;i++) {
    const [l, r] = sortedPairs[i]
    if(l > maxR) {
      res++
      maxR = r
    }
  }
  return res
};

```

## 🌟😻✔ 647 回文子串【medium】

[ref](https://leetcode.cn/problems/palindromic-substrings/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var countSubstrings = function(s) {
  const len = s.length
  const dp = new Array(len).fill(false).map(_ => new Array(len).fill(false))
  let count = 0
  for(let i=0;i<len;i++) {
    dp[i][i] = true
    count++
  }

  for(let L=2;L<=len;L++) {
    for(let i=0;i + L - 1<len;i++) {
      if(s[i] === s[i + L - 1]) {
        dp[i][i + L - 1] = i + L - 2 >= i + 1 ? dp[i + 1][i + L - 2] : true
        if(dp[i][i + L - 1]) count++
      }
    }
  }

  return count
};
```

## ?🌟😻✔ 648. 单词替换【medium】

[ref](https://leetcode.cn/problems/replace-words/)

字典树

```js
var replaceWords = function(dictionary, sentence) {
  const tree = buildTree(dictionary)
  const words = sentence.split(' ')
  for(let i=0;i<words.length;i++) {
    words[i] = replace(tree, words[i])
  }
  return words.join(' ')
};

function replace(node, word) {
  let wordEndInd = -1
  for(let i=0;i<word.length;i++) {
    if(node[word[i]]) {
      node = node[word[i]]
      if(node.isEnd) {
        wordEndInd = i
        break
      }
    } else {
      break
    }
  }
  if(wordEndInd >= 0) return word.slice(0, wordEndInd + 1)
  return word
}

function buildTree(dict) {
  const tree = {}
  for(let i=0;i<dict.length;i++) {
    const root = dict[i]
    addRoot(tree, root)
  }
  return tree
}

function addRoot(node, root) {
  for(let i=0;i<root.length;i++) {
    if(!node[root[i]]) {
      node[root[i]] = {
        isEnd: false
      }
    }
    node = node[root[i]]
    if(i === root.length - 1) {
      node.isEnd = true
    }
  }
}

```

## ?🌟😻✔ 650. 只有两个键的键盘【medium】

[ref](https://leetcode.cn/problems/2-keys-keyboard/)

动态规划、数学规律

```js
var minSteps = function(n) {
  let res = 0
  for(let i=2;i * i<=n;i++) {
    while(n % i === 0) {
      res += i
      n /= i
    }
  }
  if(n !== 1) res += n
  return res
};

```

```js
// 时间复杂度：O(N*sqrt(N))
// 空间复杂度：O(N)
var minSteps = function(n) {
  const dp = new Array(n + 1).fill(Number.MAX_SAFE_INTEGER)
  dp[1] = 0
  for(let i=2;i<=n;i++) {
    for(let j=1;j*j<=i;j++) {
      if(i % j === 0) {
        dp[i] = Math.min(dp[i], dp[j] + (i / j))
        dp[i] = Math.min(dp[i], dp[i / j] + j)
      }
    }
  }
  return dp[n]
};

//1 A
//2 AA 2
//3 AAA 3
//4 AAAA 4
//5 AAAAA 5
//6 AAAAAA 5
//7 AAAAAAA 7
//8 AAAAAAAA 6
//9 AAAAAAAAA 6
//10 AAAAAAAAA 7
//11 AAAAAAAAA 11
//12 AAAAAAAAA 7
//30 AAAAAAAAA 11


```

## 🌟😻✔ 652 寻找重复的子树【medium】

[ref](https://leetcode.cn/problems/find-duplicate-subtrees/)

二叉树、序列化

```js
var findDuplicateSubtrees = function(root) {
  const m = new Map()
  const res = []
  function dfs(node) {
    if(!node) return 'null'
    const left = dfs(node.left)
    const right = dfs(node.right)
    const str = `[${left}(${node.val})${right}]`
    if(m.get(str) === 1) {
      res.push(node)
    }
    m.set(str, (m.get(str) || 0) + 1)
    return str
  }
  dfs(root)
  return res
};
```

## 🌟😻✔ 654. 最大二叉树【medium】

[ref](https://leetcode.cn/problems/maximum-binary-tree/)

二叉树、二叉树构建

```js
// 时间复杂度：O(N^2)
// 时间复杂度：O(N)
var constructMaximumBinaryTree = function(nums) {
  function create(l, r) {
    if(l > r) return null
    let maxi = l
    for(let i=l + 1;i <= r;i++) {
      if(nums[i] > nums[maxi]) maxi = i
    }
    const node = new TreeNode(nums[maxi])

    node.left = create(l, maxi - 1)
    node.right = create(maxi + 1, r)

    return node
  }
  return create(0, nums.length - 1)
};
```

## 🌟😻✔ 655. 输出二叉树【medium】

[ref](https://leetcode.cn/problems/print-binary-tree/)

二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var printTree = function(root) {
  let height = 0, m, n
  function dfs(node, h) {
    if(!node.left && !node.right) {
      height = Math.max(h, height)
    }
    node.left && dfs(node.left, h + 1)
    node.right && dfs(node.right, h + 1)
  }
  dfs(root, 0)
  m = height + 1
  n = 2 ** (height + 1) - 1
  const res = new Array(m).fill('').map(_ => new Array(n).fill(''))

  function create(node, i, j) {
    if(node.left) {
      const leftI = i + 1
      const leftJ = j - 2 ** (height - i - 1)
      res[leftI][leftJ] = String(node.left.val)
      create(node.left, leftI, leftJ)
    }
    if(node.right) {
      const rightI = i + 1
      const rightJ = j + 2 ** (height - i - 1)
      res[rightI][rightJ] = String(node.right.val)
      create(node.right, rightI, rightJ)
    }
  }
  const jMid = Math.floor(n / 2)
  res[0][jMid] = String(root.val)

  create(root, 0, jMid)
  return res
};
```

## 🌟😻✔ 658. 找到 K 个最接近的元素【medium】

[ref](https://leetcode.cn/problems/find-k-closest-elements/)

二分搜索、数组题

```js
// 时间复杂度：O(logN+K)
// 空间复杂度：O(1)
var findClosestElements = function(arr, k, x) {
  const n = arr.length
  let l = 0, r = n - 1
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(arr[mid] >= x) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  const res = []
  l = r - 1
  while(true) {
    if(res.length === k) return res
    if(l < 0) {
      res.push(arr[r++])
    } else if(r >= n) {
      res.unshift(arr[l--])
    } else if(Math.abs(arr[l] - x) <= Math.abs(arr[r] - x)) {
      res.unshift(arr[l--])
    } else {
      res.push(arr[r++])
    }
  }
};

```

```js
// 常规搜索最近距离
// 时间复杂度：O(N+K)
// 空间复杂度：O(1)
var findClosestElements = function(arr, k, x) {
  let minInd = 0
  for(let i=0;i<arr.length;i++) {
    if(Math.abs(arr[i] - x) < Math.abs(arr[minInd] - x)) {
      minInd = i
    }
  }
  const res = [arr[minInd]]
  let l = minInd - 1, r = minInd + 1
  while(true) {
    if(res.length === k) return res
    if(l < 0) {
      res.push(arr[r++])
    } else if(r >= arr.length) {
      res.unshift(arr[l--])
    } else if(Math.abs(arr[l] - x) <= Math.abs(arr[r] - x)) {
      res.unshift(arr[l--])
    } else {
      res.push(arr[r++])
    }
  }
};

```

## ?🌟😻✔ 662. 二叉树最大宽度【medium】

[ref](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

二叉树、广度优先搜索

题解

- [【云影同学】常规BFS+位置标记+位置偏移](https://leetcode.cn/problems/maximum-width-of-binary-tree/solution/by-lxfriday-6h0f/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var widthOfBinaryTree = function(root) {
  let q = [[root, 1]]
  let max = 1
  while(q.length) {
    const tq = []
    max = Math.max(max, q[q.length - 1][1]-q[0][1]+1)
    // 偏移量
    const dis = q[0][1] - 1
    for(let i=0;i<q.length;i++) {
      const [node, k] = q[i]
      node.left && tq.push([node.left, 2 * (k-dis) - 1])
      node.right && tq.push([node.right, 2 * (k-dis)])
    }
    q = tq
  }
  return max
};
```

## ?🌟😻✔ 665. 非递减数列【medium】

[ref](https://leetcode.cn/problems/non-decreasing-array/)

贪心

```js
// 贪心，尽可能让不符合情况的 nums[i] 比较小
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var checkPossibility = function(nums) {
  const n = nums.length
  let errCnt = 0
  for(let i = 1; i < n; i++) {
    if(nums[i] < nums[i - 1]) {
      if(errCnt === 1) return false
      errCnt++
      // nums[0] 出现比较大的数，直接把 nums[0] 变小
      if(i - 2 < 0) nums[i - 1] = nums[i]
      else if(nums[i - 2] <= nums[i]) {
        // i-2(不变)  i-1(变小)  i(不变)
        nums[i - 1] = nums[i - 2]
      } else {
        // i前面的没法改，只能改i
        nums[i] = nums[i - 1]
      }
    }
  }
  return true
};

```

## ?🌟😻✔ 667. 优美的排列 II【medium】

[ref](https://leetcode.cn/problems/beautiful-arrangement-ii/)

模拟、规律题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var constructArray = function(n, k) {
  const res = new Array(n)
  let ind = 0
  for(let i = 1; i < n-k; i++) res[ind++] = i
  let a = n - k, b = n
  while(ind < n) {
    res[ind++] = a++
    if(ind < n) {
      res[ind++] = b--
    }
  }
  return res
};

// [1,2,⋯,n−k,n,n−k+1,n−1,n−k+2,⋯]

// 1 2 3 4 5 6 [1] 1
// 1 2 3 4 6 5 [2] 2>1
// 1 2 3 6 4 5 [3] 3>2>1
// 1 2 6 3 5 4 [4] 4>3>2>1
// 1 6 2 5 3 4 [5] 5>4>3>2>1

```

## ?🌟😻✔ 669. 修剪二叉搜索树【medium】

[ref](https://leetcode.cn/problems/trim-a-binary-search-tree/)

二叉搜索树、DFS、深度优先搜索

题解

- [【云影同学】递归、迭代双解法](https://leetcode.cn/problems/trim-a-binary-search-tree/solution/yun-ying-tong-xue-by-lxfriday-p3iu/)

```js
// 递归
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var trimBST = function(root, low, high) {
  if(!root) return null
  if(root.val < low) {
    return trimBST(root.right, low, high)
  } else if(root.val > high) {
    return trimBST(root.left, low, high)
  } else {
    root.left = trimBST(root.left, low, high)
    root.right = trimBST(root.right, low, high)
    return root
  }
};
```

```js
// 迭代
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var trimBST = function(root, low, high) {
  while(root) {
    if(root.val < low) root = root.right
    else if(root.val > high) root = root.left
    else break
  }
  if(!root) return null
  let rt = root
  while(root.left) {
    if(root.left.val < low) {
      root.left = root.left.right
    } else {
      root = root.left
    }
  }
  root = rt
  while(root.right) {
    if(root.right.val > high) {
      root.right = root.right.left
    } else {
      root = root.right
    }
  }
  return rt
};
```

## 🌟😻✔ 670. 最大交换【medium】

[ref](https://leetcode.cn/problems/maximum-swap/)

规律、模拟

```js
// 时间复杂度：O(lognum)
// 空间复杂度：O(lognum)
var maximumSwap = function(num) {
  const strArr = num.toString().split(''), n = strArr.length
  const maxArr = []
  let maxI = n - 1
  for(let i = n - 1;i>=0;i--) {
    if(strArr[i] > strArr[maxI]) maxI = i
    maxArr[i] = maxI
  }
  for(let i = 0;i<n;i++) {
    if(strArr[i] < strArr[maxArr[i]]) {
      const t = strArr[i]
      strArr[i] = strArr[maxArr[i]]
      strArr[maxArr[i]] = t
      return Number(strArr.join(''))
    }
  }
  return num
};
```

## ?🌟😻✔ 672. 灯泡开关 Ⅱ【medium】

[ref](https://leetcode.cn/problems/bulb-switcher-ii/)

规律、模拟

```js
var flipLights = function(n, k) {
  if(k === 0) return 1
  if(n === 1) return 2
  if(n === 2) return k===1?3:4
  else {
    if(k === 1) return 4
    if(k === 2) return 7
    return 8
  }
};
```

## ??🌟😻✔ 673. 最长递增子序列的个数【medium】

[ref](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

动态规划、递增子序列

```js
var findNumberOfLIS = function(nums) {
  const n = nums.length, dp = [], cntArr = new Array(n).fill(0).map(_ => [])
  let k = -1
  for(let i = 0;i < n; i++) {
    let idx
    if(k<0 || dp[k] < nums[i]) {
      dp[++k] = nums[i]
      idx = k
    } else {
      let l = 0, r = k
      while(l < r) {
        const mid = Math.floor((l + r) / 2)
        if(dp[mid] >= nums[i]) {
          r = mid
        } else {
          l = mid + 1
        }
      }
      dp[l] = nums[i]
      idx = l
    }
    if(idx === 0) {
      cntArr[idx].push([nums[i], 1])
    } else {
      const cntData = cntArr[idx-1]
      let sum = 0
      for(const [num, cnt] of cntData) {
        if(num < nums[i]) sum += cnt
      }
      cntArr[idx].push([nums[i], sum])
    }
  }
  let ret = 0
  for(const [num, cnt] of cntArr[k]) {
    ret += cnt
  }
  return ret
}
```

## 🌟😻✔ 674. 最长连续递增序列【easy】

[ref](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

数组题、序列、连续递增序列

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findLengthOfLCIS = function(nums) {
  const n = nums.length
  let l = 0, r = 1, max = 1
  while(r < n) {
    if(nums[r] <= nums[r - 1]) {
      max = Math.max(max, r - l)
      l = r
    }
    r++
  }
  max = Math.max(max, r - l)
  return max
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findLengthOfLCIS = function(nums) {
  const n = nums.length
  let l = 0, r = 0, max = 1
  while(r < n) {
    if(r === 0 || nums[r] > nums[r - 1] ) {
      max = Math.max(max, r - l + 1)
    } else {
      l = r
    }
    r++
  }
  return max
};
```

## ?🌟😻✔ 676. 实现一个魔法字典【medium】

[ref](https://leetcode.cn/problems/implement-magic-dictionary/)

字典树、前缀树

```js
var MagicDictionary = function() {
  this.tree = new TreeNode()
};
MagicDictionary.prototype.buildDict = function(dictionary) {
  for(let i=0;i<dictionary.length;i++) {
    const word = dictionary[i]
    let node = this.tree
    for(let j=0;j<word.length;j++) {
      if(!node.children[word[j]]) {
        node.children[word[j]] = new TreeNode()
      }
      node = node.children[word[j]]
      if(j === word.length - 1) node.isEnd = true
    }
  }
};
MagicDictionary.prototype.search = function(searchWord) {
  function search(node, cnt, i) {
    if(i === searchWord.length) {
      if(cnt === 1 && node.isEnd) return true
      return false
    }
    if(node.children[searchWord[i]] && search(node.children[searchWord[i]], cnt, i + 1)) return true
    if(cnt === 0) {
      const keys = Object.keys(node.children)
      for(let j=0;j<keys.length;j++) {
        if(keys[j] === searchWord[i]) continue
        if(search(node.children[keys[j]], 1, i + 1)) return true
      }
      return false
    }
    return false
  }
  return search(this.tree, 0, 0)
};
class TreeNode {
  constructor() {
    this.isEnd = false
    this.children = {}
  }
}
```

## ??🌟😻✔ 678. 有效的括号字符串【medium】

[ref](https://leetcode.cn/problems/valid-parenthesis-string/)

栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var checkValidString = function(s) {
  const lStack = [], starStack = []
  for(let i=0;i<s.length;i++) {
    if(s[i] === '(') {
      lStack.push(i)
    } else if(s[i] === ')') {
      if(lStack.length) lStack.pop()
      else if(starStack.length) starStack.pop()
      else return false
    } else {
      starStack.push(i)
    }
  }
  while(lStack.length) {
    while(starStack.length && starStack[0] < lStack[0]) starStack.shift()
    if(!starStack.length) return false
    lStack.shift()
    starStack.shift()
  }
  return lStack.length === 0
};
```

## 🌟😻✔ 680. 验证回文串 II【easy】

[ref](https://leetcode.cn/problems/valid-palindrome-ii/)

回文串、字符串、双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var validPalindrome = function(s) {
  let l = 0, r = s.length - 1
  while(l < r) {
    if(s[l] !== s[r]) {
      let pl = l, pr = r, leftFailed = false, rightFailed = false
      pl++
      while(pl < pr) {
        if(s[pl++] !== s[pr--]) {
          leftFailed = true
          break
        }
      }
      pl = l, pr = r
      pr--
      while(pl < pr) {
        if(s[pl++] !== s[pr--]) {
          rightFailed = true
        }
      }
      return !leftFailed || !rightFailed
    } else {
      l++
      r--
    }
  }
  return true
};
```

## ??🌟😻✔ 684. 冗余连接【medium】

[ref](https://leetcode.cn/problems/redundant-connection/solution/)

并查集、图、树、拓扑

```js
// 时间复杂度：O(NlogN)
// 时间复杂度：O(N)
var findRedundantConnection = function(edges) {
  const n = edges.length
  const parent = new Array(n + 1).fill(0).map((v, i) => i)
  console.log(parent)
  for(let i=0;i<n;i++) {
    const edge = edges[i]
    const node1 = edge[0], node2 = edge[1]
    if(find(parent, node1) !== find(parent, node2)) {
      union(parent, node1, node2)
    } else {
      return edge
    }
    console.log(node1, node2, parent)
  }
  return [0]
};

function union(parent, index1, index2) {
  parent[find(parent, index1)] = find(parent, index2)
}

function find(parent, index) {
  if(parent[index] !== index) {
    parent[index] = find(parent, parent[index])
    // return find(parent, parent[index])
  }
  return parent[index]
}
```


## ???🌟😻✔ 685. 冗余连接 II【hard】

[ref](https://leetcode.cn/problems/redundant-connection-ii/)

并查集、广度优先搜索、图、拓扑

题解

- [云影同学】并查集+广度优先搜索，难到奶奶家了](https://leetcode.cn/problems/redundant-connection-ii/solution/by-lxfriday-75sy/)

```js
// 只有一个根节点，根节点没有父节点
// 除了根节点之外的其他节点有且只有一个父节点
var findRedundantDirectedConnection = function(edges) {
  const n = edges.length
  // 节点连接关系图，BFS时用
  const connectionsToArr = new Array(n + 1).fill(0).map(_ => [])
  let badIndex = -1
  // 检查入度，看是否有节点被连接了两次
  let indegree = new Map()
  for(let i=0;i<edges.length;i++) {
    const edge = edges[i]
    indegree.set(edge[1], (indegree.get(edge[1])||0) + 1)
    // 如果有入度为2的，则表示某个节点被连接了两次
    if(indegree.get(edge[1]) === 2) {
      badIndex = i
    }
    connectionsToArr[edge[0]].push(edge[1])
  }
  if(badIndex !== -1) {
    // 能找到根节点，则某个节点A被连接了两次
    // 这种情况下想要知道结果必须知道是否存在环路，如果存在环路，则删除造成环的那个连接
    // 有环路的情况下被连接两次的那个节点除了被正常连接一次，还有需要找的多余的一次连接
    // 没有环路的情况下，随便删除哪条连着A的边都可以，依据题意，需要从数组中删除靠后的连接
    const edge = edges[badIndex]
    let q = [edge[1]]
    const used = new Set(q)
    let badConnection 
    // 用广度优先搜索查找是否存在环路，若存在环，则在某个边中必然会包含前面已经走过的节点
    while(q.length) {
      const len = q.length
      const tq = []
      for(let i=0;i<len;i++) {
        const v = q[i]
        if(connectionsToArr[v].length) {
          for(let j=0;j<connectionsToArr[v].length;j++) {
            const next = connectionsToArr[v][j]
            if(!used.has(next)) {
              used.add(next)
              tq.push(next)
            } else {
              // 存在环
              badConnection = [v, next]
            }
          }
        }
      }
      q = tq
    }
    if(badConnection) {
      // 存在环则返回重复连接初始节点的边
      return badConnection
    } else {
      // 没有环，则从后往前找第一条包含有两个入度节点的边
      for(let k = edges.length - 1;k>=0;k--) {
        if(edges[k][1] === edge[1]) return edges[k]
      }
    }
  } else {
    // 根节点被连接了，直接并查集找到多余的连接
    const parent = new Array(n + 1).fill(0).map((v, i) => i)
    for(let i=0;i<edges.length;i++) {
      const edge = edges[i]
      if(find(parent, edge[0]) !== find(parent, edge[1])) {
        union(parent, edge[0], edge[1])
      } else {
        return edge
      }
    }
  }
};

function find(parent, index) {
  if(parent[index] !== index) {
    return find(parent, parent[index])
  }
  return parent[index]
}

function union(parent, index1, index2) {
  parent[find(parent, index1)] = find(parent, index2)
}
```

## 🌟😻✔ 687. 最长同值路径【medium】

[ref](https://leetcode.cn/problems/longest-univalue-path/)

二叉树、深度优先搜索

题解

- [【云影同学】从每一个父节点出发考虑最长相同路径](https://leetcode.cn/problems/longest-univalue-path/solution/by-lxfriday-b15y/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var longestUnivaluePath = function(root) {
  if(!root) return 0
  let max = 0
  function dfs(node) {
    let lLen = 0, rLen = 0, len = 0, ret = 0
    if(node.left) {
      lLen = dfs(node.left)
      if(node.val === node.left.val) {
        len += lLen + 1
        ret = lLen + 1
      }
    }
    if(node.right) {
      rLen = dfs(node.right)
      if(node.val === node.right.val) {
        len += rLen + 1
        ret = Math.max(ret, 1 + rLen)
      }
    }
    max = Math.max(max, len)
    return ret
  }
  dfs(root)
  return max
};

```

## 🌟😻✔ 690. 员工的重要性【medium】

[ref](https://leetcode.cn/problems/employee-importance/)

图、广度优先搜索

```js
var GetImportance = function(employees, id) {
  const subMap = new Map(), valMap = new Map()
  for(const {id, importance, subordinates} of employees) {
    subMap.set(id, subordinates)
    valMap.set(id, importance)
  }
  let sum = valMap.get(id)
  let q = [id]
  const used = new Set([id])
  while(q.length) {
    const tq = []
    for(let i=0;i<q.length;i++) {
      const curr = q[i]
      const nexts = subMap.get(curr)
      for(const next of nexts) {
        if(!used.has(next)) {
          used.add(next)
          sum += valMap.get(next)
          tq.push(next)
        }
      }
    }
    q = tq
  }
  return sum
};
```

## ?🌟😻✔ 692. 前K个高频单词【medium】

[ref](https://leetcode.cn/problems/top-k-frequent-words/)

优先队列、堆、小顶堆、前k个问题

```js
// 时间复杂度：O(NlogK)
// 空间复杂度：O(N)
var topKFrequent = function(words, k) {
  const m = new Map()
  const minHeap = new MinHeap()
  for(let word of words) {
    m.set(word, (m.get(word) || 0) + 1)
  }
  for(let [word, count] of m.entries()) {
    minHeap.insert({word, count})
    if(minHeap.size() > k) minHeap.pop()
  }
  const res = []
  while(minHeap.size()) {
    res.unshift(minHeap.pop().word)
  }
  return res
};

class MinHeap {
  constructor() {
    this.heap = []
  }
  size() {
    return this.heap.length
  }
  insert(obj) {
    this.heap.push(obj)
    this.shiftUp(this.size() - 1)
  }
  pop() {
    this.swap(0, this.size() - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  shiftUp(i) {
    const parentIndex = Math.floor((i - 1) / 2)
    if(parentIndex >= 0 && (
      this.heap[i].count < this.heap[parentIndex].count
      || this.heap[i].count === this.heap[parentIndex].count && this.heap[i].word > this.heap[parentIndex].word
    )) {
      this.swap(i, parentIndex)
      this.shiftUp(parentIndex)
    }
  }
  shiftDown(i) {
    const lIndex = 2 * i + 1, rIndex = 2 * i + 2
    let minI = i
    if(lIndex < this.size() && (
      this.heap[lIndex].count < this.heap[minI].count
      || this.heap[lIndex].count === this.heap[minI].count && this.heap[lIndex].word > this.heap[minI].word
    )) {
      minI = lIndex
    }
    if(rIndex < this.size() && (
      this.heap[rIndex].count < this.heap[minI].count
      || this.heap[rIndex].count === this.heap[minI].count && this.heap[rIndex].word > this.heap[minI].word
    )) {
      minI = rIndex
    }
    if(minI !== i) {
      this.swap(i, minI)
      this.shiftDown(minI)
    }
  }
}
```

```js
// 桶排序解法
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var topKFrequent = function(words, k) {
  const m = new Map()
  let max = Number.MIN_SAFE_INTEGER
  for(let word of words) {
    m.set(word, (m.get(word) || 0) + 1)
    max = Math.max(max, m.get(word))
  }
  const bucket = new Array(max)
  for(let [word, count] of m.entries()) {
    if(!bucket[count]) {
      bucket[count] = []
    }
    let i = bucket[count].length - 1
    while(i >= 0 && bucket[count][i] > word) {
      bucket[count][i + 1] = bucket[count][i]
      i--
    }
    bucket[count][i + 1] = word
  }
  const res = []
  for(let i = max;i >= 1;i--) {
    if(bucket[i]) {
      for(let j=0;j<bucket[i].length;j++) {
        res.push(bucket[i][j])
        if(res.length === k) return res
      }
    }
  }
};
```

## ?🌟😻✔ 694. 不同岛屿的数量【medium】

[ref](https://leetcode.cn/problems/number-of-distinct-islands/)

矩阵、深度优先搜索、哈希表、集合

题解

- [【云影同学】深度优先搜索+轨迹标记](https://leetcode.cn/problems/number-of-distinct-islands/solution/-by-lxfriday-skw2/)

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var numDistinctIslands = function(grid) {
  const m = grid.length, n = grid[0].length
  const used = new Array(m).fill(0).map(_ => new Array(n).fill(false))
  let path = ''
  function walk(i, j, [originalI, originalJ]) {
    if(i < 0 || j < 0 || i >= m || j >= n || used[i][j] || grid[i][j] === 0) return
    used[i][j] = true
    path += `[${i - originalI},${j-originalJ}]`
    walk(i - 1, j, [originalI, originalJ])
    walk(i + 1, j, [originalI, originalJ])
    walk(i, j - 1, [originalI, originalJ])
    walk(i, j + 1, [originalI, originalJ])
  }
  const islandSet = new Set()
  let count = 0
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(!used[i][j] && grid[i][j] === 1) {
        path = ''
        walk(i, j, [i, j])
        if(!islandSet.has(path)) {
          count++
          islandSet.add(path)
        }
      }
    }
  }
  return count
};
```

## 😻✔ 695 岛屿的最大面积【medium】

[ref](https://leetcode.cn/problems/max-area-of-island/)

```js
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var maxAreaOfIsland = function(grid) {
  const m = grid.length
  const n = grid[0].length
  const used = new Array(m).fill(false).map(() => new Array(n).fill(false))
  let max = 0

  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 1 && !used[i][j]) {
        max = Math.max(calc(i, j), max)
      }
    }
  }

  function calc(i, j) {
    let sum = 1
    used[i][j] = true
    if(i - 1 >= 0 && !used[i - 1][j] && grid[i - 1][j] === 1) {
      sum += calc(i - 1, j)
    }
    if(i + 1 <  m && !used[i + 1][j] && grid[i + 1][j] === 1) {
      sum += calc(i + 1, j)
    }
    if(j - 1 >= 0 && !used[i][j - 1] && grid[i][j - 1] === 1) {
      sum += calc(i,j - 1)
    }
    if(j + 1 < n  && !used[i][j + 1] && grid[i][j + 1] === 1) {
      sum += calc(i, j + 1)
    }
    return sum
  }

  return max
};
```

## 🌟😻✔ 697. 数组的度【medium】

[ref](https://leetcode.cn/problems/degree-of-an-array/)

数组、模拟

```js
var findShortestSubArray = function(nums) {
  const map = new Map(), n = nums.length
  let maxDegree = 0
  for(const num of nums) {
    map.set(num, (map.get(num) || 0) + 1)
    maxDegree = Math.max(maxDegree, map.get(num))
  }
  const m = new Map()
  let l = 0, r = 0, min = Number.MAX_SAFE_INTEGER
  while(r < n) {
    m.set(nums[r], (m.get(nums[r]) || 0) + 1)
    if(m.get(nums[r]) === maxDegree) {
      while(nums[l] !== nums[r]) {
        m.set(nums[l], m.get(nums[l]) - 1)
        l++
      }
      min = Math.min(min, r - l + 1)
    }
    r++
  }
  return min  
};

```

## ??🌟😻✔ 698 划分为k个相等的子集【medium】

[ref](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

相关

- ?? [🌟【medium】 416 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/) 背包问题

我的题解

- [【云影同学】一个常规回溯解法，不用排序、dp](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/solution/-by-lxfriday-flp0/)


回溯

```js
var canPartitionKSubsets = function(nums, k) {
  const n = nums.length
  let sum = 0
  let max = Number.MIN_SAFE_INTEGER
  for(let i=0;i<n;i++) {
    sum += nums[i]
    max = Math.max(max, nums[i])
  }
  const target = sum / k
  if(target !== Math.floor(target) || max > target) return false
  let can = false
  const used = new Array(n).fill(false)
  function dfs(sum, cnt, startInd) {
    // 有k-1个target了，则剩下的数之和也为 target
    // k*target=(k-1)*target + x
    if(cnt === k - 1) {
      can = true
      return
    }
    if(sum === 0) {
      for(let i=0;i<n;i++) {
        if(!used[i] && nums[i] <= target) {
          used[i] = true
          if(sum + nums[i] === target) {
            dfs(0, cnt + 1, i + 1)
          } else {
            dfs(nums[i], cnt, i + 1)
          }
          used[i] = false
          break
        }
      }
    } else {
      for(let i=startInd;i<n;i++) {
        if(!used[i] && nums[i] + sum <= target) {
          used[i] = true
          if(sum + nums[i] === target) {
            dfs(0, cnt + 1, i + 1)
          } else {
            dfs(sum + nums[i], cnt, i + 1)
          }
          used[i] = false
        }
      }
    }
  }
  dfs(0, 0, 0)
  return can
};
```

```js
var canPartitionKSubsets = function(nums, k) {
  let sum = 0
  let max = nums[0]
  const len = nums.length
  for(let i=0;i<len;i++) {
    sum += nums[i]
    max = Math.max(max, nums[i])
  }
  const target0 = sum / k
  if(Math.floor(target0) !== target0 || max > target0) return false
  nums.sort((a, b) => a - b)
  const used = new Array(len).fill(false)

  function dfs(n, s, startIndex) {
    if(s === target0) {
      // 每找到一次就会刷新 startIndex
      return dfs(n - 1, 0, 0)
    }
    // 只要找到 n - 1 个 符合条件的捅即可，剩余的一个自然会符合条件
    if(n === 1)  return true
    for(let i=startIndex;i<nums.length;i++) {
      if(s + nums[i] > target0) break
      if(used[i]) continue
      used[i] = true
      const r = dfs(n, s + nums[i], i + 1)
      used[i] = false
      if(r) {
        return true
      }
    }
    return false
  }
  return dfs(k, 0, 0)
};
```

## 🌟😻✔ 700. 二叉搜索树中的搜索【easy】

[ref](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

二叉搜索树

```js
// 迭代版
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var searchBST = function(root, val) {
  while(root) {
    if(root.val === val) return root
    else if(root.val < val) root = root.right
    else root = root.left
  } 
  return null
};
```

```js
// 递归版
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var searchBST = function(root, val) {
  if(!root) return null
  if(root.val === val) return root
  else if(root.val < val) return searchBST(root.right, val)
  else return searchBST(root.left, val)
};
```


## 🌟😻✔ 701. 二叉搜索树中的插入操作【medium】

[ref](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

二叉搜索树

```js
// 迭代
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var insertIntoBST = function(root, val) {
  if(!root) return new TreeNode(val)
  let node = root
  let prev
  while(node) {
    prev = node
    if(node.val > val) {
      node = node.left
    } else {
      node = node.right
    }
  }
  if(prev.val < val) prev.right = new TreeNode(val)
  else prev.left = new TreeNode(val)
  return root
};
```

```js
// 递归
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var insertIntoBST = function(root, val) {
  if(!root) return new TreeNode(val)
  if(root.val > val) {
    root.left = insertIntoBST(root.left, val)
  } else {
    root.right = insertIntoBST(root.right, val)
  }
  return root
};
```

## 😻✔ 704 二分查找【easy】

[ref](https://leetcode.cn/problems/binary-search/)

二分查找

```js
// 时间复杂度：O(logn)
// 时间复杂度：O(1)
var search = function(nums, target) {
  let l = 0
  let r = nums.length - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] < target) {
      l = mid + 1
    } else if(nums[mid] > target) {
      r = mid - 1
    } else {
      return mid
    }
  }
  return -1
};
```

## 😻✔ 707 设计链表【medium】

[ref](https://leetcode.cn/problems/design-linked-list/)

链表

```js
function Node(val, next) {
  this.val = val
  this.next = next || null
}

var MyLinkedList = function() {
 this.head = new Node()
 this.tail = new Node()
 this.size = 0
};

/** 
 * @param {number} index
 * @return {number}
 */
MyLinkedList.prototype.get = function(index) {
  if(index<0 || index>= this.size) return -1
  let tHead = this.head
  let i = 0
  while(tHead) {
    if(i === index) {
      return tHead.next.val
    } else {
      tHead = tHead.next
      i++
    }
  }
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtHead = function(val) {
  const first = this.head.next
  this.head.next = new Node(val, first)
  this.size++
  if(!first) {
    this.tail.next = this.head.next
  }
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtTail = function(val) {
  if(this.tail.next) {
    const newEnd = new Node(val)
    this.tail.next.next = newEnd
    this.tail.next = newEnd
  } else {
    const node = new Node(val)
    this.head.next = node
    this.tail.next = node
  }
  this.size++
};

/** 
 * @param {number} index 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtIndex = function(index, val) {
  if(index<0) {
    this.addAtHead(val)
    return
  }
  let i = 0
  let tHead = this.head
  while(tHead) {
    if(i === index) {
      const next = tHead.next
      tHead.next = new Node(val, next)
      if(index === this.size) {
        this.tail.next = tHead.next
      }
      this.size++
      break
    } else {
      tHead = tHead.next
      i++
    }
  }
};

/** 
 * @param {number} index
 * @return {void}
 */
MyLinkedList.prototype.deleteAtIndex = function(index) {
  if(index<0 || index>= this.size) return
  let i = 0
  let tHead = this.head
  while(tHead) {
    if(i === index) {
      const next = tHead.next.next
      tHead.next = next
      if(index === this.size - 1) {
        this.tail.next = tHead
      }
      this.size--
      break
    } else {
      tHead = tHead.next
      i++
    }
  }
};
```

```js
var MyLinkedList = function() {
  this.head = new ListNode()
  this.tail = new ListNode()
  this.size = 0
};
MyLinkedList.prototype.get = function(index) {
  if(index < 0 || index >= this.size) return -1
  let head = this.head
  while(head) {
    head = head.next
    if(index===0) return head.val
    index--
  }
};
MyLinkedList.prototype.addAtHead = function(val) {
  const node = new ListNode(val)
  if(this.size === 0) {
    this.tail.next = node
  } else {
    const next = this.head.next
    next.prev = node
    node.next = next
  }
  this.head.next = node
  this.size++
};
MyLinkedList.prototype.addAtTail = function(val) {
  const node = new ListNode(val)
  if(this.size === 0) {
    this.head.next = node
  } else {
    this.tail.next.next = node
    node.prev = this.tail.next
  }
  this.tail.next = node
  this.size++
};
MyLinkedList.prototype.addAtIndex = function(index, val) {
  if(index <= 0) {
    this.addAtHead(val)
  } else if(index > 0 && index < this.size) {
    let i=0, head = this.head.next
    while(i<index) {
      head = head.next
      i++
    }
    const node = new ListNode(val)
    const next = head, prev = head.prev
    prev.next = node
    node.prev = prev
    node.next = next
    next.prev = node
    this.size++
  } else if(index === this.size) {
    this.addAtTail(val)
  }
};
MyLinkedList.prototype.deleteAtIndex = function(index) {
  if(this.size === 0 || index < 0 || index >= this.size) return
  if(this.size === 1) {
    this.head.next = null
    this.tail.next = null
  } else {
    if(index === 0) {
      this.head.next = this.head.next.next
      this.head.next.prev = null
    } else if(index === this.size - 1) {
      this.tail.next = this.tail.next.prev
      this.tail.next.next = null
    } else {
      let i=0, head = this.head.next
      while(i<index) {
        head = head.next
        i++
      }
      const next = head.next, prev = head.prev
      prev.next = next
      next.prev = prev
    }
  }
  this.size--
};

class ListNode {
  constructor(val, prev = null, next = null) {
    this.val = val
    this.prev = prev
    this.next = next
  }
}
```

## 🌟😻✔ 708. 循环有序列表的插入【medium】

[ref](https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/)

链表、循环链表

```js
var insert = function(head, insertVal) {
  const node = new Node(insertVal)
  if(!head) {
    node.next = node
    return node
  }
  let hasGoneRound = false
  let tHead = head
  while(true) {
    if(tHead.val <= insertVal && insertVal <= tHead.next.val) {
      node.next = tHead.next
      tHead.next = node
      return head
    } else {
      if(tHead.next === head) hasGoneRound = true
      if(hasGoneRound) {
        if(
          tHead.val >= tHead.next.val
        ) {
          node.next = tHead.next
          tHead.next = node
          return head
        }
      }
      tHead = tHead.next
    }
  }
};

```

## ???🌟😻✔ 711. 不同岛屿的数量 II【hard】

[ref](https://leetcode.cn/problems/number-of-distinct-islands-ii/)

深度优先搜索、哈希表、排序、集合

题解

- [【云影同学】思路清晰，代码尽量简洁，DFS+集合](https://leetcode.cn/problems/number-of-distinct-islands-ii/solution/-by-lxfriday-e1w9/)

```js
// 时间复杂度：O(MNlogMN)
// 空间复杂度：O(MN)
var numDistinctIslands2 = function(grid) {
  const m = grid.length, n = grid[0].length
  const used = new Array(m).fill(0).map(_ => new Array(n).fill(false))
  function walk(i, j, path) {
    if(i < 0 || j < 0 || i >= m || j >= n || used[i][j] || grid[i][j] === 0) return
    used[i][j] = true
    path.push([i, j])
    walk(i - 1, j, path)
    walk(i + 1, j, path)
    walk(i, j - 1, path)
    walk(i, j + 1, path)
    return path
  }
  const islandSet = new Set()
  const paths = []
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(!used[i][j] && grid[i][j] === 1) {
        paths.push(walk(i, j,[]))
      }
    }
  }
  let count = 0
  for(let path of paths) {
    const pathIdent = genIdent(shape(path))
    if(islandSet.has(pathIdent)) continue
    count++
    islandSet.add(pathIdent)
    islandSet.add(genIdent(shape(path.map(([x, y]) => [-x, y]))))
    islandSet.add(genIdent(shape(path.map(([x, y]) => [x, -y]))))
    islandSet.add(genIdent(shape(path.map(([x, y]) => [-x, -y]))))
    islandSet.add(genIdent(shape(path.map(([x, y]) => [y, x]))))
    islandSet.add(genIdent(shape(path.map(([x, y]) => [-y, x]))))
    islandSet.add(genIdent(shape(path.map(([x, y]) => [y, -x]))))
    islandSet.add(genIdent(shape(path.map(([x, y]) => [-y, -x]))))
  }
  return count
};

// 先对path排序，再相对最小点去相对坐标
function shape(path) {
  const sorted = path.sort((a, b) => a[0] - b[0] || a[1] - b[1])
  const [x0, y0] = sorted[0]
  return sorted.map(([x, y]) => [x - x0, y - y0])
}

// 对path生成标识id
function genIdent(path) {
  let str = ''
  for(const [x, y] of path) {
    str+=`[${x},${y}]`
  }
  return str
}

// 旋转、翻转所有的情况
//  x,  y       3,  1
// -x,  y      -3,  1
//  x, -y       3, -1
// -x, -y      -3, -1

//  y,  x       1,  3
// -y,  x      -1,  3
//  y, -x       1, -3
// -y, -x      -1, -3

```

## ?🌟😻✔ 712. 两个字符串的最小ASCII删除和【medium】

[ref](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)

动态规划、公共子序列、字符串

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var minimumDeleteSum = function(s1, s2) {
  const m = s1.length, n = s2.length
  let sum1 = 0, sum2 = 0
  for(let c of s1) {
    sum1 += c.charCodeAt(0)
  }
  for(let c of s2) {
    sum2 += c.charCodeAt(0)
  }
  if(m === 0) return sum2
  if(n === 0) return sum1
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  dp[0][0] = s1[0] === s2[0] ? s1[0].charCodeAt(0) : 0
  for(let i=1;i<m;i++) {
    if(s1[i] === s2[0]) dp[i][0] = s2[0].charCodeAt(0)
    else dp[i][0] = dp[i - 1][0]
  }
  for(let j=1; j < n; j++) {
    if(s1[0] === s2[j]) dp[0][j] = s1[0].charCodeAt(0)
    else dp[0][j] = dp[0][j - 1]
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      if(s1[i] === s2[j]) {
        dp[i][j] = s2[j].charCodeAt(0) + dp[i - 1][j - 1]
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
      }
    }
  }

  return sum1 + sum2 - 2 * dp[m - 1][n - 1]
};
// asciisum1 + asciisum1 = 2 * maxcommonascii + deletedascii
```

## ?🌟😻✔ 713 乘积小于 K 的子数组【medium】

[ref](https://leetcode.cn/problems/subarray-product-less-than-k/submissions/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numSubarrayProductLessThanK = function(nums, k) {
  let count = 0
  let mul = 1
  let i = 0
  for(let j = 0;j<nums.length;j++) {
    mul*=nums[j]
    while(i<=j && mul>=k) {
      mul /= nums[i]
      i++
    }
    count+=j-i+1
  }
  return count
};
```

## 😻✔ 714 买卖股票的最佳时机含手续费【medium】

动态规划

```js
// 时间复杂度：O(n)
// 空间复杂度：O(1)
var maxProfit = function(prices, fee) {
  let profitWithoutShare = 0
  let profitWithShare = -prices[0]
  for(let i = 1;i < prices.length; i++) {
    const profitWithoutShareBefore = profitWithoutShare
    const profitWithShareBefore = profitWithShare
    profitWithoutShare = Math.max(profitWithoutShareBefore, profitWithShareBefore + prices[i] - fee)
    profitWithShare = Math.max(profitWithShareBefore, profitWithoutShare - prices[i])
  }
  return profitWithoutShare
};
```

数组版

```js
// 时间复杂度：O(n)
// 空间复杂度：O(n)
var maxProfit = function(prices, fee) {
  // 0 不持有股票
  // 1 持有股票
  const len = prices.length
  const dp = new Array(len).fill(1).map(_ => [])
  dp[0][0] = 0
  dp[0][1] = -prices[0]
  for(let i = 1;i < prices.length; i++) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)
    dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i])
  }
  return dp[prices.length - 1][0]
};
```

## 🌟😻✔ 718. 最长重复子数组【medium】

[ref](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

动态规划

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var findLength = function(nums1, nums2) {
  const m = nums1.length, n = nums2.length
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  let max = 0
  for(let i=0;i<nums1.length;i++) {
    for(let j=0;j<nums2.length;j++) {
      if(nums1[i] === nums2[j]) {
        dp[i][j] = 1 + ((i >= 1 && j >= 1)? dp[i-1][j-1]:0)
        max = Math.max(dp[i][j], max)
      }
    }
  }
  return max
};
```

## 🌟😻✔ 720. 词典中最长的单词【medium】

[ref](https://leetcode.cn/problems/longest-word-in-dictionary/)

哈希表

```js
var longestWord = function(words) {
  const root = buildTree(words)
  let res = ''
  for(let i=0;i<words.length;i++) {
    const word = words[i]
    let node = root
    let canUse = true
    for(let j=0;j<word.length;j++) {
      if(!node.children[word[j]] || !node.children[word[j]].end) {
        canUse = false
        break
      }
      node = node.children[word[j]]
    }
    if(canUse) {
      if(word.length > res.length || word.length === res.length && word < res) res = word
    }
  }
  return res
};

function buildTree(words) {
  const root = new TreeNode()
  for(let i=0;i<words.length;i++) {
    const word = words[i]
    let node = root
    for(let j = 0; j < word.length; j++) {
      if(!node.children[word[j]]) node.children[word[j]] = new TreeNode()
      node = node.children[word[j]]
      if(j === word.length - 1) node.end = true
    }
  }
  return root
}

class TreeNode {
  constructor() {
    this.end = false
    this.children = {}
  }
}
```

```js
var longestWord = function(words) {
  const s = new Set([...words])
  let res = ''
  for(let word of s) {
    let has = true
    for(let i=word.length - 1;i>=1;i--) {
      if(!s.has(word.slice(0, i))) {
        has = false
      }
    }
    if(has) {
      if(res.length < word.length || (res.length === word.length && word < res))
      res = word
    }
  }
  return res
};
```

## ?🌟😻✔ 721. 账户合并【medium】

[ref](https://leetcode.cn/problems/accounts-merge/)

图、广度优先搜索

题解

- [哈希表+集合+广度优先搜索，利用到图的朴素解法。 面试官：要offer不要，我：怕了](https://leetcode.cn/problems/accounts-merge/)

```js
var accountsMerge = function(accounts) {
  const emailMap = new Map()
  const n = accounts.length
  const indexRelations = new Array(n).fill(0).map(_ => new Set())
  for(let i=0;i<n;i++) {
    const account = accounts[i]
    for(let j=1;j<account.length;j++) {
      if(emailMap.has(account[j])) {
        emailMap.get(account[j]).push(i)
      } else {
        emailMap.set(account[j], [i])
      }
    }
  }
  for(let indexes of emailMap.values()) {
    for(let index1 of indexes) {
      for(let index2 of indexes) {
        if(index1 !== index2) {
          indexRelations[index1].add(index2)
        }
      }
    }
  }
  const res = []
  const used = new Set()
  for(let i=0;i<n;i++) {
    if(used.has(i)) continue
    used.add(i)
    const accounti = accounts[i]
    const name = accounti[0]
    const emails = new Set()
    let q = [i]
    while(q.length) {
      const len = q.length
      const tq = []
      for(let j=0;j<len;j++) {
        const nexti = q[j]
        for(let k=1;k<accounts[nexti].length;k++) {
          emails.add(accounts[nexti][k])
        }
        for(let relaIdx of indexRelations[nexti]) {
          if(!used.has(relaIdx)) {
            used.add(relaIdx)
            tq.push(relaIdx)
          }
        }
      }
      q = tq
    }
    res.push([name, ...Array.from(emails).sort((a, b) => a < b ? -1 : 1)])
  }
  return res
};
```

## 🌟😻✔ 724. 寻找数组的中心下标【easy】

[ref](https://leetcode.cn/problems/find-pivot-index/)

数组

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var pivotIndex = function(nums) {
  const calArr = [], n = nums.length
  let sum = 0
  for(let i = n - 1;i >= 0; i--) {
    calArr[i] = sum
    sum += nums[i]
  }
  sum = 0
  for(let i = 0;i < n; i++) {
    if(sum === calArr[i]) return i
    sum += nums[i]
  }
  return -1
};
```

## ?🌟😻✔ 725. 分隔链表【medium】

[ref](https://leetcode.cn/problems/split-linked-list-in-parts/)

链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var splitListToParts = function(head, k) {
  let total = 0
  let tmpHead = head
  while(tmpHead) {
    total++
    tmpHead=tmpHead.next
  }
  const min = Math.floor(total / k)
  let extraCount = total % k
  const res = new Array(k).fill(null)
  let i = 0
  while(total > 0) {
    let count = 0
    const myHead = new ListNode(0, head)
    let tHead = myHead
    while(count < min) {
      tHead = tHead.next
      count++
      total--
    }
    if(extraCount > 0) {
      tHead = tHead.next
      extraCount--
      total--
    }
    head = tHead.next
    tHead.next = null
    res[i++] = myHead.next
  }
  return res
};
```

## 🌟😻✔ 733. 图像渲染【easy】

[ref](https://leetcode.cn/problems/flood-fill/)

图、深度优先搜索

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var floodFill = function(image, sr, sc, color) {
  const target = image[sr][sc]
  if(target === color) return image
  function walk(i, j) {
    const m = image.length, n = image[0].length
    if(i < 0 || i >= m || j < 0 || j >= n || image[i][j] !== target) return
    image[i][j] = color
    walk(i - 1, j)
    walk(i + 1, j)
    walk(i, j - 1)
    walk(i, j + 1)
  }
  walk(sr, sc)
  return image
};
```

## ?🌟😻✔ 734. 句子相似性【easy】

[ref](https://leetcode.cn/problems/sentence-similarity/)

集合、哈希表

```js
// 时间复杂度：O(M+N) M=similarPairs.length N=sentence1.length
// 空间复杂度：O(M)
var areSentencesSimilar = function(sentence1, sentence2, similarPairs) {
  if(sentence1.length !== sentence2.length) return false
  const similarPairsSet = new Set()
  for(let [word1, word2] of similarPairs) {
    similarPairsSet.add(`${word1}#${word2}`)
  }
  for(let i=0;i<sentence1.length;i++) {
    const word1 = sentence1[i], word2 = sentence2[i]
    if(!(
      word1 === word2
      || similarPairsSet.has(`${word1}#${word2}`)
      || similarPairsSet.has(`${word2}#${word1}`)
    ))
    return false
  }
  return true
};
```

## ?🌟😻✔ 735. 行星碰撞【medium】

[ref](https://leetcode.cn/problems/asteroid-collision/)

栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var asteroidCollision = function(asteroids) {
  const stack = []
  for(let i=0;i<asteroids.length;i++) {
    const aster = asteroids[i]
    if(aster === 0) continue
    let shouldPush = true
    while(stack.length && stack[stack.length - 1] > 0 && aster < 0) {
      if(stack[stack.length - 1] + aster < 0) {
        stack.pop()
      } else if(stack[stack.length - 1] + aster === 0) {
        stack.pop()
        shouldPush = false
        break
      } else {
        shouldPush = false
        break
      }
    }
    if(shouldPush) stack.push(aster)
  }
  return stack
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var asteroidCollision = function(asteroids) {
  const stack = []
  for(let i=0;i<asteroids.length;i++) {
    const aster = asteroids[i]
    if(aster === 0) continue
    if(!stack.length || aster > 0 || stack[stack.length - 1] < 0) {
      stack.push(aster)
    } else {
      while(stack.length && stack[stack.length - 1] > 0 && stack[stack.length - 1] + aster < 0) {
        stack.pop()
      }
      if(!stack.length || stack[stack.length - 1] < 0) {
        stack.push(aster)
      } else if(stack[stack.length - 1] + aster === 0) {
        stack.pop()
      }
    }
  }
  return stack 
};
```

## 🌟😻✔ 737. 句子相似性 II【medium】

[ref](https://leetcode.cn/problems/sentence-similarity-ii/)

图、广度优先搜索

题解

- [【云影同学】建图+广度优先搜索](https://leetcode.cn/problems/sentence-similarity-ii/solution/by-lxfriday-fno4/)

```js
var areSentencesSimilarTwo = function(sentence1, sentence2, similarPairs) {
  if(sentence1.length !== sentence2.length) return false
  // 建双向图
  const similarPairsMap = new Map()
  for(let [word1, word2] of similarPairs) {
    if(similarPairsMap.has(word1)) {
      similarPairsMap.get(word1).add(word2)
    } else {
      similarPairsMap.set(word1, new Set([word2]))
    }
    if(similarPairsMap.has(word2)) {
      similarPairsMap.get(word2).add(word1)
    } else {
      similarPairsMap.set(word2, new Set([word1]))
    }
  }
  // 广度优先逐层查找，找到即返回
  function find(word1, word2) {
    let q = [word1]
    const used = new Set([word1])
    while(q.length) {
      const len = q.length
      const tq = []
      for(let i=0;i<len;i++) {
        const word = q[i]
        if(similarPairsMap.has(word)) {
          for(let simiWord of similarPairsMap.get(word)) {
            if(simiWord === word2) return true
            if(!used.has(simiWord)) {
              used.add(simiWord)
              tq.push(simiWord)
            }
          }
        }
      }
      q = tq
    }
  }

  for(let i=0;i<sentence1.length;i++) {
    if(!(sentence1[i] === sentence2[i] || find(sentence1[i], sentence2[i]))) return false
  }
  return true
};
```

## ?🌟😻✔ 738. 单调递增的数字【medium】

[ref](https://leetcode.cn/problems/monotone-increasing-digits/)

规律题、数组、字符串

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(logN)
var monotoneIncreasingDigits = function(n) {
  const nStr = n.toString().split('')
  for(let i=nStr.length - 1; i>=1; i--) {
    if(nStr[i] < nStr[i - 1]) {
      nStr[i - 1] = String(Number(nStr[i - 1]) - 1)
      let j = i
      while(j < nStr.length) {
        nStr[j] = '9'
        j++
      }
    }
  }
  while(nStr[0] === '0') {
    nStr.shift()
  }
  return nStr.join('')
};
```

## ?🌟😻✔ 739. 每日温度【medium】

[ref](https://leetcode.cn/problems/daily-temperatures/)

单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var dailyTemperatures = function(temperatures) {
  const len = temperatures.length
  const res = new Array(len).fill(0)
  const s = []
  for(let i = len - 1;i>=0;i--) {
    while(s.length && temperatures[s[s.length - 1]] <= temperatures[i]) {
      s.pop()
    }
    if(s.length) {
      res[i] = s[s.length - 1] - i
    } else {
      res[i] = 0
    }
    s.push(i)
  }
  return res
};
```

## ?🌟😻✔ 740. 删除并获得点数【medium】

[ref](https://leetcode.cn/problems/delete-and-earn/)

动态规划

转换为打家劫舍问题

```js
// 时间复杂度：O(N+M) M = len
// 空间复杂度：O(M)
var deleteAndEarn = function(nums) {
  const len = 10**4 + 1
  const arr = new Array(len).fill(0)
  const dp = new Array(len).fill(0)
  for(let i=0;i<nums.length;i++) {
    arr[nums[i]] += nums[i]
  }
  dp[1] = arr[1]
  for(let i=2;i<len;i++) {
    dp[i] = Math.max(arr[i] + dp[i - 2], dp[i - 1])
  }
  return dp[len - 1]
};
```

```js
var deleteAndEarn = function(nums) {
  const map = new Map()
  for(let i=0;i<nums.length;i++) {
    map.set(nums[i], (map.get(nums[i]) || 0) + 1)
  }
  nums = [...map].map(_ => _[0]).sort((a, b) => a - b)
  const dp = new Array(nums.length).fill(0).map(_ => 0)
  dp[0] = nums[0] * map.get(nums[0])
  for(let i=1;i<nums.length;i++) {
    const num = nums[i]
    const a =  dp[i - 1]
    let b
    if(nums[i] === nums[i - 1] + 1) {
      b = (i - 2 >=0 ? dp[i - 2]:0)  + num * map.get(num)
    } else {
      b = dp[i - 1] + num * map.get(num)
    }
    dp[i] = Math.max(a, b)
  }
  return dp[nums.length - 1]
};
```

## ???🌟😻✔ 743. 网络延迟时间【medium】

[ref](https://leetcode.cn/problems/network-delay-time/)

最短路、最短路问题、Floyd 算法、Dijkstra 算法、深度优先搜索

优秀题解

- [【宫水三叶】涵盖所有的「存图方式」与「最短路算法（详尽注释）」](https://leetcode.cn/problems/network-delay-time/solution/gong-shui-san-xie-yi-ti-wu-jie-wu-chong-oghpz/)

```js
// Floyd 算法
// 可以将问题分解，先找出最短的距离，然后在考虑如何找出对应的行进路线。
// 如何找出最短路径呢，这里还是用到动态规划的知识，对于任何一个城市而言，i到j的最短距离不外乎存在经过i与j之间的k和不经过k两种可能，所以可以令k=1，2，3，...，n(n是城市的数目)
// 在检查d(ij)与d(ik)+d(kj)的值；在此d(ik)与d(kj)分别是目前为止所知道的i到k与k到j的最短距离，因此d(ik)+d(kj)就是i到j经过k的最短距离。
// 所以，若有d(ij)>d(ik)+d(kj)，就表示从i出发经过k再到j的距离要比原来的i到j距离短，自然把i到j的d(ij)重写为d(ik)+d(kj)，每当一个k查完了，d(ij)就是目前的i到j的最短距离。重复这一过程，最后当查完所有的k时，d(ij)里面存放的就是i到j之间的最短距离了。
var networkDelayTime = function(times, n, k) {
  const graph = new Array(n + 1).fill(0).map(_ => new Array(n + 1).fill(Number.MAX_SAFE_INTEGER))
  for(let i=1;i<=n;i++) graph[i][i] = 0
  for(let e of times) graph[e[0]][e[1]] = e[2]
  for(let kk=1;kk<=n;kk++) {
    for(let i=1;i<=n;i++) {
      for(let j=1;j<=n;j++) {
        graph[i][j] = Math.min(graph[i][j], graph[i][kk] + graph[kk][j])
      }
    }
  }
  let res = 0
  for(let i=1;i<=n;i++) {
    if(graph[k][i] === Number.MAX_SAFE_INTEGER) return -1
    res = Math.max(res, graph[k][i])
  }
  return res
};
```

```js
// 朴素DFS
var networkDelayTime = function(times, n, k) {
  if(k === n && k === 1) return 0
  const connectMap = new Map()
  for(let i=0;i<times.length; i++) {
    const [p1, p2, t] = times[i]
    if(connectMap.has(p1)) {
      connectMap.get(p1).push([p2, t])
    } else {
      connectMap.set(p1, [[p2, t]])
    }
  }
  if(!connectMap.has(k)) return -1
  const used = new Set()
  const timeArr = new Array(n + 1).fill(Number.MAX_SAFE_INTEGER)
  timeArr[0] = 0
  const dots = new Set()
  function dfs(source, timeUsed) {
    dots.add(source)
    if(timeUsed < timeArr[source]) {
      timeArr[source] = timeUsed
      if(connectMap.has(source)) {
        const nexts = connectMap.get(source)
        for(let i=0;i<nexts.length;i++) {
          const [next, timeNeed] = nexts[i]
          if(used.has(next)) continue
          used.add(next)
          dfs(next, timeUsed + timeNeed)
          used.delete(next)
        }
      }
    }
  }

  dfs(k, 0)
  return dots.size === n ? Math.max(...timeArr) : -1
};
```

## ??🌟😻✔ 745. 前缀和后缀搜索【hard】

[ref](https://leetcode.cn/problems/prefix-and-suffix-search/)

字典树、前缀树、后缀树

```js
var WordFilter = function(words) {
  this.bfPfxRoot = new TreeNode()
  this.aftPfxRoot = new TreeNode()
  for(let i=0;i<words.length;i++) {
    let bfNode = this.bfPfxRoot
    let aftNode = this.aftPfxRoot
    const word = words[i]
    for(let j=0;j<word.length;j++) {
      if(!bfNode.children[word[j]]) bfNode.children[word[j]] = new TreeNode()
      bfNode = bfNode.children[word[j]]
      bfNode.idx.push(i)
    }
    for(let j=word.length - 1;j>=0;j--) {
      if(!aftNode.children[word[j]]) aftNode.children[word[j]] = new TreeNode()
      aftNode = aftNode.children[word[j]]
      aftNode.idx.push(i)
    }
  }
};
WordFilter.prototype.f = function(pref, suff) {
  let bfNode = this.bfPfxRoot
  let aftNode = this.aftPfxRoot
  let bfPfxIdxes = [], aftPfxIdxes = []
  for(let i=0;i<pref.length;i++) {
    if(bfNode.children[pref[i]]) {
      bfNode = bfNode.children[pref[i]]
      if(i === pref.length - 1) bfPfxIdxes = bfNode.idx
    } else {
      break
    }
  }
  for(let i=suff.length - 1;i >= 0; i--) {
    if(aftNode.children[suff[i]]) {
      aftNode = aftNode.children[suff[i]]
      if(i === 0) aftPfxIdxes = aftNode.idx
    } else {
      break
    }
  }
  let bfi = bfPfxIdxes.length - 1, afti = aftPfxIdxes.length - 1
  while(bfi >=0 && afti >= 0) {
    if(bfPfxIdxes[bfi] === aftPfxIdxes[afti]) {
      return bfPfxIdxes[bfi]
    } else if(bfPfxIdxes[bfi] > aftPfxIdxes[afti]) {
      bfi--
    } else {
      afti--
    }
  }
  return -1
};

class TreeNode {
  constructor() {
    this.idx = []
    this.end = false
    this.children = {}
  }
}
```

## ✔ 746 使用最小花费爬楼梯【easy】

[ref](https://leetcode.cn/problems/min-cost-climbing-stairs/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var minCostClimbingStairs = function(cost) {
  const len = cost.length
  const dp = new Array(len).fill(0)
  dp[0] = cost[0]
  dp[1] = cost[1]
  for(let i=2;i<len;i++) {
    dp[i] = cost[i] + Math.min(dp[i - 1], dp[i - 2])
  }
  return Math.min(dp[len - 1], dp[len - 2])
};
```

## ?🌟😻✔ 752. 打开转盘锁【medium】

[ref](https://leetcode.cn/problems/open-the-lock/)

广度优先搜索

题解：

- [【云影同学】BFS 代码简洁，思路清晰，操作稳健](https://leetcode.cn/problems/open-the-lock/solution/-by-lxfriday-xyad/)

```js
var openLock = function(deadends, target) {
  const deadendsSet = new Set(deadends)
  if(deadendsSet.has('0000')) return -1
  let q = ['0000']
  const used = new Set(['0000'])
  let cnt = 0
  while(q.length) {
    const len = q.length
    const tq = []
    for(let i=0;i<len;i++) {
      const curr = q[i]
      if(curr === target) return cnt
      for(let j=0;j<4;j++) {
        const s1 = curr.slice(0, j) + ((Number(curr[j]) + 1) % 10) + curr.slice(j + 1)
        const s2 = curr.slice(0, j) + ((Number(curr[j]) - 1 + 10) % 10) + curr.slice(j + 1)
        if(!deadendsSet.has(s1) && !used.has(s1)) {
          used.add(s1)
          tq.push(s1)
        }
        if(!deadendsSet.has(s2) && !used.has(s2)) {
          used.add(s2)
          tq.push(s2)
        }
      }
    }
    q = tq
    cnt++
  }
  return -1
};
```

```js
var openLock = function(deadends, target) {
  // 没开始就结束了，脱裤子放屁
  if(target === '0000') return 0
  const deadendsSet = new Set(deadends)
  // 开始不了，今天电梯坏了不用出门上班
  if(deadendsSet.has('0000')) return -1
  const used = new Set(['0000'])
  // 要开始了，存储初始态 0000，当前层级为 0
  let q = [['0000', 0]]
  while(q.length) {
    const tq = []
    for(let i=0;i<q.length;i++) {
      // 取出关联搜索到的转盘状态，
      const [numsStr, level] = q[i]
      // 如果取出的就是target，那直接 good bye 不玩了
      if(numsStr === target) return level
      // 取出的不是 target，我还得扩散查找
      for(let j=0;j<4;j++) {
        // 直接某一位加1或者减1得到 当前锁盘的上、下两种可能转法
        const s1 = numsStr.slice(0, j) + ((Number(numsStr[j]) + 1) % 10) + numsStr.slice(j + 1)
        const s2 = numsStr.slice(0, j) + ((Number(numsStr[j]) + 9) % 10) + numsStr.slice(j + 1)
        // 如果不在死锁集合中且也没有入过队，则可以加入下一轮
        if(!used.has(s1) && !deadendsSet.has(s1)) {
          used.add(s1)
          tq.push([s1, level + 1])
        }
        if(!used.has(s2) && !deadendsSet.has(s2)) {
          used.add(s2)
          tq.push([s2, level + 1])
        }
      }
    }
    // 当前层的扫描结束，俺没有找到结果，把下一轮轮盘的搜索状态传给q，继续开始下一轮
    // 如果没了，则认为没找到，返回-1
    q = tq
  }
  return -1
};
```

## ?🌟😻✔ 763 划分字母区间【medium】

[ref](https://leetcode.cn/problems/partition-labels/)

字符串、区间、关联线段

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var partitionLabels = function(s) {
  const map = new Map()
  for(let i=0;i<s.length;i++) {
    map.set(s[i], i)
  }
  const res = []
  let endIndex = 0
  let beginIndex = 0
  for(let i=0;i<s.length;i++) {
    const w = s[i]
    endIndex = Math.max(map.get(w), endIndex)
    if(i === endIndex) {
      res.push(endIndex - beginIndex + 1)
      beginIndex = i + 1
    }
  }
  return res
};
```

## ?? 🌟✔ 768. 最多能完成排序的块 II【hard】

[ref](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)

排序、哈希表、单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxChunksToSorted = function(arr) {
  const stack = [];
  for (const num of arr) {
    if (stack.length === 0 || num >= stack[stack.length - 1]) {
      stack.push(num);
    } else {
      const mx = stack.pop();
      while (stack.length && stack[stack.length - 1] > num) {
        stack.pop();
      }
      stack.push(mx);
    }
  }
  return stack.length;
};
```

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var maxChunksToSorted = function(arr) {
  const arrSorted = [...arr].sort((a, b) => a - b)
  const n = arr.length
  let i1 = 0, i2 = 0
  let count = 0
  let m = new Map()
  while(i1<n) {
    const x = arr[i1], y = arrSorted[i2]
    m.set(y, (m.get(y) || 0) + 1)
    m.set(x, (m.get(x) || 0) - 1)
    m.get(x) === 0 && m.delete(x)
    m.get(y) === 0 && m.delete(y)
    if(!m.size) count++
    i1++
    i2++
  }
  return count
};
```

## ? 🌟✔ 769. 最多能完成排序的块【medium】

[ref](https://leetcode.cn/problems/max-chunks-to-make-sorted/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxChunksToSorted = function(arr) {
  const n = arr.length
  let cnt = 0, max = -1
  for(let i=0;i<n;i++) {
    max = Math.max(max, arr[i])
    if(i === max) cnt++
  }
  return cnt
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxChunksToSorted = function(arr) {
  const n = arr.length
  let i1 = 0, l2 = 0, r2 = 0
  let min1 = arr[i1], max1 = arr[i1]
  let count = 0
  while(i1 < n) {
    min1 = Math.min(min1, arr[i1])
    max1 = Math.max(max1, arr[i1])
    if(min1 === l2 && max1 === r2) {
      count++
      i1++
      r2++
      l2 = r2
      min1 = max1 = arr[i1]
    } else {
      i1++
      r2++
    }
  }
  return count
};
```

## ✔ 771. 宝石与石头【easy】

[ref](https://leetcode.cn/problems/jewels-and-stones/)

字符串、哈希表

```js
var numJewelsInStones = function(jewels, stones) {
  const jewelsSet = new Set(jewels.split(''))
  let cnt = 0
  for(const c of stones) {
    if(jewelsSet.has(c)) cnt++
  }
  return cnt
};
```

## ??🌟😻✔ 777. 在LR字符串中交换相邻字符【medium】

[ref](https://leetcode.cn/problems/swap-adjacent-in-lr-string/)

双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var canTransform = function(start, end) {
  const n = start.length
  let i = 0, j = 0
  while(i < n || j < n) {
    while(start[i] === 'X') i++
    while(end[j] === 'X') j++
    if(start[i] !== end[j]) return false
    if(end[j] === 'L' && i < j) return false
    if(end[j] === 'R' && i > j) return false
    i++, j++
  }
  return true
};
```

## 🌟😻✔ 781. 森林中的兔子【medium】

[ref](https://leetcode.cn/problems/rabbits-in-forest/)

贪心

```js
// 时间复杂度：O(N) N=answers.length
// 空间复杂度：O(M) M=1001
var numRabbits = function(answers) {
  const arr = new Array(1001).fill(0)
  let cnt = 0
  for(let i = 0; i < answers.length; i++) {
    arr[answers[i] + 1]++
    if(arr[answers[i] + 1] === 1) cnt += answers[i] + 1
    if(arr[answers[i] + 1] === answers[i] + 1) arr[answers[i] + 1] = 0
  }
  return cnt
};
```

## ???🌟😻✔ 782. 变为棋盘【hard】

[ref](https://leetcode.cn/problems/transform-to-chessboard/)

矩阵、模拟、规律题

题解

- [【云影同学】强规律题，反推+模拟，双百](https://leetcode.cn/problems/transform-to-chessboard/solution/by-lxfriday-7miv/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var movesToChessboard = function(board) {
  const n = board.length
  const rowSet = new Set()
  const colSet = new Set()
  const rowSum = new Array(n).fill(0)
  const colSum = new Array(n).fill(0)
  for(let i=0;i<n;i++) {
    let s = ''
    for(let j=0;j<n;j++) {
      s += board[i][j]
      rowSum[i] += board[i][j]
    }
    rowSet.add(s)
    if(
      n % 2===0 && rowSum[i] !== n / 2
      || n % 2 ===1 && rowSum[i] !== Math.floor(n / 2) && rowSum[i] !== Math.floor(n / 2) + 1
    ) {
      return -1
    }
  }
  for(let j=0;j<n;j++) {
    let s = ''
    for(let i=0;i<n;i++) {
      s += board[i][j]
      colSum[j] += board[i][j]
    }
    colSet.add(s)
    if(
      n % 2===0 && colSum[j] !== n / 2
      || n % 2 ===1 && colSum[j] !== Math.floor(n / 2) && colSum[j] !== Math.floor(n / 2) + 1
    ) {
      return -1
    }
  }
  if(colSet.size !== 2 || rowSet.size !== 2) return -1
  let rowZeroFirst = false
  let colZeroFirst = false
  if(n % 2 === 1) {
    if(rowSum[0] === Math.floor(n / 2)) rowZeroFirst = true
    if(colSum[0] === Math.floor(n / 2)) colZeroFirst = true
  }
  const sum1 = n % 2 === 0
    ? Math.min(findSwap(board, true, true), findSwap(board, false, true))
    : findSwap(board, rowZeroFirst, true)
  const sum2 = n % 2 === 0
    ? Math.min(findSwap(board, true, false), findSwap(board, false, false))
    :findSwap(board, colZeroFirst, false)
  return sum1 + sum2
};

function findSwap(board, zeroFirst, isRow) {
  const n = board.length
  let count = 0
  let isZero = zeroFirst
  let borrowCount = 0
  for(let i=0;i<n;i++) {
    const ii = isRow ? 0 : i
    const jj = isRow ? i : 0
    if(board[ii][jj] === 0 && !isZero) {
      if(borrowCount > 0) {
        borrowCount--
      } else {
        count++
        borrowCount++
      }
    } else if(board[ii][jj] === 1 && isZero) {
      if(borrowCount > 0) {
        borrowCount--
      } else {
        count++
        borrowCount++
      }
    }
    isZero = !isZero
  }
  return count
}
// 0 1 1 0
// 0 1 1 0
// 1 0 0 1
// 1 0 0 1

// ------------
// 1,1,1,0,0,1,0,0
// 0,0,0,1,1,0,1,1
// 1,1,1,0,0,1,0,0
// 0,0,0,1,1,0,1,1
// 0,0,0,1,1,0,1,1
// 0,0,0,1,1,0,1,1
// 1,1,1,0,0,1,0,0
// 1,1,1,0,0,1,0,0
// ------------
// 0,0,1,0,1,1
// 1,1,0,1,0,0
// 1,1,0,1,0,0
// 0,0,1,0,1,1
// 1,1,0,1,0,0
// 0,0,1,0,1,1
// -------------
// 1,1,1,0
// 1,1,1,0
// 0,0,0,1
// 0,0,0,1
// -------------
// 0,0,1,1
// 1,1,0,0
// 0,1,0,1
// 1,0,1,0
// -------------
// 1,0,0
// 0,1,1
// 1,0,0
// -------------
// 1,1,0
// 0,0,1
// 0,0,1

// 0,0,1
// 1,1,0
// 0,0,1

// 0,1,0
// 1,0,1
// 0,1,0
// ---------------
// 0 1 1 0
// 0 1 1 0
// 1 0 0 1
// 1 0 0 1

// 0 1 1 0
// 1 0 0 1
// 0 1 1 0
// 1 0 0 1

// 0 1 0 1
// 1 0 1 0
// 0 1 0 1
// 1 0 1 0
```

## ?🌟😻✔ 784. 字母大小写全排列【medium】

[ref](https://leetcode.cn/problems/letter-case-permutation/)

排列组合、回溯

```js
// 时间复杂度：O(N*2^N) N=s.length
// 空间复杂度：O(N)
var letterCasePermutation = function(s) {
  const n = s.length
  const res = []
  function backtracking(i, path) {
    if(i >= n) {
      res.push(path.join(''))
      return
    }
    if(path[i] >= '0' && path[i] <= '9') {
      backtracking(i + 1, path)
    } else {
      path[i] = path[i].toLowerCase()
      backtracking(i + 1, path)
      path[i] = path[i].toUpperCase()
      backtracking(i + 1, path)
    }
  }

  backtracking(0, s.split(''))
  return res
};
```

## ?🌟😻✔ 785. 判断二分图【medium】

[ref](https://leetcode.cn/problems/is-graph-bipartite/)

图、深度优先搜索、广度优先搜索

```js
// 广度优先搜索
// 时间复杂度：O(N+M) N = graph.length M=无向图的边数
// 空间复杂度：O(N)
var isBipartite = function(graph) {
  const n = graph.length
  const graphSet1 = new Set()
  const graphSet2 = new Set()
  const used = new Set()
  for(let k=0;k<n;k++) {
    if(used.has(k)) continue
    let isSet1 = false
    graphSet1.add(k)
    const q = [k]
    while(q.length) {
      const len = q.length
      for(let i=0;i<len;i++) {
        const num = q.shift()
        const next = graph[num]
        for(let j=0;j<next.length;j++) {
          if(isSet1) {
            graphSet1.add(next[j])
            if(graphSet2.has(next[j])) return false
          } else {
            graphSet2.add(next[j])
            if(graphSet1.has(next[j])) return false
          }
          if(!used.has(next[j])) {
            used.add(next[j])
            q.push(next[j])
          }
        }
      }
      isSet1 = !isSet1
    }
  }
  return true
};
```

## ?🌟😻✔ 788. 旋转数字【medium】

[ref](https://leetcode.cn/problems/rotated-digits/)

模拟

```js
var rotatedDigits = function(n) {
  const diffSet = new Set(['2', '5', '6', '9'])
  const errSet = new Set(['3', '4', '7'])
  let cnt = 0
  for(let i=1;i<=n;i++) {
    const str = i.toString()
    let diffNumCnt = 0
    let hasErrNum = false
    for(let j=0;j<str.length;j++) {
      if(errSet.has(str[j])) {
        hasErrNum = true
        break
      }
      if(diffSet.has(str[j])) {
        diffNumCnt++
      }
    }
    if(!hasErrNum && diffNumCnt > 0) cnt++
  }
  return cnt
};
```

## ??🌟😻✔ 792. 匹配子序列的单词数【medium】

[ref](https://leetcode.cn/problems/number-of-matching-subsequences/)

二分搜索、哈希表

题解

- [【云影同学】二分搜索思路](https://leetcode.cn/problems/number-of-matching-subsequences/solution/-by-lxfriday-ek1b/)

```js
var numMatchingSubseq = function(s, words) {
  const posMap = new Map()
  let cnt = 0
  for(let i=0;i<s.length;i++) {
    if(!posMap.has(s[i])) posMap.set(s[i], [])
    posMap.get(s[i]).push(i)
  }
  for(const word of words) {
    let shouwldAdd = false
    let idx = -1
    for(let i=0;i<word.length;i++) {
      if(!posMap.has(word[i])) break
      const idxes = posMap.get(word[i])
      if(idxes[idxes.length - 1] <= idx) break
      idx = binarSearch(idxes, idx)
      if(i === word.length - 1) shouwldAdd = true
    }
    if(shouwldAdd) {
      cnt++
    }
  }
  return cnt
};
function binarSearch(nums, target) {
  let l = 0, r = nums.length - 1
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] > target) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return nums[l]
}
```


```js
var numMatchingSubseq = function(s, words) {
  let cnt = 0
  for(const word of words) {
    let i = 0, j = 0
    while(i < s.length && j < word.length) {
      if(s[i] === word[j]) {
        j++
      }
      i++
    }
    if(j === word.length) cnt++
  }
  return cnt
};
```

## ???🌟😻✔ 793. 阶乘函数后 K 个零【hard】

[ref](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/)

二分搜索、阶乘尾部0、阶乘

题解

- [面试官，这道题我想不出来，不要offer行不行](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/solution/by-lxfriday-u8m3/)

```js
// 时间复杂度：O((logK)^2)
// 空间复杂度：O(1)
var preimageSizeFZF = function(k) {
  return f(k + 1) - f(k)
};

function f(k) {
  let l = 0, r = 5 * k
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    const count = getZeroCount(mid)
    if(count < k) {
      l = mid + 1
    } else {
      r = mid
    }
  }
  return r
}

// 时间复杂度：O(logN)
function getZeroCount(n) {
  let res = 0
  while(n !== 0) {
    n = Math.floor(n / 5)
    res += n
  }
  return res
}
```

## 🌟✔ 796. 旋转字符串【easy】

[ref](https://leetcode.cn/problems/rotate-string/submissions/)

略有趣

```js
var rotateString = function(s, goal) {
  return s.length === goal.length && (s + s).includes(goal)
};
```

or

```js
var rotateString = function(s, goal) {
  for(let i=1;i<=s.length;i++) {
     if(s === goal) return true
     const sA = s.split('')
     sA.push(sA.shift())
     s = sA.join('')
  }
  return false
};
```

## ?🌟😻✔ 797. 所有可能的路径【medium】

[ref](https://leetcode.cn/problems/all-paths-from-source-to-target/)

图、深度优先搜索、DFS

```js
// 从结果分析时间复杂度
// 可以把路径看成0,1,2...n-1的数列，中间的节点可以选择出不出现在路径，所以路径数是2的n次方
// 时间复杂度：O(N*2^N)
// 空间复杂度：O(N)
var allPathsSourceTarget = function(graph) {
  const n = graph.length
  const res = []
  function dfs(i, path) {
    if(i === n - 1) {
      res.push([...path, n - 1])
      return
    }
    const next = graph[i]
    if(next.length) {
      path.push(i)
      for(let k=0;k<next.length;k++) {
        dfs(next[k], path)
      }
      path.pop()
    }
  }
  dfs(0, [])
  return res
};
```

## ???🌟😻✔ 801. 使序列递增的最小交换次数【hard】

[ref](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var minSwap = function(nums1, nums2) {
  const n = nums1.length, dp = new Array(n).fill(0).map(_ => new Array(2).fill(Number.MAX_SAFE_INTEGER))
  dp[0][0] = 0
  dp[0][1] = 1
  for(let i=1; i< n;i++) {
    if(nums1[i] > nums1[i-1] && nums2[i] > nums2[i-1]) {
      dp[i][0] = dp[i-1][0]
      dp[i][1] = dp[i-1][1] + 1
    }
    if(nums1[i] > nums2[i-1] && nums2[i] > nums1[i-1]) {
      dp[i][0] = Math.min(dp[i-1][1], dp[i][0])
      dp[i][1] = Math.min(dp[i-1][0] + 1, dp[i][1])
    }
  }
  return Math.min(...dp[n - 1])
};
```

## 🌟😻✔ 807. 保持城市天际线【medium】

[ref](https://leetcode.cn/problems/max-increase-to-keep-city-skyline/)

矩阵、模拟

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var maxIncreaseKeepingSkyline = function(grid) {
  const n = grid.length, rowMax = new Array(n).fill(0), colMax = new Array(n).fill(0)
  for(let i=0;i<n;i++) {
    for(let j=0;j<n;j++) {
      rowMax[i] = Math.max(rowMax[i], grid[i][j])
      colMax[j] = Math.max(colMax[j], grid[i][j])
    }
  }
  let cnt = 0
  for(let i=0;i<n;i++) {
    for(let j=0;j<n;j++) {
      cnt += Math.min(rowMax[i], colMax[j]) - grid[i][j]
    }
  }
  return cnt
};
```

## 🌟😻✔ 811. 子域名访问计数【medium】

[ref](https://leetcode.cn/problems/subdomain-visit-count/)

哈希表

```js
var subdomainVisits = function(cpdomains) {
  const map = new Map(), n = cpdomains.length
  for(let i = 0;i < n; i++) {
    const [cnt, domain] = cpdomains[i].split(' ')
    const ds = domain.split('.')
    const subs = [ds[ds.length - 1], `${ds[ds.length - 2]}.${ds[ds.length - 1]}`]
    if(ds.length === 3) {
      subs.push(ds.join('.'))
    }
    for(let c of subs) {
      map.set(c, (map.get(c) || 0) + Number(cnt))
    }
  }
  const res = []
  for(const [domain, cnt] of map.entries()) {
    res.push(`${cnt} ${domain}`)
  }
  return res
};
```

## 🌟😻✔ 814. 二叉树剪枝【medium】

[ref](https://leetcode.cn/problems/binary-tree-pruning/)

二叉树、二叉树减枝

```js
var pruneTree = function(root) {
  function dfs(node) {
    if(node.left && !dfs(node.left)) {
      node.left = null   
    }
    if(node.right && !dfs(node.right)) {
      node.right = null
    }
    if(!node.left && !node.right && node.val === 0) return null
    return node
  }
  return dfs(root)
};
```

## ??🌟😻✔ 815 公交路线【hard】

[ref](https://leetcode.cn/problems/bus-routes/)

BFS、图

```js
var numBusesToDestination = function(routes, source, target) {
  // 还有这种恶心人的 case?，直接给我滚蛋
  if(source === target) return 0
  // 一个站点有哪几条公交线路经过
  const pointMap = new Map()
  // 公交路线交叉图
  const crossMap = new Map()
  // 能够从哪些公交路线开始
  const startArr = []
  // 能够结束于哪些公交路线
  const endSet = new Set()
  for(let i = 0;i < routes.length; i++) {
    const l = routes[i].length
    if(l === 1) continue
    for(let j = 0;j < l;j++) {
      if(routes[i][j] === target) {
        endSet.add(i)
      }
      if(routes[i][j] === source) {
        startArr.push(i)
      }
      if(pointMap.has(routes[i][j])) {
        pointMap.get(routes[i][j]).push(i)
      } else {
        pointMap.set(routes[i][j], [i])
      }
    }
  }
  // 没有开始的公交线路或者没有到达结束点的公交线路 直接 return
  if(!startArr.length || !endSet.size) return -1
  // 构建公交路线交叉图
  for(let rs of pointMap.values()) {
    for(let i=0;i<rs.length;i++) {
      for(let j=0;j<rs.length;j++) {
        if(i === j) continue
        if(crossMap.has(rs[i])) {
          crossMap.get(rs[i]).add(rs[j])
        } else {
          crossMap.set(rs[i], new Set([rs[j]]))
        }
      }
    }
  }
  // BFS 从开始线路往外扩展，搜到第一个结束线路即可认为结束了
  let q = startArr
  let next = []
  let min = 1
  const passed = new Set()
  while(q.length) {
    const cr = q.shift()
    if(endSet.has(cr)) return min
    if(!passed.has(cr)) {
      if(crossMap.has(cr)) {
        next = [...next, ...crossMap.get(cr)]
      }
      passed.add(cr)
    }
    if(!q.length && next.length > 0) {
      min++
      q = next
      next = []
    }
  }
  return -1
};

```

## 🌟😻✔ 817. 链表组件【medium】

[ref](https://leetcode.cn/problems/linked-list-components/)

链表

```js
// 时间复杂度：O(N) N=head.length
// 空间复杂度：O(M) M = nums.length
var numComponents = function(head, nums) {
  const numsSet = new Set(nums)
  let cnt = 0, hasPrev = false
  while(head) {
    if(numsSet.has(head.val)) {
      if(!hasPrev) {
        hasPrev = true
        cnt++
      }
    } else {
      hasPrev = false
    }
    head = head.next
  }
  return cnt
};
```

## ???🌟😻✔ 827. 最大人工岛【hard】

[ref](https://leetcode.cn/problems/making-a-large-island/)

矩阵、深度优先搜索

题解

- [云影同学】一种比较骚的常规解法](https://leetcode.cn/problems/making-a-large-island/solution/yi-chong-bi-jiao-sao-de-jie-fa-by-lxfrid-bfco/)

```js
var largestIsland = function(grid) {
  const n = grid.length
  let max = 0
  const used = new Array(n).fill(false).map(_ => new Array(n).fill(false))
  let isLandId = 0
  for(let i=0;i<n;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 1 && !used[i][j]) {
        const s = getS(i, j)
        setS(i, j, s, isLandId++)
      }
    }
  }
  let reversed = false
  const directs = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  for(let i=0;i<n;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 0) {
        reversed = true
        const set = new Set()
        let s = 1
        for(let k=0;k<4;k++) {
          const ii = directs[k][0] + i, jj = directs[k][1] + j
          if(ii>=0 && ii<n && jj>=0 && jj<n&& typeof grid[ii][jj] !== 'number' && !set.has(grid[ii][jj].id)) {
            set.add(grid[ii][jj].id)
            s += grid[ii][jj].s
          }
        }
        max = Math.max(max, s)
      }
    }
  }

  function getS(i, j) {
    if(i < 0 || i >= n || j < 0 || j >= n || used[i][j] || grid[i][j] === 0) return 0
    let s = 1
    used[i][j] = true
    s += getS(i + 1, j) + getS(i - 1, j) + getS(i, j + 1) + getS(i, j - 1)
    return s
  }

  function setS(i, j, s, id) {
    if(i < 0 || i >= n || j < 0 || j >= n || typeof grid[i][j] !== 'number' || grid[i][j] === 0) return
    grid[i][j] = {s, id}
    setS(i + 1, j, s, id)
    setS(i - 1, j, s, id)
    setS(i, j + 1, s, id)
    setS(i, j - 1, s, id)
  }

  return reversed ? max : n * n
};
```

## ???🌟😻✔ 828. 统计子串中的唯一字符【hard】

[ref](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/)

哈希表、子字符串

相关题目：

- ??? [🌟【hard】828. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/) 字符串、哈希表
- ?[🌟【medium】907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/) 数组、单调栈
- ?[🌟【medium】2104. 子数组范围和](https://leetcode.cn/problems/sum-of-subarray-ranges/) 数组、单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var uniqueLetterString = function(s) {
  let ans = 0, arr = new Array(26).fill(0).map(_ => [-1]), n = s.length
  for(let i = 0; i < n; ++i) arr[s.charCodeAt(i)-65].push(i)
  for(let i=0; i <= 25; ++i) arr[i].push(n)
  for(let i=0; i <= 25; ++i) {
    let m = arr[i].length-1
    for(let j = 1; j < m; ++j) ans += (arr[i][j] - arr[i][j-1]) * (arr[i][j+1] - arr[i][j])
  }
  return ans
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var uniqueLetterString = function(s) {
  const n = s.length, l = new Array(n).fill(-1), r = new Array(n).fill(n)
  let map = new Map()
  for(let i=0;i<n;i++) {
    l[i] = map.has(s[i]) ? map.get(s[i]) : -1
    map.set(s[i], i)
  }
  map = new Map()
  for(let i=n-1;i>=0;i--) {
    r[i] = map.has(s[i]) ? map.get(s[i]) : n
    map.set(s[i], i)
  }
  let res = 0
  for(let i=0;i<n;i++) res += (i - l[i]) * (r[i] - i)
  return res
};
```

## ✔ 832. 翻转图像【easy】

[ref](https://leetcode.cn/problems/flipping-an-image/)

矩阵

```js
var flipAndInvertImage = function(image) {
  const m = image.length, n = image[0].length
  for(let i=0;i<m;i++) {
    let l = 0, r = n - 1
    while(l < r) {
      const t = image[i][l]
      image[i][l] = image[i][r]
      image[i][r] = t
      l++
      r--
    }
  }
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      image[i][j] = 1 - image[i][j]
    }
  }
  return image
};
```

## ? 🌟😻✔ 836. 矩形重叠【easy】

[ref](https://leetcode.cn/problems/rectangle-overlap/)

规律、模拟、反推

```js
var isRectangleOverlap = function(rec1, rec2) {
  return !(
    rec1[0] >= rec2[2] || rec2[0] >= rec1[2] || rec1[1] >= rec2[3] || rec2[1] >= rec1[3]
  )
};
```

## ?🌟😻✔ 839. 相似字符串组【hard】

[ref](https://leetcode.cn/problems/similar-string-groups/)

图、广度优先搜索

```js
var numSimilarGroups = function(strs) {
  const n = strs.length, strLen = strs[0].length, connectionArr = new Array(n).fill(0).map(_ => [])
  for(let i=0; i<n; i++) {
    for(let j=0; j<n; j++) {
      if(i !== j) {
        let diffCnt = 0, x, y
        for(let k=0;k<strLen;k++) {
          if(strs[i][k] !== strs[j][k]) {
            diffCnt++
            if(diffCnt > 2) break
            if(x === undefined) x = k
            else y = k
          }
        }
        if(diffCnt === 0 || diffCnt === 2 && (strs[i][x] === strs[j][y] && strs[i][y] === strs[j][x])) {
          connectionArr[i].push(j)
        }
      }
    }
  }
  let cnt = 0
  const used = new Array(n).fill(false)
  for(let i=0;i<n;i++) {
    if(used[i]) continue
    cnt++
    used[i] = true
    let q = [i]
    while(q.length) {
      const tq = []
      for(let j=0;j<q.length;j++) {
        const curr = q[j]
        const nexts = connectionArr[curr]
        for(const next of nexts) {
          if(!used[next]) {
            used[next] = true
            tq.push(next)
          }
        }
      }
      q = tq
    }
  }
  return cnt
};
```

## 🌟😻✔ 841. 钥匙和房间【medium】

[ref](https://leetcode.cn/problems/keys-and-rooms/)

深度优先搜索

```js
// 时间复杂度：O(N+M)
// 空间复杂度：O(N)
var canVisitAllRooms = function(rooms) {
  const n = rooms.length
  const used = new Set()
  function dfs(roomId) {
    if(used.has(roomId)) return
    used.add(roomId)
    for(let i=0;i<rooms[roomId].length;i++) {
      dfs(rooms[roomId][i])
    }
  }
  dfs(0)
  return used.size === n
};

```

```js
// 时间复杂度：O(N+M)
// 空间复杂度：O(N)
var canVisitAllRooms = function(rooms) {
  const n = rooms.length
  const used = new Set([0])
  let q = [0]
  while(q.length) {
    const tq = []
    for(let i=0;i<q.length;i++) {
      for(let j=0;j<rooms[q[i]].length;j++) {
        const roomId = rooms[q[i]][j]
        if(!used.has(roomId)) {
          used.add(roomId)
          tq.push(roomId)
        }
      }
    }
    q = tq
  }
  return used.size === n
};
```

## 🌟😻✔ 844. 比较含退格的字符串【easy】

[ref](https://leetcode.cn/problems/backspace-string-compare/)

栈、字符串、双指针

```js
// 时间复杂度：O(M+N)
// 空间复杂度：O(M+N)
var backspaceCompare = function(s, t) {
  const stack1 = [], stack2 = []
  for(let i=0;i<s.length;i++) {
    if(s[i] === '#') stack1.pop()
    else stack1.push(s[i])
  }
  for(let i=0;i<t.length;i++) {
    if(t[i] === '#') stack2.pop()
    else stack2.push(t[i])
  }
  return stack1.join('') === stack2.join('')
};
```

## 🌟😻✔ 845. 数组中的最长山脉【medium】

[ref](https://leetcode.cn/problems/longest-mountain-in-array/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var longestMountain = function(arr) {
  let max = 0
  const n = arr.length
  for(let i=1;i<n - 1;i++) {
    if(arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {
      let l = i - 1, r = i + 1
      while(l - 1 >= 0 && arr[l - 1] < arr[l]) l--
      while(r + 1 < n && arr[r + 1] < arr[r]) r++
      max = Math.max(max, r - l + 1)
    }
  }
  return max
};
```

## ???🌟😻✔ 850. 矩形面积 II【hard】

[ref](https://leetcode.cn/problems/rectangle-area-ii/)

扫描线

```js
var rectangleArea = function(rectangles) {
  const mod = BigInt(10 ** 9 + 7)
  const xArr = []
  for(let i=0;i<rectangles.length;i++) {
    const [x1, y1, x2, y2] = rectangles[i]
    xArr.push(x1)
    xArr.push(x2)
  }
  xArr.sort((a, b) => a - b)
  let s = 0n
  for(let i=1;i<xArr.length;i++) {
    const a = xArr[i - 1], b = xArr[i], xLen = b - a
    if(xLen === 0) continue
    const lines = []
    for(let rect of rectangles) {
      if(rect[0] <= a && rect[2] >= b) lines.push([rect[1], rect[3]])
    }
    lines.sort((a, b) => a[0] - b[0] || a[1] - b[1])
    let hSum = 0
    let max =-1
    for(let j=0;j<lines.length;j++) {
      if(lines[j][0] >= max) {
        hSum += lines[j][1] - lines[j][0]
        max = lines[j][1]
        min = lines[j][0]
      } else if(lines[j][1] > max) {
        hSum += lines[j][1] - max
        max = lines[j][1]
      }
    }
    const newS = BigInt(xLen) * BigInt(hSum)
    s += newS
    s = s % mod
  }
  return s
};
```

## ?🌟😻✔ 852. 山脉数组的峰顶索引【medium】

[ref](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

二分搜索、二分法

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var peakIndexInMountainArray = function(arr) {
  let l = 0, r = arr.length - 1
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(arr[mid] > arr[mid + 1]) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return r
};
```

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var peakIndexInMountainArray = function(arr) {
  let l = 0, r = arr.length - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(mid - 1 < 0 || arr[mid] > arr[mid - 1]) {
      l = mid + 1
    } else {
      r = mid - 1
    }
  }
  return r
};
```

## ???🌟😻✔ 854. 相似度为 K 的字符串【hard】

[ref](https://leetcode.cn/problems/k-similar-strings/)

深度优先搜索、广度优先搜索

最核心的一个规则：s1、s2 同下标处的字母相同时，则不替换（操作）该字符

```js
// 深度优先搜索
var kSimilarity = function(s1, s2) {
  const s1Arr = [], s2Arr = []
  for(let i=0;i<s1.length;i++) {
    if(s1[i] !==s2[i]) {
      s1Arr.push(s1[i])
      s2Arr.push(s2[i])
    }
  }
  if(!s1Arr.length) return 0
  let min = s1Arr.length - 1
  function dfs(startInd, cnt) {
    if(cnt >= min) return
    while(startInd < s1Arr.length && s1Arr[startInd] === s2Arr[startInd]) startInd++
    if(startInd === s1Arr.length) {
      min = Math.min(min, cnt)
      return
    }
    if(cnt + minSwap(startInd, s1Arr, s2Arr) >= min) return 
    for(let i=startInd + 1;i<s1Arr.length;i++) {
      if(s1Arr[i] === s2Arr[startInd]) {
        swap(s1Arr, i, startInd)
        dfs(startInd + 1, cnt + 1)
        swap(s1Arr, i, startInd)
      }
    }
  }
  dfs(0, 0)
  return min
};

function minSwap(startInd, s1, s2) {
  let cnt = 0
  for(let i=startInd;i<s1.length;i++) {
    if(s1[i] !== s2[i]) cnt++
  }
  return Math.floor((cnt + 1) / 2)
}

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

```js
// 广度优先搜索
var kSimilarity = function(s1, s2) {
  let q = [[s1, 0]]
  let used = new Set([s1])
  let cnt = 0
  while(q.length) {
    const tq = []
    for(let i=0;i<q.length;i++) {
      let [s, ind] = q[i]
      if(s === s2) return cnt
      while(s[ind] === s2[ind]) ind++
      for(let j=ind + 1;j<s.length;j++) {
        if(s[j] === s2[j]) continue
        if(s[j] === s2[ind]) {
          const newStr = swap(s, ind, j)
          if(!used.has(newStr)) {
            used.add(newStr)
            tq.push([newStr, ind + 1])
          }
        }
      }
    }
    cnt++
    q = tq
  }
};

function swap(str, i, j) {
  const arr = str.split('')
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
  return arr.join('')
}
```

## 🌟😻✔ 856. 括号的分数【medium】

[ref](https://leetcode.cn/problems/score-of-parentheses/)

递归、栈

```js
var scoreOfParentheses = function(s) {
  const stack = [0]
  for(let c of s) {
    if(c === '(') stack.push(0)
    else {
      const curr = stack.pop()
      stack.push(stack.pop() + Math.max(1, 2 * curr))
    }
  }
  return stack.pop()
};
```

```js
var scoreOfParentheses = function(s) {
  return calc(s, 0, s.length - 1)
};
function calc(s, l, r) {
  if(l > r) return 0
  let sum = 0, lCnt = 0, rCnt = 0, i = l
  while(i<=r) {
    if(s[i] === '(') lCnt++
    else rCnt++
    if(lCnt === rCnt) break
    i++
  }
  if(i === l + 1) {
    sum += 1
    sum += calc(s, i + 1, r)
  } else {
    sum += 2 * calc(s, l + 1, i - 1)
    sum += calc(s, i + 1, r)
  }
  return sum
}
```

## ???🌟😻✔ 857. 雇佣 K 名工人的最低成本【hard】

[ref](https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/)

优先队列、大顶堆、堆

题解：

- [【云影同学】从资本家的角度来考虑贪心问题，优先队列解法](https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/solution/by-lxfriday-bp0m/)


```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var mincostToHireWorkers = function(quality, wage, k) {
  const n = quality.length, wqArr = []
  const maxHeap = new MaxHeap()
  for(let i=0;i<n;i++) {
    // 生成资质比数组，附带对应的数组下标
    wqArr[i] = [wage[i] / quality[i], i]
  }
  // 按资质比从小到大排序，资质比越小的员工资本家获利越多，资本家所需要支出的月总工资支出也会越少嘛
  wqArr.sort((a, b) => a[0] - b[0])
  let qTotal = 0
  let res = Number.MAX_SAFE_INTEGER
  for(let i=0;i<n;i++) {
    const [wq, ind] = wqArr[i], q = quality[ind]
    qTotal += q
    maxHeap.insert(q)
    if(maxHeap.size() > k) (qTotal -= maxHeap.pop())
    if(maxHeap.size() === k) res = Math.min(res, qTotal * wq)
  }
  return res
};


class MaxHeap {
  constructor() {
    this.heap = []
  }
  insert(v){
    this.heap.push(v)
    this.shiftUp(this.size() - 1)
  }
  pop(){
    this.swap(0, this.size() - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  swap(i, j){
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  size(){
    return this.heap.length
  }
  shiftUp(i){
    const pI = Math.floor((i - 1) / 2)
    if(pI >= 0 && this.heap[pI] < this.heap[i]) {
      this.swap(i, pI)
      this.shiftUp(pI)
    }
  }
  shiftDown(i){
    const lI = 2 * i + 1, rI = 2 * i + 2
    let maxI = i
    if(lI < this.size() && this.heap[lI] > this.heap[maxI]) {
      maxI = lI
    }
    if(rI < this.size() && this.heap[rI] > this.heap[maxI]) {
      maxI = rI
    }
    if(maxI !== i) {
      this.swap(i, maxI)
      this.shiftDown(maxI)
    }
  }
}
```

## 🌟😻✔ 860. 柠檬水找零【easy】

[ref](https://leetcode.cn/problems/lemonade-change/)

贪心

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var lemonadeChange = function(bills) {
  let cnt5 = 0, cnt10 = 0
  for(const bill of bills) {
    if(bill === 5) cnt5++
    else if(bill === 10) {
      if(cnt5 === 0) return false
      cnt5--
      cnt10++
    } else {
      if(cnt5 === 0) return false
      if(cnt10) {
        cnt10--
        cnt5--
      } else {
        if(cnt5 < 3) return false
        cnt5 -= 3
      }
    }
  }
  return true
};
```

## ?🌟😻✔ 862 和至少为 K 的最短子数组【hard】

[ref](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)


单调队列、前缀数组、滑动窗口、双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var shortestSubarray = function(nums, k) {
  const len = nums.length
  let min = Number.MAX_SAFE_INTEGER
  let P = new Array(len + 1).fill(0) // 前缀数组
  let S = [] // 下标单调队列
 
  for(let i=0;i<len;i++) {
    P[i + 1] = P[i] + nums[i]
  }

  for(let i=0;i<len;i++) {
    while(S.length > 0 && P[i] < P[S[S.length - 1]]) {
      S.pop()
    }
    S.push(i)

    while(S.length && P[i] + nums[i] - P[S[0]] >= k) {
      min = Math.min(min, i - S.shift() + 1)
    }
  }

  return min === Number.MAX_SAFE_INTEGER ? -1 : min
};
```

or

```js
var shortestSubarray = function(nums, k) {
  const len = nums.length
  let l = 0
  let r = 0
  let min = Number.MAX_SAFE_INTEGER
  let sum = 0

  while(r < len) {
    sum += nums[r]
    if(sum >= k) {
      let tS = 0
      for(let j=r;j>=l;j--) {
        tS += nums[j]
        if(tS >= k) {
          l = j
          sum = tS
          break
        }
      }
      min = Math.min(r - l + 1, min)
    } else {
      while((nums[l] <= 0 || sum <= 0) && l <= r) {
        sum -= nums[l]
        l++
      }
    }
    r++
  }

  return min === Number.MAX_SAFE_INTEGER ? -1 : min
};
```

## ??🌟😻✔ 863. 二叉树中所有距离为 K 的结点【medium】

[ref](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/)

二叉树、图、深度优先搜索、广度优先搜索

```js
var distanceK = function(root, target, k) {
  function rewrite(node) {
    if(node.left) {
      node.left.parent = node
      rewrite(node.left)
    }
    if(node.right) {
      node.right.parent = node
      rewrite(node.right)
    }
  }
  rewrite(root)
  const res = [], used = new Set()
  used.add(target)
  function walk(node, dis) {
    if(dis === k) {
      res.push(node.val)
      return
    }
    if(node.left && !used.has(node.left)) {
      used.add(node.left)
      walk(node.left, dis +1)
    }
    if(node.right && !used.has(node.right)) {
      used.add(node.right)
      walk(node.right, dis +1)
    }
    if(node.parent && !used.has(node.parent)) {
      used.add(node.parent)
      walk(node.parent, dis +1)
    }
  }
  walk(target, 0)
  return res
};
```

```js
var distanceK = function(root, target, k) {
  function rewrite(node) {
    if(node.left) {
      node.left.parent = node
      rewrite(node.left)
    }
    if(node.right) {
      node.right.parent = node
      rewrite(node.right)
    }
  }
  rewrite(root)
  const res = [], used = new Set([target])
  let q = [[target, 0]]
  while(q.length) {
    const tq = []
    for(let i=0;i<q.length;i++) {
      const [node, depth] = q[i]
      if(depth === k) res.push(node.val)
      if(depth < k) {
        if(node.left && !used.has(node.left)) {
          used.add(node.left)
          tq.push([node.left, depth + 1])
        }
        if(node.right && !used.has(node.right)) {
          used.add(node.right)
          tq.push([node.right, depth + 1])
        }
        if(node.parent && !used.has(node.parent)) {
          used.add(node.parent)
          tq.push([node.parent, depth + 1])
        }
      }
    }
    q = tq
  }
  return res
};
```

## 🌟😻✔ 870. 优势洗牌【medium】

[ref](https://leetcode.cn/problems/advantage-shuffle/)

数组题、排序

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN) 不算返回的res数组
var advantageCount = function(nums1, nums2) {
  const n = nums2.length
  nums1.sort((a, b) => a - b)
  for(let j=0;j<n;j++) {
    nums2[j] = {idx:j, v:nums2[j]}
  }
  nums2.sort((a, b) => a.v - b.v)
  const res = new Array(n)
  const tmp = []
  let i = 0, j = 0
  while(i < n) {
    if(nums1[i] > nums2[j].v) {
      res[nums2[j].idx] = nums1[i]
      j++
    } else {
      tmp.push(nums1[i])
    }
    i++
  }
  for(let i=0;i<n;i++) {
    if(res[i] === undefined) res[i] = tmp.pop()
  }
  return res
};
```

## ?🌟😻✔ 875. 爱吃香蕉的珂珂【medium】

[ref](https://leetcode.cn/problems/koko-eating-bananas/)

二分搜索

```js
// 时间复杂度：O(NlogM) M=max(piles)
// 空间复杂度：O(1)
var minEatingSpeed = function(piles, h) {
  let low = 1, high = 1
  for(const pile of piles) {
    high = Math.max(high, pile)
  }
  while(low < high) {
    const mid = Math.floor((low + high) / 2)
    const time = getTime(mid, piles)
    if(time <= h) {
      high = mid
    } else {
      low = mid + 1
    }
  }
  return high
};

function getTime(speed, piles) {
  let time = 0
  for(const pile of piles) {
    time += Math.ceil(pile / speed)
  }
  return time
}
```

## ✔ 876. 链表的中间结点【easy】

[ref](https://leetcode.cn/problems/middle-of-the-linked-list/)

链表、双指针、快慢指针

```js
var middleNode = function(head) {
  const myHead = new ListNode(0, head)
  let fast = myHead, slow = myHead
  while(fast.next && fast.next.next) {
    fast = fast.next.next
    slow = slow.next
  }
  return slow.next
};
```

## ??🌟😻✔ 879 盈利计划【hard】

[ref](https://leetcode.cn/problems/profitable-schemes/)

动态规划、多维背包问题

```js
// 特殊的多维费用背包问题
var profitableSchemes = function(n, minProfit, group, profit) {
  const mod = 10 ** 9 + 7
  const len = group.length
  const dp = new Array(n + 1).fill(0)
              .map(_ => new Array(len + 1).fill(0)
              .map(__ => new Array(minProfit + 1).fill(0)))

  for(let i=0;i<=n;i++) {
    dp[i][0][0] = 1
  }

  for(let i=0;i<=n;i++) {
    for(let j=1;j<=len;j++) {
      const p = profit[j-1]
      const g = group[j-1]
      for(let k=0;k<=minProfit;k++) {
        dp[i][j][k] = dp[i][j - 1][k]
        if(i >= g) {
          dp[i][j][k] += dp[i - g][j - 1][Math.max(k - p, 0)]
          if(dp[i][j][k] >= mod) {
            dp[i][j][k] -= mod
          }
        }
      }
    }
  }
  return dp[n][len][minProfit]
};

```

## ??🌟😻✔ 881. 救生艇【medium】

[ref](https://leetcode.cn/problems/boats-to-save-people/)

贪心

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var numRescueBoats = function(people, limit) {
  people.sort((a, b) => a - b)
  let cnt = 0
  let l = 0, r = people.length -1
  while(l <= r) {
    if(l < r && people[r] + people[l] <= limit) {
      l++
    }
    cnt++
    r--
  }
  return cnt
};

```

## 🌟😻✔ 886. 可能的二分法【medium】

[ref](https://leetcode.cn/problems/possible-bipartition/)

图、深度优先搜索、广度优先搜索

```js
var possibleBipartition = function(n, dislikes) {
  const disLikeMap = new Map()
  for(const pair of dislikes) {
    const [a, b] = pair
    if(!disLikeMap.has(a)) disLikeMap.set(a, new Set())
    if(!disLikeMap.has(b)) disLikeMap.set(b, new Set())
    disLikeMap.get(a).add(b)
    disLikeMap.get(b).add(a)
  }
  const colors = new Array(n + 1).fill(0)
  for(let i=1;i<=n;i++) {
    if(colors[i] !== 0) continue
    colors[i] = 1
    let q = [[i, 1]]
    while(q.length) {
      const tq = []
      for(let j=0;j<q.length;j++) {
        const [curr, pos] = q[j]
        const nexts = disLikeMap.get(curr)
        if(nexts) {
          const nextPos = -pos
          for(const next of nexts) {
            if(colors[next] !== 0) {
              if(colors[next] !== nextPos) return false
            } else {
              colors[next] = nextPos
              tq.push([next, nextPos])
            }
          }
        }
      }
      q = tq
    }
  }
  return true
};

```

## 🌟😻✔ 904. 水果成篮【medium】

[ref](https://leetcode.cn/problems/fruit-into-baskets/)

双指针、滑动窗口

```js
// 时间复杂度：O(N)
// 空间复杂度：O(M) M 最大为2 
var totalFruit = function(fruits) {
  const map = new Map(), n = fruits.length
  let max = 0
  let l = 0, r = 0
  let cnt = 0
  while(r < n) {
    if(!map.has(fruits[r])) {
      while(map.size === 2) {
        map.set(fruits[l], map.get(fruits[l]) - 1)
        if(map.get(fruits[l]) === 0) {
          map.delete(fruits[l])
        }
        l++
        cnt--
      }
    }
    map.set(fruits[r], (map.get(fruits[r]) || 0) + 1)
    cnt++
    max = Math.max(max, cnt)
    r++
  }
  return max
};
```

## 😻✔ 905. 按奇偶排序数组【easy】

[ref](https://leetcode.cn/problems/sort-array-by-parity/)

排序、数组题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var sortArrayByParity = function(nums) {
  let j = 0
  for(let i=0;i<nums.length;i++) {
    if(nums[i] % 2 === 0) {
      swap(nums, i, j)
      j++
    }
  }
  return nums
};

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

## ?🌟😻✔ 907. 子数组的最小值之和【medium】

[ref](https://leetcode.cn/problems/sum-of-subarray-minimums/)

单调栈、连续子数组

相关题目：

- ??? [🌟【hard】828. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/) 字符串、哈希表
- ?[🌟【medium】907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/) 数组、单调栈
- ?[🌟【medium】2104. 子数组范围和](https://leetcode.cn/problems/sum-of-subarray-ranges/) 数组、单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var sumSubarrayMins = function(arr) {
  const mod = 10 ** 9 + 7
  const n = arr.length, l = new Array(n).fill(-1), r = new Array(n).fill(n)
  let stack = []
  for(let i=0;i<n;i++) {
    while(stack.length && arr[stack[stack.length - 1]] >= arr[i]) {
      stack.pop()
    }
    if(stack.length) {
      l[i] = stack[stack.length - 1]
    }
    stack.push(i)
  }
  stack = []
  for(let i=n-1;i >= 0; i--) {
    while(stack.length && arr[stack[stack.length - 1]] > arr[i]) {
      stack.pop()
    }
    if(stack.length) {
      r[i] = stack[stack.length - 1]
    }
    stack.push(i)
  }
  let res = 0
  for(let i=0;i<n;i++) {
    res = (res + arr[i] * (i - l[i]) * (r[i] - i)) % mod
  }
  return res 
};

```

## 🌟😻✔ 921. 使括号有效的最少添加【medium】

[ref](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)

栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var minAddToMakeValid = function(s) {
  const stack = []
  for(let i=0;i<s.length;i++) {
    if(s[i] === '(') {
      stack.push(s[i])
    } else {
      if(stack.length && stack[stack.length - 1] === '(') {
        stack.pop()
      } else {
        stack.push(')')
      }
    }
  }
  return stack.length
};

```

## ???🌟😻✔ 927. 三等分【medium】

[ref](https://leetcode.cn/problems/three-equal-parts/)

模拟

找数字的关键在于第三段，第三段由于1的个数已经确定，所以第三段的首个1的位置是确定的，这样第三段是什么二进制排列就完全确定。

再依据第三段的二进制排列，从前两段的首个1开始比对，如果1、0的排列完全和第三段一致，且前两段的下标没有越到其它段上去，则扫描终止时，前两段的指针就是隔断的结束的地方

```js
var threeEqualParts = function(arr) {
  let oneCnt = 0
  for(const num of arr) if(num === 1) oneCnt++
  if(oneCnt % 3 !== 0) return [-1, -1]
  if(oneCnt === 0) return [0, 2]
  const oneAverage = oneCnt / 3
  let i = 0, iCnt = 0, j = arr.length - 1, jCnt = 0
  while(true) {
    if(arr[i] === 1) iCnt++
    if(iCnt === oneAverage) break
    i++
  }
  while(true) {
    if(arr[j] === 1) jCnt++
    if(jCnt === oneAverage) break
    j--
  }
  let a = 0, b = i + 1, c = j
  while(arr[a] !== 1) a++
  while(arr[b] !== 1) b++
  const aMax = b - 1, bMax = c -1
  while(true) {
    if(c === arr.length) break
    if(a > aMax || b > bMax) {
      return [-1, -1]
    }
    if(arr[a] ===  arr[b] && arr[b] === arr[c]) {
      a++, b++, c++
    } else {
      return [-1, -1]
    }
  }
  a--, b--
  return [a, b + 1]
};

```

## 🌟😻✔ 931. 下降路径最小和【medium】

[ref](https://leetcode.cn/problems/minimum-falling-path-sum/)

动态规划、滚动数组

```js
// 时间复杂度：O(N^2)
// 时间复杂度：O(N)
var minFallingPathSum = function(matrix) {
  const n = matrix.length
  let dp = new Array(n).fill(0)
  let res = Number.MAX_SAFE_INTEGER
  for(let i=0;i<n;i++) {
    const tdp = []
    for(let j=0;j<n;j++) {
      if(i === 0) tdp[j] = matrix[0][j]
      else {
        tdp[j] = Math.min(
          j - 1 >= 0 ?dp[j - 1] : Number.MAX_SAFE_INTEGER, 
          dp[j], 
          j + 1 < n ? dp[j + 1] :Number.MAX_SAFE_INTEGER, 
        ) + matrix[i][j]
      }
      if(i === n - 1) {
        res = Math.min(res, tdp[j])
      }
    }
    dp = tdp
  }
  return res
};
```

## ✔ 933 最近的请求次数【easy】

[ref](https://leetcode.cn/problems/number-of-recent-calls/)

这个题的描述很容易看不懂，但是实现起来非常简单

关键词：队列

```js
var RecentCounter = function () {
  this.q = []
}
/**
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function (t) {
  this.q.push(t)
  while (t - this.q[0] > 3000) {
    this.q.shift()
  }
  return this.q.length
}
```

## ???🌟😻✔ 940. 不同的子序列 II【hard】

[ref](https://leetcode.cn/problems/distinct-subsequences-ii/)

子序列、动态规划

```js
// 时间复杂度：O(N*C^2)
// 空间复杂度：O(C)
var distinctSubseqII = function(s) {
  const mod = 10 ** 9 + 7, n = s.length
  let dp = new Array(26).fill(0), res = 0
  for(let i=1;i<=n;i++) {
    const c = s[i - 1].charCodeAt(0) - 'a'.charCodeAt(0)
    const tdp = []
    let cnt = 0
    for(let j=0;j<26;j++) {
      if(j === c) {
        let sum = 1
        for(let k=0;k<26;k++) sum = (sum + dp[k]) % mod
        tdp[j] = sum
      } else {
        tdp[j] = dp[j]
      }
      cnt = (cnt + tdp[j]) % mod
    }
    dp = tdp
    res = cnt
  }
  return res
};
```

```js
// 时间复杂度：O(N*C^2)
// 空间复杂度：O(N*C)
var distinctSubseqII = function(s) {
  const mod = 10 ** 9 + 7, n = s.length
  const dp = new Array(n + 1).fill(0).map(_ => new Array(26).fill(0))
  for(let i=1;i<=n;i++) {
    const c = s[i - 1].charCodeAt(0) - 'a'.charCodeAt(0)
    for(let j=0;j<26;j++) {
      if(j === c) {
        let sum = 1
        for(let k=0;k<26;k++) sum = (sum + dp[i-1][k]) % mod
        dp[i][j] = sum
      } else {
        dp[i][j] = dp[i-1][j]
      }
    }
  }
  let ret = 0
  for(let i=0;i<26;i++) ret = (ret + dp[n][i]) % mod
  return ret
};

```

## ?🌟😻✔ 945. 使数组唯一的最小增量【medium】

[ref](https://leetcode.cn/problems/minimum-increment-to-make-array-unique/)

排序、数组题

```js
var minIncrementForUnique = function(nums) {
  const n = nums.length
  nums.sort((a, b) => a - b)
  let res = 0
  let i=0, prevMax = nums[0] - 1
  while(i < n) {
    if(nums[i] <= prevMax) {
      res += prevMax + 1 - nums[i]
      prevMax++
    } else {
      prevMax = nums[i]
    }
    i++
  }
  return res
};
```

```js
var minIncrementForUnique = function(nums) {
  const n = nums.length
  const cntArr = []
  for(let i=0;i<n;i++) {
    cntArr[nums[i]] = (cntArr[nums[i]] || 0) + 1
  }
  let max = cntArr.length, res = 0
  for(let i=0;i<max;i++) {
    if(cntArr[i]) {
      res += cntArr[i] - 1
      cntArr[i + 1] = (cntArr[i + 1] || 0) + cntArr[i] - 1
    }
  }
  if(cntArr[max]) {
    res += cntArr[max] * (cntArr[max] - 1) / 2
  }
  return res
};
```

## 🌟😻✔ 946. 验证栈序列【medium】

[ref](https://leetcode.cn/problems/validate-stack-sequences/)

栈、模拟

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var validateStackSequences = function(pushed, popped) {
  const stack = []
  let j = 0
  for(let i=0;i<pushed.length;i++) {
    stack.push(pushed[i])
    while(stack.length && stack[stack.length - 1] === popped[j]) {
      stack.pop()
      j++
    }
  }
  return stack.length === 0
};
```

## ?🌟😻✔ 973. 最接近原点的 K 个点【medium】

[ref](https://leetcode.cn/problems/k-closest-points-to-origin/)

优先队列、快速选择、分治法、堆、前K个问题

```js
// 期望时间复杂度：O(N)
// 空间复杂度：O(N)
var kClosest = function(points, k) {
  const arr = []
  for(let i=0;i<points.length;i++) {
    const [x, y] = points[i]
    arr[i] = [x, y, x * x + y * y]
  }
  let l = 0, r = points.length - 1
  while(true) {
    const ind = partition(arr, l, r)
    if(ind === k - 1) {
      return arr.slice(0, k).map(_ => [_[0], _[1]])
    } else if(ind > k - 1) {
      r = ind - 1
    } else {
      l = ind + 1
    }
  }
};

function partition(arr, l, r) {
  const target = arr[l][2]
  let k = l + 1
  for(let i = k; i<= r; i++) {
    if(arr[i][2] <= target) {
      swap(arr, k, i)
      k++
    }
  }
  swap(arr, k - 1, l)
  return k - 1
}

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

## ?🌟😻✔ 974. 和可被 K 整除的子数组【medium】

[ref](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)

前缀、前缀和、前缀数组

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var subarraysDivByK = function(nums, k) {
  const n = nums.length, map = new Map([[0, 1]])
  let sum = 0
  let cnt = 0
  for(let i=0;i<n;i++) {
    sum = ((nums[i] + sum) % k + k) % k
    if(map.has(sum)) {
      cnt += map.get(sum)
    }
    map.set(sum, (map.get(sum) || 0) + 1)
  }
  return cnt
};
```

## 🌟✔ 977 有序数组的平方【easy】

[ref](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```js
// 时间复杂度：O(N)
// 时间复杂度：O(1)
var sortedSquares = function(nums) {
  const len = nums.length
  let l = 0, r = len - 1
  const res = []
  while(l<=r) {
    if(Math.abs(nums[l]) >= Math.abs(nums[r])) {
      res.unshift(nums[l] ** 2)
      l++
    } else {
      res.unshift(nums[r] ** 2)
      r--
    }
  }
  return res
};
```

## 🌟😻✔ 978. 最长湍流子数组【medium】

[ref](https://leetcode.cn/problems/longest-turbulent-subarray/)

数组题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxTurbulenceSize = function(arr) {
  let l = 0, r = 1, max = 1
  const n = arr.length
  while(r < n) {
    if(arr[r] === arr[r - 1]) {
      l = r
    } else if(arr[r] > arr[r - 1]) {
      if(r - 2 < l || arr[r - 1] < arr[r - 2]) {
        max = Math.max(max, r - l + 1)
      } else {
        l = r - 1
      }
    } else {
      if(r - 2 < l || arr[r - 1] > arr[r - 2]) {
        max = Math.max(max, r - l + 1)
      } else {
        l = r - 1
      }
    }
    r++
  }
  return max
};
```

## 🌟😻✔ 980. 不同路径 III【hard】

[ref](https://leetcode.cn/problems/unique-paths-iii/)

回溯法

```js
// 时间复杂度：O(4^MN)
// 空间复杂度：O(MN)
var uniquePathsIII = function(grid) {
  const m = grid.length, n = grid[0].length
  let zeroCount = 0
  let res = 0
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  let start
  // 扫描获取0的个数，方便后面回溯确定终点
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 0) zeroCount++
      if(grid[i][j] === 1) start = [i, j]
    }
  }
  // 从起始点开始找路线
  walk(start[0], start[1], 0)
  function walk(i, j, count) {
    if(i < 0 || j < 0 || i >= m || j >= n || used[i][j] || grid[i][j] === -1) return
    if(grid[i][j] === 1 || grid[i][j] === 0) {
      used[i][j] = true
      walk(i - 1, j, count + 1)
      walk(i + 1, j, count + 1)
      walk(i, j - 1, count + 1)
      walk(i, j + 1, count + 1)
      used[i][j] = false
    } else {
      if(count + 1 === zeroCount + 2) {
        res++
      }
    }
  }
  return res
};
```

## ??🌟😻✔ 983. 最低票价【medium】

[ref](https://leetcode.cn/problems/minimum-cost-for-tickets/)

```js
// 时间复杂度：O(M) M=最后的那一天  days[days.length - 1]
// 空间复杂度：O(M+N)
var mincostTickets = function(days, costs) {
  const daysSet = new Set(days)
  const m = days[days.length - 1]
  const dp = new Array(m + 1)
  const [a, b, c] = costs
  dp[0] = 0
  for(let i=1;i<=m;i++) {
    const x = daysSet.has(i) ? (a + dp[i - 1]) : dp[i - 1]
    const y = (i > 7 ? dp[i - 7]: 0) + b
    const z = (i > 30 ? dp[i - 30]: 0) + c
    dp[i] = Math.min(x, y, z)
  }
  return dp[m]
};
```

## 🌟😻✔ 986. 区间列表的交集【medium】

[ref](https://leetcode.cn/problems/interval-list-intersections/)

区间问题、区间交集


```js
var intervalIntersection = function(firstList, secondList) {
  let i = 0, j = 0
  const res = []
  while(i < firstList.length && j < secondList.length) {
    const first = firstList[i], second = secondList[j]
    if(first[1] < second[0]) {
      i++
    } else if(second[1] < first[0]) {
      j++
    } else if(first[1] <= second[1]) {
      const target = [Math.max(first[0], second[0]), first[1]]
      res.push(target)
      i++
    } else {
      const target = [Math.max(first[0], second[0]), second[1]]
      res.push(target)
      j++
    }
  }
  return res
};
```

```js
var intervalIntersection = function(firstList, secondList) {
  const res = []
  while(firstList.length && secondList.length) {
    const first = firstList.shift(), second = secondList.shift()
    if(first[1] < second[0]) {
      secondList.unshift(second)
    } else if(second[1] < first[0]) {
      firstList.unshift(first)
    } else if(first[1] <= second[1]) {
      const target = [Math.max(first[0], second[0]), first[1]]
      res.push(target)
      const next = [first[1] + 1, second[1]]
      if(next[0] <= next[1]) {
        secondList.unshift(next)
      }
    } else {
      const target = [Math.max(first[0], second[0]), second[1]]
      res.push(target)
      const next = [second[1] + 1, first[1]]
      if(next[0] <= next[1]) {
        firstList.unshift(next)
      }
    }
  }
  return res
};
```

## ?🌟😻✔ 988. 从叶结点开始的最小字符串【medium】

[ref](https://leetcode.cn/problems/smallest-string-starting-from-leaf/)

二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var smallestFromLeaf = function(root) {
  let res
  function dfs(node, path) {
    if(!node.left && !node.right) {
      const target = String.fromCharCode(node.val + 97) + path
      if(!res) {
        res = target
      } else if(target < res){
        res = target
      }
      return
    }
    node.left && dfs(node.left, String.fromCharCode(node.val + 97) + path)
    node.right && dfs(node.right, String.fromCharCode(node.val + 97) + path)
  }
  dfs(root, '')
  return res
};
```

## 🌟😻✔ 990. 等式方程的可满足性【medium】

[ref](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

并查集

题解

- [【云影同学】并查集+两轮扫描](https://leetcode.cn/problems/satisfiability-of-equality-equations/solution/yun-ying-tong-xue-by-lxfriday-vy5u/)

```js
// 时间复杂度：O(N)
// 时间复杂度：O(K) K = 26
var equationsPossible = function(equations) {
  const parent = new Array(26).fill(0).map((v, i) => i)
  for(let i=0;i<equations.length;i++) {
    if(equations[i][1] + equations[i][2] === '==') {
      union(parent, getCode(equations[i], 0), getCode(equations[i], 3))
    }
  }
  for(let i=0;i<equations.length;i++) {
    if(
      equations[i][1] + equations[i][2] === '!='
      && find(parent, getCode(equations[i], 0)) === find(parent, getCode(equations[i], 3))
    ) {
      return false
    }
  }
  return true
};

function getCode(str, i) {
  return str.charCodeAt(i) - 'a'.charCodeAt(0)
}

function union(parent, ind1, ind2) {
  parent[find(parent, ind1)] = find(parent, ind2)
}

function find(parent, ind) {
  if(parent[ind] !== ind) return find(parent, parent[ind])
  return parent[ind]
}
```

## ?🌟😻✔ 991. 坏了的计算器【medium】

[ref](https://leetcode.cn/problems/broken-calculator/)

贪心

优秀题解

- [贪心算法及其证明](https://leetcode.cn/problems/broken-calculator/solution/tan-xin-suan-fa-ji-qi-zheng-ming-by-lenn123/)

```js
// 时间复杂度：O(logY)
// 空间复杂度：O(1)
var brokenCalc = function(X, Y) {
  let res = 0
  while(X < Y) {
    res++
    if(Y % 2) {
      Y++
    } else {
      Y /= 2
    }
  }
  res += X - Y
  return res
};

```

## ?🌟😻✔ 994. 腐烂的橘子【medium】

[ref](https://leetcode.cn/problems/rotting-oranges/)

广度优先、深度优先、BFS、DFS

```js
// 广度优先搜索写法
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var orangesRotting = function(grid) {
  const m = grid.length
  const n = grid[0].length
  const q = []
  let cnt = 0
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 2) q.push([i, j, 0])
      else if(grid[i][j] === 1) cnt++
    }
  }
  const dots = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  let maxH = 0
  while(q.length) {
    let len = q.length
    for(let k=0;k<len;k++) {
      const [i, j, h] = q.shift()
      for(let kk=0;kk<4;kk++) {
        const ii = i + dots[kk][0], jj = j + dots[kk][1]
        if(ii < 0 || jj < 0 || ii >= m || jj >= n || grid[ii][jj] !== 1) continue
        cnt--
        grid[ii][jj] = 2
        q.push([ii, jj, h + 1])
        maxH = Math.max(maxH, h + 1)
      }
    }
  }
  return cnt === 0? maxH : -1
};
```

```js
// 深度优先搜索、烂代码
// 时间复杂度：O((MN)^2)
// 空间复杂度：O(MN)
var orangesRotting = function(grid) {
  const m = grid.length
  const n = grid[0].length
  const timeUse = new Array(m).fill(0).map(_ => new Array(n).fill(Number.MAX_SAFE_INTEGER))
  const used = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 2) {
        walk(i, j, 0)
      }
    }
  }

  function walk(i, j, t) {
    if(i < 0 || j < 0 || i >= m || j >= n || used[i][j] || grid[i][j] === 0) return
    if(grid[i][j] === 2 && t !== 0) return
    timeUse[i][j] = Math.min(timeUse[i][j], t)
    used[i][j] = true
    walk(i - 1, j, t + 1)
    walk(i + 1, j, t + 1)
    walk(i, j - 1, t + 1)
    walk(i, j + 1, t + 1)
    used[i][j] = false
  }
  let max = 0
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 1) {
        if(timeUse[i][j] === Number.MAX_SAFE_INTEGER) return -1
        max = Math.max(max, timeUse[i][j])
      }
    }
  }
  return max
};
```

## 🌟😻✔ 998. 最大二叉树 II【medium】

[ref](https://leetcode.cn/problems/maximum-binary-tree-ii/)


题解
- [【云影同学】递归迭代两种解法](https://leetcode.cn/problems/maximum-binary-tree-ii/solution/3h-by-lxfriday-rel9/)

```js
// 迭代
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var insertIntoMaxTree = function(root, val) {
  let prev = null
  let node = root
  while(node && node.val > val) {
    prev = node
    node = node.right
  }
  const newNode = new TreeNode(val, node)
  if(!prev) {
    return newNode
  }
  prev.right = newNode
  return root
};
```

```js
//递归
// 利用题目给的规律
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var insertIntoMaxTree = function(root, val) {
  if(!root || val > root.val) {
    root = new TreeNode(val, root)
  } else {
    root.right = insertIntoMaxTree(root.right, val)
  }
  return root
};
```

```js
// 暴力拆解二叉树，再重组二叉树
var insertIntoMaxTree = function(root, val) {
  function extract(node) {
    if(!node) return []
    const left = extract(node.left)
    const right = extract(node.right)
    return [...left, node.val, ...right]
  }
  const nums = extract(root)
  nums.push(val)
  function create(l, r) {
    if(l > r) return null
    let maxi = l
    for(let i=l + 1;i<=r;i++) {
      if(nums[i] > nums[maxi]) maxi = i
    }
    const node = new TreeNode(nums[maxi])
    node.left = create(l, maxi - 1)
    node.right = create(maxi + 1, r)
    return node
  }
  return create(0, nums.length - 1)
};
```

## ?🌟😻✔ 1004. 最大连续1的个数 III【medium】

[ref](https://leetcode.cn/problems/max-consecutive-ones-iii/)

双指针、滑动窗口

```js
var longestOnes = function(nums, k) {
  let l = 0, r = 0
  let max = 0
  while(r < nums.length) {
    if(nums[r] === 1) {
      max = Math.max(max, r - l + 1)
    } else {
      if(k > 0) {
        k--
        max = Math.max(max, r - l + 1)
      } else {
        while(l < r && nums[l] !== 0) l++
        l++
      }
    }
    r++
  }
  return max
};
```

## 🌟😻✔ 1005. K 次取反后最大化的数组和【easy】

[ref](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

贪心

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var largestSumAfterKNegations = function(nums, k) {
  nums.sort((a, b) => a - b)
  const n = nums.length
  let sum = 0, absMin = Number.MAX_SAFE_INTEGER
  for(let i=0;i<n;i++) {
    if(nums[i] < 0 && k > 0) {
      nums[i] = -nums[i]
      k--
    }
    sum += nums[i]
    absMin = Math.min(absMin, nums[i])
  }
  if(k <= 0 || k % 2 === 0) return sum
  return sum - 2 * absMin
};
```

## 🌟😻✔ 1011. 在 D 天内送达包裹的能力【medium】

[ref](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)

二分搜素

```js
// 时间复杂度：O(NlogSum) Sum = weights 总和
// 空间复杂度：O(1)
var shipWithinDays = function(weights, days) {
  let l = Number.MIN_SAFE_INTEGER, r = 0
  for(const w of weights) {
    l = Math.max(w, l)
    r += w
  }

  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(canCarry(mid)) {
      r = mid
    } else {
      l = mid + 1
    }
  }

  return r

  function canCarry(capacity) {
    let sum = 0
    let d = 0
    for(let i=0;i<weights.length;i++) {
      const w = weights[i]
      if(sum + w > capacity) {
        d++
        sum = 0
      }
      sum += w
    }
    if(d + 1 > days) return false
    return true
  }
};
```

## 🌟😻✔ 1013. 将数组分成和相等的三个部分【easy】

[ref](https://leetcode.cn/problems/partition-array-into-three-parts-with-equal-sum/)

前缀和、数组

```js
var canThreePartsEqualSum = function(arr) {
  const n = arr.length
  let sum = 0
  for(const num of arr) sum += num
  const target = sum / 3
  if(target !== Math.floor(target)) return false
  sum = 0
  let iIdx = -1
  for(let i=0;i<arr.length;i++) {
    sum += arr[i]
    if(sum === target && iIdx === -1) iIdx = i
    if(sum === 2 * target) {
      if(iIdx >= 0 && i > iIdx && i < n - 1) return true
    }
  }
  return false
};
```

## ?🌟😻✔ 1014. 最佳观光组合【medium】

[ref](https://leetcode.cn/problems/best-sightseeing-pair/)

数组、智力题、脑筋急转弯、贪心

```js
var maxScoreSightseeingPair = function(values) {
  const n = values.length
  let res = Number.MIN_SAFE_INTEGER, maxIpair = values[0] + 0
  for(let j=1;j<n;j++) {
    res = Math.max(res, maxIpair + values[j] - j)
    maxIpair = Math.max(maxIpair, values[j] + j)
  }
  return res
};
```

```js
var maxScoreSightseeingPair = function(values) {
  const n = values.length
  let max = Number.MIN_SAFE_INTEGER
  const maxHeap = new MaxHeap()
  for(let i=1;i<n;i++) {
    maxHeap.insert({
      i: i,
      v: values[i] - i
    })
  }
  for(let i=0;i<n-1;i++) {
    while(maxHeap.peek().i <= i) {
      maxHeap.pop()
    }
    max = Math.max(max, values[i] + i + maxHeap.peek().v)
  }
  return max
};

class MaxHeap {
  constructor(){
    this.heap = []
  }
  insert(obj){
    this.heap.push(obj)
    this.shiftUp(this.size() - 1)
  }
  pop(){
    this.swap(0, this.size() - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  swap(i, j){
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  peek() {
    return this.heap[0]
  }
  size(){
    return this.heap.length
  }
  shiftUp(i){
    const parentIdx = Math.floor((i - 1) / 2)
    if(parentIdx >= 0 && this.heap[i].v > this.heap[parentIdx].v) {
      this.swap(i, parentIdx)
      this.shiftUp(parentIdx)
    }
  }
  shiftDown(i){
    const leftIdx = 2 * i + 1, rightIdx = 2 * i + 2
    let maxIdx = i
    if(leftIdx < this.size() && this.heap[leftIdx].v > this.heap[maxIdx].v) {
      maxIdx = leftIdx
    }
    if(rightIdx < this.size() && this.heap[rightIdx].v > this.heap[maxIdx].v) {
      maxIdx = rightIdx
    }
    if(maxIdx !== i) {
      this.swap(i, maxIdx)
      this.shiftDown(maxIdx)
    }
  }
}
````

## ?🌟😻✔ 1020. 飞地的数量【medium】

[ref](https://leetcode.cn/problems/number-of-enclaves/)

矩阵、广度优先搜索、深度优先搜索

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(1)
var numEnclaves = function(grid) {
  const m = grid.length, n = grid[0].length
  let q = [], cnt = 0, sum = 0
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 1) sum++
      if((i === 0 || j === 0 || i === m-1 || j === n - 1) && grid[i][j] === 1) {
        q.push([i, j])
        grid[i][j] = 0
      }
    }
  }
  const directs = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  while(q.length) {
    let tq = []
    for(let i=0;i<q.length;i++) {
      const [x, y] = q[i]
      cnt++
      for(let j=0;j<4;j++) {
        const xx = x + directs[j][0], yy = y + directs[j][1]
        if(xx >=0 && xx < m && yy >=0 && yy < n && grid[xx][yy] === 1) {
          grid[xx][yy] = 0
          tq.push([xx, yy])
        }
      }
    }
    q = tq
  }
  return sum - cnt
};
```

## 🌟😻✔ 1021. 删除最外层的括号【easy】

[ref](https://leetcode.cn/problems/remove-outermost-parentheses/)

模拟、括号

```js
var removeOuterParentheses = function(s) {
  const n = s.length
  let l = 0, r = 0, lCnt = 0, res = ''
  while(r < n) {
    if(s[r] === '(') lCnt++
    else {
      lCnt--
      if(lCnt === 0) {
        res += s.slice(l + 1, r)
        l = r + 1
      }
    }
    r++
  }
  return res
};
```

## ??🌟😻✔ 1024. 视频拼接【medium】

[ref](https://leetcode.cn/problems/video-stitching/)

贪心、排序

```js
var videoStitching = function(clips, time) {
  clips.sort((a, b) => a[0] - b[0] || b[1] - a[1])
  if(clips[0][0] !== 0) return -1
  const filterClips = [clips[0]]
  let max = clips[0][1]
  for(const clip of clips) {
    if(clip[0] > max) return -1
    if(clip[1] > max) {
      filterClips.push(clip)
      max = clip[1]
    }
    if(clip[1] >= time) break
  }
  if(max < time) return -1
  const res = []
  for(const clip of filterClips) {
    while(res.length && res[res.length - 1][0] >= clip[0]) {
      res.pop()
    }
    if(!res.length) {
      res.push(clip)
    } else {
      res.push([res[res.length - 1][1], clip[1]])
    }
    if(res[res.length - 1][1] >= time) {
      res.push([res.pop()[0], time])
      break
    }
  }
  console.log(res)
  return res.length
};
```

## 🌟😻✔ 1034. 边界着色【medium】

[ref](https://leetcode.cn/problems/coloring-a-border/)

矩阵、广度优先搜索、深度优先搜索

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var colorBorder = function(grid, row, col, color) {
  const m = grid.length, n = grid[0].length, targetColor = grid[row][col]
  const used = new Array(m).fill(0).map(_ => new Array(n).fill(false))
  const ans = new Array(m).fill(0).map(_ => new Array(n).fill(false))
  function walk(i, j) {
    if(i < 0 || j < 0 || i >= m || j >= n || used[i][j] || grid[i][j] !== targetColor) return
    used[i][j] = true
    if(
      i === 0
      || i === m - 1
      || j === 0
      || j === n - 1
      || grid[i - 1][j] !== grid[i][j]
      || grid[i + 1][j] !== grid[i][j]
      || grid[i][j - 1] !== grid[i][j]
      || grid[i][j + 1] !== grid[i][j]
      ) {
      ans[i][j] = color
    }
    walk(i + 1, j)
    walk(i - 1, j)
    walk(i, j + 1)
    walk(i, j - 1)
  }
  walk(row, col)
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(!ans[i][j]) {
        ans[i][j] = grid[i][j]
      }
    }
  }
  return ans
};
```


## ?🌟😻✔ 1035. 不相交的线【medium】

[ref](https://leetcode.cn/problems/uncrossed-lines/)

动态规划

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var maxUncrossedLines = function(nums1, nums2) {
  const m = nums1.length, n = nums2.length
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(nums1[i] === nums2[j]) {
        dp[i][j] = 1 + (i -1>=0 && j-1 >=0 ? dp[i - 1][j - 1] : 0)
      } else {
        dp[i][j] = Math.max((i - 1 >= 0? dp[i - 1][j] : 0), (j - 1>=0 ?dp[i][j - 1]:0))
      }
    }
  }
  return dp[m-1][n-1]
};
```

## ✔ 1046. 最后一块石头的重量【easy】

[ref](https://leetcode.cn/problems/last-stone-weight/)

优先队列、堆、大顶堆

```js
var lastStoneWeight = function(stones) {
  const maxHeap = new MaxHeap()
  for(const stone of stones) maxHeap.insert(stone)
  while(maxHeap.size() >= 2) {
    const v = Math.abs(maxHeap.pop() - maxHeap.pop())
    if(v > 0) maxHeap.insert(v)
  }
  return maxHeap.size() ?  maxHeap.pop() : 0
};

class MaxHeap {
  constructor(){
    this.heap = []
  }
  insert(v){
    this.heap.push(v)
    this.shiftUp(this.size() - 1)
  }
  pop(){
    this.swap(0, this.size() - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  size(){
    return this.heap.length
  }
  shiftUp(i){
    const parentIdx = Math.floor((i - 1) / 2)
    if(parentIdx >= 0 && this.heap[i] > this.heap[parentIdx]) {
      this.swap(i, parentIdx)
      this.shiftUp(parentIdx)
    }
  }
  shiftDown(i){
    const leftIdx = 2 * i + 1, rightIdx = 2 * i + 2
    let maxIdx = i
    if(leftIdx < this.size() && this.heap[leftIdx] > this.heap[maxIdx]) {
      maxIdx = leftIdx
    }
    if(rightIdx < this.size() && this.heap[rightIdx] > this.heap[maxIdx]) {
      maxIdx = rightIdx
    }
    if(maxIdx !== i) {
      this.swap(i, maxIdx)
      this.shiftDown(maxIdx)
    }
  }
}
```

## ✔ 1047. 删除字符串中的所有相邻重复项【easy】

[ref](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var removeDuplicates = function(s) {
  const stack = []
  for(const c of s) {
    if(stack.length && stack[stack.length -1] === c) stack.pop()
    else stack.push(c)
  }
  return stack.join('')
};
```

## ???🌟😻✔ 1049. 最后一块石头的重量 II【medium】

[ref](https://leetcode.cn/problems/last-stone-weight-ii/)

动态规划、01背包、背包问题

```js
var lastStoneWeightII = function(stones) {
  const n = stones.length
  let sum = 0
  for(const num of stones) sum += num
  const t = Math.floor(sum / 2)
  const dp = new Array(n + 1).fill(0).map(_ => new Array(t + 1).fill(0))
  for(let i=1;i<=n;i++) {
    const x = stones[i-1]
    for(let j=0;j<=t;j++) {
      dp[i][j] = dp[i-1][j]
      if(j >= x) {
        dp[i][j] = Math.max(dp[i][j], dp[i-1][j - x] + x)
      }
    }
  }
  return sum - 2 * dp[n][t]
};
```

## 🌟😻✔ 1052. 爱生气的书店老板【medium】

[ref](https://leetcode.cn/problems/grumpy-bookstore-owner/)

前缀树组

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxSatisfied = function(customers, grumpy, minutes) {
  const n = customers.length
  const peoplePre = []
  const noCool = []
  let max = 0
  for(let i=0;i<n;i++) {
    peoplePre[i] = customers[i] + (i > 0? peoplePre[i - 1] : 0)
    noCool[i] = (i > 0? noCool[i - 1] : 0) + (grumpy[i] === 0 ? customers[i]: 0)
  }
  for(let i=0;i<n;i++) {
    const buffCount = peoplePre[i + minutes - 1 >= n? n - 1 : i + minutes - 1] - (i - 1 >= 0 ? peoplePre[i - 1] : 0)
    const normalCount = (i-1>=0? noCool[i-1] :0) + noCool[n - 1] - noCool[i + minutes - 1 >= n ? n-1 : i + minutes - 1]
    max = Math.max(max, buffCount + normalCount)
  }

  return max
};
```

## 🌟😻✔ 1087. 花括号展开【medium】

[ref](https://leetcode.cn/problems/brace-expansion/)

回溯

```js
var expand = function(s) {
  const arr = []
  let i = 0

  while(i < s.length) {
    if(s[i] === '{') {
      i++
      const tmp = []
      while(s[i] !== '}') {
        if(s[i] !== ',') {
          tmp.push(s[i])
        }
        i++
      }
      arr.push(tmp.sort((a, b) => a < b ? -1 : 1))
    } else {
      arr.push(s[i])
    }
    i++
  }
  const res = []
  function backTracking(i, path) {
    if(i === arr.length) {
      res.push(path.join(''))
      return
    }
    if(typeof path[i] === 'string') {
      backTracking(i + 1, path)
    } else {
      const chars = path[i]
      for(let j=0;j<chars.length;j++) {
        path[i] = chars[j]
        backTracking(i + 1, path)
      }
      path[i] = chars
    }
  }

  backTracking(0, arr)
  return res
};

```

## 🌟😻✔ 1094. 拼车【medium】

[ref](https://leetcode.cn/problems/car-pooling/)

上下车问题、差分

题解
- [【云影同学】差分或者排序+双队列](https://leetcode.cn/problems/car-pooling/solution/by-lxfriday-wc6m/)

```js
// 时间复杂度：O(N + M) N=trips.length
// 空间复杂度：O(M) M=最远位置
var carPooling = function(trips, capacity) {
  const arr = new Array(1001).fill(0)
  for(let trip of trips) {
    const [peoCnt, from, to] = trip
    arr[from] += peoCnt
    arr[to] -= peoCnt
  }
  for(let i=0;i<1001;i++) {
    arr[i] += i - 1 >=0 ? arr[i - 1] : 0
    if(arr[i] > capacity) return false
  }
  return true
};
```

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var carPooling = function(trips, capacity) {
  const n = trips.length
  const q1 = [], q2 = []
  for(let i=0;i<n;i++) {
    q1.push([trips[i][1], trips[i][0]])
    q2.push([trips[i][2], trips[i][0]])
  }
  q1.sort((a, b) => a[0] - b[0])
  q2.sort((a, b) => a[0] - b[0])
  let sum = 0
  while(q1.length && q2.length) {
    if(q1[0][0] < q2[0][0]) {
      sum += q1.shift()[1]
      if(sum > capacity) return false
    } else {
      sum -= q2.shift()[1]
    }
  }
  return true
};
```

## 🌟✔ 1103 分糖果 II【easy】

[ref](https://leetcode.cn/problems/distribute-candies-to-people/)

```js
var distributeCandies = function(candies, num_people) {
  const res = new Array(num_people).fill(0)
  let n = 1
  let index = 0
  while(candies) {
    if(candies <= n) {
      res[index] += candies
      candies = 0
    } else {
      res[index] += n
      candies -= n
    }
    n++
    index++
    if(index === num_people) index = 0
  }
  return res
};
```

## 🌟😻✔ 1104. 二叉树寻路【medium】

[ref](https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree/)

二叉树

```js
// 时间复杂度：O(logN) N=label
// 空间复杂度：O(1)
var pathInZigZagTree = function(label) {
  const res = []
  let h = 1
  while(2 ** h - 1 < label) {
    h++
  }
  while(h > 0) {
    res.unshift(label)
    const upLevelMin = 2 ** (h - 2)
    const upLevelMax = 2 ** (h - 1) - 1

    const levelMin = 2 ** (h - 1)
    const levelMax = 2 ** h - 1

    let upLeftBigger = (h - 1) % 2 === 0
    let leftBigger = h % 2 === 0
    
    const levelInd = leftBigger ? (levelMax - label) : (label - levelMin)
    const upLevelInd = Math.floor(levelInd / 2)
    label = upLeftBigger ? (upLevelMax - upLevelInd) : (upLevelMin + upLevelInd)
    h--
  }
  return res
};
```

## ?🌟😻✔ 1109. 航班预订统计【medium】

[ref](https://leetcode.cn/problems/corporate-flight-bookings/)

差分、扫描线、区间问题

```js
// 时间复杂度：O(M+N)
// 空间复杂度：O(1)
var corpFlightBookings = function(bookings, n) {
  const res = new Array(n).fill(0)
  for(let booking of bookings) {
    res[booking[0] - 1] += booking[2]
    if(booking[1] < n) {
      res[booking[1]] -= booking[2]
    }
  }
  for(let i=1;i<res.length;i++) {
    res[i] += res[i - 1]
  }
  return res
};
```

```js
// 扫描线法
var corpFlightBookings = function(bookings, n) {
  const q1 = [], q2 = []
  for(let booking of bookings) {
    q1.push([booking[0], booking[2]])
    q2.push([booking[1], booking[2]])
  }
  q1.sort((a, b) => b[0] - a[0])
  q2.sort((a, b) => b[0] - a[0])
  let count = 0
  const res = new Array(n).fill(0)
  for(let i=1;i<=n;i++) {
    while(q1.length && q1[q1.length - 1][0] <= i) {
      count += q1[q1.length - 1][1]
      q1.pop()
    }
    res[i - 1] = count
    while(q2.length && q2[q2.length - 1][0] <= i) {
      count -= q2[q2.length - 1][1]
      q2.pop()
    }
  }
  return res
};
```

## 🌟😻✔ 1137. 第 N 个泰波那契数【easy】

[ref](https://leetcode.cn/problems/n-th-tribonacci-number/)

模拟

```js
var tribonacci = function(n) {
  if(n === 0) return 0
  if(n === 1 || n === 2) return 1
  let a = 0, b = 1, c = 1
  for(let i=3;i<=n;i++) {
    let pa = a, pb = b, pc = c
    c = pa + pb + pc
    a = pb
    b = pc
  }
  return c
};
```

## ?🌟😻✔ 1143 最长公共子序列【medium】

[ref](https://leetcode.cn/problems/longest-common-subsequence/)

子序列问题，动态规划

```js
var longestCommonSubsequence = function(text1, text2) {
  const m = text1.length
  const n = text2.length
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  for(let i=0;i<m;i++) {
    if(text1[i] === text2[0]) {
      dp[i][0] = 1
    } else {
      dp[i][0] = i - 1 >= 0 ?dp[i - 1][0] : 0
    }
  }
  for(let j=0;j<n;j++) {
    if(text1[0] === text2[j]) {
      dp[0][j] = 1
    } else {
      dp[0][j] = j - 1 >= 0 ?dp[0][j - 1] : 0
    }
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      if(text1[i] === text2[j]) {
        dp[i][j] = 1 + dp[i - 1][j - 1]
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
      }
    }
  }
  return dp[m - 1][n - 1]
};
```

## 🌟😻✔ 1122. 数组的相对排序【easy】

[ref](https://leetcode.cn/problems/relative-sort-array/)

计数排序

```js
var relativeSortArray = function(arr1, arr2) {
  const bucket = new Array(1001).fill(0)
  for(const num of arr1) {
    bucket[num]++
  }
  const res = []
  for(const num of arr2) {
    while(bucket[num] > 0) {
      res.push(num)
      bucket[num]--
    }
  }
  for(let i=0;i<1001;i++) {
    while(bucket[i] > 0) {
      res.push(i)
      bucket[i]--
    }
  }
  return res
};
```

## 🌟😻✔ 1150. 检查一个数是否在数组中占绝大多数【easy】

[ref](https://leetcode.cn/problems/check-if-a-number-is-majority-element-in-a-sorted-array/)

二分搜索

```js
// 单次二分搜索
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var isMajorityElement = function(nums, target) {
  const lIndex = binarySearch(nums, target)
  return nums[lIndex] === target && nums[lIndex + Math.floor(nums.length / 2)] === target
};
function binarySearch(nums, target) {
  let l = 0, r = nums.length - 1
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] >= target) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return r
}

// len = 4, rIndex = 3, lIndex = 1
// len = 5, rIndex = 4, lIndex = 2
```

```js
// 普通解法
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var isMajorityElement = function(nums, target) {
  const len = nums.length
  let l = 0, r = len - 1
  while(l < len && nums[l] < target) l++
  while(r > 0 && nums[r] > target) r--
  return r - l + 1 > len / 2
};

```

## 🌟😻✔ 1160. 拼写单词【easy】

[ref](https://leetcode.cn/problems/find-words-that-can-be-formed-by-characters/)

哈希表

```js
var countCharacters = function(words, chars) {
  const charsMap = new Map()
  for(const c of chars) {
    charsMap.set(c, (charsMap.get(c) || 0) + 1)
  }
  let res = 0
  for(const word of words) {
    let shouldAdd = true
    const map = new Map()
    for(const c of word) {
      if(!charsMap.has(c) || charsMap.get(c) === map.get(c)) {
        shouldAdd = false
        break
      }
      map.set(c, (map.get(c) || 0) + 1)
    }
    if(shouldAdd) res += word.length
  }
  return res
};
```

## ??🌟😻✔ 1190. 反转每对括号间的子串【medium】

[ref](https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/)

栈、括号问题

```js
var reverseParentheses = function(s) {
  const stack = [], n = s.length
  let i=0, depth = 0
  while(i < n) {
    if(s[i] === '(') {
      depth++
    } else if(s[i] === ')') {
      depth--
      let str = ''
      while(stack.length && stack[stack.length - 1][1] > depth) {
        const top = stack.pop()
        if(top[1] % 2 === 1) {
          str = str + top[0]
        } else {
          str = top[0] + str
        }
      }
      stack.push([str, depth])
    } else {
      let str = ''
      while(i < n && s[i] !== '(' && s[i] !== ')') {
        str += s[i]
        i++
      }
      if(depth % 2 !== 0) {
        stack.push([reverse(str), depth])
      } else {
        stack.push([str, depth])
      }
      i--
    }
    i++
  }
  return stack.map(_ => _[0]).join('')
};

function reverse(str) {
  let res = ''
  for(let i=str.length - 1;i>=0;i--) res += str[i]
  return res
}
```

## 🌟😻✔ 1208. 尽可能使字符串相等【medium】

[ref](https://leetcode.cn/problems/get-equal-substrings-within-budget/)

双指针、滑动窗口

```js
// 动态滑动窗口
// 时间复杂度：O(N) N=s.length
// 空间复杂度：O(1)
var equalSubstring = function(s, t, maxCost) {
  let res = 0
  const n = s.length
  let l = 0, r = 0
  let totalCost = 0
  while(r < n) {
    const cost = getCodeDis(s, t, r)
    totalCost += cost
    while(totalCost > maxCost) {
      totalCost -= getCodeDis(s, t, l)
      l++
    }
    res = Math.max(res, r - l + 1)
    r++
  }
  return res
};
function getCodeDis(s, t, i) {
  return Math.abs(s.charCodeAt(i) - t.charCodeAt(i))
}
```

```js
// 单增滑动窗口
// 时间复杂度：O(N) N=s.length
// 空间复杂度：O(1)
var equalSubstring = function(s, t, maxCost) {
  const n = s.length
  let l = 0, r = 0
  let totalCost = 0
  while(r < n) {
    const cost = getCodeDis(s, t, r)
    totalCost += cost
    if(totalCost > maxCost) {
      totalCost -= getCodeDis(s, t, l)
      l++
    }
    r++
  }
  return r - l
};

function getCodeDis(s, t, i) {
  return Math.abs(s.charCodeAt(i) - t.charCodeAt(i))
}
```

## 🌟😻✔ 1221. 分割平衡字符串【easy】

[ref](https://leetcode.cn/problems/split-a-string-in-balanced-strings/)

字符串

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var balancedStringSplit = function(s) {
  let lCnt = 0, rCnt = 0, res = 0
  for(let i=0;i<s.length;i++) {
    if(s[i] === 'L') lCnt++
    else rCnt++
    if(lCnt === rCnt) {
      res++
      lCnt = 0
      rCnt = 0
    }
  }
  return res
};
```

## ???🌟😻✔ 1224. 最大相等频率【hard】

[ref](https://leetcode.cn/problems/maximum-equal-frequency/)

哈希表、规律题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxEqualFreq = function(nums) {
  const n = nums.length
  // 数字出现的频次统计
  const countMap = new Map()
  // 频次相同的数字个数统计
  const freqMap = new Map()
  let maxCount = 0
  for(let i=0;i<n;i++) {
    countMap.set(nums[i], (countMap.get(nums[i]) || 0) + 1)
    maxCount = Math.max(countMap.get(nums[i]), maxCount)
    if(countMap.get(nums[i]) === 1) {
      freqMap.set(1, (freqMap.get(1) || 0) + 1)
    } else {
      freqMap.set(countMap.get(nums[i]), (freqMap.get(countMap.get(nums[i])) || 0) + 1)
      freqMap.set(countMap.get(nums[i]) - 1, freqMap.get(countMap.get(nums[i]) - 1) - 1)
      if(freqMap.get(countMap.get(nums[i]) - 1) === 0) {
        freqMap.delete(countMap.get(nums[i]) - 1)
      }
    }
    let isValid = false
    // 所有数字出现的频次都是 1 的时候，只有一个数字，或者多个数字
    if(maxCount === 1) isValid = true
    // 所有数字都相同，随便删一个
    else if(freqMap.get(maxCount) === 1 && freqMap.size === 1) isValid = true
    // 有一个频次为1的数字，且其他数字出现的频次都相同，删除频次为1的数字
    else if(freqMap.get(1) === 1 && freqMap.size === 2) isValid = true
    // 除了最大频次a的数字，其他数字的频次b都相同，且a = b + 1，删除一个频次a的数字
    else if(freqMap.get(maxCount) === 1 && freqMap.get(maxCount - 1) > 0 && freqMap.size === 2) isValid = true

    if(isValid) {
      res = i + 1
    }
  }
  return res
};
```

## ?? 🌟😻✔ 1231. 分享巧克力【medium】

[ref](https://leetcode.cn/problems/divide-chocolate/)

二分搜索

```js
var maximizeSweetness = function(sweetness, k) {
  let l = Number.MAX_SAFE_INTEGER, sum = 0
  for(let sweet of sweetness) {
    sum += sweet
    l = Math.min(l, sweet)
  }
  r = Math.floor(sum / (k + 1))
  while(l < r) {
    const mid = Math.ceil((l + r) / 2)
    if(canDoIt(mid)) {
      l = mid
    } else {
      r = mid - 1
    }
  }
  return r
  function canDoIt(min) {
    let sum = 0, cnt = 0
    for(const sweet of sweetness) {
      sum += sweet
      if(sum >= min) {
        sum = 0
        cnt++
      }
    }
    const res = cnt >= k + 1
    return res
  }
};
```

## 🌟😻✔ 1282. 用户分组【medium】

[ref](https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/)

哈希表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var groupThePeople = function(groupSizes) {
  const m = new Map()
  let res = []
  for(let i=0;i<groupSizes.length;i++) {
    const size = groupSizes[i]
    if(m.has(size)) {
      const t = m.get(size)
      if(t[t.length - 1].length < size) {
        t[t.length - 1].push(i)
      } else {
        t.push([i])
      }
    } else {
      m.set(size, [[i]])
    }
  }
  for(let values of m.values()) {
    res = [...res, ...values]
  }
  return res
};

```

## 🌟😻✔ 1302. 层数最深叶子节点的和【medium】

[ref](https://leetcode.cn/problems/deepest-leaves-sum/)

层序遍历、广度优先搜索、深度优先搜索、BFS、DFS

```js
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var deepestLeavesSum = function(root) {
  let q = [root]
  while(q.length) {
    const len = q.length
    let sum = 0
    for(let i=0;i<len;i++) {
      const node = q.shift()
      sum += node.val
      node.left && q.push(node.left)
      node.right && q.push(node.right)
    }
    if(!q.length) return sum
  }
};
```

## 🌟😻✔ 1305. 两棵二叉搜索树中的所有元素【medium】

[ref](https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/)

二叉搜索树

```js
var getAllElements = function(root1, root2) {
  const arr1 = [], arr2 = []
  function dfs(node, arr) {
    if(!node) return
    dfs(node.left, arr)
    arr.push(node.val)
    dfs(node.right, arr)
  }
  dfs(root1, arr1)
  dfs(root2, arr2)
  let i = 0, j = 0
  const res = []
  while(i < arr1.length && j < arr2.length) {
    if(arr1[i] < arr2[j]) {
      res.push(arr1[i++])
    } else {
      res.push(arr2[j++])
    }
  }
  while(i < arr1.length) {
    res.push(arr1[i++])
  }
  while(j < arr2.length) {
    res.push(arr2[j++])
  }
  return res
};
```

## ✔ 1306 跳跃游戏 III【medium】

[ref](https://leetcode.cn/problems/jump-game-iii/)

广度优先遍历

```js
// BFS
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var canReach = function(arr, start) {
  if(arr[start] === 0) return true
  const len = arr.length
  const usedIndexes = []
  const nextIndexes = [start]
  while(nextIndexes.length > 0) {
    const targetIndex = nextIndexes.pop()
    if(arr[targetIndex] === 0) return true
    usedIndexes.push(targetIndex)
    if((targetIndex - arr[targetIndex] >= 0) && !usedIndexes.includes(targetIndex - arr[targetIndex])) {
      nextIndexes.push(targetIndex - arr[targetIndex])
    }
    if((targetIndex + arr[targetIndex] <= len - 1) && !usedIndexes.includes(targetIndex + arr[targetIndex])) {
      nextIndexes.push(targetIndex + arr[targetIndex])
    }
  }
  return false
};
```

深度优先遍历

```js
// DFS
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var canReach = function(arr, start) {
  if(arr[start] === 0) return true
  const usedIndexes = []
  usedIndexes.push(start)

  function jump(index) {
    if(arr[index] === 0) {
      usedIndexes.push(index)
      return true
    }
    if(index < 0 || index >= arr.length || usedIndexes.includes(index)) {
      return false
    }
    usedIndexes.push(index)
    return jump(index - arr[index]) || jump(index + arr[index])
  }

  return jump(start - arr[start]) || jump(start + arr[start])
};

```

## ✔ 1342. 将数字变成 0 的操作次数【easy】

[ref](https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/)

数字题

```js
var numberOfSteps = function(num) {
  let cnt = 0
  while(num) {
    if(num % 2 === 1) {
      num--
    } else {
      num /= 2
    }
    cnt++
  }
  return cnt
};

```

## ✔ 1365. 有多少小于当前数字的数字【easy】

[ref](https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/)

哈希表、数组题

```js
var smallerNumbersThanCurrent = function(nums) {
  const map = new Map()
  let max = 0
  for(let i=0;i<nums.length;i++) {
    map.set(nums[i], (map.get(nums[i]) || 0) + 1)
    max = Math.max(max, nums[i])
  }
  let cnt = 0
  for(let i=0;i<=max;i++) {
    if(map.get(i) > 0) {
      const tmpCnt = map.get(i)
      map.set(i, cnt)
      cnt += tmpCnt
    }
  }
  for(let i=0;i<nums.length;i++) {
    nums[i] = map.get(nums[i])
  }
  return nums
};
```

## ??🌟😻✔ 1411 给 N x 3 网格图涂色的方案数【hard】

[ref](https://leetcode.cn/problems/number-of-ways-to-paint-n-3-grid/)

数学推导题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numOfWays = function(n) {
  let f0 = 6, f1 = 6
  for(let i=1;i<n;i++) {
    const nf0 = (3*f0 + 2*f1) % 1000000007
    const nf1 = (2*f0 + 2*f1) % 1000000007
    f0 = nf0
    f1 = nf1
  }

  return (f0 + f1) % 1000000007
};

// 0 1 2
// 0 2 1
// 1 0 2
// 1 2 0
// 2 0 1
// 2 1 0

// 0 1 0
// 0 2 0
// 1 0 1
// 1 2 1
// 2 0 2
// 2 1 2

// -----
// A B A

// B A B
// C A C
// B C B

// B A C
// C A B
// -----

// -----
// A B C

// B A B
// B C B

// B C A
// C A B
// -----
// f0 = 6, f1 = 6

// nf0 = 3*f0 + 2*f1
// nf1 = 2*f0 + 2*f1

```

## ✔ 1417. 重新格式化字符串【easy】

[ref](https://leetcode.cn/problems/reformat-the-string/)

字符串

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var reformat = function(s) {
  let str1 = ''
  let str2 = ''
  let res = ''
  for(let i=0;i<s.length;i++) {
    if(s[i] >= 0 && s[i] <= 9) {
      str1 += s[i]
    } else {
      str2 += s[i]
    }
  }
  if(str1.length < str2.length) {
    const t = str1
    str1 = str2
    str2 = t
  }
  if(str1.length - str2.length > 1) return ''
  let i = 0, j = 0
  while(i < str1.length) {
    res += str1[i] + (str2[j]? str2[j] : '')
    i++
    j++
  }
  return res
};
```

## 🌟😻✔ 1422. 分割字符串的最大得分【easy】

[ref](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/)

动态规划、迭代

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxScore = function(s) {
  let score = 0
  if(s[0] === '0') score++
  for(let i=1;i<s.length;i++) {
    if(s[i] === '1') score++
  }
  let max = score
  for(let i=1;i<s.length - 1;i++) {
    if(s[i] === '0') score++
    else if(s[i] === '1') score--
    max = Math.max(max, score)
  }
  return max
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxScore = function(s) {
  const n = s.length
  const rp = new Array(n).fill(0)
  for(let i=n-2;i>=0;i--) {
    rp[i] = rp[i + 1] + (s[i + 1] === '1'? 1 : 0)
  }
  let max = 0
  let lCount = 0
  for(let i=0;i<=n-2;i++) {
    if(s[i] === '0') {
      lCount++
    }
    max = Math.max(lCount + rp[i], max)
  }
  return max
};
```

## ✔ 1431. 拥有最多糖果的孩子【easy】

[ref](https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/)

模拟

```js
var kidsWithCandies = function(candies, extraCandies) {
  let max = 0
  for(const num of candies) max = Math.max(max, num)
  for(let i=0;i<candies.length;i++) {
    if(candies[i] + extraCandies >= max) candies[i] = true
    else candies[i] = false
  }
  return candies
};
```

## ✔ 1446. 连续字符【easy】

[ref](https://leetcode.cn/problems/consecutive-characters/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxPower = function(s) {
  let max = 1
  let len = 1
  for(let i=1;i<s.length;i++) {
    if(s[i] === s[i - 1]) {
      len++
      max = Math.max(max, len)
    } else {
      len = 1
    }
  }
  return max
};
```

## 🌟😻✔1450. 在既定时间做作业的学生人数【easy】

[ref](https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/)

区间、区间权重累加、差分、二分搜索

```js
// 暴力
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var busyStudent = function(startTime, endTime, queryTime) {
  let count = 0
  for(let i=0;i<startTime.length;i++) {
    if(startTime[i] <= queryTime && queryTime <= endTime[i]) count++
  }
  return count
};
```

```js
// 差分、区间权重累加
// 时间复杂度：O(N+queryTime)
// 空间复杂度：O(queryTime)
var busyStudent = function(startTime, endTime, queryTime) {
  const arr = new Array(queryTime).fill(0)
  const n = startTime.length
  for(let i=0;i<n;i++) {
    if(startTime[i] - 1 < queryTime) {
      arr[startTime[i] - 1] += 1
    }
    if(endTime[i] < queryTime) {
      arr[endTime[i]] -= 1
    }
  }
  for(let i=1;i<arr.length;i++) {
    arr[i] += arr[i - 1]
  }
  return arr[queryTime - 1]
};
```

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var busyStudent = function(startTime, endTime, queryTime) {
  startTime.sort((a, b) => a - b)
  endTime.sort((a, b) => a - b)
  const startCount = binarySearch(startTime, queryTime, true)
  const endCount = binarySearch(endTime, queryTime, false)
  return startCount - endCount
};

function binarySearch(nums, target, isStart) {
  let l = 0, r = nums.length
  if(isStart) {
    while(l < r) {
      const mid = Math.floor((l + r) / 2)
      if(nums[mid] > target) {
        r = mid
      } else {
        l = mid + 1
      }
    }
    return l
  } else {
    while(l <= r) {
      const mid = Math.floor((l + r) / 2)
      if(nums[mid] < target) {
        l = mid + 1
      } else {
        r = mid - 1
      }
    }
    return l
  }
}
```

## 🌟😻✔1455. 检查单词是否为句中其他单词的前缀【easy】

[ref](https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/)

```js
// 时间复杂度：O(N*M)
// 空间复杂度：O(N)
var isPrefixOfWord = function(sentence, searchWord) {
  const words = sentence.split(' ')
  for(let i=0;i<words.length;i++) {
    if(words[i].length < searchWord.length) continue
    let j = 0
    while(j < searchWord.length && words[i][j] === searchWord[j]) {
      j++
    }
    if(j === searchWord.length) {
      return i + 1
    }
  }
  return -1
};
```

## 🌟😻✔1460. 通过翻转子数组使两个数组相等【easy】

[ref](https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-sub-arrays/submissions/)

排序、数组、哈希表

题解

- [【云影同学】三种解法，哈希表+桶排序+普通交换](https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-sub-arrays/solution/by-lxfriday-95ev/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var canBeEqual = function(target, arr) {
  const mtarget = new Map(), marr = new Map()
  for(let i=0; i < target.length; i++) {
    mtarget.set(target[i], (mtarget.get(target[i]) || 0) + 1)
  }
  for(let i=0; i < arr.length; i++) {
    marr.set(arr[i], (marr.get(arr[i]) || 0) + 1)
  }
  for(let [num, count] of mtarget.entries()) {
    if(marr.get(num) !== count) return false
  }
  return true
};
```

```js
// 时间复杂度：O(M + N) N=target.length M=max(...target)
// 空间复杂度：O(M)
var canBeEqual = function(target, arr) {
  const targetBucket = []
  for(let i=0; i < target.length; i++) {
    targetBucket[target[i]] = (targetBucket[target[i]] || 0) + 1
  }
  for(let i=0; i < arr.length; i++) {
    if(targetBucket[arr[i]] === undefined) {
      return false
    } else {
      targetBucket[arr[i]]--
    }
  }
  for(let i=0;i<targetBucket.length;i++) {
    if(targetBucket[i] !== undefined &&  targetBucket[i] !== 0) return false 
  }
  return true
};
```

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var canBeEqual = function(target, arr) {
  for(let i=0; i < target.length; i++) {
    const rI = find(arr, i, target[i])
    if(rI < i) return false
    swap(arr, i, rI)
  }
  return true
};

function find(arr,start,t) {
  while(start < arr.length) {
    if(arr[start] === t) return start
    start++
  }
  return -1
}

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

## ✔1464. 数组中两元素的最大乘积【easy】

[ref](https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/)

常规题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxProduct = function(nums) {
  let max1 = Math.min(nums[0], nums[1])
  let max2 = Math.max(nums[0], nums[1])
  for(let i=2;i<nums.length;i++) {
    if(nums[i] > max2) {
      max1 = max2
      max2 = nums[i]
    } else {
      max1 = Math.max(nums[i], max1)
    }
  }
  return (max1 - 1) * (max2 - 1)
};
```

## ✔1470. 重新排列数组【easy】

[ref](https://leetcode.cn/problems/shuffle-the-array/)

数组题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var shuffle = function(nums, n) {
  const res = []
  let i = 0
  let ind = 0
  while(i < n) {
    res[ind++] = nums[i]
    res[ind++] = nums[i + n]
    i++
  }
  return res
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var shuffle = function(nums, n) {
  const x = nums.slice(0, n)
  const y = nums.slice(n)
  const res = []
  let i = 0
  while(i < x.length) {
    res.push(x[i])
    res.push(y[i++])
  }
  return res
};
```

## 🌟😻✔ 1475. 商品折扣后的最终价格【easy】

[ref](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/)

单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var finalPrices = function(prices) {
  const q = []
  for(let i=0;i < prices.length; i++) {
    while(q.length && prices[i] <= prices[q[q.length - 1]]) {
      const ind = q.pop()
      prices[ind] -= prices[i] 
    }
    q.push(i)
  }
  return prices
};
```

## ✔ 1480. 一维数组的动态和【easy】

[ref](https://leetcode.cn/problems/running-sum-of-1d-array/)

数组、累加

```js
var runningSum = function(nums) {
  for(let i=1;i<nums.length;i++) nums[i] += nums[i - 1]
  return nums
};
```

## ✔ 1582. 二进制矩阵中的特殊位置【easy】

[ref](https://leetcode.cn/problems/special-positions-in-a-binary-matrix/)

矩阵

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(M+N)
var numSpecial = function(mat) {
  const m = mat.length, n = mat[0].length
  const rows = new Array(m).fill(0)
  const cols = new Array(n).fill(0)
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(mat[i][j] === 1) {
        rows[i]++
        cols[j]++
      }
    }
  }
  let count = 0
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(mat[i][j] === 1 && rows[i] === 1 && cols[j] === 1) count++
    }
  }
  return count
};
```

## 🌟😻✔ 1592. 重新排列单词间的空格【easy】

[ref](https://leetcode.cn/problems/rearrange-spaces-between-words/)

双指针、字符串

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var reorderSpaces = function(text) {
  const len = text.length, words = []
  let l = 0, r = 0, charsLen = 0
  while(r < len) {
    if(text[r] !== ' ') {
      l = r
      while(r < len && text[r] !== ' ') {
        r++
      }
      words.push(text.slice(l, r))
      charsLen += r - l
    }
    r++
  }
  const spaceLen = len - charsLen
  if(words.length === 1) return words[0] + (new Array(spaceLen).fill(' ').join(''))
  const avaSpace = Math.floor(spaceLen / (words.length - 1))
  return words.join(new Array(avaSpace).fill(' ').join('')) + new Array(spaceLen %  (words.length - 1)).fill(' ').join('')
};
```

## ✔ 1598. 文件夹操作日志搜集器【easy】

[ref](https://leetcode.cn/problems/crawler-log-folder/)

常规题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var minOperations = function(logs) {
  let res = 0
  for(let i=0;i<logs.length;i++) {
    const log = logs[i]
    if(log === '../') {
      res = Math.max(res - 1, 0)
    } else if(log !== './') {
      res++
    }
  }
  return res
};
```

## 🌟😻✔ 1608. 特殊数组的特征值【easy】

[ref](https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/)

计数排序、桶排序、排序

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var specialArray = function(nums) {
  const n = nums.length
  nums.sort((a, b) => a - b)
  for(let i = n - 1; i >= 0; i--) {
    if(i > 0 && nums[i] === nums[i - 1]) continue
    if(i === 0 && n - i <= nums[i]) return n - i
    if(n - i <= nums[i] && n - i > nums[i - 1]) return n - i
  }
  return -1
};
```

```js
// 计数排序
// 时间复杂度：O(M) M=1001
// 空间复杂度：O(M)
var specialArray = function(nums) {
  const n = nums.length
  const bucket = new Array(1001).fill(0)
  for(let i=0;i<n;i++) {
    bucket[nums[i]]++
  }
  let cnt = 0
  for(let i=1000;i>=0;i--) {
    cnt += bucket[i]
    if(cnt === i) return i
  }
  return -1
};
```

## ✔ 1619. 删除某些元素后的数组均值【easy】

[ref](https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/)

常规模拟

```js
var trimMean = function(arr) {
  const n = arr.length, deleteCount = n / 20
  arr.sort((a, b) => a - b)
  let sum = 0
  for(let i=deleteCount;i<n - deleteCount;i++)  {
    sum += arr[i]
  }
  return sum / (n - 2 * deleteCount)
};
```

## ✔ 1624. 两个相同字符之间的最长子字符串【easy】

[ref](https://leetcode.cn/problems/largest-substring-between-two-equal-characters/)

双指针

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var maxLengthBetweenEqualCharacters = function(s) {
  let max = -1
  for(let i=0;i<s.length;i++) {
    let j = s.length - 1
    while(j > i && s[j] !== s[i]) j--
    max = Math.max(max, j - i - 1)
  }
  return max
};
```

## ✔ 1636. 按照频率将数组升序排序【easy】

[ref](https://leetcode.cn/problems/sort-array-by-increasing-frequency/)

排序

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var frequencySort = function(nums) {
  const cntMap = new Map()
  for(let i=0;i<nums.length;i++) {
    cntMap.set(nums[i], (cntMap.get(nums[i]) || 0) + 1)
  }
  const cntArr = Array.from(cntMap)
  cntArr.sort((a, b) => a[1] - b[1] || b[0] - a[0])
  const res = []
  for(let i=0;i<cntArr.length;i++) {
    for(let j=0;j<cntArr[i][1];j++) {
      res.push(cntArr[i][0])
    }
  }
  return res
};
```

## ✔ 1640. 能否连接形成数组【easy】

[ref](https://leetcode.cn/problems/check-array-formation-through-concatenation/)

哈希表

```js
var canFormArray = function(arr, pieces) {
  let i = 0
  const map = new Map()
  for(let piece of pieces) {
    map.set(piece[0], piece)
  }
  while(i < arr.length) {
    const start = arr[i] 
    if(!map.has(start)) return false
    const nums = map.get(start)
    let j =0
    while(j < nums.length) {
      if(arr[i++] !== nums[j++]) return false
    }
  }
  return true
};
```

## 🌟✔ 1652. 拆炸弹【easy】

[ref](https://leetcode.cn/problems/defuse-the-bomb/)

数组题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var decrypt = function(code, k) {
  const arr = [...code, ...code], n = code.length
  let sum = 0
  let l = k >= 0 ? 1 : n + k
  let r = k>=0 ? k : n - 1
  for(let i = l; i <= r;i++) {
    sum += arr[i]
  }
  for(let i = 0; i < n;i++) {
    code[i] = sum
    sum += arr[++r] - arr[l++]
  }
  return code
};


````

## ✔ 1656. 设计有序流【easy】

[ref](https://leetcode.cn/problems/design-an-ordered-stream/)

哈希表、数组

```js
var OrderedStream = function(n) {
  this.i = 1
  this.stream = []
};

OrderedStream.prototype.insert = function(idKey, value) {
  this.stream[idKey] = value
  const res = []
  while(this.stream[this.i]) {
    res.push(this.stream[this.i++])
  }
  return res
};
```

## ✔ 1672. 最富有客户的资产总量【easy】

[ref](https://leetcode.cn/problems/richest-customer-wealth/)

矩阵、数组

```js
var maximumWealth = function(accounts) {
  let max = 0
  for(const accountArr of accounts) {
    let sum = 0
    for(const num of accountArr) sum += num
    max = Math.max(max, sum)
  }
  return max
};
```

## 🌟😻✔ 1694. 重新格式化电话号码【easy】

[ref](https://leetcode.cn/problems/reformat-phone-number/)

模拟

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var reformatNumber = function(number) {
  let nums = ''
  for(const num of number) {
    if(num !== ' ' && num >= '0' && num <= '9') nums += num
  }
  let res = ''
  let i = 0
  while(i < nums.length) {
    const resLen = nums.length - i
    if(resLen <= 4) {
      if(resLen === 4) {
        res += nums.slice(i, i + 2) + '-'
        i += 2
        res += nums.slice(i, i + 2)
        i += 2
      } else if(resLen === 3) {
        res += nums.slice(i, i + 3)
        i += 3
      } else {
        res += nums.slice(i, i + 2)
        i += 2
      } 
    } else {
      res += nums.slice(i, i + 3) + '-'
      i += 3
    }
  }

  return res
};
```

## 🌟😻✔ 1706. 球会落何处【medium】

[ref](https://leetcode.cn/problems/where-will-the-ball-fall/)

矩阵、模拟

```js
var findBall = function(grid) {
  const m = grid.length, n = grid[0].length
  const res = new Array(n).fill(-1)
  for(let j=0;j<n;j++) {
    let col = j
    for(let i = 0;i<m;i++) {
      if(
        col === 0 && grid[i][col] === -1 || 
        col === n - 1 && grid[i][col] === 1 || 
        grid[i][col] === -1 && grid[i][col - 1] === 1 ||
        grid[i][col] === 1 && grid[i][col + 1] === -1
      ) {
        col = -1
        break
      }
      col += grid[i][col]
    }
    res[j] = col
  }
  return res
};
```

```js
var findBall = function(grid) {
  const m = grid.length, n = grid[0].length
  let base = new Array(n).fill(0).map((_, i) => [i, i]) // 原来, 现在
  const res = new Array(n).fill(-1)
  for(let i=0;i<m;i++) {
    const next = []
    for(let k=0;k<base.length;k++) {
      const [ori, currJ] = base[k]
      if(currJ === 0 && grid[i][currJ] === -1) continue
      if(currJ === n - 1 && grid[i][currJ] === 1) continue
      if(grid[i][currJ] === 1 && grid[i][currJ + 1] === -1) continue
      if(grid[i][currJ] === -1 && grid[i][currJ - 1] === 1) continue
      next.push([ori, grid[i][currJ] + currJ])
    }
    base = next
  }
  for(let i=0;i<base.length;i++) {
    res[base[i][0]] = base[i][1]
  }
  return res
};
```

## 🌟😻✔ 1784. 检查二进制字符串字段【easy】

[ref](https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/)

简单模拟

```js
// 时间复杂度：O(N)
var checkOnesSegment = function(s) {
  let i = 0
  let cnt = 0
  while(i < s.length) {
    if(s[i] === '1') {
      if(i - 1 < 0 || s[i - 1] === '0') {
        cnt++
        if(cnt > 1) return false
      }
    }
    i++
  }
  return true
};
```

## 🌟😻✔ 1790. 仅执行一次字符串交换能否使两个字符串相等【easy】

[ref](https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/)

数组题、模拟

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var areAlmostEqual = function(s1, s2) {
  const arr = []
  for(let i=0;i<s1.length;i++) {
    if(s1[i] !== s2[i]) arr.push(i)
    if(arr.length > 2) return false
  }
  if(!arr.length) return true
  return s1[arr[0]] === s2[arr[1]] && s2[arr[0]] === s1[arr[1]]
};
```

## 🌟😻✔ 1800. 最大升序子数组和【easy】

[ref](https://leetcode.cn/problems/maximum-ascending-subarray-sum/)

数组题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxAscendingSum = function(nums) {
  const n = nums.length
  let max = nums[0]
  let r = 0, sum = 0
  while(r < n) {
    if(r === 0 || nums[r] > nums[r - 1]) {
      sum += nums[r]
    } else {
      sum = nums[r]
    }
    max = Math.max(max, sum)
    r++
  }
  return max
};
```

## ?🌟😻✔ 1979. 找出数组的最大公约数【easy】

[ref](https://leetcode.cn/problems/find-greatest-common-divisor-of-array/)

公约数、最大公约数

```js
// 最大公约数：greatest common divisor => gcd => 时间复杂度logM
// 时间复杂度：O(N+logM) M 是最大值
// 空间复杂度：O(1)
var findGCD = function(nums) {
  let min = nums[0], max = nums[0]
  for(let i=1;i<nums.length;i++) {
    min = Math.min(min, nums[i])
    max = Math.max(max, nums[i])
  }
  // return gcd1(min, max)
  return gcd2(max, min)
};

function gcd1(a, b) {
  return b === 0? a : gcd(b, a % b)
}

function gcd2(a, b) {
  while(b !== 0) {
    const pb = b
    b = a % b
    a = pb
  }
  return a
}
```

## ?🌟😻✔ 2104. 子数组范围和【medium】

[ref](https://leetcode.cn/problems/sum-of-subarray-ranges/) 

单调栈、连续子数组、数组

相关题目：

- ??? [🌟【hard】828. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/) 字符串、哈希表
- ?[🌟【medium】907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/) 数组、单调栈
- ?[🌟【medium】2104. 子数组范围和](https://leetcode.cn/problems/sum-of-subarray-ranges/) 数组、单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var subArrayRanges = function(nums) {
  const n = nums.length,
   minL = new Array(n).fill(-1),
   maxL = new Array(n).fill(-1),
   minR = new Array(n).fill(n),
   maxR = new Array(n).fill(n)
  let minStack = [], maxStack = []
  for(let i=0;i<n;i++) {
    while(minStack.length && nums[minStack[minStack.length - 1]] >= nums[i]) {
      minStack.pop()
    }
    if(minStack.length) {
      minL[i] = minStack[minStack.length - 1]
    }
    minStack.push(i)

    while(maxStack.length && nums[maxStack[maxStack.length - 1]] <= nums[i]) {
      maxStack.pop()
    }
    if(maxStack.length) {
      maxL[i] = maxStack[maxStack.length - 1]
    }
    maxStack.push(i)
  }
  minStack = [], maxStack = []
  for(let i = n-1; i >= 0; i--) {
    while(minStack.length && nums[minStack[minStack.length - 1]] > nums[i]) {
      minStack.pop()
    }
    if(minStack.length) {
      minR[i] = minStack[minStack.length - 1]
    }
    minStack.push(i)

    while(maxStack.length && nums[maxStack[maxStack.length - 1]] < nums[i]) {
      maxStack.pop()
    }
    if(maxStack.length) {
      maxR[i] = maxStack[maxStack.length - 1]
    }
    maxStack.push(i)
  }
  let minSum = 0, maxSum = 0
  for(let i=0;i<n;i++) {
    minSum += nums[i] * (i - minL[i]) * (minR[i] - i)
    maxSum += nums[i] * (i - maxL[i]) * (maxR[i] - i)
  }
  return maxSum - minSum
};

```


## 🌟😻✔ 剑指 Offer 04. 二维数组中的查找【medium】

[ref](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

```js
// 普通版
var findNumberIn2DArray = function(matrix, target) {
  if(!matrix.length) return false
  const m = matrix.length
  const n = matrix[0].length
  for(let j = n - 1; j >= 0; j--) {
    if(target === matrix[0][j]) {
      return true
    } else if(target < matrix[0][j]) {
      continue
    } else {
      for(let i = 1; i < m; i++) {
        if(matrix[i][j] === target) {
          return true
        } else if(matrix[i][j] < target) {
          continue
        } else {
          break
        }
      }
    }
  }
  return false
};
```

```js
// 高效版
// 时间复杂度：O(m+n)
// 空间复杂度：O(1)
var findNumberIn2DArray = function(matrix, target) {
  if(!matrix.length || !matrix[0].length) return false
  const m  = matrix.length
  const n  = matrix[0].length
  let i = 0
  let j = n - 1
  while(i < m && j >= 0) {
    if(matrix[i][j] === target) {
      return true
    } else if(matrix[i][j] > target) {
      j--
    } else {
      i++
    }
  }
  return false
};
```

## ✔ 剑指 Offer 05. 替换空格【easy】

[ref](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var replaceSpace = function(s) {
  let res = ''
  for(let c of s) {
    if(c === ' ') {
      res+='%20'
    } else {
      res+=c
    }
  }
  return res
};
```

## ✔ 剑指 Offer 06. 从尾到头打印链表【easy】

[ref](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

```js
var reversePrint = function(head) {
  const res = []
  while(head) {
    res.unshift(head.val)
    head = head.next
  }
  return res
};
```

## ✔ 剑指 Offer 09. 用两个栈实现队列【easy】

[ref](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```js
var CQueue = function() {
  this.inStack = []
  this.outStack = []
};

/** 
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
  this.inStack.push(value)
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
  // 必须要把 outStack 出干净之后才能再次从 instack 中拿数据
  if(!this.outStack.length) {
    if(this.inStack.length) {
      this.toOut()
      return this.outStack.pop()
    }
    return -1
  }
  return this.outStack.pop()
};

CQueue.prototype.toOut = function() {
  while(this.inStack.length) {
    this.outStack.push(this.inStack.pop())
  }
}
```

## ?🌟😻✔ 剑指 Offer 10- II. 青蛙跳台阶问题【easy】

[ref](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

动态规划、斐波拉契数列

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numWays = function(n) {
  if(n === 1 || n === 0) return 1
  let prev1 = 1
  let prev2 = 2
  for(let i=3;i<=n;i++) {
    const prev1Bf = prev1
    const prev2Bf = prev2
    prev2 = (prev1Bf + prev2Bf) % 1000000007
    prev1 = prev2Bf
  }
  return prev2
};

```

## 🌟😻✔ 剑指 Offer 12. 矩阵中的路径【medium】

[ref](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)

回溯

```js
// 时间复杂度：O(MN*3**L) L=word.length
// 空间复杂度：O(MN)
var exist = function(board, word) {
  const m = board.length
  const n = board[0].length

  function find(i, j, startIndex) {
    if(i < 0 || i >= m || j < 0 || j >= n || used[i][j] || board[i][j] !== word[startIndex]) return false
    if(startIndex === word.length - 1) return true
    used[i][j] = true

    const res = find(i + 1, j, startIndex + 1)
      || find(i - 1, j, startIndex + 1)
      || find(i, j + 1, startIndex + 1)
      || find(i, j - 1, startIndex + 1)

    used[i][j] = false
    return res
  }

  const used = new Array(m).fill(false).map(_ =>  new Array(n).fill(false))

  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(find(i, j, 0)) return true
    }
  }

  return false
};
```

## 😻✔ 剑指 Offer 13. 机器人的运动范围【medium】

[ref](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

动态规划、递归

```js
// 动态规划、递推
// 时间复杂度：O(m*n)
// 空间复杂度：O(m*n)
var movingCount = function(m, n, k) {
  const dp = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  dp[0][0] = true
  let count = 1
  for(let i=1;i<m;i++) {
    dp[i][0] = sum(i, 0) <= k && dp[i - 1][0]
    dp[i][0] && count++
  }
  for(let j=1;j<n;j++) {
    dp[0][j] = sum(0, j) <= k && dp[0][j - 1]
    dp[0][j] && count++
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      dp[i][j] = sum(i, j) <= k && (
        i - 1 >= 0 && dp[i - 1][j] ||
        j - 1 >= 0 && dp[i][j - 1]
      )
      dp[i][j] && count++
    }
  }
  return count
};

function sum(i, j) {
  let s = 0
  while(i>0) {
    s += i % 10
    i = Math.floor(i / 10)
  }
  while(j > 0) {
    s += j % 10
    j = Math.floor(j / 10)
  }
  return s
}
```

```js
// 递归
// 时间复杂度：O(mn)
// 空间复杂度：O(mn)
var movingCount = function(m, n, k) {
  let count = 0
  const walked = new Array(m).fill(false).map(_ => new Array(n).fill(false))
  function walk(i, j) {
    if(i < m && j < n && sum(i, j) <= k && !walked[i][j]) {
      walked[i][j] = true
      count++
      walk(i + 1, j)
      walk(i, j + 1)
    }
  }
  walk(0, 0)
  return count
};

function sum(i, j) {
  let s = 0
  while(i > 0) {
    s += i % 10
    i = Math.floor(i / 10)
  }
  while(j > 0) {
    s += j % 10
    j = Math.floor(j / 10)
  }
  return s
}
```

## ??🌟😻✔ 剑指 Offer 14- I. 剪绳子【medium】

[ref](https://leetcode.cn/problems/jian-sheng-zi-lcof/)

动态规划、数学规律

```js
var cuttingRope = function(n) {
  if(n <= 3) return n - 1
  let res = 1
  while(n > 4) {
    res *= 3
    n -= 3
  }
  return res * n
};
```

```js
// 数学规律解法
// 时间复杂度：O(1)
// 时间复杂度：O(1)
var cuttingRope = function(n) {
  if(n <= 3) return n - 1
  const a = Math.floor(n / 3), b = n % 3
  if(b === 0) return 3 ** a
  if(b === 1) return (3 ** (a - 1)) * 4
  return (3 ** a) * 2
};
```

```js
// 动态规划思路
// 时间复杂度：O(N^2)
// 时间复杂度：O(N)
var cuttingRope = function(n) {
  const dp = new Array(n + 1).fill(1)
  for(let i=2;i<=n;i++) {
    for(let j=1;j<i;j++) {
      dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j])
    }
  }
  return dp[n]
};
```

## ???🌟😻✔ 剑指 Offer 14- II. 剪绳子 II【medium】

[ref](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/)

数学规律

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var cuttingRope = function(n) {
  const mod = 1000000007
  if(n <= 3) return n - 1
  let res = 1
  while(n > 4) {
    res = (res * 3) % mod
    n -= 3
  }
  return (res * n) % mod
};

// 10 => 3 3 4 => 36
// 9  => 3 3 3 => 27
// 8  => 3 3 2 => 18
// 7  => 3 4 => 12
// 6  => 3 3 => 9
// 5  => 3 2 => 6
// 4  => 3 1 or 2 2 => 4
// 3  => 2 1 => 2
// 2  => 1 1 => 1

```

## ??🌟😻✔ 剑指 Offer 15. 二进制中1的个数【easy】

[ref](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/submissions/)

二进制、二进制运算

```js
// 循环检查每一位上1的个数
// 时间复杂度：O(K) k=32
// 空间复杂度：O(1)
var hammingWeight = function(n) {
  let count = 0
  for(let i=0;i<32;i++) {
    if(n & (1 << i)) count++
  }
  return count
};
// 1 << 32 === 1
```

```js
// 循环检查每一位上1的个数
// 时间复杂度：O(logN) logN <= 32
// 空间复杂度：O(1)
var hammingWeight = function(n) {
  let count = 0
  // 每循环一次都会清理掉从右往左的第一个1
  while(n) {
    n &= n - 1
    count++
  }
  return count
};
```

## ??🌟😻✔ 剑指 Offer 16. 数值的整数次方【medium】

[ref](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

快速幂、规律题

```js
// 快速幂
// 时间复杂度：O(logN)
// 空间复杂度：O(logN)
var myPow = function(x, n) {
  function pow(x, n) {
    if(n === 0) return 1
    if(n === 1) return x
    const y = pow(x, Math.floor(n / 2))
    const res =  y * y * (n % 2 === 0 ? 1 : x)
    return res
  }
  return n < 0? 1 / pow(x, -n): pow(x, n)
};

```


## ✔ 剑指 Offer 18. 删除链表的节点【easy】

[ref](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var deleteNode = function(head, val) {
  const myHead = new ListNode()
  myHead.next = head
  let thead = myHead
  while(thead.next) {
    if(thead.next.val === val) {
      thead.next = thead.next.next
      return myHead.next
    } else {
      thead = thead.next
    }
  }
  return myHead.next
};

```

## ??🌟😻✔ 剑指 Offer 19. 正则表达式匹配【hard】

[ref](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

动态规划

```js
// 动态规划
// 时间复杂度：O(M*N)
// 空间复杂度：O(M*N)
var isMatch = function(s, p) {
  const m = s.length, n = p.length
  const dp = new Array(m + 1).fill(0).map(_ => new Array(n + 1).fill(false))

  dp[0][0] = true

  for(let j=2;j<=n;j++) {
    if(p[j-1] === '*') {
      dp[0][j] = dp[0][j-2]
    }
  }
  
  for(let i=1;i<=m;i++) {
    for(let j=1;j<=n;j++) {
      if(p[j - 1] === '.' || s[i - 1] === p[j - 1]) {
        dp[i][j] = dp[i-1][j-1]
      } else if(p[j-1] === '*') {
        dp[i][j] = dp[i][j-2]
        if(p[j - 2] === '.' || p[j - 2] === s[i - 1]) {
          dp[i][j] = dp[i][j] || dp[i-1][j]
        }
      }
    }
  }

  return dp[m][n]
};

```

## ?? 🌟😻✔ 剑指 Offer 20. 表示数值的字符串【medium】

[ref](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

模拟、规律

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var isNumber = function(s) {
  // 去除首尾空格，之后不要再让我看到空格了啊，看到反手就是false
  s = s.trim().toLowerCase()
  if(!s.length) return false
  // 根据 e 直接拆分
  const sSplit = s.split('e')
  // 只有一个元素，那就不是科学计数法
  if(sSplit.length === 1) {
    return checkLeft(sSplit[0])
  } else if(sSplit.length === 2) {
    // 有两个元素，那可能是科学计数法
    return checkLeft(sSplit[0]) && checkRight(sSplit[1])
  }
  // 反手 false
  return false
};

// 检测e左侧部分
function checkLeft(s) {
  if(!s.length) return false
  let i=0
  let hasDot = false
  // 去除首正负号，之后不要让我看到符号了啊
  if(s[0] === '+' || s[0] === '-') {
    s = s.slice(1)
    // 好小子，难道只有符号没数字？
    if(!s.length) return false
  }
  while(i<s.length) {
    if(s[i] === '.') {
      // 难不成有几个 '.'?
      // 难不成s === '.'?
      if(hasDot || s.length === 1) return false
      hasDot = true
      i++
    // 我只要数字，别的我统统不要
    } else if(s[i] !== ' ' && s[i] >= 0 && s[i] <= 9) {
      i++
    } else {
      return false
    }
  }
  return true
}

// 检测整数部分
function checkRight(s) {
  if(!s.length) return false
  let i = 0
  // 去除首正负号，之后不要让我看到符号了啊
  if(s[0] === '+' || s[0] === '-') {
    s = s.slice(1)
    // 好小子，难道只有符号没数字？
    if(!s.length) return false
  }
  while(i<s.length) {
    // 思路清晰，我只要数字，别来其他幺蛾子
    // ' ' == 0 这点要注意，得排除
    if(s[i] !== ' ' && s[i] >= 0 && s[i] <= 9) {
      i++
    } else {
      return false
    }
  }
  return true
}
```

## 😻✔ 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面【easy】

[ref](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var exchange = function(nums) {
  let l = 0
  for(let i=0;i<nums.length;i++) {
    if(nums[i] % 2 === 1) {
      swap(nums, l, i)
      l++
    }
  }
  return nums
};

function swap(nums, i, j) {
  const t = nums[i]
  nums[i] = nums[j]
  nums[j] = t
}
```

## 😻✔ 剑指 Offer 22 链表中倒数第k个节点【easy】

[ref](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

链表

```js
var getKthFromEnd = function(head, k) {
  let tail = head
  for(let i=0;i<k;i++) {
    tail = tail.next
  }
  while(tail) {
    tail = tail.next
    head = head.next
  }
  return head
};
```

## ✔ 剑指 Offer 25 合并两个排序的链表【easy】

[ref](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

```js
var mergeTwoLists = function(l1, l2) {
  const head = new ListNode()
  let tHead = head
  while(l1 && l2) {
    if(l1.val < l2.val) {
      tHead.next = l1
      l1 = l1.next
    } else {
      tHead.next = l2
      l2 = l2.next
    }
    tHead = tHead.next
  }
  if(l1) {
    tHead.next = l1
  }
  if(l2) {
    tHead.next = l2
  }
  return head.next
};
```

## 😻✔ 剑指 Offer 26 树的子结构【medium】

[ref](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

二叉树

```js
// M=A.length N=A.length
// 时间复杂度：O(MN)
// 空间复杂度：O(M)
var isSubStructure = function(A, B) {
  if(!A || !B) return false
  return isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)
};

function isSub(A, B) {
  if(!B) return true
  if(!A) return false
  if(A.val !== B.val) return false
  return isSub(A.left, B.left) && isSub(A.right, B.right)
}
```

## 🌟😻✔ 剑指 Offer 27. 二叉树的镜像【easy】

[ref]()https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/

二叉树、镜像二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var mirrorTree = function(root) {
  if(!root) return null
  function create(node1, node2) {
    if(node1.left) {
      node2.right = new TreeNode(node1.left.val)
      create(node1.left, node2.right)
    }
    if(node1.right) {
      node2.left = new TreeNode(node1.right.val)
      create(node1.right, node2.left)
    }
  }
  const newRoot = new TreeNode(root.val)
  create(root, newRoot)
  return newRoot
};
```

## ?🌟😻✔ 剑指 Offer 28. 对称的二叉树【easy】

[ref](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)

二叉树、对称二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var isSymmetric = function(root) {
  if(!root) return true
  return compare(root.left, root.right)  
};

function compare(lnode, rnode) {
  if(!lnode && !rnode) return true
  if(lnode && rnode && lnode.val === rnode.val) {
    return compare(lnode.left, rnode.right) && compare(lnode.right, rnode.left)
  }
  return false
}
```

## ?🌟😻✔ 剑指 Offer 29. 顺时针打印矩阵【medium】

[ref](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

```js
// 时间复杂度：O(M*N)
// 时间复杂度：O(1)
var spiralOrder = function(matrix) {
  if(!matrix.length || !matrix[0].length) return []
  const m = matrix.length
  const n = matrix[0].length
  const len = m * n
  const res = []

  for(let i=0;i<Math.floor((m + 1) / 2);i++) {
    for(let j = i;j<=n - i - 1;j++) {
      res.push(matrix[i][j])
      if(res.length === len) return res 
    }
    for(let j = i + 1;j<m - i - 1;j++) {
      res.push(matrix[j][n - i - 1])
      if(res.length === len) return res
    }
    for(let j =n - i - 1;j>i;j--) {
      res.push(matrix[m - i - 1][j])
      if(res.length === len) return res
    }
    for(let j =m - i - 1;j>i;j--) {
      res.push(matrix[j][i])
      if(res.length === len) return res
    }
  }
};

// 1 2  3  4
// 5 6  7  8
// 9 10 11 12
// m=4 n=3
```

## ??🌟😻✔ 剑指 Offer 31. 栈的压入、弹出序列【medium】

[ref](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var validateStackSequences = function(pushed, popped) {
  let j=0
  const stack = []
  for(let i=0;i<pushed.length;i++) {
    stack.push(pushed[i])
    while(stack.length && stack[stack.length - 1] === popped[j]) {
      stack.pop()
      j++
    }
  }
  return stack.length === 0
};

```

## 🌟😻✔ 剑指 Offer 32 - I. 从上到下打印二叉树【medium】

[ref](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

BFS

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var levelOrder = function(root) {
  if(!root) return []
  const q = [root]
  const res = []
  while(q.length) {
    const t = q.shift()
    res.push(t.val)
    if(t.left) q.push(t.left)
    if(t.right) q.push(t.right)
  }
  return res
};
```

## 🌟😻✔ 剑指 Offer 32 - II. 从上到下打印二叉树 II【easy】

[ref](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

二叉树、BFS

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var levelOrder = function(root) {
  if(!root) return []
  let q = [root]
  let tq = []
  const res = []
  let tres = []
  while(q.length) {
    const node = q.shift()
    tres.push(node.val)
    node.left && tq.push(node.left)
    node.right && tq.push(node.right)
    if(!q.length) {
      q = tq
      tq = []
      res.push(tres)
      tres = []
    }
  }
  return res
};
```

## ? 🌟😻✔ 剑指 Offer 32 - III. 从上到下打印二叉树 III【medium】

[ref](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

二叉树、BFS

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var levelOrder = function(root) {
  if(!root) return []
  let tq = []
  let fromLeft = true
  let q = [root]
  const res = []
  let tres = []
  while(q.length) {
    const node = q.shift()
    if(fromLeft) {
      tres.push(node.val)
    } else {
      tres.unshift(node.val)
    }
    node.left && tq.push(node.left)
    node.right && tq.push(node.right)
    if(!q.length) {
      res.push(tres)
      tres = []
      q = tq
      tq = []
      fromLeft = !fromLeft
    }
  }
  return res
};
```

## ?? 🌟😻✔ 剑指 Offer 33. 二叉搜索树的后序遍历序列【medium】

[ref](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

二叉搜索树、后序遍历

```js
var verifyPostorder = function(postorder) {
  function verify(i, j) {
    if(i >= j) return true
    let l = i
    while(postorder[l] < postorder[j]) {
      l++
    }
    let leftMaxI = l
    while(postorder[l] > postorder[j]) {
      l++
    }
    return l === j && verify(i, leftMaxI - 1) && verify(leftMaxI, j - 1)
  }

  return verify(0, postorder.length - 1)
};
```

## ? 🌟😻✔ 剑指 Offer 34. 二叉树中和为某一值的路径【medium】

[ref](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

二叉树、二叉树路径和

```js
// 时间复杂度：O(N^2)
// 时间复杂度：O(N)
var pathSum = function(root, target) {
  if(!root) return []
  const res = []
  function dfs(node, path, sum) {
    if(!node.left && !node.right) {
      if(target === sum + node.val ) {
        res.push([...path, node.val])
      }
      return
    }
    path.push(node.val)
    node.left && dfs(node.left, path, sum + node.val)
    node.right && dfs(node.right, path, sum + node.val)
    path.pop()
  }
  dfs(root, [], 0)
  return res
};
```

## ?? 🌟😻✔ 剑指 Offer 35. 复杂链表的复制【medium】

[ref](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

链表

```js
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

// 时间复杂度：O(N)
// 空间复杂度：O(N)
var copyRandomList = function(head) {
  const map = new Map()
  function copyNode(node) {
    if(!node) return null
    if(map.has(node)) {
      return map.get(node)
    }
    const newNode = new Node(node.val)
    map.set(node, newNode)
    newNode.next = copyNode(node.next)
    newNode.random = copyNode(node.random)
    return newNode
  }

  return copyNode(head)
};
```

更优解

```js
/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var copyRandomList = function(head) {
  if(!head) return null
  const theHead = head
  while(head) {
    const newNode = new Node(head.val)
    const next = head.next
    head.next = newNode
    newNode.next = next
    head = next
  }
  head = theHead
  while(head) {
    const next = head.next
    next.random = head.random? head.random.next : null 
    head = next.next
  }
  head = theHead
  const newHead = new Node()
  let tHead = newHead
  while(head) {
    const copyNode = head.next
    head.next = copyNode.next
    head = head.next
    tHead.next = copyNode
    tHead = tHead.next
  }
  return newHead.next
};
```

## ?? 🌟😻✔ 剑指 Offer 36. 二叉搜索树与双向链表【medium】

[ref](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

二叉搜索树、双向链表

最优解

```js
// 时间复杂度：O(N)
// 时间复杂度：O(N)
var treeToDoublyList = function(root) {
  let head = null, prev = null
  if(!root) return null
  function dfs(node) {
    if(!node) return
    dfs(node.left)
    if(!head) {
      head = node
    } else {
      prev.right = node
      node.left = prev
    }
    prev = node
    dfs(node.right)
  }
  dfs(root)
  prev.right = head
  head.left = prev
  return head
};
```

略差解

```js
var treeToDoublyList = function(root) {
  if(!root) return null
  function dfs(node) {
    if(!node) return [null, null]
    let [leftMin, leftMax] = dfs(node.left) 
    const [rightMin, rightMax] = dfs(node.right)
    if(leftMax) {
      leftMax.right = node
      node.left = leftMax
    }
    if(rightMin) {
      node.right = rightMin
      rightMin.left = node
    }
    return [leftMin ? leftMin : node, rightMax ? rightMax : node]
  }

  const [minNode, maxNode] = dfs(root)

  minNode.left = maxNode
  maxNode.right = minNode
  return minNode
};
```

## ??🌟😻✔ 剑指 Offer 37. 序列化二叉树【hard】

[ref](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/)

二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) {
  return reserialize(root, '')
};

function reserialize(node, str) {
  if(!node) {
    str += 'null,'
    return str
  }
  str += node.val + ','
  str = reserialize(node.left, str)
  str = reserialize(node.right, str)
  return str
}

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
  return redeserialize(data.split(','), {i:0})
};

function redeserialize(datalist, indObj) {
  if(datalist[indObj.i] === 'null') {
    indObj.i++
    return null
  }
  const node = new TreeNode(parseInt(datalist[indObj.i], 10))
  indObj.i++
  node.left = redeserialize(datalist, indObj)
  node.right = redeserialize(datalist, indObj)
  return node
}
```

## ✔ 剑指 Offer 39. 数组中出现次数超过一半的数字【easy】

[ref](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

哈希表

```js
var majorityElement = function(nums) {
  const n = nums.length
  const map = new Map()
  for(let i=0;i<nums.length;i++) {
    map.set(nums[i], map.has(nums[i]) ? map.get(nums[i]) + 1 : 1)
    if(map.get(nums[i]) > n / 2) {
      return nums[i]
    }
  }
};
```

## 🌟😻✔ 剑指 Offer 40 最小的k个数【medium】

[ref](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

单调队列、小顶堆

```js
// 时间复杂度：O(N^2)
// 时间复杂度：O(N)
var getLeastNumbers = function(arr, k) {
  const res = []
  for(let i=0;i<arr.length;i++) {
    res.push(arr[i])
    let j = res.length - 1
    while(j - 1 >= 0 && res[j] < res[j - 1]) {
      swap(res, j, j - 1)
      j--
    }
    if(res.length > k) res.pop()
  }
  return res
};
function swap(arr, i, j) {
  let t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

## ??🌟😻✔ 剑指 Offer 43. 1～n 整数中 1 出现的次数【hard】

[ref](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/submissions/)

规律题

```js
// 规律题
// 参考 https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/jin-hu-shuang-bai-javascriptai-hao-zhe-by-tang_cha/
var countDigitOne = function(n) {
  const prevArr = [0, 1, 20, 300, 4000, 50000, 600000, 7000000, 80000000, 900000000]
  let count = 0
  let str = '' + n
  const len = str.length
  let i=0
  while(i < len) {
    const targetNum = str[i]
    const numCount = len - i - 1
    count += targetNum * prevArr[numCount]
    if(targetNum === '1') {
      count++
      if(i !== len - 1) {
        count += Number(str.slice(i + 1))
      }
    }
    if(targetNum > 1) {
      count += 10 ** numCount
    }
    i++
  }
  return count
};

// // 位数        1 的个数               总1的个数
// 0               0                       0 (0~0)
// 1               1                       1  => (0~9)
// 2               11 + 8 => 19            20 => 10 ^ 1 + 10 * 1 (0~99)
// 3               100 + 20*9              300 => 10 ^ 2 + 10 * 20 (0~999)
// 4                                       4000 => 10 ^ 3 + 10 * 300 (0~9999)
// 5                                       50000 => 10 ^ 4 + 10 * 4000 (0~99999)
// 6                                       600000 => 10 ^ 5 + 10 * 50000 (0~999999)
// 7                                       7000000 => 10 ^ 6 + 10 * 550000
// 8                                       80000000 => 10 ^ 6 + 10 * 550000
// 9                                       900000000 => 10 ^ 6 + 10 * 550000

// 54321
// 0-50000
// 0-4000
// 0-300
// 0-20
// 0-1
```

## ??🌟😻✔ 剑指 Offer 44. 数字序列中某一位的数字【medium】

[ref](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

规律题、数学规律

```js
// 时间复杂度：O(logN)  logN 是目标数字 fullnum 的位数 
// 空间复杂度：O(logN)
var findNthDigit = function(n) {
  n++
  let count = 1
  // 位数
  let k = 1
  while(count + k * 9 * 10 ** (k - 1) < n) {
    count += k * 9 * 10 ** (k - 1)
    k++
  }
  n -= count
  // 对应位数的首个数字
  const targetFullNum = 10 ** (k - 1) + Math.floor((n - 1) / k)
  n -= Math.floor((n - 1) / k) * k
  return targetFullNum.toString()[n - 1]
};
// 1 0-9 10 => 10
// 2 10-99 2*9*10 => 180
// 3 100-999 3*9*100 => 2700

```

## ?🌟😻✔ 剑指 Offer 45 把数组排成最小的数【medium】

[ref](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

同 [#179 最大数](https://leetcode.cn/problems/largest-number/)

```js
var minNumber = function(nums) {
  return nums.sort((x, y) => ('' + x + y) - ('' + y + x)).join('')
};
```

## 🌟😻✔ 剑指 Offer 45 把数组排成最小的数【medium】

[ref](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/)

动态规划

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(1) 直接在给定的 grid 上进行的更改，没有创建额外的空间
var maxValue = function(grid) {
  if(grid.length === 0 || grid[0].length === 0) return 0
  const m = grid.length
  const n = grid[0].length
  for(let i=1;i<m;i++) {
    grid[i][0] += grid[i - 1][0]
  }
  for(let j=1;j<n;j++) {
    grid[0][j] += grid[0][j - 1]
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      grid[i][j] += Math.max(grid[i-1][j], grid[i][j - 1])
    }
  }
  return grid[m-1][n-1]
};
```

## ??🌟😻✔ 剑指 Offer 49. 丑数【medium】

[ref](https://leetcode.cn/problems/chou-shu-lcof/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var nthUglyNumber = function(n) {
  const dp = new Array(n + 1).fill(1)
  let l2 = 1, l3 = 1, l5 = 1
  for(let i=2;i<=n;i++) {
    const p2 = dp[l2] * 2
    const p3 = dp[l3] * 3
    const p5 = dp[l5] * 5
    const min = Math.min(p2, p3, p5)
    if(min === p2) {
      l2++
    }

    if(min === p3) {
      l3++
    }

    if(min === p5) {
      l5++
    }
    dp[i] = min
  }
  return dp[n]
};

```

## ✔ 剑指 Offer 50 第一个只出现一次的字符【easy】

[ref](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var firstUniqChar = function(s) {
  const map = new Map()
  for(let i=0;i<s.length;i++) {
    map.set(s[i], map.has(s[i])? map.get(s[i]) + 1 : 1)
  }
  for(let i=0;i<s.length;i++) {
    if(map.get(s[i]) === 1) return s[i]
  }
  return ' '
};
```

## 🌟😻✔ 剑指 Offer 51 数组中的逆序对【hard】

[ref](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

归并排序

```js
// 时间复杂度：O(nlogn)
// 空间复杂度：O(n)
/**
 * @param {number[]} nums
 * @return {number}
 */
var reversePairs = function(nums) {
  let total = 0
  /**
  * @param {number[]} arr
  * @return {number[]}
  */
  function mergeSort(arr, l, r) {
    if (r === l) return [arr[l]]
    if (r < l) return []
    const mid = Math.floor((l + r) / 2)
    return merge(mergeSort(arr, l, mid), mergeSort(arr, mid + 1, r))
  }

  /**
  * @param {number[]} arr1
  * @param {number[]} arr2
  * @return {number[]}
  */
  function merge(arr1, arr2) {
    const res = []
    const len1 = arr1.length
    const len2 = arr2.length
    let l1 = 0
    let l2 = 0
    while(l1 < len1 && l2 < len2) {
      if(arr1[l1] <= arr2[l2]) {
        res.push(arr1[l1++])
      } else {
        total += len1 - l1
        res.push(arr2[l2++])
      }
    }
    while(l1 < len1) {
      res.push(arr1[l1++])
    }
    while(l2<len2) {
      res.push(arr2[l2++])
    }
    return res
  }

  mergeSort(nums, 0, nums.length - 1)
  return total
};
```

## ?? 🌟😻✔ 剑指 Offer 52. 两个链表的第一个公共节点【easy】

[ref](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

链表、链表公共节点

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var getIntersectionNode = function(headA, headB) {
  let pA = headA  
  let pB = headB
  while(pA !== pB) {
    pA = pA ? pA.next : headB
    pB = pB ? pB.next : headA
  }
  return pA
};
```

## ?? 🌟😻✔ 剑指 Offer 53 - I. 在排序数组中查找数字 I【easy】

[ref](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

二分搜索

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var search = function(nums, target) {
  const n = nums.length
  let lIndex = binarySearch(nums, target, true)
  let rIndex = binarySearch(nums, target, false) - 1
  if(
    lIndex >= 0 && lIndex < n &&
    rIndex >= 0 && rIndex < n &&
    lIndex <= rIndex &&
    nums[lIndex] === target &&
    nums[rIndex] === target
  ) {
    return rIndex - lIndex + 1
  }
  return 0
};

function binarySearch(nums, target, isLeft) {
  let l = 0, r = nums.length - 1
  while(l <= r) {
    const mid = (l + r) >> 1
    if(nums[mid] > target || (isLeft && nums[mid] >= target)) {
      r = mid - 1
    } else {
      l = mid + 1
    }
  }
  return l
}
```

## ?? 🌟😻✔ 剑指 Offer 53 - II. 0～n-1中缺失的数字【easy】

[ref](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)

二分查找

```js
// 二分
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var missingNumber = function(nums) {
  let l = 0, r = nums.length - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] !== mid) {
      r = mid - 1
    } else {
      l = mid + 1
    }
  }
  return ++r
};
```

```js
// 常规遍历
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var missingNumber = function(nums) {
  for(let i=0;i<nums.length;i++) {
    if(nums[i] !== i) {
      return i
    }
  }
  return nums.length
};
```

## 🌟😻✔ 剑指 Offer 54. 二叉搜索树的第k大节点【easy】

[ref](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

二叉搜索树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var kthLargest = function(root, k) {
  let target
  let count = 0
  function dfs(node) {
    node.right && dfs(node.right)
    count++
    if(count === k) {
      target = node.val
    }
    node.left && dfs(node.left)
  }
  dfs(root)
  return target
};
```

## 🌟😻✔ 剑指 Offer 55 - I. 二叉树的深度【easy】

[ref](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/)

二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var maxDepth = function(root) {
  let max = 0
  function dfs(node, h) {
    if(!node) {
      max = Math.max(max, h)
      return
    }
    dfs(node.left, h + 1)
    dfs(node.right, h + 1)
  }
  dfs(root, 0)
  return max
};
```

## 🌟😻✔ 剑指 Offer 55 - II. 平衡二叉树【easy】

[ref](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/)

二叉树、平衡二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var isBalanced = function(root) {
  let is = true
  function dfs(node) {
    if(!node) return 0
    const lh = dfs(node.left)
    const rh = dfs(node.right)
    if(Math.abs(lh - rh) > 1) {
      is = false
    }
    return Math.max(lh, rh) + 1
  }
  dfs(root)
  return is
};
```

## ?? 🌟😻✔ 剑指 Offer 56 - I. 数组中数字出现的次数【medium】

[ref](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

二进制、与或非、位运算

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var singleNumbers = function(nums) {
  let x = 0, a, b, first = 1;
  for(let val of nums) {
    x ^= val; // 对原数组所有数进行异或操作，最后的 x = a ^ b，  a 和 b 是要返回的两个数字
  }

  // 从 x 中任意找一个1，因为 1 代表着是 a 和 b 肯定不同的位置，为了方便，找到最低位的 1 即可
  while((first & x) === 0) {
    first <<= 1;
  }

  // 然后通过 first 对原数组进行分组，二进制串中在这一位为 1 或 0 的分为两组，因此相同数字肯定被分到一组，a 和 b 肯定一个是1， 一个是0，所以被分到两组
  for(let val of nums) {
    if(val & first) {
      // 这里最终异或完是 val 跟 a 的从最右侧开始数，一样长度的数，都是一样的
      a ^= val;
    } else {
      // 这里最终异或完是 val 跟 a 的从最右侧开始数，一样长度的数，除了最低位1那里不一样，右侧都一样的
      b ^= val;
    }
  }
  return [a, b];
};
```

## ?? 🌟😻✔ 剑指 Offer 56 - II. 数组中数字出现的次数 II【medium】

[ref](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

二进制、位运算、规律题

```js
// ref https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/jian-zhi-56-shu-zu-zhong-shu-zi-chu-xian-rgt7/
// 利用三个相同数的特性，在二进制表示中，每一位上三个相同数的二进制位对3取余数必为0
// 把所有数的二进制位相加，所有位对3取余数，则得到落单的那个数的二进制表示，再转换为十进制即可
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var singleNumber = function(nums) {
  const dp = new Array(32).fill(0)
  for(let i = 0; i < nums.length; i++) {
    let j = 0
    while(nums[i]) {
      dp[j] += nums[i] % 2
      nums[i] >>= 1
      j++
    }
  }
  let res = 0
  for(let i = 0; i < 32; i++) {
    res += (1 << i) * (dp[i] % 3)
  }
  return res
};
```

## ✔ 剑指 Offer 57. 和为s的两个数字【easy】

[ref](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var twoSum = function(nums, target) {
  let l = 0, r = nums.length - 1
  while(l < r) {
    const s = nums[l] + nums[r]
    if(s === target) {
      break
    } else if(s > target) {
      r--
    } else {
      l++
    }
  }
  return [nums[l], nums[r]]
};
```

## ?? 🌟😻✔ 剑指 Offer 57 - II. 和为s的连续正数序列【easy】

[ref](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

双指针、滑动窗口

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findContinuousSequence = function(target) {
  let l = 1, r = 2
  let sum = 1
  const max = Math.ceil(target / 2)
  const res = []
  while(r <= max) {
    sum += r
    while(l < r && sum > target) {
      sum -= l
      l++
    }
    if(sum === target) {
      const t = []
      for(let j=l;j<=r;j++) {
        t.push(j)
      }
      res.push(t)
    }
    r++
  }
  return res
};
```


## ✔ 剑指 Offer 58 - I. 翻转单词顺序【easy】

[ref](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var reverseWords = function(s) {
  let res = ''
  const arr = s.split(' ').reverse()
  for(let str of arr) {
    if(str !== '') {
      res = res + str + ' '
    }
  }
  return res.slice(0, res.length - 1)
};
```

## ✔ 剑指 Offer 58 - II. 左旋转字符串【easy】

[ref](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```js
var reverseLeftWords = function(s, n) {
  return s.slice(n) + s.slice(0, n)
};
```

## 🌟😻✔ 剑指 Offer 59 - I. 滑动窗口的最大值【hard】

[ref](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(K)
var maxSlidingWindow = function(nums, k) {
  if(!nums.length || k === 0) return []
  const q = []
  for(let i=0;i<k;i++) {
    while(q.length && q[q.length - 1] < nums[i]) {
      q.pop()
    }
    q.push(nums[i])
  }
  const res = [q[0]]
  for(let i=k;i<nums.length;i++) {
    while(q.length && q[q.length - 1] < nums[i]) {
      q.pop()
    }
    q.push(nums[i])
    if(q[0] === nums[i - k]) {
      q.shift()
    }
    res.push(q[0])
  }
  return res
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(K)
var maxSlidingWindow = function(nums, k) {
  if(!nums.length) return []
  const res = []
  const q = []
  for(let i=0;i<k-1;i++) {
    while(q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop()
    }
    q.push(i)
  }
  for(let i=k-1;i<nums.length;i++) {
    while(q.length && q[0] <= i - k) {
      q.shift()
    }
    while(q.length && nums[i] >= nums[q[q.length - 1]]) {
      q.pop()
    }
    q.push(i)
    res.push(nums[q[0]])
  }
  return res
};
```

## ?? 🌟😻✔ 剑指 Offer 59 - II. 队列的最大值【medium】

[ref](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)

队列、栈、单调数组、双端队列

```js
var MaxQueue = function() {
  this.q = []
  this.dq = []
};

/**
 * @return {number}
 */
MaxQueue.prototype.max_value = function() {
  if(!this.q.length) return -1
  return this.dq[0]
};

/** 
 * @param {number} value
 * @return {void}
 */
MaxQueue.prototype.push_back = function(value) {
  while(this.dq.length && value > this.dq[this.dq.length - 1]) {
    this.dq.pop()
  }
  this.dq.push(value)
  this.q.push(value)
};

/**
 * @return {number}
 */
MaxQueue.prototype.pop_front = function() {
  if(!this.q.length) return -1
  const t = this.q.shift()
  if(t === this.dq[0]) {
    this.dq.shift()
  }
  return t
};
```

or 双指针

```js
// 求滑动窗口最大值的变种题
// 设计一个数组，用双指针表示当前 push、pop 到哪一位了，即可实现队列效果
// maxQ 是一个单调下标数组，当push操作新添加一个值的时候，让 maxQ 中所有比该数小的数对应的下标全部出栈，最后让当前值的下标入栈
// 由于是一个可变宽度的滑动窗口，故获取最大下标之前，要先看是否还存在合理下标
// 对于每一个新push的数，其下标必然是处于 maxQ 的末尾
// 只要 l、r 区间内还存在符合条件的下标，则必然 maxQ 中会有值
var MaxQueue = function() {
  this.l = 0
  this.r = -1
  this.baseArr = []
  this.maxQ = []
};

/**
 * @return {number}
 */
MaxQueue.prototype.max_value = function() {
  if(this.l > this.r) return -1
  while(this.maxQ.length && this.maxQ[0] < this.l) {
    this.maxQ.shift()
  }
  return this.baseArr[this.maxQ[0]]
};

/** 
 * @param {number} value
 * @return {void}
 */
MaxQueue.prototype.push_back = function(value) {
  this.baseArr[++this.r] = value
  while(this.maxQ.length && this.baseArr[this.maxQ[this.maxQ.length - 1]] <= value) {
    this.maxQ.pop()
  }
  this.maxQ.push(this.r)
};

/**
 * @return {number}
 */
MaxQueue.prototype.pop_front = function() {
  if(this.l > this.r) return -1
  return this.baseArr[this.l++]
};
```

## ?? 🌟😻✔ 剑指 Offer 60. n个骰子的点数【medium】

[ref](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/)

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var dicesProbability = function(n) {
  let dp = [1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6]
  for(let i=2;i<=n;i++) {
    const tmp = new Array(5 * i + 1).fill(0)
    for(let j = 0; j < dp.length; j++) {
      for(let k = 0; k < 6; k++) {
        tmp[j + k] += dp[j] / 6
      }
    }
    dp = tmp
  }

  return dp
};
```

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var dicesProbability = function(n) {
  const min = n
  const max = 6 * n
  const dp = new Array(n + 1).fill(0).map(_ => new Array(max + 1).fill(0))
  dp[1][1] = 1 / 6
  dp[1][2] = 1 / 6
  dp[1][3] = 1 / 6
  dp[1][4] = 1 / 6
  dp[1][5] = 1 / 6
  dp[1][6] = 1 / 6

  for(let i=2;i<=n;i++) {
    const iMin = i
    const iMax = i * 6
    for(let j = iMin; j <= iMax; j++) {
      dp[i][j] = 
          (j - 1 >= i - 1 && j - 1 <= 6 * (i - 1) ? dp[i - 1][j - 1] : 0)
        + (j - 2 >= i - 1 && j - 2 <= 6 * (i - 1) ? dp[i - 1][j - 2] : 0)
        + (j - 3 >= i - 1 && j - 3 <= 6 * (i - 1) ? dp[i - 1][j - 3] : 0)
        + (j - 4 >= i - 1 && j - 4 <= 6 * (i - 1) ? dp[i - 1][j - 4] : 0)
        + (j - 5 >= i - 1 && j - 5 <= 6 * (i - 1) ? dp[i - 1][j - 5] : 0)
        + (j - 6 >= i - 1 && j - 6 <= 6 * (i - 1) ? dp[i - 1][j - 6] : 0)
      dp[i][j] *= 1 / 6
    }
  }

  return dp[n].slice(min, max + 1)
};

//    1        2         3      4       5      6
// [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]

// 2                   3               4              5            6          7       8         9      10     11     12
// f(1) * f(1)   f(1) * f(2)      f(1) * f(3)    f(1) * f(4)     1  5       1   6   2   6
//               f(2) * f(1)      f(2) * f(2)    f(2) * f(3)     2  4       2   5   3   5
//                                f(3) * f(1)    f(3) * f(2)     3  3       3   4   4   4
//                                               f(4) * f(1)     4  2       4   3   5   3
//                                                               5  1       5   2   6   2
//                                                                          6   1

// 3          4             5      
// 1*1*1     1*1*2        1 1 3
//                        1 2 2

// f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)
```

## ? 🌟😻✔ 剑指 Offer 61. 扑克牌中的顺子【easy】

[ref](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

```js
var isStraight = function(nums) {
  nums.sort((a, b) => a - b)
  let kingCount = 0
  let l = 0
  while(l < nums.length && nums[l] === 0) {
    kingCount++
    l++
  }
  if(kingCount === 5) return true
  let prev = nums[l]
  l++
  while(l < nums.length) {
    if(nums[l] === prev) {
      return false
    } else if(nums[l] - prev - 1 <= kingCount) {
      kingCount -= nums[l] - prev - 1
      prev = nums[l]
      l++
    } else {
      return false
    }
  }
  return true
};
```

## ??? 🌟😻✔ 剑指 Offer 62. 圆圈中最后剩下的数字【easy】

[ref](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

规律题、约瑟夫环、直接背结论

- [约瑟夫环——公式法（递推公式）](https://blog.csdn.net/u011500062/article/details/72855826)

```js
// 约瑟夫环、根据结果反推、直接背递推公式
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var lastRemaining = function(n, m) {
  let ans = 0
  for(let i=2;i<=n;i++) {
    ans = (ans + m) % i
  }
  return ans
};

// 0 1 2 3 4 5 m = 6   3
// 0 1 2 3 4           3
// 1 2 3 4             2
// 3 4 1               0
// 3 4                 0
// 3                   0

// nextX = (x + m) % nextLen
// 0
// 0 = (0 + 6) % 2
// 0 = (0 + 6) % 3
// 2 = (0 + 6) % 4
// 3 = (2 + 6) % 5
// 3 = (3 + 6) % 6

```

## 🌟😻✔ 剑指 Offer 63 股票的最大利润【easy】

[ref](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var maxProfit = function(prices) {
  if(prices.length < 2) return 0
  let max = 0
  let min = prices[0]
  for(let i=1;i<prices.length;i++) {
    max = Math.max(max, prices[i] - min)

    if(prices[i] < min) {
      min = prices[i]
    }
  }
  return max
};
```

## ? 🌟😻✔ 剑指 Offer 64. 求1+2+…+n【medium】

[ref](https://leetcode.cn/problems/qiu-12n-lcof/)

求和、非常规求和

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var sumNums = function(n) {
  let res = n
  n && (res += sumNums(n - 1))
  return res 
};
```

## ??🌟😻✔ 剑指 Offer 65. 不用加减乘除做加法【easy】

[ref](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

二进制、位运算

参考

- [面试题65. 不用加减乘除做加法（位运算，清晰图解）](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/)

```js
// 时间复杂度：O(1)
// 空间复杂度：O(1)
var add = function(a, b) {
  while(b !== 0) {
    const t = (a & b) << 1
    a ^= b
    b = t
  }
  return a
};
// a=3
// 11
// b=2
// 10

// a=100
// b=1

// a=0
// b=101
```

## 🌟😻✔ 剑指 Offer 66. 构建乘积数组【medium】

[ref](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/)

数组题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var constructArr = function(nums) {
  const n = nums.length
  const rp = new Array(n)
  rp[n - 1] = 1
  for(let i = n-2; i >=0; i--) {
    rp[i] = rp[i + 1] * nums[i + 1]
  }
  let lMul = 1
  for(let i=0;i<n;i++) {
    rp[i] = lMul * rp[i]
    lMul *= nums[i]
  }
  return rp
};
```

## ??🌟😻✔ 剑指 Offer 67. 把字符串转换成整数【medium】

[ref](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

字符串、字符串转换为整数

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var strToInt = function(str) {
  const max = 2 ** 31 - 1
  const min = -(2 ** 31)
  while(str.length && str[0] === ' ') {
    str = str.slice(1)
  }
  if(str[0] === '+' || str[0] === '-' || (str[0] >=0 && str[0] <= 9)) {
    let neg = 1
    let i=0
    if(str[i] === '+') {
      neg *= 1
      i++
    } else if(str[i] === '-') {
      neg *= -1
      i++
    }
    if(str[i] === '+' || str[i] === '-') return 0
    let num = 0
    while(str[i] !== ' ' && str[i] >=0 && str[i] <= 9) {
      if((10 * num + neg * Number(str[i])) >= max) return max
      if((10 * num + neg * Number(str[i])) <= min) return min
      num = 10 * num + neg * Number(str[i])
      i++
    }
    return num
  }
  return 0
};

```

## 🌟😻✔ 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先【easy】

[ref](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/submissions/)

二叉搜索树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var lowestCommonAncestor = function(root, p, q) {
  while(true) {
    if(root.val < p.val && root.val < q.val) {
      root = root.right
    } else if(root.val > p.val && root.val > q.val) {
      root = root.left
    } else {
      return root
    }
  }
};
```

## 🌟😻✔ 剑指 Offer 68 - II. 二叉树的最近公共祖先【easy】

[ref](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var lowestCommonAncestor = function(root, p, q) {
  let target
  function dfs(node) {
    if(!node) return false
    const isTarget = node === p || node === q
    let lfind = dfs(node.left)
    let rfind = dfs(node.right)
    if(lfind && rfind || isTarget && (lfind || rfind)) {
      target = node
    }
    return lfind || rfind || isTarget
  }

  dfs(root)
  return target
};  
```

## 🌟😻✔ 面试题 01.02. 判定是否互为字符重排【easy】

[ref](https://leetcode.cn/problems/check-permutation-lcci/)

哈希表

```js
// 时间复杂度：O(M+N) M=s1.length, N=s2.length
// 空间复杂度：O(K) K 是s1中不同字符的个数，K 最大为 M
var CheckPermutation = function(s1, s2) {
  const m = new Map()
  let diffCnt = 0
  for(let i=0;i<s1.length;i++) {
    m.set(s1[i], (m.get(s1[i]) || 0) + 1)
    if(m.get(s1[i]) === 1) {
      diffCnt++
    }
  }
  for(let i=0;i<s2.length;i++) {
    if(!m.has(s2[i]) || m.get(s2[i]) === 0) return false
    m.set(s2[i], m.get(s2[i]) - 1)
    if(m.get(s2[i]) === 0) diffCnt--
  }
  return diffCnt === 0
};
```

## 🌟😻✔ 面试题 01.03. URL化【easy】

[ref](https://leetcode.cn/problems/string-to-url-lcci/)

字符串

```js
var replaceSpaces = function(S, length) {
  let res = ''
  for(let i=0;i<length;i++) {
    if(S[i] === ' ') res += '%20'
    else res += S[i]
  }
  return res
};
```

## 🌟😻✔ 面试题 01.04. 回文排列【easy】

[ref](https://leetcode.cn/problems/palindrome-permutation-lcci/)

哈希表

```js
var canPermutePalindrome = function(s) {
  const map = new Map()
  for(const c of s) map.set(c, (map.get(c) || 0) + 1)
  let singleCnt = 0
  for(const cnt of map.values()) {
    if(cnt % 2 === 1) {
      singleCnt++
    }
  }
  return singleCnt <= 1
};
```

## 🌟😻✔ 面试题 01.06. 字符串压缩【easy】

[ref](https://leetcode.cn/problems/compress-string-lcci/)

字符串

```js
var compressString = function(S) {
  const n = S.length
  let res = '', i = 0
  while(i < n) {
    let cnt = 0, target = S[i]
    while(i < n && S[i] === target) i++, cnt++
    res += `${target}${cnt}`
  }
  return res.length >= n ? S : res
};
```

## ??🌟😻✔ 面试题 01.07. 旋转矩阵【medium】

[ref](https://leetcode.cn/problems/rotate-matrix-lcci/)

原地旋转矩阵

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var rotate = function(matrix) {
  const n = matrix.length
  for(let i=0;i < Math.floor(n / 2); i++) {
    for(let j=0; j < Math.floor((n + 1) / 2); j++) {
      const t = matrix[i][j]
      matrix[i][j] = matrix[n - 1 - j][i]
      matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]
      matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]
      matrix[j][n - 1 - i] = t
    }
  }
};

// x=i,    y=j
// x=j,    y=n - 1 - i
// x=n - 1 - i,    y=n - 1 - j
// x=n - 1 - j,   y=i
```

## 🌟😻✔ 面试题 01.08. 零矩阵【medium】

[ref](https://leetcode.cn/problems/zero-matrix-lcci/)

矩阵、哈希表、集合

```js
// 时间复杂度：O(M*N)
// 空间复杂度：O(M+N)
var setZeroes = function(matrix) {
  const rowS = new Set(), colS = new Set(), m = matrix.length, n = matrix[0].length
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(matrix[i][j] === 0) {
        rowS.add(i)
        colS.add(j)
      }
    }
  }
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(rowS.has(i) || colS.has(j)) {
        matrix[i][j] = 0
      }
    }
  }
  return matrix
};
```

## 🌟😻✔ 面试题 01.09. 字符串轮转【easy】

[ref](https://leetcode.cn/problems/string-rotation-lcci/)

字符串题、字符串旋转

```js
var isFlipedString = function(s1, s2) {
  return (s1 + s1).indexOf(s2) !== -1 && s1.length === s2.length
};
```

## 🌟😻✔ 面试题 02.01. 移除重复节点【easy】

[ref](https://leetcode.cn/problems/remove-duplicate-node-lcci/)

链表

```js
var removeDuplicateNodes = function(head) {
  const set = new Set(), myHead = new ListNode()
  myHead.next = head
  let tHead = myHead
  while(tHead.next) {
    if(set.has(tHead.next.val)) {
      tHead.next = tHead.next.next
    } else {
      set.add(tHead.next.val)
      tHead = tHead.next
    }
  }
  return myHead.next
};
```

## 🌟😻✔ 面试题 02.02. 返回倒数第 k 个节点【easy】

[ref](https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/)

链表

```js
var kthToLast = function(head, k) {
  let tHead = head, cnt = 1
  while(cnt < k) {
    tHead = tHead.next
    cnt++
  }
  let tHead2 = head
  while(tHead.next) {
    tHead = tHead.next
    tHead2 = tHead2.next
  }
  return tHead2.val
};
```

## 🌟😻✔ 面试题 02.03. 删除中间节点【easy】

[ref](https://leetcode.cn/problems/delete-middle-node-lcci/)

链表

```js
var deleteNode = function(node) {
  let prev = null
  while(node.next) {
    node.val = node.next.val
    prev = node
    node = node.next
  }
  prev.next = null
};
```

## 🌟😻✔ 面试题 02.04. 分割链表【medium】

[ref](https://leetcode.cn/problems/partition-list-lcci/)

链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var partition = function(head, x) {
  const myHead1 = new ListNode(0), myHead2 = new ListNode(0)
  let th1 = myHead1, th2 = myHead2
  while(head) {
    if(head.val < x) {
      th1.next = head
      th1 = th1.next
    } else {
      th2.next = head
      th2 = th2.next
    }
    head = head.next
  }
  th2.next = null
  th1.next = myHead2.next
  return myHead1.next
};

```

## 🌟😻✔ 面试题 02.05 链表求和【medium】

[ref](https://leetcode.cn/problems/sum-lists-lcci/)

链表

```js
var addTwoNumbers = function(l1, l2) {
  let add = 0
  const head = new ListNode()
  let tHead = head
  while(l1 || l2) {
    const tS = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + add
    add = Math.floor(tS / 10)
    tHead.next = new ListNode(tS % 10)
    tHead = tHead.next
    l1 && (l1 = l1.next)
    l2 && (l2 = l2.next)
  }
  if(add > 0) {
    tHead.next = new ListNode(add)
  }
  return head.next
};
```

## 🌟😻✔ 面试题 02.06. 回文链表【easy】

[ref](https://leetcode.cn/problems/palindrome-linked-list-lcci/)

链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var isPalindrome = function(head) {
  const myHead = new ListNode()
  myHead.next = head
  let fast = myHead, slow  = myHead
  while(fast.next && fast.next.next) {
    fast = fast.next.next
    slow = slow.next
  }
  if(slow === fast) return true
  let head1 = head, head2 = slow.next
  slow.next = null, head2 = reverse(head2)
  while(head1) {
    if(head1.val !== head2.val) return false
    head1 = head1.next
    head2 = head2.next
  }
  return true
};

function reverse(head) {
  const myHead = new ListNode()
  
  while(head) {
    const next = myHead.next
    myHead.next = head
    head = head.next
    myHead.next.next = next
  }
  return myHead.next
}
```

## ?🌟😻✔ 面试题 02.07. 链表相交【easy】

[ref](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

链表、相交链表

```js
var getIntersectionNode = function(headA, headB) {
  let pA = headA, pB = headB
  while(pA && pB) {
    if(pA === pB) return pA
    if(!pA.next && !pB.next) return null
    pA = pA.next ? pA.next : headB
    pB = pB.next ? pB.next : headA
  }
  return null
};
```

## 🌟😻✔ 面试题 02.08. 环路检测【medium】

[ref](https://leetcode.cn/problems/linked-list-cycle-lcci/)

链表、环形链表

```js
var detectCycle = function(head) {
  const myHead = new ListNode()
  myHead.next = head
  let slow = myHead, fast = myHead
  while(fast.next && fast.next.next) {
    slow = slow.next
    fast = fast.next.next
    if(slow === fast) {
      fast = myHead
      while(fast !== slow) {
        slow = slow.next
        fast = fast.next
      }
      return slow
    }
  }
  return null
};

// a + n(b + c) = 2 (a + b)
// nb + nc - 2b = a
// (n - 1)b + nc - c + c = a
// (n - 1)b + (n - 1)c + c = a
// (n-1)(b + c) + c = a
```

## 🌟😻✔ 面试题 03.01. 三合一【easy】

[ref](https://leetcode.cn/problems/three-in-one-lcci/)

设计题

```js

var TripleInOne = function(stackSize) {
  this.stackSize = stackSize
  this.stack = []
  this.idxes = [0, 1, 2]
};
TripleInOne.prototype.push = function(stackNum, value) {
  if(this.idxes[stackNum] <= (this.stackSize - 1) * 3 + stackNum) {
    this.stack[this.idxes[stackNum]] = value
    this.idxes[stackNum] += 3  
  }
};
TripleInOne.prototype.pop = function(stackNum) {
  if(this.idxes[stackNum] === stackNum) return -1
  this.idxes[stackNum] -= 3
  return this.stack[this.idxes[stackNum]]
};
TripleInOne.prototype.peek = function(stackNum) {
  if(this.idxes[stackNum] === stackNum) return -1
  return this.stack[this.idxes[stackNum] - 3]
};

TripleInOne.prototype.isEmpty = function(stackNum) {
  return this.idxes[stackNum] === stackNum
};
```

## 🌟😻✔ 面试题 03.02. 栈的最小值【easy】

[ref](https://leetcode.cn/problems/min-stack-lcci/)

设计题、栈

```js
var MinStack = function() {
  this.stack = []
  this.min = []
};
MinStack.prototype.push = function(x) {
  this.stack.push(x)
  if(!this.min.length || this.min[this.min.length - 1] >= x) {
    this.min.push(x)
  } else {
    this.min.push(this.min[this.min.length - 1])
  }
};
MinStack.prototype.pop = function() {
  this.min.pop()
  return this.stack.pop()
};
MinStack.prototype.top = function() {
  return this.stack[this.stack.length - 1]
};
MinStack.prototype.getMin = function() {
  return this.min[this.min.length - 1]
};
```

## 🌟😻✔ 面试题 03.03. 堆盘子【medium】

[ref](https://leetcode.cn/problems/stack-of-plates-lcci/)

栈

```js
var StackOfPlates = function(cap) {
  this.cap = cap
  this.stacks = []
};
StackOfPlates.prototype.push = function(val) {
  if(!this.stacks.length || this.stacks[this.stacks.length - 1].length === this.cap) {
    this.stacks.push([val])
  } else {
    this.stacks[this.stacks.length - 1].push(val)
  }
};
StackOfPlates.prototype.pop = function() {
  if(!this.stacks.length || this.cap === 0) return -1
  const ret = this.stacks[this.stacks.length - 1].pop()
  if(!this.stacks[this.stacks.length - 1].length) this.stacks.pop()
  return ret
};
StackOfPlates.prototype.popAt = function(index) {
  if(!this.stacks[index] || this.cap === 0) return -1
  const ret = this.stacks[index].pop()
  if(!this.stacks[index].length) this.stacks.splice(index, 1)
  return ret
};

```

## 🌟😻✔ 面试题 03.04. 化栈为队【easy】

[ref](https://leetcode.cn/problems/implement-queue-using-stacks-lcci/)

设计题、栈

```js
var MyQueue = function() {
  this.stack = []
  this.tmpStack = []
};
MyQueue.prototype.push = function(x) {
  while(this.stack.length) {
    this.tmpStack.push(this.stack.pop())
  }
  this.tmpStack.push(x)
};
MyQueue.prototype.pop = function() {
  while(this.tmpStack.length) {
    this.stack.push(this.tmpStack.pop())
  }
  return this.stack.pop()
};
MyQueue.prototype.peek = function() {
  while(this.tmpStack.length) {
    this.stack.push(this.tmpStack.pop())
  }
  return this.stack[this.stack.length - 1]
};
MyQueue.prototype.empty = function() {
  return this.stack.length === 0 && this.tmpStack.length === 0
};
```

## ?🌟😻✔ 面试题 03.05. 栈排序【medium】

[ref](https://leetcode.cn/problems/sort-of-stacks-lcci/)

栈

```js
var SortedStack = function() {
  this.stack = []
  this.tmpStack = []
};
SortedStack.prototype.push = function(val) {
  while(this.stack.length && this.stack[this.stack.length - 1] < val) {
    this.tmpStack.push(this.stack.pop())
  }
  this.tmpStack.push(val)
  while(this.tmpStack.length) {
    this.stack.push(this.tmpStack.pop())
  }
};
SortedStack.prototype.pop = function() {
  return this.stack.pop()
};
SortedStack.prototype.peek = function() {
  if(this.isEmpty()) return -1
  return this.stack[this.stack.length - 1]
};
SortedStack.prototype.isEmpty = function() {
  return this.stack.length === 0
};

```

## 🌟😻✔ 面试题 03.06. 动物收容所【medium】

[ref](https://leetcode.cn/problems/animal-shelter-lcci/)

队列、设计题

```js
var AnimalShelf = function() {
  this.q = [[], []]
};
AnimalShelf.prototype.enqueue = function(animal) {
  this.q[animal[1]].push(animal[0])
};
AnimalShelf.prototype.dequeueAny = function() {
  if(!this.q[1].length && !this.q[0].length) return [-1, -1]
  else if(this.q[0].length && !this.q[1].length) return [this.q[0].shift(), 0]
  else if(!this.q[0].length && this.q[1].length) return [this.q[1].shift(), 1]
  else if(this.q[0][0] < this.q[1][0]) {
    return [this.q[0].shift(), 0]
  } else {
    return [this.q[1].shift(), 1]
  }
};
AnimalShelf.prototype.dequeueDog = function() {
  if(!this.q[1].length) return [-1, -1]
  return [this.q[1].shift(), 1]
};
AnimalShelf.prototype.dequeueCat = function() {
  if(!this.q[0].length) return [-1, -1]
  return [this.q[0].shift(), 0]
};
```

## 🌟😻✔ 面试题 04.01. 节点间通路【medium】

[ref](https://leetcode.cn/problems/route-between-nodes-lcci/)

广度优先搜索

```js
var findWhetherExistsPath = function(n, graph, start, target) {
  const map = new Map()
  for(let i=0;i<graph.length;i++) {
    const [x, y] = graph[i]
    if(x === y) continue
    if(!map.has(x)) map.set(x, new Set())
    map.get(x).add(y)
  }
  if(!map.has(start)) return false
  let q = [start]
  let used = new Set([start])
  while(q.length) {
    const tq = []
    for(let i=0;i<q.length;i++) {
      if(q[i] === target) return true
      const nexts = map.get(q[i])
      if(nexts) {
        for(let next of nexts) {
          if(!used.has(next)) {
            used.add(next)
            tq.push(next)
          }
        }
      }
    }
    q = tq
  }
  return false
};
```

## 🌟😻✔ 面试题 04.02. 最小高度树【easy】

[ref](https://leetcode.cn/problems/minimum-height-tree-lcci/)

二叉树、二叉搜索树

```js
var sortedArrayToBST = function(nums) {
  function create(l, r) {
    if(l > r) return null
    if(l === r) return new TreeNode(nums[l])
    const mid = Math.floor((l+r) / 2)
    const node = new TreeNode(nums[mid])
    node.left = create(l, mid - 1)
    node.right = create(mid + 1, r)
    return node
  }
  return create(0, nums.length - 1)
};
```

## 🌟😻✔ 面试题 04.03. 特定深度节点链表【medium】

[ref](https://leetcode.cn/problems/list-of-depth-lcci/)

广度优先搜索

```js
var listOfDepth = function(tree) {
  if(!tree) return []
  let q = [tree]
  const res = []
  while(q.length) {
    const tq = []
    const myHead = new ListNode()
    let tHead = myHead
    for(let i=0;i<q.length;i++) {
      const node = q[i]
      tHead.next = new ListNode(node.val)
      tHead = tHead.next
      node.left && tq.push(node.left)
      node.right && tq.push(node.right)
    }
    q = tq
    res.push(myHead.next)
  }
  return res
};
```

## 🌟😻✔ 面试题 04.04. 检查平衡性【easy】

[ref](https://leetcode.cn/problems/check-balance-lcci/)

二叉树

```js
var isBalanced = function(root) {
  let is = true
  function dfs(node) {
    if(!node) return 0
    const lDepth = dfs(node.left)
    const rDepth = dfs(node.right)
    if(Math.abs(lDepth - rDepth) > 1) is = false
    return Math.max(lDepth, rDepth) + 1
  }
  dfs(root)
  return is
};
```

## 🌟😻✔ 面试题 04.05. 合法二叉搜索树【medium】

[ref](https://leetcode.cn/problems/legal-binary-search-tree-lcci/)

二叉搜索树

```js
var isValidBST = function(root) {
  if(!root) return true
  let isBST = true, prev
  function dfs(node) {
    node.left && dfs(node.left)
    if(prev !== undefined && node.val <= prev) isBST = false
    prev = node.val
    node.right && dfs(node.right)
  }
  dfs(root)
  return isBST
};
```

## 🌟😻✔ 面试题 04.06. 后继者【medium】

[ref](https://leetcode.cn/problems/successor-lcci/)

中继后续、二叉搜索树

```js
var inorderSuccessor = function(root, p) {
  if(!root) return null
  if(root.val <= p.val) return inorderSuccessor(root.right, p)
  const ans = inorderSuccessor(root.left, p)
  return ans === null ? root: ans
};
```

```js
var inorderSuccessor = function(root, p) {
  if(!root) return null
  let prev, res = null
  function dfs(node) {
    node.left && dfs(node.left)
    if(prev === p) {
      res = node
    }
    prev = node
    node.right && dfs(node.right)
  }
  dfs(root)
  return res
};
```

## 🌟😻✔ 面试题 04.08. 首个共同祖先【medium】

[ref](https://leetcode.cn/problems/first-common-ancestor-lcci/)

二叉树

```js
var lowestCommonAncestor = function(root, p, q) {
  let res
  function dfs(node) {
    if(!node) return 0
    let sum = (node === p || node === q) ? 1 : 0
    sum += dfs(node.left)
    sum += dfs(node.right)
    if(sum === 2 && !res) {
      res = node
    }
    return sum
  }
  dfs(root)
  return res
};
```

## 🌟😻✔ 面试题 04.10. 检查子树【medium】

[ref](https://leetcode.cn/problems/check-subtree-lcci/)

二叉树

```js
var checkSubTree = function(t1, t2) {
  if(!t1 && !t2) return true
  if(!t1 && t2 || t1 && !t2) return false
  if(t1.val === t2.val && check(t1.left, t2.left) && check(t1.right, t2.right)) return true  
  else return checkSubTree(t1.left, t2) || checkSubTree(t1.right, t2)
};

function check(node1, node2) {
  if(!node1 && !node2) return true
  if(node1 && !node2 || !node1 && node2) return false
  return node1.val === node2.val && check(node1.left, node2.left) && check(node1.right, node2.right)
}
```

## 🌟😻✔ 面试题 04.12. 求和路径【medium】

[ref](https://leetcode.cn/problems/paths-with-sum-lcci/?favorite=xb9lfcwi)

二叉树、前缀和

```js
var pathSum = function(root, sum) {
  const map = new Map([[0, 1]])
  let cnt = 0, s = 0
  function dfs(node) {
    if(!node) return
    s += node.val
    if(map.has(s - sum)) {
      cnt += map.get(s - sum)
    }
    map.set(s, (map.get(s) || 0) + 1)
    dfs(node.left)
    dfs(node.right)
    map.set(s, map.get(s) - 1)
    s -= node.val
  }
  dfs(root)
  return cnt
};
```

## ? 🌟😻✔ 面试题 05.01. 插入【medium】

[ref](https://leetcode.cn/problems/insert-into-bits-lcci/)

二进制、位运算

```js
var insertBits = function(N, M, i, j) {
  let res = 0
  for(let k=0;k<32;k++) {
    let v
    if(k >= i && k <= j) {
      v = ((M >> (k - i)) & 1)
    } else {
      v = ((N >> k) & 1)
    }
    res |= (v << k)
  }
  return res
};
```

## 🌟😻✔ 面试题 05.02. 二进制数转字符串【medium】

[ref](https://leetcode.cn/problems/bianry-number-to-string-lcci/?favorite=xb9lfcwi)

二进制

```js
var printBin = function(num) {
  let res = '0.'
  while(num !== 0) {
    if(res.length >= 35) return 'ERROR'
    num *= 2
    if(num >= 1) {
      res += 1
      num -= 1
    } else {
      res += 0
    }
  }
  return res
};
// 0.625
// 0.25  0.1
// 0.5  0.10
// 0  0.101
```

## 🌟😻✔ 面试题 05.03. 翻转数位【easy】

[ref](https://leetcode.cn/problems/reverse-bits-lcci/)

二进制、位运算

```js
// >> 和 >>> 的区别：https://zhidao.baidu.com/question/1495631221535712979.html
var reverseBits = function(num) {
  num = (num >>> 0).toString(2)
  num = new Array(32 - num.length).fill('0').join('') + num
  let max = 0, l = 0, r = 0, zeroCnt = 0
  while(r < 32) {
    if(num[r] === '0') {
      zeroCnt++
    }
    while(zeroCnt > 1) {
      if(num[l] === '0') zeroCnt--
      l++
    }
    max = Math.max(max, r - l + 1)
    r++
  }
  return max
};
```

## ?🌟😻✔ 面试题 05.06. 整数转换【easy】

[ref](https://leetcode.cn/problems/convert-integer-lcci/)

二进制、位运算

```js
var convertInteger = function(A, B) {
  A = (A >>> 0).toString(2)
  B = (B >>> 0).toString(2)
  A = new Array(32 - A.length).fill(0).join('') + A
  B = new Array(32 - B.length).fill(0).join('') + B
  let cnt = 0
  for(let i=0;i<32;i++) {
    if(A[i] !== B[i]) cnt++
  }
  return cnt
};
```

## 🌟😻✔ 面试题 05.07. 配对交换【easy】

[ref](https://leetcode.cn/problems/exchange-lcci/)

二进制、位运算

```js
var exchangeBits = function(num) {
  let a = 0b10101010101010101010101010101010, b = 0b01010101010101010101010101010101
  a &= num, b &= num
  a >>= 1
  b <<= 1
  return (a | b)
};
```

## 🌟😻✔ 面试题 08.01. 三步问题【easy】

[ref](https://leetcode.cn/problems/three-steps-problem-lcci/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var waysToStep = function(n) {
  const mod = 1000000007
  const dp = new Array(n + 1).fill(1)
  dp[2] = 2
  dp[3] = 4
  for(let i=4;i<=n;i++) {
    dp[i] = ((dp[i-1] + dp[i-2]) % mod + dp[i-3]) % mod
  }
  return dp[n]
};
```

## 🌟😻✔ 面试题 08.02. 迷路的机器人【medium】

[ref](https://leetcode.cn/problems/robot-in-a-grid-lcci/)

深度优先搜索

```js
var pathWithObstacles = function(grid) {
  const m = grid.length, n = grid[0].length, used = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  let res = []
  function walk(i, j, path) {
    if(i >= m || j >= n || grid[i][j] === 1 || used[i][j]) return
    used[i][j] = true
    if(i === m - 1 && j === n - 1) {
      res = [...path, [i, j]]
      return
    }
    path.push([i, j])
    walk(i + 1, j, path)
    walk(i, j + 1, path)
    path.pop()
  }
  walk(0, 0, [])
  return res
};
```

## 🌟😻✔ 面试题 08.03. 魔术索引【easy】

[ref](https://leetcode.cn/problems/magic-index-lcci/)

数组题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findMagicIndex = function(nums) {
  for(let i=0;i<nums.length;i++) {
    if(i === nums[i]) return i
    if(nums[i] > i) i = nums[i] - 1
  }
  return -1
};
```

## 🌟😻✔ 面试题 08.04. 幂集【medium】

[ref](https://leetcode.cn/problems/power-set-lcci/)

深度优先搜索、子集问题、回溯法

```js
var subsets = function(nums) {
  const res = [], n = nums.length
  function dfs(path, idx) {
    res.push([...path])
    for(let i=idx;i<n;i++) {
      path.push(nums[i])
      dfs(path, i + 1)
      path.pop()
    }
  }
  dfs([], 0)
  return res
};
```

## 🌟😻✔ 面试题 08.05. 递归乘法【medium】

[ref](https://leetcode.cn/problems/recursive-mulitply-lcci/)

模拟运算

```js
var multiply = function(A, B) {
  if(A === 0 || B === 0) return 0
  if(A < B) {
    return multiply(B, A)
  }
  return A + multiply(A, B - 1)
};

```

## ??🌟😻✔ 面试题 08.06. 汉诺塔问题【easy】

[ref](https://leetcode.cn/problems/hanota-lcci/)

栈、递归

```js
var hanota = function(A, B, C) {
  moveA2C(A, B, C, A.length)
};
function moveA2C(A, B, C, len) {
  console.log(A, B, C)
  if(len === 1) {
    C.push(A.pop())
    return
  }
  moveA2C(A, C, B, len-1)
  moveA2C(A, B, C, 1)
  moveA2C(B, A, C, len - 1)
}
```

## 🌟😻✔ 面试题 08.07. 无重复字符串的排列组合【medium】

[ref](https://leetcode.cn/problems/permutation-i-lcci/)

回溯、排列

```js
var permutation = function(S) {
  const n = S.length, used = new Array(n).fill(false)
  const res = []
  function dfs(path) {
    if(path.length === n) {
      res.push(path.join(''))
      return
    }
    for(let i=0;i<n;i++) {
      if(used[i]) continue
      used[i] = true
      path.push(S[i])
      dfs(path)
      path.pop()
      used[i] = false
    }
  }
  dfs([])
  return res
};
```

## 🌟😻✔ 面试题 08.08. 有重复字符串的排列组合【medium】

[ref](https://leetcode.cn/problems/permutation-ii-lcci/)

回溯法、深度优先搜索

```js
var permutation = function(S) {
  const res = [], n = S.length, used = new Array(n).fill(false)
  function dfs(path) {
    if(path.length === n) {
      res.push(path.join(''))
      return
    }
    const layerUsed = new Set()
    for(let i=0;i<n;i++) {
      if(layerUsed.has(S[i]) || used[i]) continue
      layerUsed.add(S[i])
      path.push(S[i])
      used[i] = true
      dfs(path)
      used[i] = false
      path.pop()
    }
  }
  dfs([])
  return res
};
```

## 🌟😻✔ 面试题 08.09. 括号【medium】

[ref](https://leetcode.cn/problems/bracket-lcci/)

回溯法、深度优先搜索

```js
var generateParenthesis = function(n) {
  const res = []
  function walk(path, lCnt, rCnt) {
    if(lCnt === n && rCnt === n) {
      res.push(path)
      return
    }
    if(lCnt < n) {
      walk(path + '(', lCnt + 1, rCnt)
    }
    if(rCnt < lCnt) {
      walk(path + ')', lCnt, rCnt + 1)
    }
  }
  walk('', 0, 0)
  return res
};
```

## 🌟😻✔ 面试题 08.10. 颜色填充【easy】

[ref](https://leetcode.cn/problems/color-fill-lcci/)

矩阵

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var floodFill = function(image, sr, sc, newColor) {
  const m = image.length, n = image[0].length, target = image[sr][sc]
  if(target === newColor) return image
  function walk(i, j) {
    if(i >= m || i < 0 || j >= n || j < 0 || image[i][j] !== target) return
    image[i][j] = newColor
    walk(i - 1, j)
    walk(i + 1, j)
    walk(i, j - 1)
    walk(i, j + 1)
  }
  walk(sr, sc)
  return image
};
```

## 🌟😻✔ 面试题 08.11. 硬币【medium】

[ref](https://leetcode.cn/problems/coin-lcci/)

动态规划、背包问题、完全背包

```js
var waysToChange = function(n) {
  const mod = 1000000007, dp = new Array(n + 1).fill(0), coins = [1, 5, 10, 25]
  dp[0] = 1
  for(let coin of coins) {
    for(let i=1;i<=n;i++) {
      if(i >= coin) {
        dp[i] = (dp[i] + dp[i - coin]) % mod
      }
    }
  }
  return dp[n]
};
```

## ?🌟😻✔ 面试题 08.14. 布尔运算【medium】

[ref](https://leetcode.cn/problems/boolean-evaluation-lcci/)

枚举、模拟、DFS、递归

```js
var countEval = function(s, result) {
  const map = new Map()
  function count(str) {
    if(map.has(str)) return map.get(str)
    if(str.length === 1) {
      map.set(str, new Map([[Number(str[0]), 1]]))
      return map.get(str)
    }
    const calRes = new Map()
    for(let i=0;i<str.length;i++) {
      if(isOp(str[i])) {
        const op = str[i]
        const left = count(str.slice(0, i)), right = count(str.slice(i + 1))
        for(let [lv, lCnt] of left.entries()) {
          for(let [rv, rCnt] of right.entries()) {
            let cal
            if(op === '&') cal = lv & rv
            else if(op === '|') cal = lv | rv
            else cal = lv ^ rv
            calRes.set(cal, (calRes.get(cal) || 0) + lCnt * rCnt)
          }
        }
      }
    }
    map.set(str, calRes)
    return calRes
  }
  count(s)
  return map.get(s).get(result) ? map.get(s).get(result) : 0
};

function isOp(c) {
  return c === '&' || c === '|'|| c === '^'
}
```

## 🌟😻✔ 面试题 10.01. 合并排序的数组【easy】

[ref](https://leetcode.cn/problems/sorted-merge-lcci/)

归并排序、原地排序

```js
var merge = function(A, m, B, n) {
  let k = m + n - 1
  m--, n--
  while(m >= 0 && n >= 0) {
    if(A[m] > B[n]) {
      A[k--] = A[m--]
    } else {
      A[k--] = B[n--]
    }
  }
  while(m >= 0) {
    A[k--] = A[m--]
  }
  while(n >= 0) {
    A[k--] = B[n--]
  }
};
```

## 🌟😻✔ 面试题 10.02. 变位词组【medium】

[ref](https://leetcode.cn/problems/group-anagrams-lcci/)

哈希表

对字符串按字符code排序

```js
var groupAnagrams = function(strs) {
  const map = new Map()
  for(let str of strs) {
    const str2 = str.split('').sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).join('')
    if(!map.has(str2)) map.set(str2, [])
    map.get(str2).push(str)
  }
  return Array.from(map.values())
}; 
```

笨办法，做数量统计然后编码

```js
var groupAnagrams = function(strs) {
  const map = new Map()
  for(let str of strs) {
    const arr = new Array(26).fill(0)
    for(let i=0; i<str.length; i++) {
      arr[str.charCodeAt(i) - 'a'.charCodeAt(0)]++
    }
    let s = ''
    for(let i=0;i<26;i++) {
      s += `${i}:${arr[i]} `
    }
    if(!map.has(s)) map.set(s, [])
    map.get(s).push(str)
  }
  return Array.from(map.values())
}; 
```

## ??🌟😻✔ 面试题 10.03. 搜索旋转数组【medium】

[ref](https://leetcode.cn/problems/search-rotate-array-lcci/)

二分搜索

```js
// 时间复杂度：O(logN) 最差会退化到 O(N)
// 空间复杂度：O(1)
var search = function(arr, target) {
  let l = 0, r = arr.length - 1
  if(arr[l] === target) return l
  while(arr[l] === arr[0]) l++
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(arr[mid] > arr[0]) {
      if(arr[mid] >= target && target > arr[0]) {
        r = mid
      } else {
        l = mid + 1
      }
    } else {
      if(arr[mid] < target && target < arr[0]) {
        l = mid + 1
      } else {
        r = mid
      }
    }
  }
  return arr[l] === target ? l : -1
};
```

```js
var search = function(arr, target) {
  let l = 0, r = arr.length - 1, n = arr.length
  if(arr[0] === target) return 0
  while(l <= r && arr[r] === arr[0]) r--
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(target > arr[0]) {
      if(arr[mid] < target && arr[mid] >= arr[0]) {
        l = mid + 1
      } else {
        r = mid
      }
    } else {
      if(arr[mid] >= target && arr[mid] < arr[n - 1]) {
        r = mid
      } else {
        l = mid + 1
      }
    }
  }
  return arr[l] === target ? l : -1
};
```

## 🌟😻✔ 面试题 10.05. 稀疏数组搜索【easy】

[ref](https://leetcode.cn/problems/sparse-array-search-lcci/)

二分搜索、稀疏数组

```js
var findString = function(words, s) {
  let l = 0, r = words.length
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    let tMid = mid
    while(tMid >= l && words[tMid] === '') tMid--
    if(tMid < l) l = mid + 1
    else {
      if(words[tMid] === s) return tMid
      else if(words[tMid] < s) {
        l = mid + 1
      } else {
        r = tMid - 1
      }
    }
  }
  return -1
};
```

## 🌟😻✔ 面试题 10.09. 排序矩阵查找【medium】

[ref](https://leetcode.cn/problems/sorted-matrix-search-lcci/)

矩阵搜索

```js
// 时间复杂度：O(M+N)
// 空间复杂度：O(1)
var searchMatrix = function(matrix, target) {
  if(!matrix.length) return false
  const m = matrix.length, n = matrix[0].length
  let i = 0, j = n - 1
  while(i < m && j >= 0) {
    if(matrix[i][j] === target) return true
    else if(matrix[i][j] < target) i++
    else j--
  }
  return false
};
```

## 🌟😻✔ 面试题 10.10. 数字流的秩【medium】

[ref](https://leetcode.cn/problems/rank-from-stream-lcci/)

二分搜索

```js
var StreamRank = function() {
  this.arr = []
};
StreamRank.prototype.track = function(x) {
  const ind = this.search(x)
  this.arr.splice(ind, 0, x)
};
// 第一个大于X的数对应的下标
StreamRank.prototype.search = function(x) {
  if(!this.arr.length) return 0
  if(x >= this.arr[this.arr.length - 1]) return this.arr.length
  let l = 0, r = this.arr.length - 1
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(this.arr[mid] > x) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return r
};
StreamRank.prototype.getRankOfNumber = function(x) {
  return this.search(x)
};

```

## 🌟😻✔ 面试题 10.11. 峰与谷【medium】

[ref](https://leetcode.cn/problems/peaks-and-valleys-lcci/)

摆动数组、常规模拟

```js
var wiggleSort = function(nums) {
  const n = nums.length
  let top = true
  for(let i=0;i<n - 1;i++) {
    if(top && nums[i] < nums[i + 1] || !top && nums[i] > nums[i + 1]) {
      swap(nums, i, i + 1)
    }
    top = !top
  }
};
function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

## ?🌟😻✔ 面试题 16.01. 交换数字【medium】

[ref](https://leetcode.cn/problems/swap-numbers-lcci/)

二进制、位运算

```js
var swapNumbers = function(numbers) {
  numbers[0] = numbers[0] + numbers[1]
  numbers[1] = numbers[0] - numbers[1]
  numbers[0] = numbers[0] - numbers[1]
  return numbers
};
```

```js
var swapNumbers = function(numbers) {
  numbers[0] = numbers[0] ^ numbers[1]
  numbers[1] = numbers[0] ^ numbers[1]
  numbers[0] = numbers[0] ^ numbers[1]
  return numbers
};
```

## 🌟😻✔ 面试题 16.02. 单词频率【medium】

[ref](https://leetcode.cn/problems/words-frequency-lcci/)

哈希表、字典树

```js
var WordsFrequency = function(book) {
  this.tree = new Node()
  for(let i=0;i<book.length;i++) {
    let node = this.tree
    const word = book[i]
    for(let j=0; j < word.length; j++) {
      if(!node.chl[word[j]]) node.chl[word[j]] = new Node()
      node = node.chl[word[j]]
      if(j === word.length - 1) {
        node.cnt++
      }
    }
  }
};
WordsFrequency.prototype.get = function(word) {
  let node = this.tree
  let cnt = 0
  for(let i=0;i<word.length;i++) {
    if(!node.chl[word[i]]) break
    node = node.chl[word[i]]
    if(i === word.length - 1) {
      cnt = node.cnt
    }
  }
  return cnt
};

class Node {
  constructor() {
    this.cnt = 0
    this.chl = {}
  }
}
```

```js
var WordsFrequency = function(book) {
  this.m  = new Map()
  for(let word of book) {
    this.m.set(word, (this.m.get(word) || 0) + 1)
  }
};
WordsFrequency.prototype.get = function(word) {
  return this.m.get(word) || 0
};
```

## 🌟😻✔ 面试题 16.04. 井字游戏【medium】

[ref](https://leetcode.cn/problems/tic-tac-toe-lcci/)

模拟

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(1)
var tictactoe = function(board) {
  const n = board.length
  let xWinStr = '', oWinStr = ''
  for(let i=0;i<n;i++) {
    xWinStr += 'X'
    oWinStr += 'O'
  }
  for(let i=0;i<n;i++) {
    if(board[i] === xWinStr) return 'X' 
    else if(board[i] === oWinStr) return 'O'
  }
  for(let j=0;j<n;j++) {
    let str = ''
    for(let i=0;i<n;i++) str += board[i][j]
    if(str === xWinStr) return 'X'
    else if(str === oWinStr) return 'O'
  }
  let lStr = '', rStr = ''
  for(let i=0;i<n;i++) {
    lStr += board[i][i]
    rStr += board[i][n - 1 - i]
  }
  if(lStr === xWinStr || rStr === xWinStr) return 'X'
  else if(lStr === oWinStr || rStr === oWinStr) return 'O'

  for(let i=0;i<n;i++) {
    for(let j=0;j<n;j++) {
      if(board[i][j] === ' ') return 'Pending'
    }
  }
  return 'Draw'
};
```

## 🌟😻✔ 面试题 16.05. 阶乘尾数【easy】

[ref](https://leetcode.cn/problems/factorial-zeros-lcci/)

模拟

```js
var trailingZeroes = function(n) {
  let cnt = 0
  while(n) {
    n = Math.floor(n / 5)
    cnt += n
  }
  return cnt
};
```

## 🌟😻✔ 面试题 16.06. 最小差【medium】

[ref](https://leetcode.cn/problems/smallest-difference-lcci/)

二分搜索

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var smallestDifference = function(a, b) {
  a = a.sort((x, y) => x - y)
  let min = Number.MAX_SAFE_INTEGER
  for(let num of b) {
    min = Math.min(min, Math.abs(search(a, num) - num))
  }
  return min
};
function search(arr, target) {
  let l = 0, r = arr.length - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(arr[mid] === target) return target
    else if(arr[mid] > target) {
      r = mid - 1
    } else {
      l = mid + 1
    }
  }
  if(r < 0) return arr[l]
  else if(l >= arr.length) return arr[r]
  else {
    if(Math.abs(arr[l] - target) < Math.abs(arr[r] - target)) {
      return arr[l]
    } else {
      return arr[r]
    }
  }
}
```

## ?🌟😻✔ 面试题 16.10. 生存人数【medium】

[ref](https://leetcode.cn/problems/living-people-lcci/)

差分数组、差分

```js
// 时间复杂度：O(N+W) W = 101
// 空间复杂度：O(W)
var maxAliveYear = function(birth, death) {
  const arr = new Array(101).fill(0), n = birth.length
  for(i=0;i<n;i++) {
    arr[birth[i] - 1900] += 1
    if(death[i] - 1899 <= 100) {
      arr[death[i] - 1899] -= 1
    }
  }
  let max = 0, s = 0
  for(let i=0;i<101;i++) {
    s += arr[i]
    arr[i] = s
    max = Math.max(max, s)
  }
  for(let i=0;i<101;i++) {
    if(arr[i] === max) return i + 1900
  }
};
```

## 🌟😻✔ 面试题 16.11. 跳水板【easy】

[ref](https://leetcode.cn/problems/diving-board-lcci/)

模拟

```js
var divingBoard = function(shorter, longer, k) {
  if(k === 0) return []
  if(shorter === longer) return [k*longer]
  const res = []
  for(let i=0;i<=k;i++) {
    res.push(longer * i + shorter * (k-i))
  }
  return res
};
```

## ?🌟😻✔ 面试题 16.13. 平分正方形【medium】

[ref](https://leetcode.cn/problems/bisect-squares-lcci/)

模拟

题解

- [云影同学】时间复杂度超100%，难度不大，侮辱性极强](https://leetcode.cn/problems/bisect-squares-lcci/solution/by-lxfriday-ulws/)

```js
var cutSquares = function(square1, square2) {
  const center1 = [square1[0] + square1[2] / 2, square1[1] + square1[2] / 2]
  const center2 = [square2[0] + square2[2] / 2, square2[1] + square2[2] / 2]
  const x1l = square1[0], x1r = square1[0] + square1[2], y1d = square1[1], y1u = square1[1] + square1[2]
  const x2l = square2[0], x2r = square2[0] + square2[2], y2d = square2[1], y2u = square2[1] + square2[2]
  if(center1[0] === center2[0]) {
    return [center1[0], Math.min(y1d, y2d), center1[0], Math.max(y1u, y2u)]
  }
  if(center1[1] === center2[1]) {
    return [Math.min(x1l, x2l), center1[1], Math.max(x1r, x2r), center1[1]]
  }
  // a 斜率 b 常数
  const a = (center2[1] - center1[1]) / (center2[0] - center1[0]), b = center2[1] - a * center2[0]
  const y1lt = a * x1l + b, y1rt = a * x1r + b, x1dt = (y1d - b) / a, x1ut = (y1u - b) / a
  const y2lt = a * x2l + b, y2rt = a * x2r + b, x2dt = (y2d - b) / a, x2ut = (y2u - b) / a
  const points = []
  // 算交叉点
  if(y1d <= y1lt && y1lt <= y1u) points.push([x1l, y1lt])
  if(y1d <= y1rt && y1rt <= y1u) points.push([x1r, y1rt])
  if(x1l <= x1dt && x1dt <= x1r) points.push([x1dt, y1d])
  if(x1l <= x1ut && x1ut <= x1r) points.push([x1ut, y1u])
  if(y2d <= y2lt && y2lt <= y2u) points.push([x2l, y2lt])
  if(y2d <= y2rt && y2rt <= y2u) points.push([x2r, y2rt])
  if(x2l <= x2dt && x2dt <= x2r) points.push([x2dt, y2d])
  if(x2l <= x2ut && x2ut <= x2r) points.push([x2ut, y2u])
  points.sort((arr1, arr2) => arr1[0] - arr2[0] || arr1[1] - arr2[1])
  return [...points[0], ...points[points.length - 1]]
};

// y = ax+b
// x = (y - b) / a
```

## ?🌟😻✔ 面试题 16.14. 最佳直线【medium】

[ref](https://leetcode.cn/problems/best-line-lcci/)

模拟、暴力

```js
var bestLine = function(points) {
  const n = points.length, arr = new Array(n).fill(1), SArr = new Array(n)
  let max = 1
  for(let i=0; i < n; i++) {
    const [x1, y1] = points[i]
    for(let j=i + 1; j < n; j++) {
      const [x2, y2] = points[j]
      let cnt = 2, S = [i, j]
      for(let k=j + 1; k < n; k++) {
        const [x3, y3] = points[k]
        if(x1 === x2 || x2 === x3 || x1 === x3) {
          if(x1 === x2 && x2 === x3) {
            cnt++
          }
        } else {
          if((y3 - y2) / (x3 - x2) === (y2 - y1) / (x2 - x1)) {
            cnt++
          }
        }
      }
      if(cnt > arr[i]) {
        SArr[i] = S
        arr[i] = cnt
      }
    }
    max = Math.max(max, arr[i])
  }
  const preRes = []
  for(let i=0;i<n;i++) {
    if(arr[i] === max) preRes.push(SArr[i])
  }
  preRes.sort((a, b) => a[0] - b[0] || a[1] - b[1])
  return preRes[0]
};
```

## 🌟😻✔ 面试题 16.15. 珠玑妙算【easy】

[ref](https://leetcode.cn/problems/master-mind-lcci/)

模拟

```js
var masterMind = function(solution, guess) {
  let yesCnt = 0, fackCnt = 0, m1 = new Map(), m2 = new Map()
  for(let i=0;i<4;i++) {
    if(solution[i] === guess[i]) {
      yesCnt++
    } else {
      m1.set(solution[i], (m1.get(solution[i]) || 0) + 1)
      m2.set(guess[i], (m2.get(guess[i]) || 0) + 1)
    }
  }
  for(const [c, cnt] of m2.entries()) {
    for(let i=0;i<cnt;i++) {
      if(m1.get(c) > 0) {
        m1.set(c, m1.get(c) - 1)
        fackCnt++
      }
    }
  }
  return [yesCnt, fackCnt]
};
```

## ??🌟😻✔ 面试题 16.16. 部分排序【medium】

[ref](https://leetcode.cn/problems/sub-sort-lcci/)

单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var subSort = function(array) {
  const n = array.length, stack = []
  if(n < 2) return [-1, -1]
  let l = n, r = -1, deleteMax = Number.MIN_SAFE_INTEGER
  for(let i=0;i<n;i++) {
    while(stack.length && array[stack[stack.length - 1]] > array[i]) {
      const idx = stack.pop()
      l = Math.min(l, idx)
      deleteMax = Math.max(deleteMax, array[idx])
    }
    if(array[i] >= deleteMax) {
      stack.push(i)
    } else {
      r = i
    }
  }
  return stack.length === n ? [-1, -1] : [l, r]
};
```

## 🌟😻✔ 面试题 16.17. 连续数列【easy】

[ref](https://leetcode.cn/problems/contiguous-sequence-lcci/)

动态规划、数组题

```js
var maxSubArray = function(nums) {
  const n = nums.length
  let i = 1, max = nums[0], prevSum = nums[0]
  while(i < n) {
    if(prevSum < 0) prevSum = 0
    prevSum += nums[i]
    max = Math.max(max, prevSum)
    i++
  }
  return max
};
```

## 🌟😻✔ 面试题 16.19. 水域大小【medium】

[ref](https://leetcode.cn/problems/pond-sizes-lcci/)

矩阵、深度优先搜索、DFS

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var pondSizes = function(land) {
  const m = land.length, n = land[0].length
  const res = []
  const directs = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]]
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(land[i][j] === 0) {
        res.push(walk(i, j))
      }
    }
  }
  function walk(i, j) {
    if(i < 0 || i >= m || j < 0 || j >= n || land[i][j] !== 0) return 0
    land[i][j] = 1
    let sum = 1
    for(let k =0;k<8;k++) {
      sum += walk(i + directs[k][0], j + directs[k][1])
    }
    return sum
  }

  return res.sort((a, b) => a - b)
};
```

## 🌟😻✔ 面试题 16.20. T9键盘【medium】

[ref](https://leetcode.cn/problems/t9-lcci/)

哈希表

```js
// 时间复杂度：O(W) W=所有单词的长度总和
// 时间复杂度：O(1) 不算结果数组和匹配对象 numsMap，空间是O(1)
var getValidT9Words = function(num, words) {
  const res = [], n = words.length
  const numsMap = {a: '2',b: '2',c: '2',d: '3',e: '3',f: '3',g: '4',h: '4',i: '4',j: '5',k: '5',l: '5',m: '6',n: '6',o: '6',p: '7',q: '7',r: '7',s: '7',t: '8',u: '8',v: '8',w: '9',x: '9',y: '9',z: '9'}
  for(let i=0;i<n;i++) {
    let shouldAdd = true
    for(let j=0;j<words[i].length;j++) {
      if(numsMap[words[i][j]] !== num[j]) {
        shouldAdd = false
        break
      }
    }
    if(shouldAdd) res.push(words[i])
  }  
  return res
};
```

## 🌟😻✔ 面试题 16.21. 交换和【medium】

[ref](https://leetcode.cn/problems/sum-swap-lcci/)

模拟

```js
// 时间复杂度：O(M+N) M=array1.length N=array2.length
// 空间复杂度：O(M)
var findSwapValues = function(array1, array2) {
  let sum1 = 0, sum2 = 0
  for(const num of array1) sum1 += num
  for(const num of array2) sum2 += num
  const target = (sum1 + sum2) / 2
  if(target !== Math.floor(target)) return []
  const set = new Set(array1)
  for(let num of array2) {
    if(set.has(target - (sum2 - num))) return [target - (sum2 - num), num]
  }
  return []
};
```

## 🌟😻✔ 面试题 16.24. 数对和【medium】

[ref](https://leetcode.cn/problems/pairs-with-sum-lcci/)

数组、哈希表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var pairSums = function(nums, target) {
  const res = [], map = new Map()
  for(let num of nums) {
    if(map.has(target - num) && map.get(target - num) > 0) {
      map.set(target - num, map.get(target - num) - 1)
      res.push([num, target - num])
    } else {
      map.set(num, (map.get(num) || 0) + 1)
    }
  }
  return res
};
```

## ?🌟😻✔ 面试题 16.25. LRU 缓存【medium】

[ref](https://leetcode.cn/problems/lru-cache-lcci/)

设计题

```js
var LRUCache = function(capacity) {
  this.map = new Map()
  this.capacity = capacity
};
LRUCache.prototype.get = function(key) {
  if(!this.map.has(key)) return -1
  const ret = this.map.get(key)
  this.put(key, ret)
  return ret
};
LRUCache.prototype.put = function(key, value) {
  if(this.map.has(key)) {
    this.map.delete(key)
  } else {
    if(this.map.size === this.capacity) {
      this.map.delete(this.map.keys().next().value)
    }
  }
  this.map.set(key, value)
};
```

双向链表
```js
var LRUCache = function(capacity) {
  this.head = new Node()
  this.tail = new Node()
  this.capacity = capacity
  this.size = 0
  this.map = {}
};

LRUCache.prototype.get = function(key) {
  if(!this.map[key]) return -1
  const ret = this.map[key].val
  this.put(key, ret)
  return ret
};

LRUCache.prototype.delete = function(key) {
  const node = this.map[key]
  delete this.map[key]
  if(this.size === 1) {
    this.head.next = null
    this.tail.next = null
  } else {
    const prev = node.prev, next = node.next
    if(prev && next) {
      prev.next = next
      next.prev = prev
    } else if(prev) {
      prev.next = null
      this.tail.next = prev
    } else {
      next.prev = null
      this.head.next = next
    }
  }
  this.size--
};

LRUCache.prototype.add = function(key, value) {
  const node = new Node(key, value)
  this.map[key] = node
  if(this.size === 0) {
    this.head.next = node
    this.tail.next = node
  } else {
    this.tail.next.next = node
    node.prev = this.tail.next
    this.tail.next = node
  }
  this.size++
};

LRUCache.prototype.put = function(key, value) {
  if(this.map[key]) {
    this.delete(key)
  } else {
    if(this.size === this.capacity) {
      this.delete(this.head.next.key)
    }
  }
  this.add(key, value)
};


class Node {
  constructor(key, val) {
    this.key = key
    this.val = val
    this.prev = null
    this.next = null
  }
}
```

## ?🌟😻✔ 面试题 16.26. 计算器【medium】

[ref](https://leetcode.cn/problems/calculator-lcci/)

模拟、计算器

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var calculate = function(s) {
  let res = 0
  let i=0
  let sign = '+', tmp = 0
  while(i < s.length) {
    if(s[i] !== ' ') {
      if(s[i] === '+') {
        res += tmp
        tmp = 0
        sign = '+'
        i++
      } else if(s[i] === '-') {
        res += tmp
        tmp = 0
        sign = '-'
        i++
      } else if(s[i] === '*') {
        sign = '*'
        i++
      } else if(s[i] === '/') {
        sign = '/'
        i++
      } else {
        let num = 0
        while(s[i] !== ' ' && s[i] >= '0' && s[i] <= '9') num = 10 * num + Number(s[i++])
        if(sign === '+') {
          tmp = num
        } else if(sign === '-') {
          tmp = -num
        } else if(sign === '*') {
          tmp *= num
        } else {
          tmp = (tmp / num > 0) ? Math.floor(tmp / num) : Math.ceil(tmp / num)
        }
      }
    } else {
      i++
    }
  }
  res += tmp
  return res
};
```

## 🌟😻✔ 面试题 17.01. 不用加号的加法【easy】

[ref](https://leetcode.cn/problems/add-without-plus-lcci/)

二进制、位运算

```js
var add = function(a, b) {
  while(a) {
    let pa = a
    a = a & b
    a <<= 1
    b = pa ^ b
  }
  return b
};
```

## 🌟😻✔ 面试题 17.04. 消失的数字【easy】

[ref](https://leetcode.cn/problems/missing-number-lcci/)

数组原地操作

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var missingNumber = function(nums) {
  const n = nums.length
  for(let i=0;i<n;i++) {
    while(nums[i] !== i && nums[i] < n) {
      swap(nums, i, nums[i])
    }
  }
  for(let i=0;i<n;i++) {
    if(nums[i] !== i) return i
  }
  return n
};

function swap(nums, i, j) {
  const t = nums[i]
  nums[i] = nums[j]
  nums[j] = t
}
```

## ?🌟😻✔ 面试题 17.05.  字母与数字【medium】

[ref](https://leetcode.cn/problems/find-longest-subarray-lcci/)

前缀和

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var findLongestSubarray = function(array) {
  const n = array.length, map = new Map([[0, -1]])
  let len = 0, sum = 0, idxs = []
  for(let i=0;i<n;i++) {
    sum += array[i][0] >= '0' && array[i][0] <= '9' ? 1 : -1
    if(map.has(sum)) {
      if(i - map.get(sum) > len) {
        len = i - map.get(sum)
        idxs = [map.get(sum) + 1, i + 1]
      }
    } else {
      map.set(sum, i)
    }
  }
  return len === 0 ? [] : array.slice(idxs[0], idxs[1])
};
```

## ?🌟😻✔ 面试题 17.07. 婴儿名字【medium】

[ref](https://leetcode.cn/problems/baby-names-lcci/)

图、广度优先搜索

```js
var trulyMostPopular = function(names, synonyms) {
  const connectionMap = new Map()
  for(const synonym of synonyms) {
    const [name1, name2] = synonym.slice(1, synonym.length - 1).split(',')
    if(!connectionMap.has(name1)) connectionMap.set(name1, new Set())
    if(!connectionMap.has(name2)) connectionMap.set(name2, new Set())
    connectionMap.get(name1).add(name2)
    connectionMap.get(name2).add(name1)
  }
  const used = new Set()
  const sameNameMap = new Map()
  for(const name of connectionMap.keys()) {
    if(used.has(name)) continue
    used.add(name)
    let q = [name]
    const arr = []
    while(q.length) {
      const tq = []
      for(let i=0;i<q.length;i++) {
        const currName = q[i]
        arr.push(currName)
        const nexts = connectionMap.get(currName)
        for(let next of nexts) {
          if(!used.has(next)) {
            used.add(next)
            tq.push(next)
          }
        }
      }
      q = tq
    }
    arr.sort((a, b) => {
      if(a < b) return -1
      else if(a < b) return 1
      return 0
    })
    const target = arr[0]
    for(let e of arr) {
      sameNameMap.set(e, target)
    }
  }
  const resMap = new Map()
  for(let str of names) {
    let name = '', cnt = 0, i = 0
    while(str[i] !== '(') name += str[i++]
    cnt = Number(str.slice(i + 1, str.length - 1))
    const realName = getRealName(name)
    resMap.set(realName, (resMap.get(realName) || 0) + cnt)
  }

  function getRealName(s) {
    return sameNameMap.has(s) ? sameNameMap.get(s) : s
  }
  return Array.from(resMap).map(_ => {
    return `${_[0]}(${_[1]})`
  })
};
```

## ?🌟😻✔ 面试题 17.08. 马戏团人塔【medium】

[ref](https://leetcode.cn/problems/circus-tower-lcci/)

俄罗斯套娃问题、二分搜索

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var bestSeqAtIndex = function(height, weight) {
  const arr = [], n = height.length
  for(let i=0;i<height.length;i++) {
    arr.push([height[i], weight[i]])
  }
  arr.sort((a, b) => a[0] - b[0] || b[1] - a[1])
  const dp = []
  let k = -1
  for(let i=0;i<n;i++) {
    const w = arr[i][1]
    if(!dp.length || dp[k] < w) {
      dp[++k] = w
    } else {
      let l = 0, r = k
      while(l < r) {
        const mid = Math.floor((l + r) / 2)
        if(dp[mid] >= w) {
          r = mid
        } else {
          l = mid + 1
        }
      }
      dp[l] = w
    }
  }
  return k + 1
};
```

## 🌟😻✔ 面试题 17.09. 第 k 个数【medium】

[ref](https://leetcode.cn/problems/get-kth-magic-number-lcci/)

动态规划

```js
// 动态规划
// 时间复杂度：O(K)
// 空间复杂度：O(K)
var getKthMagicNumber = function(k) {
  const dp = new Array(k + 1).fill(1)
  let i3 = 1, i5 = 1, i7 = 1
  for(let i=2;i<=k;i++) {
    const min = Math.min(dp[i3] * 3, dp[i5] * 5, dp[i7] * 7)
    if(min === dp[i3] * 3) {
      i3++
    }
    if(min === dp[i5] * 5) {
      i5++
    }
    if(min === dp[i7] * 7) {
      i7++
    }
    dp[i] = min
  }
  return dp[k]
};
```

## ?🌟😻✔ 面试题 17.10. 主要元素【easy】

[ref](https://leetcode.cn/problems/find-majority-element-lcci/)

摩尔排序

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var majorityElement = function(nums) {
  let num = nums[0], cnt = 1, i = 1
  while(i < nums.length) {
    if(nums[i] === num) cnt++
    else if(cnt === 0) {
      num = nums[i]
      cnt++
    } else {
      cnt--
    }
    i++
  }
  cnt = 0
  for(let i=0;i<nums.length;i++) {
    if(nums[i] === num) cnt++
  }
  return cnt > nums.length / 2 ? num : -1
};

```

## ?🌟😻✔ 面试题 17.11. 单词距离【medium】

[ref](https://leetcode.cn/problems/find-closest-lcci/)

模拟

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var findClosest = function(words, word1, word2) {
  const n = words.length
  let idx1 = Number.MIN_SAFE_INTEGER, idx2 = Number.MIN_SAFE_INTEGER
  let min = Number.MAX_SAFE_INTEGER
  for(let i=0;i<n;i++) {
    if(words[i] === word1) idx1 = i
    else if(words[i] === word2) idx2 = i
    if(idx1 !== Number.MIN_SAFE_INTEGER && idx2 !== Number.MIN_SAFE_INTEGER) {
      min = Math.min(min, Math.abs(idx1 - idx2))
    }
  }
  return min
};
```

## 🌟😻✔ 面试题 17.12. BiNode【easy】

[ref](https://leetcode.cn/problems/binode-lcci/)

二叉树、二叉搜索树

```js
var convertBiNode = function(root) {
  let head = null, prev = null
  function dfs(node) {
    if(!node) return
    const left = node.left
    const right = node.right
    node.left = null
    dfs(left)
    if(!head) head = node
    if(prev) {
      prev.right = node
    }
    prev = node
    dfs(right)
  }
  dfs(root)
  return head
};
```

## ??🌟😻✔ 面试题 17.13. 恢复空格【medium】

[ref](https://leetcode.cn/problems/re-space-lcci/)

动态规划、背包问题、完全背包

```js
var respace = function(dictionary, sentence) {
  const n = sentence.length, dp = new Array(n + 1).fill(0)
  for(let i = 1;i <= sentence.length; i++) {
    for(let word of dictionary) {
      if(i >= word.length && word === sentence.slice(i - word.length, i)) {
        dp[i] = Math.max(dp[i], dp[i - word.length] + word.length)
      } else {
        dp[i] = Math.max(dp[i], dp[i - 1])
      }
    }    
  }
  return n - dp[n]
};
```

## ?🌟😻✔ 面试题 17.14. 最小K个数【medium】

[ref](https://leetcode.cn/problems/smallest-k-lcci/)

堆、优先队列、快速选择、前k个问题

```js
// 快选思想
// 期望时间复杂度：O(N)
// 空间时间复杂度：O(1)
var smallestK = function(arr, k) {
  if(!k) return []
  let l = 0, r = arr.length - 1
  while(true) {
    const partInd = partition(l, r)
    if(partInd + 1 === k) return arr.slice(0, partInd + 1)
    else if(partInd + 1 > k) {
      r = partInd - 1
    } else {
      l = partInd + 1
    }
  }
  function partition(l, r) {
    if(l === r) return l
    const randI = l + Math.floor(Math.random() * (r - l + 1))
    swap(arr, l, randI)
    const pivot = arr[l]
    let j = l + 1
    for(let i=l + 1;i<=r;i++) {
      if(arr[i] < pivot) {
        swap(arr, i, j)
        j++
      }
    }
    swap(arr, j-1, l)
    return j-1
  }
};

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}

```

## ??🌟😻✔ 面试题 17.15. 最长单词【medium】

[ref](https://leetcode.cn/problems/longest-word-lcci/)

递归、哈希表、数组

```js
var longestWord = function(words) {
  const wordsSet = new Set(words)
  words.sort((a, b) => {
    if(a.length === b.length) {
      if(a < b) return -1
      else if(a > b) return 1
      return 0
    } else {
      return b.length - a.length
    }
  })
  function search(word, idx) {
    if(idx === word.length) return true
    for(let i=idx;i<word.length;i++) {
      // 排除自己匹配自己
      if(idx === 0 && i === word.length - 1) continue
      if(wordsSet.has(word.slice(idx, i + 1)) && search(word, i + 1)) return true
    }
    return false
  }
  for(let i=0;i<words.length;i++) {
    if(search(words[i], 0)) return words[i]
  }
  return ''
};
```

## 🌟😻✔ 面试题 17.16. 按摩师【easy】

[ref](https://leetcode.cn/problems/the-masseuse-lcci/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var massage = function(nums) {
  if(nums.length === 0) return 0
  if(nums.length <= 2) return Math.max(...nums)
  const n = nums.length
  let a = nums[0], b = Math.max(nums[0], nums[1])
  for(let i=2;i<n;i++) {
    let pa = a, pb = b
    b = Math.max(nums[i] + pa, pb)
    a = pb
  }
  return b
};
```

## ?🌟😻✔ 面试题 17.17. 多次搜索【medium】

[ref](https://leetcode.cn/problems/multi-search-lcci/)

字典树

```js
var multiSearch = function(big, smalls) {
  const m = big.length,n =smalls.length, res = new Array(n).fill(0).map(_ => [])
  const root = buildTree(smalls)
  for(let i=0;i<m;i++) {
    let node = root
    let j = i
    while(j < m && node.chl[big[j]]) {
      node = node.chl[big[j]]
      j++
      if(node.e) {
        res[node.idx].push(i)
      }
    }
  }
  return res
};

function buildTree(arr) {
  const root = new Node()
  for(let i=0;i<arr.length;i++) {
    const word = arr[i]
    let node = root
    for(let j=0;j<word.length;j++) {
      if(!node.chl[word[j]]) node.chl[word[j]] = new Node()
      node = node.chl[word[j]]
      if(j === word.length - 1) {
        node.e = true
        node.idx = i
      }
    }
  }
  return root
}

class Node {
  constructor() {
    this.e = false
    this.idx = 0
    this.chl = {}
  }
}
```

哈希表暴力解法

```js
var multiSearch = function(big, smalls) {
  const m = big.length, n = smalls.length, map = new Map(), res = new Array(n).fill(0).map(_ => [])
  for(let i=0;i<n;i++) {
    map.set(smalls[i], i)
  }
  for(let i=0;i<m;i++) {
    for(let j=i;j<m;j++) {
      const target = big.slice(i, j + 1)
      if(map.has(target)) {
        res[map.get(target)].push(i)
      }
    }
  }
  return res
};
````

## 🌟😻✔ 面试题 17.18. 最短超串【medium】

[ref](https://leetcode.cn/problems/shortest-supersequence-lcci/)

滑动窗口

```js
var shortestSeq = function(big, small) {
  const m = big.length, map = new Map()
  let diffCnt = small.length
  for(const num of small) {
    map.set(num, 1)
  }
  let l = 0, r = 0
  let min = Number.MAX_SAFE_INTEGER, res = []
  while(r < m) {
    if(map.has(big[r])) {
      map.set(big[r], map.get(big[r]) - 1)
      if(map.get(big[r]) === 0) diffCnt--
      if(diffCnt === 0 && r - l + 1 < min) {
        min = r - l + 1
        res = [l, r]
      }
      while(diffCnt === 0) {
        map.set(big[l], map.get(big[l]) + 1)
        if(map.get(big[l]) === 1) diffCnt++
        l++
        if(diffCnt === 0 && r - l + 1 < min) {
          min = r - l + 1
          res = [l, r]
        }
      }
    }
    r++
  }
  return res
};
```

## ?🌟😻✔ 面试题 17.19. 消失的两个数字【hard】

[ref](https://leetcode.cn/problems/missing-two-lcci/)

常规模拟题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var missingTwo = function(nums) {
  const n = nums.length + 2
  let n1 = false, n2 = false
  for(let i=0;i<nums.length;i++) {
    while(nums[i] !== i + 1 && nums[i] !== n && nums[i] !== n - 1) {
      swap(nums, i, nums[i] - 1)
    }
    if(nums[i] === n) {
      n1 = true
    } else if(nums[i] === n - 1) {
      n2 = true
    }
  }
  const res = []
  for(let i=0;i<nums.length;i++) {
    if(nums[i] !== i + 1) res.push(i + 1)
  }
  if(!n1) res.push(n)
  if(!n2) res.push(n - 1)
  return res
};

function swap(nums, i, j) {
  const t = nums[i]
  nums[i] = nums[j]
  nums[j] = t
}
```

## ?🌟😻✔ 面试题 17.22. 单词转换【medium】

[ref](https://leetcode.cn/problems/word-transformer-lcci/)

图、深度优先搜索、广度优先搜索

```js
var findLadders = function(beginWord, endWord, wordList) {
  wordList.push(beginWord)
  const wordListSet = new Set(wordList), used = new Set(), connectionMap = new Map()
  if(!wordListSet.has(endWord)) return []
  let res = []

  for(const word of wordList) {
    const relas = new Set()
    for(let i=0; i< word.length;i++) {
      for(let j=0;j<26;j++) {
        const target = word.slice(0, i) + String.fromCharCode('a'.charCodeAt(0) + j) + word.slice(i + 1)
        if(target !== word && wordListSet.has(target)) {
          relas.add(target)
        }
      }
    }
    connectionMap.set(word, relas)
  }
  used.add(beginWord)
  function walk(curr, path) {
    if(curr === endWord) {
      res = [...path]
      return
    }
    const nexts = connectionMap.get(curr)
    if(nexts) {
      for(const next of nexts) {
        if(used.has(next)) continue
        used.add(next)
        path.push(next)
        walk(next, path)
        path.pop()
      }
    }
  }
  walk(beginWord, [beginWord])
  return res
};
```

## ? 🌟😻✔ 面试题 17.23. 最大黑方阵【medium】

[ref](https://leetcode.cn/problems/max-black-square-lcci/)

矩阵

```js
var findSquare = function(matrix) {
  const n = matrix.length
  const downDp = new Array(n).fill(0).map(_ => new Array(n).fill(0)), rDp = new Array(n).fill(0).map(_ => new Array(n).fill(0))
  for(let i=n-1;i>=0;i--) {
    for(let j=0;j<n;j++) {
      if(matrix[i][j] === 0) {
        downDp[i][j] = (i + 1 < n ? downDp[i + 1][j] : 0) + 1
      }
    }
  }
  for(let i=0;i<n;i++) {
    for(let j=n-1;j>=0;j--) {
      if(matrix[i][j] === 0) {
        rDp[i][j] = (j + 1 < n ? rDp[i][j + 1] : 0) + 1
      }
    }
  }
  let cMax = 0, x, y
  for(let i=0;i<n;i++) {
    for(let j=0;j<n;j++) {
      if(matrix[i][j] === 0) {
        let zMin = Math.min(downDp[i][j], rDp[i][j])
        let k = 1, len = 1
        while(k <= zMin && i + k - 1 < n && j + k - 1 < n){
          if(rDp[i + k - 1][j] >= k && downDp[i][j + k - 1] >= k) {
            len = k
          }
          k++
        }
        if(cMax < len) {
          cMax = len
          x = i, y = j
        }
      }
    }
  }
  // console.log(downDp)
  // console.log(rDp)
  return cMax === 0? [] : [x, y, cMax]
};

```

## 🌟😻✔ 剑指 Offer II 002. 二进制加法【medium】

[ref](https://leetcode.cn/problems/JFETK5/)

二进制运算

```js
// 时间复杂度：O(max(M, N))
// 空间复杂度：O(1)
var addBinary = function(a, b) {
  let res = '', add = 0, i = a.length - 1, j = b.length - 1
  while(i >= 0 || j >= 0) {
    const sum = add + Number(i >= 0 ? a[i] : 0) + Number(j >= 0 ? b[j] : 0)
    res = (sum % 2) + res
    add = Math.floor(sum / 2)
    i--
    j--
  }
  if(add > 0) {
    res = 1 + res
  }
  return res
};
```

## 🌟😻✔ 剑指 Offer II 003. 前 n 个数字二进制中 1 的个数【easy】

[ref](https://leetcode.cn/problems/w3tCBm/)

二进制运算

```js
var countBits = function(n) {
  const dp = new Array(n + 1).fill(0)
  for(let i=1;i<=n;i++) {
    dp[i] = dp[i >> 1] + (i & 1)
  }
  return dp
};
```

```js
var countBits = function(n) {
  const res = []
  for(let i=0;i<=n;i++) {
    let j = i, cnt = 0
    while(j) {
      cnt += (j & 1)
      j >>= 1
    }
    res.push(cnt)
  }
  return res
};
```

## ?🌟😻✔ 剑指 Offer II 004. 只出现一次的数字 【medium】

[ref](https://leetcode.cn/problems/WGki4K/)

位运算

```js
var singleNumber = function(nums) {
  let ret = 0
  for(let i=0;i<32;i++) {
    let total = 0
    for(let j=0;j<nums.length;j++) {
      total += ((nums[j] >> i) & 1)
    }
    if(total % 3 !== 0) {
      ret |= (1 << i)
    }
  }

  return ret
};
```

```js
var singleNumber = function(nums) {
  const binaryArr = new Array(32).fill(0)
  for(let i=0;i<nums.length;i++) {
    const num = nums[i]
    for(let i=0;i<32;i++) {
      binaryArr[i] += ((num >> i) & 1)
    }
  }
  console.log(binaryArr)
  let ret = 0
  for(let i=0;i<32;i++) {
    ret += (binaryArr[i] % 3) * (1 << i)
  }
  return ret
};
```

## ?🌟😻✔ 剑指 Offer II 005. 单词长度的最大乘积【medium】

[ref](https://leetcode.cn/problems/aseY1I/)

位运算

```js
// 时间复杂度：O(L+N^2) L=words所有字符数之和 N=words.length
// 空间复杂度：O(N)
var maxProduct = function(words) {
  const n = words.length
  const binaWords = []
  for(let i=0;i<n;i++) {
    let num = 0
    for(let j=0;j<words[i].length;j++) {
      num |= (1 << (words[i].charCodeAt(j) - 'a'.charCodeAt(0)))
    }
    binaWords.push(num)
  }
  let max = 0
  for(let i=0;i<n;i++) {
    for(let j=i + 1;j<n;j++) {
      if((binaWords[i] & binaWords[j]) === 0) {
        max = Math.max(max, words[i].length * words[j].length)
      }
    }
  }
  return max
}

```

## 🌟😻✔ 剑指 Offer II 006. 排序数组中两个数字之和【easy】

[ref](https://leetcode.cn/problems/kLl5u1/)

哈希表、双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var twoSum = function(numbers, target) {
  let l = 0, r = numbers.length - 1
  while(l < r) {
    if(numbers[l] + numbers[r] === target) {
      return [l, r]
    } else if(numbers[l] + numbers[r] < target) {
      l++
    } else {
      r--
    }
  }
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var twoSum = function(numbers, target) {
  const map = new Map()
  for(let i = 0;i<numbers.length;i++) {
    if(map.has(target - numbers[i])) {
      return [map.get(target - numbers[i]), i]
    }
    map.set(numbers[i], i)
  }
};
```

## ??🌟😻✔ 剑指 Offer II 007. 数组中和为 0 的三个数【medium】

[ref](https://leetcode.cn/problems/1fGaJU/)

排序、双指针

```js
// 时间复杂度：O(N^2)
// 时间复杂度：O(logN)
var threeSum = function(nums) {
  nums.sort((a, b) => a - b)
  const n = nums.length
  const res = []
  for(let i=0;i<n - 2;i++) {
    let l = i + 1, r = n - 1
    if(nums[i] > 0) break
    if(i-1>=0 &&nums[i] === nums[i - 1]) continue
    while(l < r) {
      const sum = nums[i] + nums[l] + nums[r]
      if(sum === 0) {
        res.push([nums[i], nums[l], nums[r]])
        l++
        while(l < r && nums[l] === nums[l-1]) l++
      } else if(sum > 0) {
        r--
      } else {
        l++
      }
    }
  }
  return res
};
```

## 🌟😻✔ 剑指 Offer II 008. 和大于等于 target 的最短子数组【medium】

[ref](https://leetcode.cn/problems/2VG8Kg/)

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var minSubArrayLen = function(target, nums) {
  const n = nums.length
  let l = 0, r = 0
  let min = Number.MAX_SAFE_INTEGER
  let sum = 0
  while(r < n) {
    sum += nums[r]
    while(sum - nums[l] >= target) {
      sum -= nums[l]
      l++
    }
    if(sum >= target) min = Math.min(min, r - l + 1)
    r++
  }
  return min === Number.MAX_SAFE_INTEGER ? 0 : min
};
```

## 🌟😻✔ 剑指 Offer II 009. 乘积小于 K 的子数组【medium】

[ref](https://leetcode.cn/problems/ZVAVXX/)

双指针

```js
// 双指针
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var numSubarrayProductLessThanK = function(nums, k) {
  if(k === 0 || k === 1) return 0
  const n = nums.length
  let cnt = 0, mul = 1, l = 0, r = 0
  while(r < n) {
    mul *= nums[r]
    while(mul >= k) mul /= nums[l++]
    cnt += r - l + 1
    r++
  }
  return cnt
};
```

## 🌟😻✔ 剑指 Offer II 010. 和为 k 的子数组【medium】

[ref](https://leetcode.cn/problems/QTMn0o/)

前缀和

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var subarraySum = function(nums, k) {
  const n = nums.length, map = new Map([[0, 1]])
  let sum = 0, cnt = 0
  for(let i=0;i<n;i++) {
    sum += nums[i]
    if(map.has(sum - k)) {
      cnt += map.get(sum - k)
    }
    map.set(sum, (map.get(sum) || 0) + 1)
  }
  return cnt
};

```

## 🌟😻✔ 剑指 Offer II 011. 0 和 1 个数相同的子数组【medium】

[ref](https://leetcode.cn/problems/A1NYOS/)

前缀和

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var findMaxLength = function(nums) {
  const n = nums.length
  for(let i=0;i<n;i++) {
    if(nums[i] === 0) nums[i] = -1
  }
  const map = new Map([[0, -1]])
  let max = 0
  let sum = 0
  for(let i=0;i<n;i++) {
    sum += nums[i]
    if(map.has(sum)) {
      max = Math.max(max, i - map.get(sum))
    } else {
      map.set(sum, i)
    }
  }
  return max
};
```

## 🌟😻✔ 剑指 Offer II 012. 左右两边子数组的和相等【easy】

[ref](https://leetcode.cn/problems/tvdfij/)

常规数组题

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var pivotIndex = function(nums) {
  let  n = nums.length, rSum = 0
  for(let i=n - 1; i >= 0; i--) rSum += nums[i]
  let lSum = 0
  for(let i=0; i < n; i++) {
    rSum -= nums[i]
    if(lSum === rSum) return i
    lSum += nums[i]
  }
  return -1
};
```

## 🌟😻✔ 剑指 Offer II 013. 二维子矩阵的和【medium】

[ref](https://leetcode.cn/problems/O4NDxx/)

前缀和

```js
// 时间复杂度：O(MN) M=matrix.length, N=matrix[0].length
// 空间复杂度：O(1)
var NumMatrix = function(matrix) {
  for(let i=0;i<matrix.length;i++) {
    for(let j=0;j<matrix[0].length;j++) {
      matrix[i][j] += 
        (i-1 >=0 ? matrix[i-1][j]:0)
        +
        (j-1>=0?matrix[i][j - 1]:0)
        -
        ((i - 1 >= 0 && j - 1 >=0) ? matrix[i - 1][j - 1] : 0)
    }
  }
  this.matrix = matrix
};

// 时间复杂度：O(1)
// 空间复杂度：O(1)
NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {
  const ma = this.matrix
  return ma[row2][col2]
         -
         (col1 - 1>= 0 ? ma[row2][col1 - 1] : 0)
         -
         (row1 - 1 >=0 ? ma[row1 - 1][col2] : 0)
         +
         (row1 - 1 >= 0 && col1 - 1 >= 0 ? ma[row1 - 1][col1 - 1] : 0)
};

```

## ??🌟😻✔ 剑指 Offer II 014. 字符串中的变位词【medium】

[ref](https://leetcode.cn/problems/MPnaiL/)

哈希表、滑动窗口

```js
// 时间复杂度：O(M+N) M=s1.length N=s2.length
// 空间复杂度：O(e) e 最大为 26
var checkInclusion = function(s1, s2) {
  const map = new Map()
  let diffCnt = 0
  for(let i=0;i<s1.length;i++) {
    map.set(s1[i], (map.get(s1[i]) || 0) + 1)
    if(map.get(s1[i]) === 1) diffCnt++
  }
  let l=0, r = 0
  while(r < s2.length) {
    map.set(s2[r], (map.get(s2[r]) || 0) - 1)
    if(map.get(s2[r]) === 0) diffCnt--
    if(map.get(s2[r]) === -1) diffCnt++
    if(diffCnt === 0) return true
    while(map.get(s2[r]) < 0) {
      map.set(s2[l], map.get(s2[l]) + 1)
      if(map.get(s2[l]) === 0) diffCnt--
      if(map.get(s2[l]) === 1) diffCnt++
      if(diffCnt === 0) return true
      l++
    }
    r++
  }
  return false
};
```

## ?🌟😻✔ 剑指 Offer II 015. 字符串中的所有变位词【medium】

[ref](https://leetcode.cn/problems/VabMRr/)

滑动窗口

```js
// 时间复杂度：O(M+N) M=s.length N=p.length
// 空间复杂度：O(e) e 最大为26
var findAnagrams = function(s, p) {
  const map = new Map()
  let diffCnt = 0
  for(let i=0;i<p.length;i++) {
    map.set(p[i], (map.get(p[i]) || 0) + 1)
    if(map.get(p[i]) === 1) diffCnt++
  }
  const res = []
  let l = 0, r = 0
  while(r < s.length) {
    map.set(s[r], (map.get(s[r]) || 0) - 1)
    if(map.get(s[r]) === 0) diffCnt--
    if(map.get(s[r]) === -1) diffCnt++
    if(diffCnt === 0) res.push(l)
    while(map.get(s[r]) < 0) {
      map.set(s[l], map.get(s[l]) + 1)
      if(map.get(s[l]) === 0) diffCnt--
      if(map.get(s[l]) === 1) diffCnt++
      l++
      if(diffCnt === 0) res.push(l)
    }
    r++
  }
  return res
};
```

## 🌟😻✔ 剑指 Offer II 016. 不含重复字符的最长子字符串【medium】

[ref](https://leetcode.cn/problems/wtcaE1/)

滑动窗口

```js
// 滑动窗口
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var lengthOfLongestSubstring = function(s) {
  const map = new Map()
  let l = 0, r = 0
  let max = 0
  while(r < s.length) {
    map.set(s[r], (map.get(s[r]) || 0) + 1)
    while(map.get(s[r]) > 1) {
      map.set(s[l], map.get(s[l]) - 1)
      l++
    }
    max = Math.max(max, r - l + 1)
    r++
  }
  return max
};
```
## ?? 🌟😻✔ 剑指 Offer II 017. 含有所有字符的最短字符串【hard】

[ref](https://leetcode.cn/problems/M1oyTv/)

滑动窗口

```js
// 时间复杂度：O(N)
// 空间复杂度：O(W) W最大为26
var minWindow = function(s, t) {
  const tMap = new Map()
  let diffCnt = 0
  for(let c of t) {
    tMap.set(c, (tMap.get(c) || 0) + 1)
    if(tMap.get(c) === 1) diffCnt++
  }
  let l = 0, r = 0
  let res = ''
  while(r < s.length) {
    if(tMap.has(s[r])) {
      tMap.set(s[r], (tMap.get(s[r]) || 0) - 1)
      if(tMap.get(s[r]) === 0) diffCnt--
      if(diffCnt === 0 && (res === '' || res.length > r - l + 1)) res = s.slice(l, r + 1)
      while(diffCnt === 0) {
        if(tMap.has(s[l])) {
          tMap.set(s[l], tMap.get(s[l]) + 1)
          if(tMap.get(s[l]) === 1) diffCnt++
        }
        l++
        if(diffCnt === 0 && (res === '' || res.length > r - l + 1)) res = s.slice(l, r + 1)
      }
    }
    r++
  }
  return res
};

```

## 🌟😻✔ 剑指 Offer II 018. 有效的回文【easy】

[ref](https://leetcode.cn/problems/XltzEq/)

回文串

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var isPalindrome = function(s) {
  const sArr = []
  for(let i=0;i<s.length;i++) {
    const slower = s[i].toLowerCase()
    if(slower !== ' ' && (slower >= '0' && slower <= '9' || slower >= 'a' && slower <= 'z')) sArr.push(slower)
  }
  let l = 0, r = sArr.length - 1
  while(l < r) {
    if(sArr[l++] !== sArr[r--]) return false
  }
  return true
};
```

## 🌟😻✔ 剑指 Offer II 019. 最多删除一个字符得到回文【easy】

[ref](https://leetcode.cn/problems/RQku0D/)

双指针

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var validPalindrome = function(s) {
  const n = s.length
  let l = 0, r = n - 1
  while(l < r) {
    if(s[l] === s[r]) {
      l++
      r--
    } else{
      return isPalindrome(s, l + 1, r) || isPalindrome(s, l, r - 1)
    }
  }
  return true
};

function isPalindrome(s, l, r) {
  while(l < r) {
    if(s[l++] !== s[r--]) return false
  }
  return true
}

```

## 🌟😻✔ 剑指 Offer II 020. 回文子字符串的个数【medium】

[ref](https://leetcode.cn/problems/a7VOhD/?favorite=e8X3pBZi)

动态规划

```js
// 动态规划
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var countSubstrings = function(s) {
  const n = s.length, dp = new Array(n).fill(0).map(_ => new Array(n).fill(true))
  let cnt = 0
  for(let i=n-1;i>=0;i--) {
    for(let j=i;j<n;j++) {
      if(s[i] === s[j] && (
        i === j
        || i + 1 === j
        || dp[i + 1][j - 1])
      ) {
        dp[i][j] = true
        cnt++
      } else {
        dp[i][j] = false
      }
    }
  }
  return cnt
};
```

```js
// 普通解法
var countSubstrings = function(s) {
  let cnt = 0
  for(let i=0;i<s.length;i++) {
    let k = 0
    while(i - k >=0 && i + k < s.length && is(s, i - k, i + k)) k++
    cnt += k
    if(i + 1 < s.length && s[i] === s[i + 1]) {
      k = 0
      while(i - k >=0 && i + 1 + k < s.length && is(s, i - k, i + 1 + k)) k++
      cnt+= k
    }
  }
  return cnt
};

function is(s, l, r) {
  while(l < r) {
    if(s[l++] !== s[r--]) return false
  }
  return true
}
```

## 🌟😻✔ 剑指 Offer II 021. 删除链表的倒数第 n 个结点【medium】

[ref](https://leetcode.cn/problems/SLwz0R/?favorite=e8X3pBZi)

链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var removeNthFromEnd = function(head, n) {
  const myHead = new ListNode()
  myHead.next = head
  let tHead = myHead
  while(n>0) {
    tHead = tHead.next
    n--
  }
  let tHead2 = myHead
  while(tHead.next) {
    tHead = tHead.next
    tHead2 = tHead2.next
  }
  tHead2.next = tHead2.next.next
  return myHead.next
};
```

## 🌟😻✔ 剑指 Offer II 022. 链表中环的入口节点【medium】

[ref](https://leetcode.cn/problems/c32eOV/)

链表、环形链表

```js
// a +b+ n(b+c) = 2(a+b)
// a = nb+nc-b = c - c + nb + nc - b = c + (n-1)(b+c)
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var detectCycle = function(head) {
  const myHead = new ListNode()
  myHead.next = head
  let fast = myHead, slow = myHead
  while(fast.next && fast.next.next) {
    fast = fast.next.next
    slow = slow.next
    if(fast === slow) {
      fast = myHead
      while(fast !== slow) {
        fast=fast.next
        slow=slow.next
      }
      return fast
    }
  }
  return null
};
```

```js
// 哈希表
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var detectCycle = function(head) {
  const set = new Set()
  while(head) {
    if(set.has(head)) return head
    set.add(head)
    head = head.next
  }
  return null
};
```
## 🌟😻✔ 剑指 Offer II 023. 两个链表的第一个重合节点【easy】

[ref](https://leetcode.cn/problems/3u1WK4/)

链表

```js
var getIntersectionNode = function(headA, headB) {
  let pa = headA, pb = headB
  while(pa && pb) {
    if(pa === pb) return pa
    if(!pa.next && !pb.next) return null
    pa = pa.next ? pa.next : headB
    pb = pb.next ? pb.next : headA
  }
  return null
};
```

## 🌟😻✔ 剑指 Offer II 024. 反转链表【easy】

[ref](https://leetcode.cn/problems/UHnkqh/)

链表

```js
var reverseList = function(head) {
  const myHead = new ListNode()
  while(head) {
    const next = myHead.next
    myHead.next = head
    head = head.next
    myHead.next.next = next
  }
  return myHead.next
};

```

## 🌟😻✔ 剑指 Offer II 025. 链表中的两数相加【medium】

[ref](https://leetcode.cn/problems/lMSNwu/)

链表

```js
var addTwoNumbers = function(l1, l2) {
  const num1Arr = [], num2Arr = []
  while(l1) {
    num1Arr.push(l1.val)
    l1 = l1.next
  }
  while(l2) {
    num2Arr.push(l2.val)
    l2 = l2.next
  }
  const myHead = new ListNode()
  let add = 0
  while(num1Arr.length || num2Arr.length || add > 0) {
    let a = num1Arr.length > 0 ? num1Arr.pop() : 0
    let b = num2Arr.length > 0 ? num2Arr.pop() : 0
    const sum = add + a + b
    add = Math.floor(sum / 10)
    const next = myHead.next
    myHead.next = new ListNode(sum % 10)
    myHead.next.next = next 
  }
  return myHead.next
};
```


## 🌟😻✔ 剑指 Offer II 026. 重排链表【medium】

[ref](https://leetcode.cn/problems/LGjMqU/)

链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var reorderList = function(head) {
  const myHead = new ListNode(0, head)
  let slow = myHead, fast = myHead
  while(fast.next && fast.next.next) {
    slow = slow.next
    fast = fast.next.next
  }
  if(slow === fast) return head
  let head1 = head
  head2 = slow.next
  slow.next = null
  head2 = reverse(head2)
  const myHead2 = new ListNode()
  let tHead = myHead2
  while(head1 && head2) {
    tHead.next = head1
    head1 = head1.next
    tHead.next.next = head2
    head2 = head2.next
    tHead = tHead.next.next
  }
  if(head1) {
    tHead.next = head1
  }
  if(head2) {
    tHead.next = head2
  }
  return myHead2.next
};

function reverse(head) {
  const myHead = new ListNode()
  while(head) {
    const next = myHead.next
    myHead.next = head
    head = head.next
    myHead.next.next = next
  }
  return myHead.next
}
```

## ?🌟😻✔ 剑指 Offer II 027. 回文链表【easy】

[ref](https://leetcode.cn/problems/aMhZSa/)

链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var isPalindrome = function(head) {
  const myHead = new ListNode(0, head)
  let fast = myHead, slow = myHead
  while(fast.next && fast.next.next) {
    slow = slow.next
    fast = fast.next.next
  }
  if(slow === fast) return true
  fast = slow.next
  slow.next = null
  fast = reverse(fast)
  slow = head
  while(slow && fast) {
    if(slow.val !== fast.val) return false
    slow = slow.next
    fast = fast.next
  }
  return true
};

function reverse(head) {
  const myHead = new ListNode()
  while(head) {
    const next = myHead.next
    myHead.next = head
    head = head.next
    myHead.next.next = next
  }
  return myHead.next
}
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var isPalindrome = function(head) {
  let str = ''
  while(head) {
    str += head.val
    head = head.next
  }
  let l = 0, r = str.length - 1
  while(l < r) {
    if(str[l++] !== str[r--]) return false
  }
  return true
};
```

## 🌟😻✔ 剑指 Offer II 028. 展平多级双向链表【medium】

[ref](https://leetcode.cn/problems/Qv1Da2/)

深度优先搜索、链表

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var flatten = function(head) {
  if(!head) return null
  const myHead = new Node()
  let tHead = myHead
  function dfs(node) {
    const next = node.next, child = node.child
    tHead.next = node
    node.prev = tHead
    tHead = tHead.next
    node.child = null
    child && dfs(child) 
    next && dfs(next) 
  }
  dfs(head)
  myHead.next.prev = null
  return myHead.next
};
```

## 🌟😻✔ 剑指 Offer II 029. 排序的循环链表【medium】

[ref](https://leetcode.cn/problems/4ueAj6/)

链表、环形链表

```js
var insert = function(head, insertVal) {
  if(!head) {
    const node = new Node(insertVal)
    node.next = node
    return node
  }
  let tHead = head
  let canInsert = false
  do {
    if(tHead.val <= insertVal && insertVal <= tHead.next.val) {
      canInsert = true
      break
    } else {
      tHead = tHead.next
    }
  } while(tHead !== head)
  if(canInsert) {
    tHead.next = new Node(insertVal, tHead.next)
  } else {
    let maxNode = new Node(Number.MIN_SAFE_INTEGER)
    tHead = head
    do {
      if(tHead.val >= maxNode.val) {
        maxNode = tHead
      }
      tHead = tHead.next
    } while(tHead !== head)
    maxNode.next = new Node(insertVal, maxNode.next)
  }
  return head
};

```

## 🌟😻✔ 剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器【medium】

[ref](https://leetcode.cn/problems/FortPu/)

哈希表、设计

```js
var RandomizedSet = function() {
  this.map = new Map()
  this.arr = []
};
RandomizedSet.prototype.insert = function(val) {
  if(this.map.has(val)) return false
  this.arr.push(val)
  this.map.set(val, this.arr.length - 1)
  return true
};
RandomizedSet.prototype.remove = function(val) {
  if(!this.map.has(val)) return false
  const ind = this.map.get(val)
  this.arr[ind] = this.arr[this.arr.length - 1]
  this.map.set(this.arr[ind], ind)
  this.map.delete(val)
  this.arr.pop()
  return true
};
RandomizedSet.prototype.getRandom = function() {
  const len = this.arr.length
  return this.arr[Math.floor(Math.random() * len)]
};

```

## 🌟😻✔ 剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器【medium】

[ref](https://leetcode.cn/problems/OrIXps/)

设计题、LRU

```js
var LRUCache = function(capacity) {
  this.capacity = capacity
  this.cache = new Map()
};
LRUCache.prototype.get = function(key) {
  if(!this.cache.has(key)) return -1
  const ret = this.cache.get(key)
  this.put(key, ret)
  return ret
};
LRUCache.prototype.put = function(key, value) {
  if(this.cache.has(key)) {
    this.cache.delete(key)
  } else {
    if(this.cache.size === this.capacity) {
      this.cache.delete(this.cache.keys().next().value)
    }
  }
  this.cache.set(key, value)
};
```

## 🌟😻✔ 剑指 Offer II 032. 有效的变位词【medium】

[ref](https://leetcode.cn/problems/dKk3P7/)

哈希表

```js
var isAnagram = function(s, t) {
  if(s.length !== t.length || s === t) return false
  const map = new Map()
  let cnt = 0
  for(let i=0;i<s.length;i++) {
    map.set(s[i], (map.get(s[i]) || 0) + 1)
    if(map.get(s[i]) === 1) cnt++
  }
  for(let i=0;i<t.length;i++) {
    if(!map.has(t[i]) || map.get(t[i]) === 0) return false
    map.set(t[i], map.get(t[i]) - 1)
    if(map.get(t[i]) === 0) cnt--
  }
  return cnt === 0
};
```

## 🌟😻✔ 剑指 Offer II 033. 变位词组【medium】

[ref](https://leetcode.cn/problems/sfvd7V/)

排序、哈希表

```js
var groupAnagrams = function(strs) {
  const map = new Map()
  for(let str of strs) {
    const nstr = str.split('').sort((a, b) => a.charCodeAt(0) - b.charCodeAt(0)).join('')
    if(map.has(nstr)) {
      map.get(nstr).push(str)
    } else {
      map.set(nstr, [str])
    }
  }
  return Array.from(map.values())
};
```

```js
var groupAnagrams = function(strs) {
  const map = new Map()
  for(let i=0;i<strs.length;i++) {
    const arr = new Array(26).fill(0)
    for(let j=0;j<strs[i].length;j++) {
      arr[strs[i].charCodeAt(j) - 'a'.charCodeAt(0)]++
    }
    let s = ''
    for(let j=0;j<26;j++) {
      s += `${j}-${arr[j]},`
    }
    if(map.has(s)) {
      map.get(s).push(strs[i])
    } else {
      map.set(s, [strs[i]])
    }
  }
  return Array.from(map.values())
};
```

## ?🌟😻✔ 剑指 Offer II 034. 外星语言是否排序【easy】

[ref](https://leetcode.cn/problems/lwyVBB/)

哈希表

```js
var isAlienSorted = function(words, order) {
  const orderMap = new Map()
  for(let i=0;i<order.length;i++) {
    orderMap.set(order[i], i)
  }
  const n = words.length
  for(let i=0;i<n;i++) {
    if(i + 1 < n) {
      let k = 0
      while(k < words[i].length && k < words[i + 1].length && words[i][k] === words[i + 1][k]) {
        k++
      }
      if(k === words[i].length) continue
      if(k === words[i + 1].length) return false
      if(orderMap.get(words[i][k]) > orderMap.get(words[i + 1][k])) return false
    }
  }
  return true
};
```

## 🌟😻✔ 剑指 Offer II 035. 最小时间差【medium】

[ref](https://leetcode.cn/problems/569nqc/)

排序

```js
var findMinDifference = function(timePoints) {
  const dayMinuts = 24 * 60
  const n = timePoints.length
  for(let i=0;i<n;i++) {
    const tSplit = timePoints[i].split(':')
    timePoints[i] = Number(tSplit[0]) * 60 + Number(tSplit[1])
  }
  timePoints.sort((a, b) => a - b)
  timePoints.push(timePoints[0] + dayMinuts)
  let min = Number.MAX_SAFE_INTEGER
  for(let i=1;i<n+1;i++) {
    min = Math.min(min, timePoints[i] - timePoints[i-1])
  }
  return min
};
```

## 🌟😻✔ 剑指 Offer II 036. 后缀表达式【medium】

[ref](https://leetcode.cn/problems/8Zf90G/)

栈

```js
var evalRPN = function(tokens) {
  const stack = []
  for(let i=0;i<tokens.length;i++) {
    if(isNum(tokens[i])) {
      stack.push(Number(tokens[i]))
    } else {
      const num2 = stack.pop(), num1 = stack.pop()
      let res
      if(tokens[i] === '+') res = num1 + num2
      else if(tokens[i] === '-') res = num1 - num2
      else if(tokens[i] === '*') res = num1 * num2
      else {
        res = num1 / num2 > 0 ? Math.floor(num1 / num2) : Math.ceil(num1 / num2)
      }
      stack.push(res)
    }
  }
  return stack.pop()
};

function isNum(token) {
  return !(token === '+' || token === '-' || token === '*' || token === '/')
}
```

## 🌟😻✔ 剑指 Offer II 037. 小行星碰撞【medium】

[ref](https://leetcode.cn/problems/XagZNi/)

栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var asteroidCollision = function(asteroids) {
  const stack = []
  for(let i=0;i<asteroids.length;i++) {
    const curr = asteroids[i]
    if(!stack.length || curr > 0 || curr < 0 && stack[stack.length - 1] < 0) {
      stack.push(curr)
    } else {
      while(stack.length && stack[stack.length - 1] > 0 && stack[stack.length - 1] + curr < 0) {
        stack.pop()
      }
      if(!stack.length || stack[stack.length -1] < 0) {
        stack.push(curr)
      } else if(stack[stack.length - 1] + curr === 0) {
        stack.pop()
      }
    }
  }
  return stack
};
```

## 🌟😻✔ 剑指 Offer II 038. 每日温度【medium】

[ref](https://leetcode.cn/problems/iIQa4I/)

单调栈

```js
// 单调栈
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var dailyTemperatures = function(temperatures) {
  const stack = [], n = temperatures.length, res = new Array(n).fill(0)
  for(let i=0;i<temperatures.length;i++) {
    const tmp = temperatures[i]
    while(stack.length && temperatures[stack[stack.length - 1]] < tmp) {
      const ind = stack.pop()
      res[ind] = i - ind
    }
    stack.push(i)
  }
  return res
};
```

## ??🌟😻✔ 剑指 Offer II 039. 直方图最大矩形面积【easy】

[ref](https://leetcode.cn/problems/0ynMMM/)

单调栈

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var largestRectangleArea = function(heights) {
  heights.unshift(0)
  heights.push(0)
  const stack = [], n = heights.length
  let max = 0
  for(let i=0;i<n;i++) {
    while(stack.length && heights[stack[stack.length - 1]] > heights[i]) {
      const h = heights[stack.pop()]
      const prevIdx = stack[stack.length - 1]
      max = Math.max(max, (i - prevIdx - 1) * h)
    }
    stack.push(i)
  }
  return max
};
```

## ? 🌟😻✔ 剑指 Offer II 040. 矩阵中最大的矩形【hard】

[ref](https://leetcode.cn/problems/PLYXKQ/?favorite=e8X3pBZi)

单调栈

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var maximalRectangle = function(matrix) {
  if(!matrix.length) return 0 
  for(let i=0;i<matrix.length;i++) {
    matrix[i] = 0 + matrix[i] + 0
  }
  const m = matrix.length, n = matrix[0].length, dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  let max = 0
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(matrix[i][j] === '1') {
        dp[i][j] = 1 + (i-1 >= 0 ? dp[i-1][j] : 0)
      }
    }
  }
  for(let i=0;i<m;i++) {
    const stack = []
    for(let j=0;j<n;j++) {
      while(stack.length && dp[i][stack[stack.length - 1]] > dp[i][j]) {
        const idx = stack.pop()
        const l = stack[stack.length - 1]
        max = Math.max(max, dp[i][idx] * (j - l - 1))
      }
      stack.push(j)
    }
  }
  return max
};
```

## 🌟😻✔ 剑指 Offer II 041. 滑动窗口的平均值【easy】

[ref](https://leetcode.cn/problems/qIsx9U/)

滑动窗口

```js
var MovingAverage = function(size) {
  this.window = []
  this.sum = 0
  this.size = size
};
MovingAverage.prototype.next = function(val) {
  this.sum += val
  this.window.push(val)
  if(this.window.length > this.size) {
    this.sum -= this.window.shift()
  }
  return this.sum / this.window.length
};

```

## 🌟😻✔ 剑指 Offer II 042. 最近请求次数【medium】

[ref](https://leetcode.cn/problems/H8086Q/)

二分搜索、双端队列

```js
var RecentCounter = function() {
  this.pings = []
  this.l = 0
};
RecentCounter.prototype.ping = function(t) {
  this.pings.push(t)
  let l = this.l, r = this.pings.length
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(t - this.pings[mid] <= 3000) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  this.l = l
  return this.pings.length - l
};

```

## ?? 🌟😻✔ 剑指 Offer II 043. 往完全二叉树添加节点【medium】

[ref](https://leetcode.cn/problems/NaqhDT/)

设计题、队列

```js
var CBTInserter = function(root) {
  this.q = []
  this.root = root
  let q = [root]
  while(q.length) {
    const node = q.shift()
    if(node.left) q.push(node.left)
    if(node.right) q.push(node.right)
    if(!node.left || !node.right) this.q.push(node)
  }
};
CBTInserter.prototype.insert = function(v) {
  const topNode = this.q[0]
  const newNode = new TreeNode(v)
  if(!topNode.left) topNode.left = newNode
  else if(!topNode.right) topNode.right = newNode
  this.q.push(newNode)
  if(topNode.left && topNode.right) this.q.shift()
  return topNode.val
};

CBTInserter.prototype.get_root = function() {
  return this.root
};
```

## 🌟😻✔ 剑指 Offer II 044. 二叉树每层的最大值【medium】

[ref](https://leetcode.cn/problems/hPov7L/)

二叉树、广度优先搜索

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var largestValues = function(root) {
  if(!root) return []
  const res = []
  let q = [root]
  while(q.length) {
    let max = Number.MIN_SAFE_INTEGER
    const tq = []
    for(let i=0;i<q.length;i++) {
      const node = q[i]
      max = Math.max(max, node.val)
      node.left && tq.push(node.left)
      node.right && tq.push(node.right)
    }
    res.push(max)
    q = tq
  }
  return res
};
```

## 🌟😻✔ 剑指 Offer II 045. 二叉树最底层最左边的值【medium】

[ref](https://leetcode.cn/problems/LwUNpT/)

二叉树、广度优先搜索、深度优先搜索

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var findBottomLeftValue = function(root) {
  let res
  let q = [root]
  while(q.length) {
    res = q[0].val
    const tq = []
    for(let i=0;i<q.length;i++) {
      const node = q[i]
      node.left && tq.push(node.left)
      node.right && tq.push(node.right)
    }
    q = tq
  }
  return res
};
```

## 🌟😻✔ 剑指 Offer II 046. 二叉树的右侧视图【medium】

[ref](https://leetcode.cn/problems/WNC0Lk/)

二叉树、广度优先搜索、深度优先搜索
  
```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var rightSideView = function(root) {
  const res = []
  if(!root) return res
  let q = [root]
  while(q.length) {
    const tq = []
    res.push(q[q.length - 1].val)
    for(let i=0;i<q.length;i++) {
      const node = q[i]
      node.left && tq.push(node.left)
      node.right && tq.push(node.right)
    }
    q = tq
  }
  return res
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var rightSideView = function(root) {
  const res = []
  if(!root) return res
  function dfs(node, depth) {
    res[depth] = node.val
    node.left && dfs(node.left, depth + 1)
    node.right && dfs(node.right, depth + 1)
  }
  dfs(root, 0)
  return res
};
```

## 🌟😻✔ 剑指 Offer II 047. 二叉树剪枝【medium】

[ref](https://leetcode.cn/problems/pOCWxh/)

二叉树、深度优先搜索

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var pruneTree = function(root) {
  function dfs(node) {
    if(!node) return true
    let lRes = dfs(node.left)
    let rRes = dfs(node.right)
    if(lRes) node.left = null
    if(rRes) node.right = null
    if(lRes && rRes && node.val === 0) return true
    return false
  }
  const allZero = dfs(root)
  if(allZero) return null
  return root
};

```

## ??🌟😻✔ 剑指 Offer II 048. 序列化与反序列化二叉树【hard】

[ref](https://leetcode.cn/problems/h54YBf/?favorite=e8X3pBZi)

设计题、二叉树、序列化

```js
var serialize = function(root) {
  let res = ''
  function serializer(node) {
    if(!node) {
      res += 'null#'
      return
    }
    res += `${node.val}#`
    serializer(node.left)
    serializer(node.right)
  }
  serializer(root)
  return res
};
var deserialize = function(data) {
  let arr = data.split('#'), i = 0
  console.log(arr)
  function deserializer() {
    if(arr[i] === 'null') {
      i++
      return null
    }
    const node = new TreeNode(+arr[i++])
    const left = deserializer()
    const right = deserializer()
    node.left = left
    node.right = right
    return node
  }
  return deserializer()
};
```

```js
var serialize = function(root) {
  let res = ''
  function serializer(node) {
    if(!node) {
      res += '[]'
      return
    }
    res += '['
    res += `${node.val}`
    serializer(node.left)
    serializer(node.right)
    res += ']'
  }
  serializer(root)
  return res
};
var deserialize = function(data) {
  let i = 0
  function deserializer() {
    if(data[i] === '[') i++
    if(data[i] === ']') {
      i++
      return null
    }
    let sign = 1
    if(data[i] === '-') {
      sign = -1
      i++
    }
    let num = 0
    while(data[i] >= '0' && data[i] <= '9') num = 10 * num + Number(data[i++])
    const node = new TreeNode(sign * num)
    node.left = deserializer()
    node.right = deserializer()
    i++
    return node
  }
  return deserializer()
};

```

## 🌟😻✔ 剑指 Offer II 049. 从根节点到叶节点的路径数字之和【medium】

[ref](https://leetcode.cn/problems/h54YBf/)

二叉树、二叉树序列化

```js
var serialize = function(root) {
  let res = ''
  function serializer(node) {
    if(!node) {
      res += 'null#'
      return
    }
    res += `${node.val}#`
    serializer(node.left)
    serializer(node.right)
  }
  serializer(root)
  return res
};
var deserialize = function(data) {
  let arr = data.split('#'), i = 0
  function deserializer() {
    if(arr[i] === 'null') {
      i++
      return null
    }
    const node = new TreeNode(+arr[i++])
    node.left = deserializer()
    node.right = deserializer()
    return node
  }
  return deserializer()
};

```

```js
var serialize = function(root) {
  let res = ''
  function serializer(node) {
    if(!node) {
      res += '[]'
      return
    }
    res += '['
    res += `${node.val}`
    serializer(node.left)
    serializer(node.right)
    res += ']'
  }
  serializer(root)
  return res
};
var deserialize = function(data) {
  let i = 0
  function deserializer() {
    if(data[i] === '[') i++
    if(data[i] === ']') {
      i++
      return null
    }
    let sign = 1
    if(data[i] === '-') {
      sign = -1
      i++
    }
    let num = 0
    while(data[i] >= '0' && data[i] <= '9') num = 10 * num + Number(data[i++])
    const node = new TreeNode(sign * num)
    node.left = deserializer()
    node.right = deserializer()
    i++
    return node
  }
  return deserializer()
};

```

## 🌟😻✔ 剑指 Offer II 049. 从根节点到叶节点的路径数字之和【medium】

[ref](https://leetcode.cn/problems/3Etpl5/)

二叉树

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var sumNumbers = function(root) {
  let sum = 0
  function dfs(node, s) {
    s = s * 10  + node.val
    if(!node.left && !node.right) {
      sum += s
    }
    node.left && dfs(node.left, s)
    node.right && dfs(node.right, s)
  }
  dfs(root, 0)
  return sum
};
```

## 🌟😻✔ 剑指 Offer II 050. 向下的路径节点之和【medium】

[ref](https://leetcode.cn/problems/6eUYwP/)

前缀和、二叉树、深度优先搜素

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var pathSum = function(root, targetSum) {
  if(!root) return 0
  const map = new Map([[0, 1]])
  let cnt = 0
  function dfs(node, sum) {
    sum += node.val
    if(map.has(sum - targetSum)) {
      cnt += map.get(sum - targetSum)
    }
    map.set(sum, (map.get(sum) || 0 ) + 1)
    node.left && dfs(node.left, sum)
    node.right && dfs(node.right, sum)
    map.set(sum, (map.get(sum) || 0 ) - 1)
  }
  dfs(root, 0)
  return cnt
};
```

## 🌟😻✔ 剑指 Offer II 051. 节点之和最大的路径【hard】

[ref](https://leetcode.cn/problems/jC7MId/)

二叉树

```js
var maxPathSum = function(root) {
  let max = Number.MIN_SAFE_INTEGER
  function dfs(node) {
    if(!node) return 0
    const leftMax = dfs(node.left)
    const rightMax = dfs(node.right)
    max = Math.max(
      max,
      node.val,
      node.val + leftMax,
      node.val + rightMax,
      node.val + rightMax + leftMax,
    )
    return Math.max(node.val, node.val + leftMax, node.val + rightMax)
  }
  dfs(root)
  return max
};
```

## 🌟😻✔ 剑指 Offer II 052. 展平二叉搜索树【easy】

[ref](https://leetcode.cn/problems/NYBBNL/)

二叉搜索树、中序遍历

```js
var increasingBST = function(root) {
  let head = null
  let tHead = null
  function dfs(node) {
    const left = node.left, right = node.right
    node.left = null
    node.right = null
    left && dfs(left)
    if(!head) head = node
    if(!tHead) tHead = node
    else {
      tHead.right = node
      tHead = tHead.right
    }
    right && dfs(right)
  }
  dfs(root)
  return head
};
```

## 🌟😻✔ 剑指 Offer II 053. 二叉搜索树中的中序后继【medium】

[ref](https://leetcode.cn/problems/P5rCT8/)

二叉搜索树、中序遍历

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var inorderSuccessor = function(root, p) {
  let res = null
  let shouldBeNext = false
  function dfs(node) {
    node.left && dfs(node.left)
    if(shouldBeNext) {
      res = node
      shouldBeNext = false
    }
    if(p === node) shouldBeNext = true
    node.right && dfs(node.right)
  }
  dfs(root)
  return res
};
```

## ?🌟😻✔ 剑指 Offer II 054. 所有大于等于节点的值之和【medium】

[ref](https://leetcode.cn/problems/w6cpku/)

利用中序遍历的反向，二叉搜索树中序遍历会从小到大走一遍树中的节点，中序遍历的反向则会从大到小走一遍二叉搜索树的所有节点，用sum记录前面遍历到的大值，到node的时候sum就是值比node.val 大的节点值之和

```js
// 中序遍历的反向
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var convertBST = function(root) {
  if(!root) return null
  let sum = 0
  function dfs(node, bigger) {
    node.right && dfs(node.right)
    sum += node.val
    node.val = sum
    node.left && dfs(node.left)
  }
  dfs(root, 0)
  return root
};
```

```js
// 递归函数 dfs 返回的是该节点及其子节点的数值和
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var convertBST = function(root) {
  if(!root) return null
  function dfs(node, bigger) {
    if(!node) return 0
    const rValue = dfs(node.right, bigger)
    const nodeValue = node.val
    node.val = nodeValue + rValue + bigger
    const lValue = dfs(node.left, node.val)
    return lValue + nodeValue + rValue
  }
  dfs(root, 0)
  return root
};
```

## ?🌟😻✔ 剑指 Offer II 055. 二叉搜索树迭代器【medium】

[ref](https://leetcode.cn/problems/kTOapQ/)

二叉树、迭代器

```js
var BSTIterator = function(root) {
  this.i = 0
  this.arr = []
  const that = this
  function dfs(node) {
    node.left && dfs(node.left)
    that.arr.push(node.val)
    node.right && dfs(node.right)
  }
  dfs(root)
};
BSTIterator.prototype.next = function() {
  return this.arr[this.i++]
};
BSTIterator.prototype.hasNext = function() {
  return this.i < this.arr.length
};
```

```js
var BSTIterator = function(root) {
  this.curr = root
  this.arr = []
};
BSTIterator.prototype.next = function() {
  while(this.curr) {
    this.arr.push(this.curr)
    this.curr = this.curr.left
  }
  this.curr = this.arr.pop()
  const ret = this.curr.val
  this.curr =  this.curr.right
  return ret
};
BSTIterator.prototype.hasNext = function() {
  return this.curr || this.arr.length
};
```

## 🌟😻✔ 剑指 Offer II 056. 二叉搜索树中两个节点之和【medium】

[ref](https://leetcode.cn/problems/opLdQZ/)

二叉搜索树、中序遍历

```js
var findTarget = function(root, k) {
  let can = false
  const set = new Set()
  function dfs(node) {
    node.left && dfs(node.left)
    if(set.has(k - node.val)) can = true
    set.add(node.val)
    node.right && dfs(node.right)
  }
  dfs(root)
  return can
};
```

## ???🌟😻✔ 剑指 Offer II 057. 值和下标之差都在给定的范围内【medium】

[ref](https://leetcode.cn/problems/7WqeDu/) 

桶排序、滑动窗口

```js
// 时间复杂度：O(N)
// 时间复杂度：O(min(N, K))
var containsNearbyAlmostDuplicate = function(nums, k, t) {
  const map = new Map()
  for(let i=0;i<nums.length;i++) {
    const val = nums[i]
    const id = getId(val, t + 1)
    if(map.has(id)) return true
    if(map.has(id - 1) && val - map.get(id - 1) <= t) return true
    if(map.has(id + 1) && map.get(id + 1) - val <= t) return true
    map.set(id, val)
    if(i - k >= 0) {
      map.delete(getId(nums[i - k], t + 1))
    }
  }
  return false
};

function getId(val, size) {
  return Math.floor(val / size)
}
```

## ?🌟😻✔ 剑指 Offer II 058. 日程表【medium】

[ref](https://leetcode.cn/problems/fi9suh/)

二分搜索

```js
var MyCalendar = function() {
  this.arr = []
};
MyCalendar.prototype.book = function(start, end) {
  let l = 0, r = this.arr.length - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    const [s, e] = this.arr[mid]
    if(start >= e) {
      l = mid + 1
    } else if(end <= s) {
      r = mid - 1
    } else {
      return false
    }
  }
  this.arr.splice(l, 0, [start, end])
  return true
};

```

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N)
var MyCalendar = function() {
  this.arr = []
};
MyCalendar.prototype.book = function(start, end) {
  if(!this.arr.length) {
    this.arr.push([start, end])
    return true
  } else if(end <= this.arr[0][0]) {
    this.arr.unshift([start, end])
    return true
  } else if(start >= this.arr[this.arr.length - 1][1]) {
    this.arr.push([start, end])
    return true
  } else if(this.arr.length === 1) {
    return false
  } else {
    for(let i=0;i<this.arr.length - 1;i++) {
      const [s, e] = this.arr[i]
      const [nexts, nexte] = this.arr[i + 1]
      if(start >= e && end <= nexts) {
        this.arr.splice(i + 1, 0, [start, end])
        return true
      }
    }
    return false
  }
};

```

## 🌟😻✔ 剑指 Offer II 059. 数据流的第 K 大数值【medium】

[ref](https://leetcode.cn/problems/jBjn9C/)

优先队列

```js
var KthLargest = function(k, nums) {
  this.minHeap = new MinHeap()
  this.capacity = k
  for(let num of nums) {
    this.minHeap.insert(num)
    if(this.minHeap.size() > k) {
      this.minHeap.pop()
    }
  }
};

KthLargest.prototype.add = function(val) {
  this.minHeap.insert(val)
  if(this.minHeap.size() > this.capacity) this.minHeap.pop()
  return this.minHeap.peek()
};

class MinHeap {
  constructor() {
    this.heap = []
  }
  insert(v){
    this.heap.push(v)
    this.shiftUp(this.size() - 1)
  }
  pop(){
    this.swap(0, this.size() - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  peek() {
    return this.heap[0]
  }
  swap(i, j){
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  shiftUp(i){
    const parentIdx = Math.floor((i - 1) / 2)
    if(parentIdx >= 0 && this.heap[i] < this.heap[parentIdx]) {
      this.swap(i, parentIdx)
      this.shiftUp(parentIdx)
    }
  }
  shiftDown(i){
    const leftIdx = 2 * i + 1, rightIdx = 2 * i + 2
    let minIdx = i
    if(leftIdx < this.size() && this.heap[leftIdx] < this.heap[minIdx]) {
      minIdx = leftIdx
    }
    if(rightIdx < this.size() && this.heap[rightIdx] < this.heap[minIdx]) {
      minIdx = rightIdx
    }
    if(minIdx !== i) {
      this.swap(i, minIdx)
      this.shiftDown(minIdx)
    }
  }
  size(){
    return this.heap.length
  }
}

```

## 🌟😻✔ 剑指 Offer II 060. 出现频率最高的 k 个数字【medium】

[ref](https://leetcode.cn/problems/g5c51o/)

快速选择

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var topKFrequent = function(nums, k) {
  const map = new Map()
  for(let num of nums) {
    map.set(num, (map.get(num) || 0) + 1)
  }
  const arr = Array.from(map)
  let l = 0, r = arr.length - 1
  while(true) {
    const ind = partition(arr, l, r)
    if(ind === k - 1) break
    else if(ind < k - 1) {
      l = ind + 1
    } else {
      r = ind - 1
    }
  }
  return arr.slice(0, k).map(_ => _[0])
};

function partition(arr, l, r) {
  const target = arr[l]
  let j = l + 1
  for(let i=j;i<=r;i++) {
    if(arr[i][1] > target[1]) {
      swap(arr, j, i)
      j++
    }
  }
  swap(arr, l, j - 1)
  return j - 1
}

function swap(arr, i, j) {
  const t = arr[i]
  arr[i] = arr[j]
  arr[j] = t
}
```

```JS
// 时间复杂度：O(NlogK)
// 空间复杂度：O(N)
var topKFrequent = function(nums, k) {
  const map = new Map()
  for(let num of nums) {
    map.set(num, (map.get(num) || 0) + 1)
  }
  const arr = Array.from(map)
  const heap = new MinHeap()
  for(let i=0;i<arr.length;i++) {
    heap.insert(arr[i])
    if(heap.size() > k) heap.pop()
  }
  return heap.heap.map(_ => _[0])
};

class MinHeap {
  constructor() {
    this.heap = []
  }
  insert(data) {
    this.heap.push(data)
    this.shiftUp(this.size() - 1)
  }
  pop() {
    this.swap(0, this.size() - 1)
    const ret = this.heap.pop()
    this.shiftDown(0)
    return ret
  }
  size() {
    return this.heap.length
  }
  swap(i, j) {
    const t = this.heap[i]
    this.heap[i] = this.heap[j]
    this.heap[j] = t
  }
  shiftUp(i) {
    const parentIdx = Math.floor((i-1) / 2)
    if(parentIdx >= 0 && this.heap[i][1] < this.heap[parentIdx][1]) {
      this.swap(i, parentIdx)
      this.shiftUp(parentIdx)
    }
  }
  shiftDown(i) {
    const leftIdx = 2 * i + 1, rightIdx = 2 * i + 2
    let minIdx = i
    if(leftIdx < this.size() && this.heap[leftIdx][1] < this.heap[minIdx][1]) {
      minIdx = leftIdx
    }
    if(rightIdx < this.size() && this.heap[rightIdx][1] < this.heap[minIdx][1]) {
      minIdx = rightIdx
    }
    if(minIdx !== i) {
      this.swap(i, minIdx)
      this.shiftDown(minIdx)
    }
  }
}
```

## 🌟😻✔ 剑指 Offer II 061. 和最小的 k 个数对【medium】

[ref](https://leetcode.cn/problems/qn8gGX/)

优先队列

```js
var kSmallestPairs = function(nums1, nums2, k) {
  class MinHeap {
    constructor() {
      this.heap = []
    }
    size(){
      return this.heap.length
    }
    insert(data){
      this.heap.push(data)
      this.shiftUp(this.size() - 1)
    }
    pop(){
      this.swap(0, this.size() - 1)
      const ret = this.heap.pop()
      this.shiftDown(0)
      return ret
    }
    swap(i, j) {
      const t = this.heap[i]
      this.heap[i] = this.heap[j]
      this.heap[j] = t
    }
    sum(i) {
      return nums1[this.heap[i][0]] + nums2[this.heap[i][1]]
    }
    shiftUp(i) {
      const parentIdx = Math.floor((i - 1) / 2)
      if(parentIdx >=0 && this.sum(i) < this.sum(parentIdx)) {
        this.swap(i, parentIdx)
        this.shiftUp(parentIdx)
      }
    }
    shiftDown(i) {
      const leftIdx = 2 * i + 1, rightIdx = 2 * i + 2
      let minIdx = i
      if(leftIdx < this.size() && this.sum(leftIdx) < this.sum(minIdx)) {
        minIdx = leftIdx
      }
      if(rightIdx < this.size() && this.sum(rightIdx) < this.sum(minIdx)) {
        minIdx = rightIdx
      }
      if(minIdx !== i) {
        this.swap(i, minIdx)
        this.shiftDown(minIdx)
      }
    }
  }
  const minHeap = new MinHeap()
  const m = nums1.length, n = nums2.length
  for(let i=0;i<Math.min(m, k);i++) {
    minHeap.insert([i, 0])
  }
  const res = []
  while(k > 0 && minHeap.size()) {
    const top  = minHeap.pop()
    res.push([nums1[top[0]], nums2[top[1]]])
    if(top[1] + 1 < n) {
      minHeap.insert([top[0], top[1] + 1])
    }
    k--
  }
  return res
};
```

## 🌟😻✔ 剑指 Offer II 062. 实现前缀树【medium】

[ref](https://leetcode.cn/problems/QC3q1f/)

字典树

```js
var Trie = function() {
  this.root = new Node()
};
Trie.prototype.insert = function(word) {
  let node = this.root
  for(let i=0;i<word.length;i++) {
    if(!node.children[word[i]]) node.children[word[i]] = new Node()
    node = node.children[word[i]]
    if(i === word.length - 1) node.isEnd = true
  }
};
Trie.prototype.search = function(word) {
  let node = this.root
  for(let i=0;i<word.length;i++) {
    if(!node.children[word[i]]) return false
    node = node.children[word[i]]
    if(i === word.length - 1) return node.isEnd
  }
};
Trie.prototype.startsWith = function(prefix) {
  let node = this.root
  for(let i=0;i<prefix.length;i++) {
    if(!node.children[prefix[i]]) return false
    node = node.children[prefix[i]]
  }
  return true
};

class Node {
  constructor() {
    this.isEnd = false
    this.children = {}
  }
}
```

## 🌟😻✔ 剑指 Offer II 063. 替换单词【medium】

[ref](https://leetcode.cn/problems/UhWRSj/)

字典树

```js
var replaceWords = function(dictionary, sentence) {
  const root = buildTree(dictionary)
  const words = sentence.split(' ')
  for(let i=0;i<words.length;i++) {
    words[i] = replace(root, words[i])
  }
  return words.join(' ')
};

function replace(root, word) {
  let node = root
  for(let i=0;i<word.length;i++) {
    if(node.children[word[i]]) {
      node = node.children[word[i]]
    } else {
      return word
    }
    if(node.isEnd) return word.slice(0, i + 1)
  }
  return word
}

function buildTree(dictionary) {
  const root = new Node()
  for(let i=0;i<dictionary.length;i++) {
    const word = dictionary[i]
    let node = root
    for(let j=0;j<word.length;j++) {
      if(!node.children[word[j]]) node.children[word[j]] = new Node()
      node = node.children[word[j]]
      if(j === word.length - 1) node.isEnd = true
    }
  }
  return root
}

class Node {
  constructor() {
    this.isEnd = false
    this.children = {}
  }
}
```

## 🌟😻✔ 剑指 Offer II 064. 神奇的字典【medium】

[ref](https://leetcode.cn/problems/US1pGT/)

字典树

```js
var MagicDictionary = function() {
  this.root = new Node()
};
MagicDictionary.prototype.buildDict = function(dictionary) {
  for(let i=0;i<dictionary.length;i++) {
    const word = dictionary[i]
    let node = this.root
    for(let j=0;j<word.length;j++) {
      if(!node.children[word[j]]) node.children[word[j]] = new Node()
      node = node.children[word[j]]
      if(j === word.length - 1) node.isEnd = true
    }
  }
};

MagicDictionary.prototype.search = function(searchWord) {
  function search(node, ind, changed) {
    if(ind === searchWord.length) {
      if(changed) return node.isEnd
      return false
    }
    if(node.children[searchWord[ind]] && search(node.children[searchWord[ind]], ind + 1, changed)) return true 
    if(!changed) {
      const keys = Object.keys(node.children)
      for(let i=0;i<keys.length;i++) {
        if(searchWord[ind] === keys[i]) continue
        if(search(node.children[keys[i]], ind + 1, true)) return true
      }
      return false
    }
    return false
  }
  return search(this.root, 0, false)
};

class Node {
  constructor() {
    this.isEnd = false
    this.children = {}
  }
}
```

## 🌟😻✔ 剑指 Offer II 065. 最短的单词编码【medium】

[ref](https://leetcode.cn/problems/iSwD2y/)

字典树

```js
var minimumLengthEncoding = function(words) {
  const set = new Set(words)
  for(let word of words) {
    for(let i=1;i<word.length;i++) {
      set.delete(word.slice(i))
    }
  }
  let res = 0
  for(let word of set) {
    res += word.length + 1
  }
  return res
};
```

```js
var minimumLengthEncoding = function(words) {
  words = words.map(_ => _.split('').reverse().join(''))
  let res = 0
  const root = new Node()
  for(let i=0;i<words.length;i++) {
    const word = words[i]
    let node = root
    for(let j=0;j<word.length;j++) {
      if(!node.children[word[j]]) node.children[word[j]] = new Node()
      node = node.children[word[j]]
    }
  }
  function walk(node, len) {
    const keys = Object.keys(node.children)
    if(!keys.length) {
      res += len + 1
    }
    for(let i=0;i<keys.length;i++) {
      walk(node.children[keys[i]], len + 1)
    }
  }
  walk(root, 0)
  return res
};

class Node {
  constructor() {
    this.children = {}
  }
}

````

```js
// 排序+字典树
var minimumLengthEncoding = function(words) {
  words = words.map(_ => _.split('').reverse().join(''))
  words.sort((a, b) => b.length - a.length)
  let res = 0
  const root = new Node()
  for(let i=0;i<words.length;i++) {
    const word = words[i]
    let node = root
    let shouldAdd = false
    for(let j=0;j<word.length;j++) {
      if(!node.children[word[j]]) {
        node.children[word[j]] = new Node()
        shouldAdd = true
      }
      node = node.children[word[j]]
    }
    if(shouldAdd) res += 1 + word.length
  }
  return res
};

class Node {
  constructor() {
    this.children = {}
  }
}

```

## 🌟😻✔ 剑指 Offer II 066. 单词之和【medium】

[ref](https://leetcode.cn/problems/z1R5dt/)

字典树、前缀树

```js
var MapSum = function() {
  this.root = new Node()
};
MapSum.prototype.insert = function(key, val) {
  let node = this.root
  for(let i=0;i<key.length;i++) {
    if(!node.children[key[i]]) node.children[key[i]] = new Node()
    node = node.children[key[i]]
    if(i === key.length - 1) {
      node.isEnd = true
      node.val = val
    }
  }
};
MapSum.prototype.sum = function(prefix) {
  let node = this.root
  for(let i=0;i<prefix.length;i++) {
    if(!node.children[prefix[i]]) return 0
    node = node.children[prefix[i]]
  }
  let sum = 0
  function walk(node) {
    if(node.isEnd) sum += node.val
    const keys = Object.keys(node.children)
    for(let i=0;i<keys.length;i++) {
      walk(node.children[keys[i]])
    }
  }
  walk(node)
  return sum
};

class Node {
  constructor() {
    this.isEnd = false
    this.val = 0
    this.children = {}
  }
}
```

## ??? 🌟😻✔ 剑指 Offer II 067. 最大的异或【medium】

[ref](https://leetcode.cn/problems/ms70jA/)

字典树

```js
var findMaximumXOR = function (nums) {
  const root = []
  let max = Number.MIN_SAFE_INTEGER
  for (let num of nums) {
    add(root, num)
    max = Math.max(max, num ^ getVal(root, num))
  }
  return max
}

function getVal(node, num) {
  let ret = 0
  for (let i = 30; i >= 0; i--) {
    const j = (num >> i) & 1
    const target = 1 - j
    if (node[target]) {
      node = node[target]
      ret |= target << i
    } else {
      ret |= j << i
      node = node[j]
    }
  }
  return ret
}

function add(node, num) {
  for (let i = 30; i >= 0; i--) {
    const n = (num >> i) & 1
    if (!node[n]) node[n] = []
    node = node[n]
  }
}
```

## 🌟😻✔ 剑指 Offer II 068. 查找插入位置【easy】

[ref](https://leetcode.cn/problems/N6YdxV/)

二分搜索

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var searchInsert = function(nums, target) {
  if(target > nums[nums.length - 1]) return nums.length
  let l = 0, r = nums.length - 1
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] >= target) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return l
};
```

```js
var searchInsert = function(nums, target) {
  let l = 0, r = nums.length - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(nums[mid] === target) {
      return mid
    } else if(nums[mid] > target) {
      r = mid - 1
    } else {
      l = mid + 1
    }
  }
  return l
};
```

## 🌟😻✔ 剑指 Offer II 069. 山峰数组的顶部【easy】

[ref](https://leetcode.cn/problems/B1IidL/)

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var peakIndexInMountainArray = function(arr) {
  let l = 0, r = arr.length - 1
  while(l < r) {
    const mid = (l + r) >> 1
    if(arr[mid] > arr[mid + 1]) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return l
};
```

## 🌟😻✔ 剑指 Offer II 070. 排序数组中只出现一次的数字【medium】

[ref](https://leetcode.cn/problems/skFtm2/)

二分搜索

```js
// 时间复杂度：O(logN)
// 空间复杂度：O(1)
var singleNonDuplicate = function(nums) {
  const n = nums.length
  let l = 0, r = nums.length - 1
  while(l <= r) {
    const mid = Math.floor((l + r) / 2)
    if(mid - 1 >= 0 && nums[mid - 1] === nums[mid]) {
      if(mid % 2 === 1) {
        l = mid + 1
      } else {
        r = mid - 1
      }
    } else if(mid + 1 < n && nums[mid + 1] === nums[mid]) {
      if(mid % 2 === 0) {
        l = mid + 1
      } else {
        r = mid - 1
      }
    } else {
      return nums[mid]
    }
  }
};
```

## ? 🌟😻✔ 剑指 Offer II 071. 按权重生成随机数【medium】

[ref](https://leetcode.cn/problems/cuyjEf/)

二分搜索

```js
var Solution = function(w) {
  this.arr = []
  let sum = 0
  for(let i=0;i<w.length;i++) {
    sum += w[i]
    this.arr.push(sum)
  }
  this.min = 1
  this.max = sum
};
Solution.prototype.pickIndex = function() {
  const target = Math.floor(Math.random() * (this.max - this.min + 1)) + this.min, arr = this.arr
  let l = 0, r = arr.length - 1
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(arr[mid] >= target) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return l
};
```

## 🌟😻✔ 剑指 Offer II 072. 求平方根【easy】

[ref](https://leetcode.cn/problems/jJ0w9p/)

二分搜索

```js
var mySqrt = function(x) {
  let l = 0, r = x
  while(l < r) {
    const mid = Math.ceil((l + r) / 2)
    const s = mid * mid
    if(s === x) return mid
    else if(s > x) {
      r = mid - 1
    } else {
      l = mid
    }
  }
  return l
};
```

## ? 🌟😻✔ 剑指 Offer II 073. 狒狒吃香蕉【medium】

[ref](https://leetcode.cn/problems/nZZqjQ/)

二分搜索

```js
var minEatingSpeed = function(piles, h) {
  const n = piles.length
  let max = Number.MIN_SAFE_INTEGER
  for(let i=0;i<n;i++) {
    max = Math.max(piles[i], max)
  }
  let l = 1, r = max
  while(l < r) {
    const mid = Math.floor((l + r) / 2)
    if(getCost(piles, mid) <= h) {
      r = mid
    } else {
      l = mid + 1
    }
  }
  return l
};

function getCost(piles, speed) {
  let cost = 0
  for(let i=0;i<piles.length;i++) {
    cost += Math.ceil(piles[i] / speed)
  }
  return cost
}
```

## 🌟😻✔ 剑指 Offer II 074. 合并区间【medium】

[ref](https://leetcode.cn/problems/SsGoHC/)

区间问题

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(logN)
var merge = function(intervals) {
  intervals.sort((a, b) => a[0] - b[0] || a[1] - b[1])
  let stack = []
  for(let i=0;i<intervals.length;i++) {
    const interval = intervals[i]
    if(!stack.length) stack.push(interval)
    else {
      const end = stack[stack.length - 1]
      if(end[1] < interval[0]) {
        stack.push(interval)
      } else {
        stack.pop()
        stack.push([end[0], Math.max(end[1], interval[1])])
      }
    }
  }
  return stack
};
```

## ? 🌟😻✔ 剑指 Offer II 075. 数组相对排序【easy】

[ref](https://leetcode.cn/problems/0H97ZC/)

排序

```js
var relativeSortArray = function(arr1, arr2) {
  const s2 = new Set(arr2)
  const m1 = new Map()
  const tailArr = []
  for(let i=0;i<arr1.length;i++) {
    if(s2.has(arr1[i])) m1.set(arr1[i], (m1.get(arr1[i]) || 0) + 1)
    else {
      let j = tailArr.length - 1
      while(j >= 0 && tailArr[j] > arr1[i]) {
        tailArr[j+1] = tailArr[j]
        j--
      }
      tailArr[j + 1] = arr1[i]
    }
  }
  const res = []
  for(let i=0;i<arr2.length;i++) {
    for(let j=0;j<m1.get(arr2[i]);j++) {
      res.push(arr2[i])
    }
  }
  return [...res, ...tailArr]
};

```

## 🌟😻✔ 剑指 Offer II 076. 数组中的第 k 大的数字【medium】

[ref](https://leetcode.cn/problems/xx4gT2/?favorite=e8X3pBZi)

快速选择

```js
var findKthLargest = function(nums, k) {
  let l = 0, r = nums.length - 1
  while(true) {
    const ind = partition(nums, l, r)
    if(ind === k-1) return nums[ind]
    else if(ind > k-1) {
      r = ind - 1
    } else {
      l = ind + 1
    }
  }
};

function partition(nums, l, r) {
  const target = nums[l]
  let j = l + 1
  for(let i=j;i<=r;i++) {
    if(nums[i] >= target) {
      swap(nums, j, i)
      j++
    }
  }
  swap(nums, j - 1, l)
  return j - 1
}

function swap(nums, i, j) {
  const t = nums[i]
  nums[i] = nums[j]
  nums[j] = t
}
```

## 🌟😻✔ 剑指 Offer II 077. 链表排序【medium】

[ref](https://leetcode.cn/problems/7WHec2/)

分治法、归并排序

```js
var sortList = function(head) {
  const myHead = new ListNode(0, head)
  let fast = myHead, slow  = myHead
  while(fast.next && fast.next.next) {
    fast = fast.next.next
    slow = slow.next
  }
  if(slow === fast) return head
  const next = slow.next
  slow.next = null
  return merge(sortList(head), sortList(next))
};

function merge(head1, head2) {
  const myHead = new ListNode()
  let tHead = myHead
  while(head1 && head2) {
    if(head1.val < head2.val) {
      tHead.next = head1
      head1 = head1.next
    } else {
      tHead.next = head2
      head2 = head2.next
    }
    tHead = tHead.next
  }
  if(head1) {
    tHead.next = head1
  }
  if(head2) {
    tHead.next = head2
  }
  return myHead.next
}
```

## 🌟😻✔ 剑指 Offer II 078. 合并排序链表【hard】

[ref](https://leetcode.cn/problems/vvXgSW/)

归并排序

```js
var mergeKLists = function(lists) {
  if(!lists.length) return null
  function mergeSort(arr, l, r) {
    if(l === r) return arr[l]
    const mid = Math.floor((l + r) / 2)
    return merge(mergeSort(arr, l, mid), mergeSort(arr, mid + 1, r))
  }
  return mergeSort(lists, 0, lists.length - 1)
};


function merge(head1, head2) {
  const myHead = new ListNode()
  let tHead = myHead
  while(head1 && head2) {
    if(head1.val < head2.val) {
      tHead.next = head1
      head1 = head1.next
    } else {
      tHead.next = head2
      head2 = head2.next
    }
    tHead = tHead.next
  }
  if(head1) {
    tHead.next = head1
  }
  if(head2) {
    tHead.next = head2
  }
  return myHead.next
}
```

## 🌟😻✔ 剑指 Offer II 079. 所有子集【medium】

[ref](https://leetcode.cn/problems/TVdhkn/)

回溯法

```js
var subsets = function(nums) {
  const res = []
  function walk(path, ind) {
    res.push([...path])
    for(let i=ind;i<nums.length;i++) {
      path.push(nums[i])
      walk(path, i + 1)
      path.pop()
    }
  }
  walk([], 0)
  return res
};
```

## 🌟😻✔ 剑指 Offer II 080. 含有 k 个元素的组合【medium】

[ref](https://leetcode.cn/problems/uUsW3B/)

回溯法、集合问题

```js
var combine = function(n, k) {
  const res = []
  function walk(path, start) {
    if(path.length === k) {
      res.push([...path])
      return
    }
    for(let i=start;i<=n;i++) {
      path.push(i)
      walk(path, i + 1)
      path.pop()
    }
  }
  walk([], 1)
  return res
};
```

## 🌟😻✔ 剑指 Offer II 081. 允许重复选择元素的组合【medium】

[ref](https://leetcode.cn/problems/Ygoe9J/)

回溯法

```js
var combinationSum = function(candidates, target) {
  const res = []
  function walk(path, sum, start) {
    if(sum === target) {
      res.push([...path])
      return
    }
    for(let i=start;i<candidates.length;i++) {
      if(sum + candidates[i] <= target) {
        path.push(candidates[i])
        walk(path, sum + candidates[i], i)
        path.pop()
      }
    }
  }
  walk([], 0, 0)
  return res
};

```

## 🌟😻✔ 剑指 Offer II 082. 含有重复元素集合的组合【medium】

[ref](https://leetcode.cn/problems/4sjJUc/)

回溯法

```js
var combinationSum2 = function(candidates, target) {
  candidates.sort((a, b) => a - b)
  const res = [], n = candidates.length
  const used = new Array(n).fill(false)
  function walk(path, sum, startIdx) {
    if(sum === target) {
      res.push([...path])
      return
    }
    for(let i=startIdx;i<=n;i++) {
      if(i-1>=0 && !used[i - 1] && candidates[i] === candidates[i-1]) continue
      if(!used[i] && candidates[i] + sum <= target) {
        path.push(candidates[i])
        used[i] = true
        walk(path, sum + candidates[i], i + 1)
        used[i] = false
        path.pop()
      }
    }
  }
  walk([], 0, 0)
  return res
};
```

## 🌟😻✔ 剑指 Offer II 083. 没有重复元素集合的全排列【medium】

[ref](https://leetcode.cn/problems/VvJkup/)

回溯法

```js
var permute = function(nums) {
  const res = [], n = nums.length
  const used = new Array(n).fill(false)
  function walk(path) {
    if(path.length === n) {
      res.push([...path])
      return
    }
    for(let i=0;i<n;i++) {
      if(!used[i]) {
        path.push(nums[i])
        used[i] = true
        walk(path)
        path.pop()
        used[i] = false
      }
    }
  }
  walk([])
  return res
};
```

## 🌟😻✔ 剑指 Offer II 084. 含有重复元素集合的全排列【medium】

[ref](https://leetcode.cn/problems/7p8L0Z/)

回溯法

```js
var permuteUnique = function(nums) {
  nums.sort((a, b) => a - b)
  const n = nums.length, res = []
  const used = new Array(n).fill(false)
  function walk(path) {
    if(path.length === n) {
      res.push([...path])
      return
    }
    for(let i=0;i<n;i++) {
      if(used[i] || i-1>=0 && !used[i-1] && nums[i] === nums[i - 1]) continue 
      used[i] = true
      path.push(nums[i])
      walk(path)
      path.pop()
      used[i] = false
    }
  }
  walk([])
  return res
};
```

## ?🌟😻✔ 剑指 Offer II 085. 生成匹配的括号【medium】

[ref](https://leetcode.cn/problems/IDBivT/)

回溯法

```js
var generateParenthesis = function(n) {
  const res = []
  function walk(str, lCnt, rCnt) {
    if(lCnt === n && rCnt === n) {
      res.push(str)
      return
    }
    if(lCnt < n) {
      walk(str + '(', lCnt + 1, rCnt)
    }
    if(rCnt < lCnt) {
      walk(str + ')', lCnt, rCnt + 1)
    }
  }
  walk('', 0, 0)
  return res
};
```

## 🌟😻✔ 剑指 Offer II 086. 分割回文子字符串【medium】

[ref](https://leetcode.cn/problems/M99OJA/)

回文串、动态规划、回溯法

```js
var partition = function(s) {
  const n = s.length, dp = new Array(n).fill(false).map(_ => new Array(n).fill(true))
  for(let i=n-2;i>=0;i--) {
    for(let j=i+1;j<n;j++) {
      dp[i][j] = s[i] === s[j] && dp[i+1][j-1]
    }
  }
  const res = []
  function walk(path, startInd) {
    if(startInd>=n) {
      res.push([...path])
      return
    }
    for(let i=startInd;i<n;i++) {
      if(dp[startInd][i]) {
        path.push(s.slice(startInd, i + 1))
        walk(path, i + 1)
        path.pop()
      }
    }
  }
  walk([], 0)
  return res
};

```

## ? 🌟😻✔ 剑指 Offer II 087. 复原 IP 【medium】

[ref](https://leetcode.cn/problems/0on3uN/)

回溯法

```js
var restoreIpAddresses = function(s) {
  const res = [], n = s.length
  function walk(path, ind, k) {
    if(k === 1) {
      if(ind < n && isValid(s.slice(ind))) res.push(path.join('.') + '.' + s.slice(ind))
      return
    }
    for(let i=ind;i<Math.min(n, ind + 3);i++) {
      if(isValid(s.slice(ind, i + 1))) {
        path.push(s.slice(ind, i + 1))
        walk(path, i + 1, k - 1)
        path.pop()
      }
    }
  }
  walk([], 0, 4)
  return res
};
function isValid(str) {
  if(str === '0') return true
  if(str[0] === '0') return false
  return 255 >= Number(str) && Number(str) >= 0
}
```

## 🌟😻✔ 剑指 Offer II 088. 爬楼梯的最少成本【easy】

[ref](https://leetcode.cn/problems/GzCJIP/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var minCostClimbingStairs = function(cost) {
  const n = cost.length
  let a = 0, b = 0
  for(let i=2;i<n;i++) {
    let pa = a, pb = b
    a = pb
    b = Math.min(pa + cost[i-2], pb + cost[i-1])
  }
  return Math.min(a + cost[n-2], b + cost[n-1])
};
```

## 🌟😻✔ 剑指 Offer II 089. 房屋偷盗【medium】

[ref](https://leetcode.cn/problems/Gu0c2T/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var rob = function(nums) {
  const n = nums.length, dp = new Array(n).fill(0)
  dp[0] = nums[0]
  for(let i=1;i<n;i++) {
    dp[i] = Math.max(dp[i-1], nums[i] + (i-2>=0?dp[i-2]:0))
  }
  return dp[n-1]
};
```

## 🌟😻✔ 剑指 Offer II 090. 环形房屋偷盗【medium】

[ref](https://leetcode.cn/problems/PzWKhm/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var rob = function(nums) {
  const n = nums.length, dp1 = new Array(n-1).fill(0), dp2 = new Array(n-1).fill(0)
  if(n === 1) return nums[0]
  dp1[0] = nums[0], dp2[0] = nums[1]
  for(let i=1;i<n-1;i++) {
    dp1[i] = Math.max(dp1[i-1], nums[i] + (i-2>=0 ?dp1[i-2] : 0))
  }
  for(let i=2;i<n;i++) {
    dp2[i-1] = Math.max(dp2[i-2], nums[i] + (i-3>=0 ?dp2[i-3] : 0))
  }
  return Math.max(dp1[n-2], dp2[n-2])
};
```

## 🌟😻✔ 剑指 Offer II 091. 粉刷房子【medium】

[ref](https://leetcode.cn/problems/JEj789/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var minCost = function(costs) {
  let a = costs[0][0], b = costs[0][1], c = costs[0][2]
  for(let i=1;i<costs.length;i++) {
    let pa = a, pb = b, pc = c
    a = costs[i][0] + Math.min(pb, pc)
    b = costs[i][1] + Math.min(pa, pc)
    c = costs[i][2] + Math.min(pa, pb)
  }
  return Math.min(a, b, c)
};
```

## 🌟😻✔ 剑指 Offer II 092. 翻转字符【medium】

[ref](https://leetcode.cn/problems/cyJERH/)

动态规划

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var minFlipsMonoIncr = function(s) {
  const n = s.length, dp = new Array(n).fill(0).map(_ => new Array(2).fill(Number.MAX_SAFE_INTEGER))
  if(s[0] === '0') {
    dp[0][0] = 0
    dp[0][1] = 1
  } else {
    dp[0][0] = 1
    dp[0][1] = 0
  }
  for(let i=1;i<n;i++) {
    if(s[i] === '0') {
      dp[i][0] = dp[i-1][0]
      dp[i][1] = 1 + Math.min(dp[i-1][0], dp[i-1][1])
    } else {
      dp[i][0] = 1 + dp[i-1][0]
      dp[i][1] = Math.min(dp[i-1][0], dp[i-1][1])
    }
  }
  return Math.min(...dp[n - 1])
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(1)
var minFlipsMonoIncr = function(s) {
  const n = s.length
  let a = Number.MAX_SAFE_INTEGER, b = Number.MAX_SAFE_INTEGER
  if(s[0] === '0') {
    a = 0
    b = 1
  } else {
    a = 1
    b = 0
  }
  for(let i=1;i<n;i++) {
    let pa = a, pb = b
    if(s[i] === '0') {
      a = pa
      b = 1 + Math.min(pa, pb)
    } else {
      a = 1 + pa
      b = Math.min(pa, pb)
    }
  }
  return Math.min(a, b)
};
```

## ??🌟😻✔ 剑指 Offer II 093. 最长斐波那契数列【medium】

[ref](https://leetcode.cn/problems/Q91FMA/)

动态规划

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var lenLongestFibSubseq = function(arr) {
  const n = arr.length, map = new Map()
  let max = 0
  for(let i=0;i<n;i++) {
    map.set(arr[i], i)
  }
  const dp = new Array(n).fill(0).map(_ => new Array(n).fill(0))
  for(let i=0;i<n;i++) {
    for(let k=i+2;k<n;k++) {
      const j = map.get(arr[k] - arr[i]) || -1
      if(j > i && j < k) {
        dp[j][k] = dp[i][j] + 1
        max = Math.max(max, dp[j][k])
      }
    }
  }
  return max === 0 ? 0 : max + 2
};
```

## ???🌟😻✔ 剑指 Offer II 094. 最少回文分割【hard】

[ref](https://leetcode.cn/problems/omKAoA/)

回文串、动态规划

```js
// 时间复杂度：O(N^2)
// 空间复杂度：O(N^2)
var minCut = function(s) {
  const n = s.length
  const fp = new Array(n).fill(0).map(_ => new Array(n).fill(true))
  for(let i=n-2;i>=0;i--) {
    for(let j=i + 1;j<n;j++) {
      fp[i][j] = false
      if(s[i] === s[j]) {
        fp[i][j] = i + 1 <= j - 1 ? fp[i + 1][j - 1] : true
      }
    }
  }
  const dp = new Array(n + 1).fill(0).map((_, i) => i)
  for(let j=1;j<=n;j++) {
    for(let i=j;i>=1;i--) {
      if(fp[i-1][j-1]) {
        dp[j] = Math.min(dp[j], dp[i - 1] + 1) 
      }
    }
  }
  return dp[n] - 1
};
```

## ?🌟😻✔ 剑指 Offer II 095. 最长公共子序列【medium】

[ref](https://leetcode.cn/problems/qJnOS7/)

动态规划

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var longestCommonSubsequence = function(text1, text2) {
  const m = text1.length, n = text2.length, dp = new Array(m + 1).fill(0).map(_ => new Array(n + 1).fill(0))
  
  for(let i=1;i<=m;i++) {
    for(let j=1;j<=n;j++) {
      if(text1[i-1] === text2[j-1]) {
        dp[i][j] = 1 + dp[i-1][j-1]
      } else {
        dp[i][j] = Math.max(dp[i-1][j], dp[i][j - 1])
      }
    }
  }

  return dp[m][n]
};
```

```js
//优化版
// 时间复杂度：O(MN)
// 空间复杂度：O(N)
var longestCommonSubsequence = function(text1, text2) {
  const m = text1.length, n = text2.length
  let dp = new Array(n + 1).fill(0)
  
  for(let i=1;i<=m;i++) {
    const tdp = []
    for(let j=0;j<=n;j++) {
      if(i === 0 || j === 0) {
        tdp.push(0)
      } else if(text1[i-1] === text2[j-1]) {
        tdp.push(1 + dp[j-1])
      } else {
        tdp.push(Math.max(dp[j], tdp[j - 1]))
      }
    }
    dp = tdp
  }

  return dp[n]
};
```

## ?🌟😻✔ 剑指 Offer II 096. 字符串交织【medium】

[ref](https://leetcode.cn/problems/IY6buf/?favorite=e8X3pBZi)

动态规划

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var isInterleave = function(s1, s2, s3) {
  const m = s1.length, n = s2.length
  if(m + n !== s3.length) return false
  const dp = new Array(m + 1).fill(false).map(_ => new Array(n + 1).fill(true))
  dp[0][0] = true
  for(let i=1;i<=m;i++) {
    dp[i][0] = s1[i-1] === s3[i-1] && dp[i - 1][0]
  }
  for(let j=1;j<=n;j++) {
    dp[0][j] = s2[j-1] === s3[j-1] && dp[0][j - 1]
  }
  for(let i=1;i<=m;i++) {
    for(let j=1;j<=n;j++) {
      dp[i][j] = 
        s1[i-1] === s3[i + j - 1] && dp[i-1][j] || 
        s2[j-1] === s3[i + j - 1] && dp[i][j-1] || false
    }
  }
  return dp[m][n]
}; 
```

## 🌟😻✔ 剑指 Offer II 098. 路径的数目【medium】

[ref](https://leetcode.cn/problems/2AoeFn)

动态规划

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var uniquePaths = function(m, n) {
  const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))
  for(let i=0;i<m;i++) {
    dp[i][0] = 1
  }
  for(let j=0;j<n;j++) {
    dp[0][j] = 1
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      dp[i][j] = dp[i-1][j] + dp[i][j - 1]
    }
  }
  return dp[m-1][n-1]
};
```

滚动数组优化

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(N)
var uniquePaths = function(m, n) {
  let dp = new Array(n).fill(1)
  for(let i=1;i<m;i++) {
    const tdp = [1]
    for(let j=1;j<n;j++) {
      tdp.push(dp[j] + tdp[j - 1])
    }
    dp = tdp
  }
  return dp[n-1]
};
```

## 🌟😻✔ 剑指 Offer II 099. 最小路径之和【medium】

[ref](https://leetcode.cn/problems/0i0mDW/comments/)

动态规划

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var minPathSum = function(grid) {
  const m = grid.length, n = grid[0].length, dp = new Array(m).fill(0).map(_ => new Array(n).fill(Number.MAX_SAFE_INTEGER))
  dp[0][0] = grid[0][0]
  for(let i=1;i<m;i++) {
    dp[i][0] = grid[i][0] + dp[i-1][0]
  }
  for(let j=1;j<n;j++) {
    dp[0][j] = grid[0][j] + dp[0][j-1]
  }
  for(let i=1;i<m;i++) {
    for(let j=1;j<n;j++) {
      dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1])
    }
  }
  return dp[m-1][n-1]
};
```

滚动数组优化

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(N)
var minPathSum = function(grid) {
  const m = grid.length, n = grid[0].length
  let dp = new Array(n).fill(Number.MAX_SAFE_INTEGER)
  dp[0] = grid[0][0]
  for(let j=1;j<n;j++) {
    dp[j] = grid[0][j] + dp[j-1]
  }
  for(let i=1;i<m;i++) {
    const tdp = []
    for(let j=0;j<n;j++) {
      if(j === 0) {
        tdp.push(dp[0] + grid[i][j])
      } else {
        tdp.push(grid[i][j] + Math.min(dp[j], tdp[j-1]))
      }
    }
    dp = tdp
  }
  return dp[n-1]
};
```

## 🌟😻✔ 剑指 Offer II 100. 三角形中最小路径之和【medium】

[ref](https://leetcode.cn/problems/IlPe0q/)

动态规划

```js
// 时间复杂度：O(K) K=triangle中所有的元素个数
// 空间复杂度：O(M) M=max(triangle[i])
var minimumTotal = function(triangle) {
  let dp = [triangle[0][0]]
  for(let i=1;i<triangle.length;i++) {
    const tdp = []
    for(let j=0; j < triangle[i].length; j++) {
      if(j === 0) {
        tdp.push(triangle[i][j] + dp[j])
      } else if(j === triangle[i].length - 1) {
        tdp.push(triangle[i][j] + dp[j-1])
      } else {
        tdp.push(triangle[i][j] + Math.min(dp[j], dp[j - 1]))
      }
    }
    dp = tdp
  }
  return Math.min(...dp)
};
```

## ?🌟😻✔ 剑指 Offer II 101. 分割等和子集【easy】

[ref](https://leetcode.cn/problems/NUPfPr/)

背包问题、01背包、动态规划

```js
// 时间复杂度：O(N*target)
// 空间复杂度：O(target)
var canPartition = function(nums) {
  let sum = 0, max = Number.MIN_SAFE_INTEGER
  for(const num of nums) {
    sum += num
    max = Math.max(max, num)
  }
  const target = sum / 2
  if(target !== Math.floor(target) || max > target) return false
  const dp = new Array(target + 1).fill(false)
  dp[0] = true
  for(let i=0;i<nums.length;i++) {
    for(let j=target; j >= 0; j--) {
      if(j - nums[i] >= 0) {
        dp[j] |= dp[j - nums[i]]
      }
    }
  }
  return dp[target]
};
```

## ?? 🌟😻✔ 剑指 Offer II 102. 加减的目标值【medium】

[ref](https://leetcode.cn/problems/YaVDxD/)

动态规划、回溯法、背包问题、01背包

有序背包

```js
var findTargetSumWays = function(nums, target) {
  let sum = 0
  for(const num of nums) sum += num
  const neg = (sum - target) / 2
  if(neg !== Math.floor(neg) || neg < 0) return 0
  const dp = new Array(neg + 1).fill(0)
  dp[0] = 1
  for(const num of nums) {
    for(let j=neg;j>=num;j--) {
      dp[j] += dp[j - num]
    }
  }
  return dp[neg]
};
```

```js
// 回溯
// 时间仅仅击败 6%
var findTargetSumWays = function(nums, target) {
  const n = nums.length
  let cnt = 0
  function walk(sum, ind) {
    if(ind === n) {
      if(sum === target) cnt++
      return
    }
    walk(sum + nums[ind], ind + 1)
    walk(sum - nums[ind], ind + 1)
  }
  walk(0, 0)
  return cnt
};
```

## ?? 🌟😻✔ 剑指 Offer II 103. 最少的硬币数目【medium】

[ref](https://leetcode.cn/problems/gaM7Ch/)

无序背包、背包问题、动态规划

```js
// coins 放在外层是因为要把某个 coin 能达到的所有情况全部扫描出来
// 上一个coin所有的case都扫描出来之后，再用后面coin继续扫描
// 用后面的coin的时候就不需要前面的coin参与了，达到去重效果
var coinChange = function(coins, amount) {
  const dp = new Array(amount + 1).fill(Number.MAX_SAFE_INTEGER)
  dp[0] = 0
  for(let coin of coins) {
    for(let i=coin;i<=amount;i++) {
      dp[i] = Math.min(dp[i], dp[i - coin] + 1)
    }
  }
  return dp[amount] === Number.MAX_SAFE_INTEGER ? -1 : dp[amount]
};
```

## ?? 🌟😻✔ 剑指 Offer II 104. 排列的数目【medium】

[ref](https://leetcode.cn/problems/D0F0SV/)

动态规划、有序背包、背包问题

```js
// 排列，有顺序，所以对于 dp[i]，其可能为 nums 中的任何 num
var combinationSum4 = function(nums, target) {
  const dp = new Array(target + 1).fill(0)
  dp[0] = 1
  for(let i=0;i<=target;i++) {
    for(const num of nums) {
      if(i >= num) {
        dp[i] += dp[i - num]
      }
    }
  }
  return dp[target]
};
```

## 🌟😻✔ 剑指 Offer II 105. 岛屿的最大面积【medium】

[ref](https://leetcode.cn/problems/ZL6zAn/)

矩阵、深度优先搜索

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(1)
var maxAreaOfIsland = function(grid) {
  const m = grid.length, n = grid[0].length
  function walk(i, j) {
    if(i < 0 || i>=m || j < 0 || j>=n || grid[i][j] === 0) return 0
    grid[i][j] = 0
    let sum = 1
    sum += walk(i + 1, j) + walk(i - 1, j) + walk(i, j + 1) + walk(i, j - 1)
    return sum
  }
  let max = 0
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 1) {
        max = Math.max(max, walk(i, j))
      }
    }
  }
  return max
};
```

```js
// BFS
var maxAreaOfIsland = function(grid) {
  const m = grid.length, n = grid[0].length
  const directs = [[-1, 0], [1, 0], [0, 1], [0, -1]]
  function walk(i, j) {
    grid[i][j] = 0
    let q = [[i, j]]
    let sum = 1
    while(q.length) {
      const tq = []
      for(let i=0;i<q.length;i++) {
        const [x, y] = q[i]
        for(let j=0;j<4;j++) {
          const xx = x + directs[j][0], yy = y + directs[j][1]
          if(xx < 0 || xx >=m || yy < 0 || yy >= n || grid[xx][yy] === 0) continue
          grid[xx][yy] = 0
          tq.push([xx, yy])
          sum += 1
        }
      }
      q = tq
    }
    return sum
  }
  let max = 0
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(grid[i][j] === 1) {
        max = Math.max(max, walk(i, j))
      }
    }
  }
  return max
};
```

## ? 🌟😻✔ 剑指 Offer II 106. 二分图【medium】

[ref](https://leetcode.cn/problems/vEAB3K/)

图、二分图、深度优先搜索、广度优先搜索

```js
// BFS 染色法
// 碰到没有染色的节点，就把当前节点染色为1，然后BFS找连接的节点
// 相邻节点染色相反，如果碰到已经染过色的节点，则判断其已经染过的色和应该染的色是否相同
// 不同则返回false，表示无法分成二分图
var isBipartite = function(graph) {
  const n = graph.length
  const colors = new Array(n).fill(0)
  for(let i=0;i<n;i++) {
    if(colors[i] > 0) continue
    let q = [[i, 1]]
    colors[i] = 1
    while(q.length) {
      const tq = []
      for(let j=0;j<q.length;j++) {
        const [target, pos] = q[j]
        for(let k=0;k<graph[target].length;k++) {
          const next = graph[target][k]
          const nextPos = pos === 1? 2 : 1
          if(!colors[next]) {
            colors[next] = nextPos
            tq.push([next, nextPos])
          } else {
            if(nextPos !== colors[next]) return false
          }
        }
      }
      q = tq
    }
  }
  return true
};
```

## 🌟😻✔ 剑指 Offer II 107. 矩阵中的距离【medium】

[ref](https://leetcode.cn/problems/2bCMpM/)

广度优先搜索、多源广度优先

```js
// 时间复杂度：O(MN)
// 空间复杂度：O(MN)
var updateMatrix = function(mat) {
  const m = mat.length, n = mat[0].length
  let q = []
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(mat[i][j] === 0) {
        q.push([i, j, 0])
        mat[i][j] = '0'
      }
    }
  }
  const directs = [[-1, 0], [1, 0], [0, 1], [0, -1]]
  while(q.length) {
    const tq = []
    for(let i=0;i<q.length;i++) {
      const [x, y, dis] = q[i]
      for(let j=0;j<4;j++) {
        const xx = x + directs[j][0], yy = y + directs[j][1]
        if(xx < 0 || xx >= m || yy < 0 || yy >= n || mat[xx][yy] !== 1) continue
        mat[xx][yy] = `${dis + 1}`
        tq.push([xx, yy, dis + 1])
      }
    }
    q = tq
  }
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      mat[i][j] = Number(mat[i][j])
    }
  }
  return mat
};

```

## 🌟😻✔ 剑指 Offer II 108. 单词演变【hard】

[ref](https://leetcode.cn/problems/om3reC/)

图、广度优先搜索、深度优先搜索

```js
var ladderLength = function(beginWord, endWord, wordList) {
  const wordListSet = new Set(wordList)
  if(!wordListSet.has(endWord)) return 0
  wordListSet.add(beginWord)
  const connectMap = new Map()
  for(let word of wordListSet) {
    const s = new Set()
    for(let i=0;i<word.length;i++) {
      for(let j=0;j<26;j++) {
        const target = word.slice(0, i) + String.fromCharCode('a'.charCodeAt(0) + j) + word.slice(i + 1)
        if(wordListSet.has(target)) {
          s.add(target)
        }
      }
    }
    connectMap.set(word, s)
  }
  let q = [[beginWord, 1]]
  const used = new Set([beginWord])
  while(q.length) {
    const tq = []
    for(let [word, depth] of q) {
      if(word === endWord) return depth
      const nexts = connectMap.get(word)
      for(let next of nexts) {
        if(!used.has(next)) {
          used.add(next)
          tq.push([next, depth + 1])
        }
      }
    }
    q = tq
  }
  return 0
};
```

## 🌟😻✔ 剑指 Offer II 109. 开密码锁【medium】

[ref](https://leetcode.cn/problems/zlDJc7/)

广度优先搜索

```js
var openLock = function(deadends, target) {
  const deadendsSet = new Set(deadends)
  if(deadendsSet.has('0000')) return -1
  let q = [['0000', 0]]
  const used = new Set('0000')
  while(q.length) {
    const tq = []
    for(let i=0;i<q.length;i++) {
      const [s, cnt] = q[i]
      if(s === target) return cnt
      for(let i=0;i<4;i++) {
        const nextS1 = s.slice(0, i) + ((Number(s[i]) + 1) % 10) + s.slice(i + 1)
        const nextS2 = s.slice(0, i) + ((Number(s[i]) - 1 + 10) % 10) + s.slice(i + 1)
        if(!used.has(nextS1) && !deadendsSet.has(nextS1)) {
          used.add(nextS1)
          tq.push([nextS1, cnt + 1])
        }
        if(!used.has(nextS2) && !deadendsSet.has(nextS2)) {
          used.add(nextS2)
          tq.push([nextS2, cnt + 1])
        }
      }
    }
    q = tq
  }
  return -1
};
```

## 🌟😻✔ 剑指 Offer II 110. 所有路径【medium】

[ref](https://leetcode.cn/problems/bP4bmD/)

回溯法

```js
var allPathsSourceTarget = function(graph) {
  const res = [], n = graph.length
  function walk(path, ind) {
    if(ind === n - 1) {
      res.push([...path])
      return
    }
    for(let i=0;i<graph[ind].length;i++) {
      const next = graph[ind][i]
      path.push(next)
      walk(path, next)
      path.pop()
    }
  }
  walk([0], 0)

  return res
};
```

```js
// Floyd 求路径数量
var allPathsSourceTarget = function(graph) {
  const n = graph.length, dp = new Array(n).fill(0).map(_ => new Array(n).fill(0))
  for(let i=0;i<n;i++) {
    for(let k=0;k<graph[i].length;k++) {
      const j = graph[i][k]
      dp[i][j] = 1
    }
  }
  for(let k=0;k<n;k++) {
    for(let i=0;i<n;i++) {
      for(let j=0;j<n;j++) {
        if(i !== j && i !== k && k !== j) {
          dp[i][j] += dp[i][k] * dp[k][j]
        }
      }
    }
  }
  console.log(dp[0][n-1])
};
```

## 🌟😻✔ 剑指 Offer II 111. 计算除法【medium】

[ref](https://leetcode.cn/problems/vlzXQL/)

Floyd 算法

```js
var calcEquation = function(equations, values, queries) {
  const idMap = new Map()
  let id = 0
  for(let equation of equations) {
    const [c1, c2] = equation
    if(!idMap.has(c1)) {
      idMap.set(c1, id++)
    }
    if(!idMap.has(c2)) {
      idMap.set(c2, id++)
    }
  }
  const dp = new Array(id).fill(0).map(_ => new Array(id).fill(-1))
  for(let i=0;i<equations.length;i++) {
    const [c1, c2] = equations[i], v = values[i]
    const id1 = idMap.get(c1), id2 = idMap.get(c2)
    dp[id1][id2] = v
    dp[id2][id1] = 1 / v
    dp[id1][id1] = 1
    dp[id2][id2] = 1
  }
  for(let k of idMap.values()) {
    for(let i of idMap.values()) {
      for(let j of idMap.values()) {
        if(dp[i][k] !== -1 && dp[k][j] !== -1) {
          dp[i][j] = dp[i][k] * dp[k][j]
        }
      }
    }
  }
  const res = []
  for(const query of queries) {
    const [c1, c2] = query
    if(idMap.has(c1) && idMap.has(c2)) {
      res.push(dp[idMap.get(c1)][idMap.get(c2)])
    } else {
      res.push(-1)
    }
  }
  return res
};
```

## ?🌟😻✔ 剑指 Offer II 112. 最长递增路径【hard】

[ref](https://leetcode.cn/problems/fpTFWP/)

图、广度优先搜索、深度优先搜索、记忆化搜索

```js

var longestIncreasingPath = function(matrix) {
  const m = matrix.length, n = matrix[0].length, dp = new Array(m).fill(0).map(_ => new Array(n).fill(0))

  function walk(i, j) {
    if(dp[i][j]) return dp[i][j]
    let depth = 0

    if(i-1>=0 && matrix[i-1][j] > matrix[i][j]) {
      depth = Math.max(depth, walk(i - 1, j))
    }
    if(i+1<m && matrix[i+1][j] > matrix[i][j]) {
      depth = Math.max(depth, walk(i + 1, j))
    }
    if(j-1>=0 && matrix[i][j-1] > matrix[i][j]) {
      depth = Math.max(depth, walk(i, j - 1))
    }
    if(j+1<n && matrix[i][j + 1] > matrix[i][j]) {
      depth = Math.max(depth, walk(i, j + 1))
    }
    const ret = depth + 1
    dp[i][j] = ret
    return ret
  }
  let q = []
  let max = Number.MIN_SAFE_INTEGER, maxIdxes = []
  for(let i=0;i<m;i++) {
    for(let j=0;j<n;j++) {
      if(!dp[i][j]) {
        walk(i, j)
      }
      if(dp[i][j] > max) {
        max = Math.max(max, dp[i][j])
        q = [[i, j, max]]
      }
    }
  }
  const res = []
  const directs = [[-1, 0], [1, 0], [0, -1], [0, 1]]
  while(q.length) {
    const [x, y, depth] = q.shift()
    res.push([x, y])
    for(let i=0;i<4;i++) {
      const xx = x + directs[i][0], yy = y + directs[i][1]
      if(xx >= 0 && xx < m && yy >= 0 && yy < n && dp[xx][yy] === depth - 1) {
        q.push([xx, yy, depth - 1])
        break
      }
    }
  }
  console.log(res)
  return res.length
};
```

## ?🌟😻✔ 剑指 Offer II 113. 课程顺序【medium】

[ref](https://leetcode.cn/problems/QA2IGt/)

拓扑排序、广度优先搜索

```js
var findOrder = function(numCourses, prerequisites) {
  const courseMap = new Map()
  const indegree = new Array(numCourses).fill(0)
  for(let prerequisite of prerequisites) {
    const [a, b] = prerequisite
    indegree[a]++
    if(!courseMap.has(b)) {
      courseMap.set(b, [])
    }
    courseMap.get(b).push(a)
  }
  let q = []
  for(let i=0;i<numCourses;i++) {
    if(indegree[i] === 0) q.push(i)
  }
  const res = []
  while(q.length) {
    const tq = []
    for(let i = 0; i < q.length; i++) {
      const curr = q[i]
      res.push(curr)
      const nexts = courseMap.get(curr)
      if(nexts) {
        for(let j=0;j<nexts.length;j++) {
          const next = nexts[j]
          indegree[next]--
          if(indegree[next] === 0) {
            tq.push(next)
          }
        }
      }
    }
    q = tq
  }
  
  return res.length === numCourses ? res : []
};
```

## ??🌟😻✔ 剑指 Offer II 114. 外星文字典【hard】

[ref](https://leetcode.cn/problems/Jf1JuT/)

图、拓扑排序、广度优先搜索

```js
var alienOrder = function(words) {
  const connectionMap = new Map(), n = words.length, chars = new Set()
  let isValid = true
  function walk(l, r, idx) {
    let i = l
    while(i <= r) {
      if(idx >= words[i].length) {
        i++
        continue
      }
      chars.add(words[i][idx])
      let j = i
      while(j + 1 <= r) {
        if(words[j][idx] === words[j + 1][idx]) {
          j++
        } else {
          if(idx >= words[j + 1].length) isValid = false
          break
        }
      }
      if(j + 1 <= r) {
        walk(i, j, idx + 1)
        if(!connectionMap.has(words[j][idx])) {
          connectionMap.set(words[j][idx], new Set())
        }
        connectionMap.get(words[j][idx]).add(words[j + 1][idx])
      } else {
        walk(i, r, idx + 1)
      }
      i = j + 1
    }
  }
  walk(0, n - 1, 0)
  if(!isValid) return ''
  const latterMap = new Map()
  for(const c of chars) {
    let q = [c]
    const used = new Set()
    while(q.length) {
      const tq = []
      for(let i=0;i<q.length;i++) {
        const curr = q[i]
        const nexts = connectionMap.get(curr)
        if(nexts) {
          for(const next of nexts) {
            if(next === c) isValid = false
            if(!used.has(next)) {
              used.add(next)
              tq.push(next)
            }
          }
        }
      }
      q = tq
    }
    latterMap.set(c, used.size)
  }
  const res = Array.from(latterMap).sort((a, b) => {
    if(b[1] !== a[1]) return b[1] - a[1]
    else {
      if(a[0] < b[0]) return -1
      if(a[0] > b[0]) return 1
      return 0
    }
  }).map(_ => _[0]).join('')
  return isValid ? res : ''
};

```

## ?🌟😻✔ 剑指 Offer II 115. 重建序列【medium】

[ref](https://leetcode.cn/problems/ur2n8P/)

拓扑排序、广度优先搜索

```js
var sequenceReconstruction = function(nums, sequences) {
  const n = nums.length, indegree = new Array(n).fill(0)
  const nextMap = new Map()
  for(let sequence of sequences) {
    for(let i=0;i<sequence.length - 1;i++) {
      const a = sequence[i], b = sequence[i + 1]
      if(!nextMap.has(a)) {
        nextMap.set(a, new Set())
      }
      if(!nextMap.get(a).has(b)) {
        nextMap.get(a).add(b)
        indegree[b - 1]++
      }
    }
  }
  let q = []
  for(let i=0;i<n;i++) {
    if(indegree[i] === 0) q.push(i + 1)
  }
  let k = 0
  while(q.length) {
    if(q.length > 1) return false
    const curr = q.shift()
    if(nums[k++] !== curr) return false
    const nexts = nextMap.get(curr)
    if(nexts) {
      for(let next of nexts) {
        indegree[next-1]--
        if(indegree[next-1] === 0) {
          q.push(next)
        }
      }
    }
  }
  return k === nums.length
};
```

## ?🌟😻✔ 剑指 Offer II 116. 省份数量【medium】

[ref](https://leetcode.cn/problems/bLyHh0/)

深度优先搜索、图

```js
var findCircleNum = function(isConnected) {
  const n = isConnected.length
  const used = new Array(n).fill(false)
  let cnt = 0
  function walk(i) {
    for(let j=0;j<n;j++) {
      if(!used[j] && isConnected[i][j] === 1) {
        used[j] = true
        walk(j)
      }
    }
  }
  for(let i=0;i<n;i++) {
    if(used[i]) continue
    used[i] = true
    cnt++
    walk(i)
  }
  return cnt
};
```

## ?🌟😻✔ 剑指 Offer II 117. 相似的字符串【hard】

[ref](https://leetcode.cn/problems/H6lPxb/)

图、广度优先搜索

```js
var numSimilarGroups = function(strs) {
  const n = strs.length, strLen = strs[0].length, connectionArr = new Array(n).fill(0).map(_ => [])
  for(let i=0; i<n; i++) {
    for(let j=0; j<n; j++) {
      if(i !== j) {
        let diffCnt = 0, x, y
        for(let k=0;k<strLen;k++) {
          if(strs[i][k] !== strs[j][k]) {
            diffCnt++
            if(diffCnt > 2) break
            if(x === undefined) x = k
            else y = k
          }
        }
        if(diffCnt === 0 || diffCnt === 2 && (strs[i][x] === strs[j][y] && strs[i][y] === strs[j][x])) {
          connectionArr[i].push(j)
        }
      }
    }
  }
  let cnt = 0
  const used = new Array(n).fill(false)
  for(let i=0;i<n;i++) {
    if(used[i]) continue
    cnt++
    used[i] = true
    let q = [i]
    while(q.length) {
      const tq = []
      for(let j=0;j<q.length;j++) {
        const curr = q[j]
        const nexts = connectionArr[curr]
        for(const next of nexts) {
          if(!used[next]) {
            used[next] = true
            tq.push(next)
          }
        }
      }
      q = tq
    }
  }
  return cnt
};

```

## ?🌟😻✔ 剑指 Offer II 118. 多余的边【medium】

[ref](https://leetcode.cn/problems/7LpjUW/)

并查集

```js
var findRedundantConnection = function(edges) {
  const n = edges.length, parent = new Array(n).fill(0).map((v, i) => i)
  for(const edge of edges) {
    const [idx1, idx2] = edge
    if(find(parent, idx1) !== find(parent, idx2)) {
      union(parent, idx1, idx2)
    } else {
      return edge
    }
  }
};
function union(parent, idx1, idx2) {
  parent[find(parent, idx1)] = find(parent, idx2)
}
function find(parent, idx) {
  if(parent[idx]!==idx) {
    parent[idx] = find(parent, parent[idx])
  }
  return parent[idx]
}
```

## ?🌟😻✔ 剑指 Offer II 118. 多余的边【medium】

[ref](https://leetcode.cn/problems/WhsWhI/)

哈希表

```js
// 时间复杂度：O(NlogN)
// 空间复杂度：O(N)
var longestConsecutive = function(nums) {
  nums = [...new Set(nums)].sort((a, b) => a - b)
  let max = 0, minIdx = 0
  for(let i=1;i<nums.length;i++) {
    if(nums[i] !== nums[i - 1] + 1) {
      max = Math.max(max, i - minIdx)
      minIdx = i
    }
  }
  max = Math.max(max, nums.length - minIdx)
  return max
};
```

```js
// 时间复杂度：O(N)
// 空间复杂度：O(N)
var longestConsecutive = function(nums) {
  const numsSet = new Set(nums)
  let max = 0
  for(let i=0;i<nums.length;i++) {
    let num = nums[i]
    if(!numsSet.has(num - 1)) {
      let cnt = 0
      while(numsSet.has(num)) {
        numsSet.delete(num)
        cnt++
        num++
      }
      max = Math.max(max, cnt)
    }
  }
  return max
};
```

